<!doctype html>
<html lang="en">

<head>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="favicon.png">
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1">

  <title>Clarivore</title>
  <script src="https://unpkg.com/@zxing/library@latest"></script>
  <script src="https://docs.opencv.org/4.5.2/opencv.js" type="text/javascript"></script>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111630;
      --ink: #e9ecff;
      --muted: #a8b2d6;
      --brand: #7c9cff;
      --ok: #22c55e;
      --warn: #facc15;
      --bad: #ef4444;
      --border: #2a3261;
      --hover: #4c5ad4;
      --shadow: 0 10px 30px rgba(0, 0, 0, .35);
    }

    html {
      margin: 0;
      padding: 0;
      min-height: 100%;
      width: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
      background: var(--bg);
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      width: 100%;
      background: var(--bg);
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
      touch-action: pan-x pan-y;
    }

    * {
      box-sizing: border-box;
      touch-action: pan-x pan-y;
    }

    .menuWrap,
    .menuInner,
    .overlayLayer,
    .tip {
      touch-action: pan-x pan-y;
    }

    .wrap {
      min-height: 100%;
      display: flex;
      flex-direction: column;
      width: 100%
    }

    .content {
      flex: 1;
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px;
      padding-bottom: 100px;
      width: 100%;
      box-sizing: border-box
    }

    a {
      color: inherit;
      text-decoration: none
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 50;
      background: linear-gradient(180deg, #0f1530, #0b1020);
      border-bottom: 1px solid #1c2347;
      box-shadow: var(--shadow);
      width: 100%;
      position: relative
    }

    .mode-toggle-container {
      position: absolute;
      top: 12px;
      left: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 60
    }

    .mode-toggle-label {
      font-size: 0.85rem;
      color: var(--muted);
      white-space: nowrap
    }

    .mode-toggle {
      position: relative;
      width: 56px;
      height: 30px;
      background: #1a2351;
      border: 1px solid var(--border);
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.2s ease
    }

    .mode-toggle.active {
      background: #3651ff;
      border-color: #4e65ff
    }

    .mode-toggle::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.2s ease
    }

    .mode-toggle.active::after {
      transform: translateX(26px)
    }

    .mode-toggle:hover {
      border-color: var(--hover);
      box-shadow: 0 0 0 3px #7c9cff33
    }

    @media (max-width: 600px) {
      .mode-toggle-container {
        top: 8px;
        left: 10px;
        flex-direction: column;
        gap: 4px
      }

      .mode-toggle-label {
        font-size: 0.65rem;
        text-align: center;
        line-height: 1
      }

      .mode-toggle {
        width: 48px;
        height: 26px
      }

      .mode-toggle::after {
        width: 18px;
        height: 18px
      }

      .mode-toggle.active::after {
        transform: translateX(22px)
      }
    }

    .topin {
      max-width: 1100px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 12px 22px 10px;
      flex-wrap: wrap;
      justify-content: center;
      box-sizing: border-box
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 16px;
      font-weight: 800;
      flex-shrink: 0;
      cursor: pointer
    }

    .brand img {
      width: 52px;
      height: 52px;
      border-radius: 6px
    }

    .brand span {
      font-size: clamp(1.5rem, 1.3rem + 1vw, 2.1rem);
    }

    .topNav {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center
    }

    .tab {
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: #12183a;
      border-radius: 999px;
      cursor: pointer;
      white-space: nowrap
    }

    .acctBtn {
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: #12183a;
      border-radius: 999px;
      cursor: pointer;
      white-space: nowrap
    }

    .tab:hover,
    .btn:hover,
    .acctBtn:hover,
    .chip.clickable:hover,
    .ackBtn:hover,
    .pill:hover,
    .algBtn:hover {
      border-color: var(--hover);
      box-shadow: 0 0 0 3px #7c9cff33 inset, 0 2px 10px #0b1b60aa;
    }

    h1 {
      font-size: clamp(1.4rem, 1.1rem + 1.5vw, 2rem);
      margin: 6px 0 12px
    }

    .note {
      color: var(--muted)
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .chip {
      padding: 8px 10px;
      border: 1px solid var(--border);
      background: #12183a;
      border-radius: 999px;
      font-size: 14px
    }

    .chip.active {
      border-color: #4c5ad4;
      box-shadow: 0 0 0 3px #7c9cff33 inset, 0 0 10px #24307a66
    }

    .chip.clickable {
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent
    }

    .pill {
      padding: 10px 14px;
      border: 1px dashed #33408c;
      border-radius: 12px
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #1a2351;
      cursor: pointer;
      color: #fff
    }

    .btnPrimary {
      background: #3651ff;
      border-color: #4e65ff
    }

    .btnSecondary {
      background: #4c5ad4;
      border-color: #5c6ce8
    }

    .btnDanger {
      background: #8b1d1d;
      border-color: #a12525
    }

    .btnSuccess {
      background: #17663a;
      border-color: #1a7b46
    }

    .mgrRow {
      display: flex;
      justify-content: flex-end;
      margin: 12px 0;
      gap: 10px;
      flex-wrap: wrap
    }

    .cards {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: center
    }

    .card {
      background: var(--panel);
      border: 1px solid #1a2042;
      border-radius: 16px;
      box-shadow: var(--shadow);
      width: 330px;
      overflow: hidden
    }

    .card img {
      display: block;
      width: 100%;
      height: 160px;
      object-fit: cover
    }

    .card .pad {
      padding: 12px
    }

    .banner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: #351b1b;
      border: 1px solid #5b2c2c;
      border-radius: 12px;
      padding: 10px 12px;
      margin: 10px 0
    }

    .legend {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      color: var(--muted);
      margin: 10px 0 16px
    }

    .key {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 2px solid currentColor
    }

    .key.ok {
      color: var(--ok)
    }

    .key.warn {
      color: var(--warn)
    }

    .key.bad {
      color: var(--bad)
    }

    .ackBtn {
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid
    }

    @keyframes ackPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 180, 180, 0.45);
      }

      50% {
        box-shadow: 0 0 0 8px rgba(255, 180, 180, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(255, 180, 180, 0);
      }
    }

    .ackBtn.off {
      background: #8b1d1d;
      border-color: #a12525;
      animation: ackPulse 1.8s ease-in-out infinite
    }

    .ackBtn.on {
      background: #17663a;
      border-color: #1a7b46;
      animation: none
    }

    /* Navigation Dropdowns */
    .nav-group {
      position: relative;
      display: inline-block;
    }

    .nav-dropdown-trigger {
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: #12183a;
      border-radius: 999px;
      cursor: pointer;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--ink);
      font-family: inherit;
      font-size: inherit;
    }

    .nav-dropdown-trigger:after {
      content: '';
      border: 4px solid transparent;
      border-top-color: var(--muted);
      margin-top: 2px;
    }

    .nav-dropdown-trigger:hover,
    .nav-group:hover .nav-dropdown-trigger {
      border-color: var(--hover);
      box-shadow: 0 0 0 3px #7c9cff33 inset, 0 2px 10px #0b1b60aa;
    }

    .nav-dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      min-width: 200px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      z-index: 1000;
      margin-top: 4px;
    }

    .nav-dropdown-content::before {
      content: '';
      position: absolute;
      top: -4px;
      left: 0;
      right: 0;
      height: 4px;
      background: transparent;
    }

    .nav-group:hover .nav-dropdown-content,
    .nav-dropdown-content:hover {
      display: block;
      animation: fadeIn 0.2s ease;
    }

    .nav-dropdown-content .tab {
      display: block;
      width: 100%;
      text-align: left;
      border: none;
      background: transparent;
      margin-bottom: 2px;
      border-radius: 8px;
    }

    .nav-dropdown-content .tab:hover {
      background: rgba(124, 156, 255, 0.1);
      box-shadow: none;
      border: none;
    }

    @media (max-width: 640px) {
      .tabs {
        gap: 6px 8px;
      }

      .tab,
      .nav-dropdown-trigger {
        font-size: 0.8rem;
        padding: 6px 10px;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -10px);
      }

      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }

    /* Viewer: simple image that scales with page zoom */
    .menuWrap {
      display: none;
      background: #0d132a;
      border-radius: 14px;
      position: relative;
      overflow: hidden;
      min-height: 140px;
      transform-origin: top left;
      touch-action: pan-y;
    }

    .menuWrap.show {
      display: block
    }

    .menuInner {
      position: relative;
      display: inline-block;
      user-select: none;
      line-height: 0;
      transform-origin: top left;
      min-width: 100%
    }

    .menuImg {
      display: block;
      max-width: 100%;
      height: auto;
      width: 100%;
      -webkit-user-drag: none;
      user-drag: none;
      -webkit-touch-callout: none;
      touch-action: none;
      pointer-events: none
    }

    .overlayLayer {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      line-height: normal;
      width: 100%;
      height: 100%
    }

    .overlay {
      position: absolute;
      border: 1.5px solid;
      border-radius: 4px;
      background: transparent;
      pointer-events: auto;
      box-sizing: border-box;
      touch-action: manipulation
    }

    .overlay:hover {
      box-shadow: none
    }

    .overlay.selected {
      animation: overlayPulse 1.5s ease-in-out infinite;
      background: transparent !important;
      outline-style: solid;
    }

    /* Set outline color to match border color based on status */
    .overlay.selected.safe {
      outline-color: rgb(22, 163, 74);
    }

    .overlay.selected.removable {
      outline-color: rgb(202, 138, 4);
    }

    .overlay.selected.unsafe {
      outline-color: rgb(220, 38, 38);
    }

    @keyframes overlayPulse {

      0%,
      100% {
        outline-width: 0px;
      }

      50% {
        outline-width: 3px;
      }
    }

    /* When zoomed, the parent is scaled so we need smaller values that will appear correct */
    .menuWrap.zoomed .overlay.selected {
      animation: overlayPulseZoomed 1.5s ease-in-out infinite;
    }

    @keyframes overlayPulseZoomed {

      0%,
      100% {
        outline-width: 0px;
      }

      50% {
        outline-width: 3px;
      }
    }

    /* Mobile overlay zoom mode */
    .menuWrap.zoomed {
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #0b1020;
      z-index: 998;
      touch-action: none;
      -webkit-overflow-scrolling: auto;
    }

    .menuWrap.zoomed .menuInner {
      transition: transform 0.3s ease-out;
      touch-action: none;
    }

    /* Top gradient overlay when zoomed */
    .zoomTopOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: calc(env(safe-area-inset-top, 0px) + 80px);
      background: linear-gradient(to bottom,
          rgba(11, 16, 32, 1) 0%,
          rgba(11, 16, 32, 0.95) calc(env(safe-area-inset-top, 0px)),
          rgba(11, 16, 32, 0.7) 80%,
          transparent 100%);
      z-index: 999;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .zoomTopOverlay.show {
      opacity: 1;
    }

    .zoomBackButton {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 8px;
      cursor: pointer;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s ease;
    }

    .zoomBackButton:active {
      background: rgba(255, 255, 255, 0.25);
      transform: scale(0.92);
    }

    .zoomBackButton svg {
      width: 20px;
      height: 20px;
      stroke: rgba(255, 255, 255, 0.9);
    }

    /* Zoomed dish info overlay */
    .zoomedDishInfo {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top,
          rgba(11, 16, 32, 0.98) 0%,
          rgba(11, 16, 32, 0.95) 40%,
          rgba(11, 16, 32, 0.85) 55%,
          rgba(11, 16, 32, 0.65) 70%,
          rgba(11, 16, 32, 0.4) 82%,
          rgba(11, 16, 32, 0.15) 92%,
          transparent 100%);
      padding: 60px 16px calc(8px + env(safe-area-inset-bottom, 0px)) 16px;
      z-index: 999;
      display: none;
    }

    .zoomedDishInfo.show {
      display: block;
    }

    .zoomedDishInfo h3 {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--ink);
    }

    .zoomedDishInfo .allergenChips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .zoomedDishInfo .allergenChip {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 500;
      line-height: 1.4;
      text-align: left;
    }

    .zoomedDishInfo .allergenChip.danger {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #fca5a5;
    }

    .zoomedDishInfo .allergenChip.safe {
      background: rgba(34, 197, 94, 0.15);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: #86efac;
    }

    .zoomedDishInfo .allergenChip.caution {
      background: rgba(250, 204, 21, 0.15);
      border: 1px solid rgba(250, 204, 21, 0.3);
      color: #fde047;
    }

    /* Remove tip pulse animation - no longer needed */
    .mobileMenuNotice {
      margin: 16px 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch
    }

    .mobileMenuNotice .mobileMenuOpenBtn {
      width: 100%
    }

    #mobileViewerChrome {
      position: fixed;
      inset: 0;
      z-index: 3400;
      display: none;
      pointer-events: none
    }

    body.mobileViewerActive #mobileViewerChrome {
      display: block
    }

    #mobileViewerChrome .chromeTop {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0) + 12px);
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
      padding: 0 clamp(12px, 3vw, 20px);
      pointer-events: none;
      z-index: 3500
    }

    #mobileViewerChrome button {
      pointer-events: auto
    }

    .mobileViewerSummary {
      display: none !important
    }

    .mobileViewerSummaryInner {
      display: inline-flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      padding: 10px 16px;
      border-radius: 14px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      background: rgba(8, 12, 28, 0.94);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
      color: var(--muted);
      max-width: min(800px, calc(100% - 24px))
    }

    .mobileViewerSummaryInner .label {
      font-weight: 600;
      color: var(--ink);
      white-space: nowrap;
      font-size: 0.9rem
    }

    .mobileViewerSummaryInner .values {
      color: var(--ink)
    }

    .mobileInfoHeaderRow {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 16px 8px;
      border-bottom: 1px solid rgba(76, 90, 212, 0.2)
    }

    .mobileInfoHeader {
      font-weight: 700;
      font-size: 1.1rem;
      color: var(--ink);
      flex: 1
    }

    .mobileInfoClose {
      background: rgba(76, 90, 212, 0.3);
      border: 1px solid rgba(76, 90, 212, 0.5);
      color: var(--ink);
      width: 36px;
      height: 36px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      line-height: 1;
      flex-shrink: 0
    }

    .mobileInfoClose:hover {
      background: rgba(76, 90, 212, 0.5);
      border-color: var(--hover)
    }

    .mobileInfoContent {
      padding: 0 16px 16px 16px !important
    }

    .mobileViewerControlBtn {
      background: rgba(18, 24, 58, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.5);
      color: var(--ink);
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35)
    }

    .mobileZoomGroup {
      display: inline-flex;
      align-items: center;
      gap: 14px;
      background: rgba(18, 24, 58, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.4);
      border-radius: 999px;
      padding: 10px 18px;
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.3)
    }

    .mobileZoomGroup button {
      background: transparent;
      border: none;
      color: var(--ink);
      font-size: 1.3rem;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .mobileZoomGroup span {
      font-weight: 600;
      color: var(--ink);
      min-width: 60px;
      text-align: center;
      font-size: 0.95rem
    }

    body.mobileViewerActive {
      overflow: hidden
    }

    body.mobileViewerActive .menuWrap {
      pointer-events: auto;
      position: fixed;
      inset: 0;
      margin: 0;
      border-radius: 0;
      padding: calc(env(safe-area-inset-top, 0) + 90px) clamp(14px, 4vw, 36px) calc(env(safe-area-inset-bottom, 0) + 80px);
      background: rgba(4, 7, 20, 0.96);
      z-index: 3100;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 32px
    }

    body.mobileViewerActive .menuWrap .menuInner {
      margin: 0 auto;
      touch-action: pan-y;
      -webkit-user-drag: none;
    }

    body.mobileViewerActive .mobileMenuNotice {
      display: none !important
    }

    body.mobileViewerActive .topbar,
    body.mobileViewerActive #root> :not(.menuWrap),
    body.mobileViewerActive .modalBack,
    body.mobileViewerActive .photoModal,
    body.mobileViewerActive .qrPromoBackdrop,
    body.mobileViewerActive .qrBanner {
      display: none !important
    }

    .ovBadge {
      position: absolute;
      top: 3px;
      right: 3px;
      width: 18px;
      height: 18px;
      background: #3651ff;
      border: 1.5px solid #dbe2ff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
      pointer-events: auto;
      line-height: 1
    }

    .ovBadge:hover {
      background: #4e65ff
    }

    .ovWarning {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 18px;
      height: 18px;
      background: #facc15;
      border: 1.5px solid #fef08a;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      z-index: 10;
      pointer-events: auto;
      line-height: 1;
      color: #000;
    }

    .ovWarning:hover {
      background: #fbbf24;
      box-shadow: 0 0 6px #facc15
    }

    /* Tooltip (with mobile X). We'll shrink it based on visual viewport scale. */
    .tip {
      position: absolute;
      z-index: 3400;
      pointer-events: auto;
      background: rgba(15, 21, 52, 0.98);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid #2a3466;
      border-radius: 10px;
      padding: 10px;
      box-shadow: var(--shadow);
      display: none;
      max-width: 280px;
      transform-origin: top left
    }

    /* Removed .tip.pulse animation - no longer needed */
    .tipHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px
    }

    .tTitle {
      font-weight: 800
    }

    .tClose {
      border: 1px solid #2a3466;
      background: #16205a;
      color: #fff;
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer;
      line-height: 1
    }

    .tClose:hover {
      border-color: var(--hover)
    }

    .love-button-tooltip {
      border: 1px solid #2a3466;
      background: #16205a;
      color: #fff;
      border-radius: 8px;
      padding: 4px 8px;
      cursor: pointer;
      line-height: 1;
      margin-right: 8px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
      position: relative;
      z-index: 10
    }

    .love-button-tooltip:hover {
      border-color: var(--hover)
    }

    .love-button-tooltip.loved {
      background: rgba(236, 72, 153, 0.2);
      border-color: #ec4899;
      color: #ec4899
    }

    .tipHoverMessage {
      font-size: 0.85rem;
      color: #6b7ce6;
      text-align: center;
      margin: 8px 0 0 0;
      padding: 6px 0 0 0;
      animation: pulseText 2s ease-in-out infinite
    }

    @keyframes pulseText {

      0%,
      100% {
        opacity: 0.6
      }

      50% {
        opacity: 1
      }
    }

    .addToOrderBtn {
      width: 100%;
      padding: 8px 12px;
      background: #4c5ad4;
      border: 1px solid #6b7ce6;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      margin-top: 12px;
      transition: background 0.2s
    }

    .addToOrderBtn:hover {
      background: #5a6ae6
    }

    .addToOrderBtn:disabled {
      background: #6b7280;
      border-color: #6b7280;
      cursor: not-allowed;
      opacity: 0.6
    }

    .addToOrderConfirm {
      margin-top: 12px;
      padding: 12px;
      background: rgba(248, 113, 113, 0.12);
      border: 1px solid rgba(248, 113, 113, 0.35);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .addToOrderConfirm p {
      margin: 0;
      color: #fecaca;
      font-size: 0.88rem;
      line-height: 1.4
    }

    .addToOrderConfirmActions {
      display: flex;
      gap: 10px;
      justify-content: center
    }

    .addToOrderConfirmActions button {
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      border: 1px solid transparent;
      cursor: pointer
    }

    .addToOrderConfirmCancel {
      background: #475569;
      border-color: #475569;
      color: #f8fafc
    }

    .addToOrderConfirmCancel:hover {
      background: #64748b;
      border-color: #64748b
    }

    .addToOrderConfirmProceed {
      background: #f87171;
      border-color: #f87171;
      color: #fff
    }

    .addToOrderConfirmProceed.warn {
      background: #facc15;
      border-color: #facc15;
      color: #0b1020
    }

    .addToOrderConfirmProceed:hover {
      opacity: 0.9
    }

    .appPromptBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(6, 11, 34, 0.68);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5000;
      padding: 24px
    }

    .appPromptModal {
      width: min(420px, 100%);
      background: rgba(12, 18, 44, 0.97);
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 18px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 24px 48px rgba(5, 8, 20, 0.55)
    }

    .appPromptModal h3 {
      margin: 0;
      font-size: 1.1rem;
      color: #fff
    }

    .appPromptModal p {
      margin: 0;
      color: #cbd5f5;
      font-size: 0.95rem;
      line-height: 1.4
    }

    .appPromptModal textarea {
      width: 100%;
      min-height: 120px;
      resize: vertical;
      background: rgba(9, 14, 36, 0.95);
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 12px;
      padding: 12px;
      color: #fff;
      font-size: 0.95rem;
      font-family: inherit
    }

    .appPromptModal textarea:focus {
      outline: 2px solid rgba(102, 126, 255, 0.7);
      outline-offset: 2px
    }

    .appPromptModalActions {
      display: flex;
      justify-content: flex-end;
      gap: 12px
    }

    .appPromptModalActions button {
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid transparent;
      font-size: 0.92rem;
      font-weight: 600;
      cursor: pointer
    }

    .appPromptCancel {
      background: transparent;
      border-color: rgba(148, 163, 184, 0.4);
      color: #cbd5f5
    }

    .appPromptCancel:hover {
      background: rgba(148, 163, 184, 0.15)
    }

    .appPromptConfirm {
      background: #4c5ad4;
      border-color: #6b7ce6;
      color: #fff
    }

    .appPromptConfirm:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(76, 90, 212, 0.25)
    }

    .orderSidebar {
      position: fixed;
      right: 0;
      top: 0;
      width: 320px;
      max-width: 90vw;
      height: 100vh;
      background: rgba(15, 21, 52, 0.98);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-left: 1px solid #2a3466;
      z-index: 3600;
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3)
    }

    .orderSidebar.open {
      transform: translateX(0)
    }

    .orderSidebar.minimized {
      width: auto;
      height: auto;
      background: transparent;
      border: none;
      box-shadow: none;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      right: 16px;
      top: 16px;
      transform: none
    }

    .orderSidebar.minimized .orderSidebarContent {
      display: none
    }

    .orderSidebar.minimized .orderSidebarTitle {
      display: none
    }

    .orderSidebar.minimized .orderSidebarFooter {
      display: none
    }

    .orderSidebar.minimized .orderSidebarHeader {
      border: none;
      padding: 0;
      background: transparent
    }

    .orderSidebarHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid #2a3466
    }

    .orderSidebarTitle {
      font-weight: 800;
      font-size: 1.1rem;
      color: #fff;
      margin: 0
    }

    .orderSidebarToggle {
      background: #4c5ad4;
      border: 1px solid #6b7ce6;
      border-radius: 6px;
      padding: 8px 16px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap
    }

    .orderSidebarToggle:hover {
      background: #5a6ae6;
      border-color: #7c8ff0
    }

    .orderSidebar.minimized .orderSidebarToggle {
      display: inline-flex
    }

    .orderSidebarContent {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .orderSidebarStatus {
      background: rgba(12, 18, 44, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.25);
      border-radius: 12px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .orderSidebarStatusHeader {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .orderSidebarStatusTitle {
      font-weight: 600;
      color: #f1f5ff;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.05em
    }

    .orderSidebarCard {
      background: rgba(14, 20, 50, 0.92);
      border: 1px solid rgba(76, 90, 212, 0.3);
      border-radius: 12px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .orderSidebarPendingCard {
      background: rgba(24, 32, 78, 0.95);
      border-color: rgba(124, 138, 255, 0.5);
      box-shadow: 0 18px 40px rgba(10, 16, 52, 0.55)
    }

    .orderSidebarCard .orderItem {
      background: transparent;
      border: none;
      padding: 0;
      margin: 0
    }

    .orderSidebarCard .orderItemRemove {
      border-color: #f87171;
      color: #f87171
    }

    .orderSidebarCard .orderItemRemove:hover {
      background: #f87171;
      color: #fff
    }

    .orderSidebarPendingLabel {
      font-size: 0.78rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #a5b4fc;
      font-weight: 700
    }

    .orderSidebarPendingMeta {
      font-size: 0.9rem;
      color: #e2e8f0
    }

    .orderSidebarPendingBadge {
      margin: 8px 0 12px;
      display: flex
    }

    .orderSidebarPendingBadge .orderConfirmStatusBadge {
      width: 100%;
      justify-content: center;
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      text-align: center;
      padding: 8px 12px;
      min-height: auto
    }

    .orderSidebarKitchenQuestion {
      margin: 16px 0;
      padding: 16px;
      background: rgba(251, 191, 36, 0.15);
      border: 2px solid rgba(251, 191, 36, 0.4);
      border-radius: 12px
    }

    .orderSidebarKitchenQuestionLabel {
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #fbbf24;
      font-weight: 700;
      margin-bottom: 8px
    }

    .orderSidebarKitchenQuestionText {
      font-size: 1rem;
      color: #fff;
      font-weight: 600;
      margin-bottom: 12px;
      line-height: 1.4
    }

    .orderSidebarKitchenQuestionActions {
      display: flex;
      gap: 10px
    }

    .orderSidebarQuestionBtn {
      flex: 1;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      border: none;
      transition: all 0.2s
    }

    .orderSidebarQuestionYes {
      background: #4caf50;
      color: #fff;
      border: 2px solid #5cbf60
    }

    .orderSidebarQuestionYes:hover {
      background: #5cbf60;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4)
    }

    .orderSidebarQuestionNo {
      background: #ef4444;
      color: #fff;
      border: 2px solid #f87171
    }

    .orderSidebarQuestionNo:hover {
      background: #f87171;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4)
    }

    .orderSidebarTimestamps {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(76, 90, 212, 0.25);
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .orderSidebarTimestamp {
      font-size: 0.85rem;
      color: #cbd5f5;
      line-height: 1.4
    }

    .orderSidebarTimestampActor {
      font-weight: 600;
      color: #a5b4fc
    }

    .orderSidebarTimestampTime {
      color: #94a3b8;
      margin-left: 4px
    }

    .orderSidebarRescindBtn {
      width: 100%;
      padding: 10px 14px;
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(239, 68, 68, 0.4);
      border-radius: 8px;
      color: #fca5a5;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 12px;
      transition: all 0.2s
    }

    .orderSidebarRescindBtn:hover {
      background: rgba(239, 68, 68, 0.25);
      border-color: rgba(239, 68, 68, 0.6);
      color: #f87171
    }

    .orderSidebarDishList {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      color: #f8fafc;
      font-size: 0.95rem
    }

    .orderSidebarDishList li {
      margin: 0
    }

    .orderSidebarEmpty.small {
      padding: 12px;
      font-size: 0.9rem
    }

    .orderItem {
      background: rgba(42, 52, 102, 0.5);
      border: 1px solid #2a3466;
      border-radius: 8px;
      padding: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px
    }

    .orderItemName {
      font-weight: 600;
      color: #fff;
      flex: 1
    }

    .orderItemRemove {
      background: none;
      border: 1px solid #ef4444;
      border-radius: 4px;
      padding: 4px 8px;
      color: #ef4444;
      cursor: pointer;
      font-size: 0.85rem
    }

    .orderItemRemove:hover {
      background: #ef4444;
      color: #fff
    }

    .orderSidebarFooter {
      border-top: 1px solid #2a3466;
      padding: 16px
    }

    .confirmOrderBtn {
      width: 100%;
      padding: 12px;
      background: #4caf50;
      border: 1px solid #4caf50;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600
    }

    .confirmOrderBtn:hover {
      background: #5cbf60
    }

    .orderSidebarEmpty {
      text-align: center;
      color: var(--muted);
      padding: 40px 20px;
      font-style: italic
    }

    .orderConfirmDrawer {
      position: fixed;
      inset: 0;
      background: rgba(6, 11, 34, 0.85);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 32px;
      z-index: 4200
    }

    .orderConfirmDrawer.show {
      display: flex
    }

    .orderConfirmPanel {
      width: min(1180px, 95vw);
      max-height: 90vh;
      background: linear-gradient(180deg, #0b1020, #050815);
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 24px;
      box-shadow: 0 26px 70px rgba(3, 8, 30, 0.7);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative
    }

    body.orderConfirmOpen {
      overflow: hidden
    }

    .orderConfirmHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 24px 28px 18px;
      border-bottom: 1px solid rgba(76, 90, 212, 0.25)
    }

    .orderConfirmHeader h2 {
      margin: 0;
      font-size: clamp(1.2rem, 1rem + 1vw, 1.6rem);
      color: #fff
    }

    .orderConfirmClose {
      background: rgba(22, 32, 90, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.4);
      color: #fff;
      width: 42px;
      height: 42px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 26px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .orderConfirmClose:hover {
      border-color: var(--hover);
      box-shadow: 0 0 10px rgba(102, 126, 255, 0.6)
    }

    .orderConfirmLayout {
      display: flex;
      gap: 32px;
      padding: 22px 28px 30px;
      overflow: auto;
      justify-content: center
    }

    .orderConfirmPrimary {
      flex: 1;
      min-width: 0;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      gap: 20px
    }

    .orderConfirmAside {
      width: 340px;
      min-width: 280px;
      display: flex;
      flex-direction: column;
      gap: 18px
    }

    .orderConfirmAside[hidden] {
      display: none !important;
      width: 0 !important;
      min-width: 0 !important
    }

    .orderConfirmSection {
      background: rgba(21, 28, 66, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.25);
      border-radius: 18px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px
    }

    .orderConfirmSection h3 {
      margin: 0;
      font-size: 1.05rem;
      color: #fff
    }

    .orderConfirmSummaryList {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 18px
    }

    .orderConfirmSummaryList li {
      margin: 0;
      padding: 0;
      list-style: none
    }

    .orderConfirmSummaryList li::before {
      display: none
    }

    .orderConfirmForm label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.92rem;
      color: #cbd5f5
    }

    .orderConfirmForm input,
    .orderConfirmForm textarea,
    .orderConfirmForm select {
      background: rgba(11, 16, 40, 0.95);
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 10px;
      padding: 10px 12px;
      color: #fff;
      font-size: 1rem
    }

    .orderConfirmForm textarea {
      resize: vertical;
      min-height: 90px
    }

    .orderConfirmForm input:focus,
    .orderConfirmForm textarea:focus,
    .orderConfirmForm select:focus {
      outline: 2px solid rgba(102, 126, 255, 0.7);
      outline-offset: 2px
    }

    .orderConfirmRadioGroup {
      display: flex;
      gap: 12px;
      flex-wrap: wrap
    }

    .orderConfirmRadioGroup label {
      flex-direction: row;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: rgba(12, 18, 44, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.25);
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer
    }

    .orderConfirmRadioGroup input {
      margin: 0
    }

    .orderConfirmConditional {
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .orderConfirmConditional [data-mode] {
      display: flex;
      flex-direction: column;
      gap: 6px
    }

    .orderConfirmConditional [data-mode][hidden] {
      display: none
    }

    .orderConfirmChips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px
    }

    .orderConfirmChip {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(76, 90, 212, 0.25);
      border: 1px solid rgba(102, 126, 255, 0.4);
      color: #fff;
      font-size: 0.85rem
    }

    .orderConfirmChip.muted {
      background: rgba(80, 90, 120, 0.35);
      border-color: rgba(120, 130, 160, 0.5);
      color: #cbd5f5
    }

    .orderConfirmDishCard {
      background: rgba(12, 18, 44, 0.95);
      border: 1px solid rgba(76, 90, 212, 0.3);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px
    }

    .orderConfirmDishCardHeader {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px
    }

    .orderConfirmDishName {
      font-size: 1.05rem;
      font-weight: 600;
      color: #fff
    }

    .orderConfirmDishBadge {
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      border: 1px solid transparent;
      white-space: nowrap
    }

    .orderConfirmDishBadge--success {
      background: rgba(34, 197, 94, 0.16);
      border-color: rgba(34, 197, 94, 0.35);
      color: #4ade80
    }

    .orderConfirmDishBadge--warn {
      background: rgba(250, 204, 21, 0.15);
      border-color: rgba(250, 204, 21, 0.4);
      color: #facc15
    }

    .orderConfirmDishBadge--danger {
      background: rgba(248, 113, 113, 0.15);
      border-color: rgba(248, 113, 113, 0.35);
      color: #f87171
    }

    .orderConfirmDishBadge--info {
      background: rgba(96, 165, 250, 0.15);
      border-color: rgba(96, 165, 250, 0.35);
      color: #93c5fd
    }

    .orderConfirmDishSection {
      display: flex;
      flex-direction: column;
      gap: 6px
    }

    .orderConfirmDishSectionTitle {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(203, 213, 255, 0.7)
    }

    .orderDishStatusList {
      margin: 6px 0 0 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.9rem
    }

    .orderDishStatusList li {
      list-style: disc;
      color: #dbe2ff
    }

    .orderDishStatusList li.success {
      color: #34d399
    }

    .orderDishStatusList li.warn {
      color: #facc15
    }

    .orderDishStatusList li.danger {
      color: #f87171
    }

    .orderDishStatusList li.info {
      color: #9ca9e2
    }

    .orderConfirmDishNote {
      margin: 0;
      font-size: 0.9rem;
      color: #cbd5f5
    }

    .orderConfirmServerTabs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 14px
    }

    .orderConfirmServerTab {
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(15, 22, 48, 0.9);
      border: 1px solid rgba(102, 126, 255, 0.35);
      color: #cbd5f5;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.15s
    }

    .orderConfirmServerTab:hover {
      border-color: rgba(102, 126, 255, 0.8);
      color: #fff
    }

    .orderConfirmServerTab.is-active {
      background: rgba(76, 90, 212, 0.25);
      border-color: rgba(102, 126, 255, 0.75);
      color: #fff
    }

    .orderConfirmServerOrders {
      display: flex;
      flex-direction: column;
      gap: 16px
    }

    .serverOrderCard {
      background: rgba(12, 18, 44, 0.95);
      border: 1px solid rgba(76, 90, 212, 0.3);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .serverOrderHeader {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px
    }

    .serverOrderTitle {
      font-size: 1rem;
      font-weight: 600;
      color: #fff
    }

    .serverOrderMeta {
      font-size: 0.9rem;
      color: #9ca3c7;
      margin-top: 4px
    }

    .serverOrderDetails {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 0.92rem;
      color: #dbe2ff
    }

    .serverOrderActions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px
    }

    .serverOrderActions button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid transparent;
      font-size: 0.87rem;
      font-weight: 600;
      cursor: pointer
    }

    .serverOrderActions button[data-server-action="approve"] {
      background: #4ade80;
      border-color: #4ade80;
      color: #052e16
    }

    .serverOrderActions button[data-server-action="reject"] {
      background: rgba(248, 113, 113, 0.18);
      border-color: rgba(248, 113, 113, 0.4);
      color: #fecaca
    }

    .serverOrderActions button[data-server-action="dispatch"] {
      background: #60a5fa;
      border-color: #60a5fa;
      color: #031633
    }

    .serverOrderActions button:hover {
      opacity: 0.9
    }

    .serverOrderEmpty {
      color: #9ca3c7;
      font-style: italic;
      font-size: 0.9rem
    }

    .kitchenOrderList {
      display: flex;
      flex-direction: column;
      gap: 16px
    }

    .kitchenOrderCard {
      background: rgba(11, 18, 40, 0.95);
      border: 1px solid rgba(76, 90, 212, 0.25);
      border-radius: 16px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .kitchenOrderHeader {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px
    }

    .kitchenOrderTitle {
      font-size: 1rem;
      font-weight: 600;
      color: #fff
    }

    .kitchenOrderMeta {
      font-size: 0.9rem;
      color: #9ca3c7;
      margin-top: 4px
    }

    .kitchenOrderActions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px
    }

    .kitchenOrderActions button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid transparent;
      font-size: 0.87rem;
      font-weight: 600;
      cursor: pointer
    }

    .kitchenOrderActions button[data-kitchen-action="acknowledge"] {
      background: #4ade80;
      border-color: #4ade80;
      color: #052e16
    }

    .kitchenOrderActions button[data-kitchen-action="message"] {
      background: #60a5fa;
      border-color: #60a5fa;
      color: #031633
    }

    .kitchenOrderActions button:hover {
      opacity: 0.9
    }

    .kitchenOrderNotes {
      font-size: 0.9rem;
      color: #dbe2ff
    }

    .orderConfirmActions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center
    }

    .orderConfirmStatusText {
      font-size: 0.9rem
    }

    .orderConfirmStatusText.error {
      color: #f87171
    }

    .orderConfirmStatusText.success {
      color: #34d399
    }

    .orderConfirmAuthPrompt {
      margin: 16px 0;
      padding: 16px;
      background: rgba(234, 179, 8, 0.15);
      border: 1px solid rgba(234, 179, 8, 0.4);
      border-radius: 12px
    }

    .orderConfirmAuthText {
      margin: 0 0 12px;
      color: #facc15;
      font-size: 0.95rem;
      text-align: center
    }

    .orderConfirmAuthButtons {
      display: flex;
      gap: 10px;
      justify-content: center
    }

    .orderConfirmAuthBtn {
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.2s
    }

    .orderConfirmSignInBtn {
      background: #4c5ad4;
      color: #fff;
      border: 2px solid #6b7ce6
    }

    .orderConfirmSignInBtn:hover {
      background: #6b7ce6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(76, 90, 212, 0.4)
    }

    .orderConfirmSignUpBtn {
      background: #10b981;
      color: #fff;
      border: 2px solid #34d399
    }

    .orderConfirmSignUpBtn:hover {
      background: #34d399;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4)
    }

    .orderConfirmPrimaryBtn,
    .orderConfirmSecondaryBtn {
      padding: 12px 18px;
      border-radius: 10px;
      border: 1px solid transparent;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s
    }

    .orderConfirmPrimaryBtn {
      background: #4c5ad4;
      border-color: #6b7ce6;
      color: #fff
    }

    .orderConfirmPrimaryBtn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(76, 90, 212, 0.25)
    }

    .orderConfirmPrimaryBtn:disabled {
      background: #475569;
      border-color: #64748b;
      color: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6
    }

    .orderConfirmSecondaryBtn {
      background: rgba(15, 22, 48, 0.95);
      border-color: rgba(102, 126, 255, 0.35);
      color: #cbd5f5
    }

    .orderConfirmSecondaryBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(8, 12, 30, 0.4)
    }

    .orderConfirmCodeBlock {
      padding: 18px;
      border-radius: 16px;
      background: rgba(14, 20, 48, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.25);
      display: flex;
      flex-direction: column;
      gap: 14px
    }

    .orderConfirmCodeValue {
      font-size: 1.6rem;
      font-weight: 800;
      letter-spacing: 4px;
      color: #fff;
      background: rgba(76, 90, 212, 0.2);
      border: 1px solid rgba(102, 126, 255, 0.6);
      padding: 12px 18px;
      border-radius: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 140px
    }

    .orderConfirmStatusBadge {
      align-self: flex-start;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      background: rgba(102, 126, 255, 0.18);
      color: #9db2ff;
      border: 1px solid rgba(102, 126, 255, 0.35)
    }

    .orderConfirmStatusBadge[data-tone="success"] {
      background: rgba(16, 185, 129, 0.2);
      color: #6ee7b7;
      border-color: rgba(45, 212, 191, 0.4)
    }

    .orderConfirmStatusBadge[data-tone="warn"] {
      background: rgba(234, 179, 8, 0.18);
      color: #facc15;
      border-color: rgba(250, 204, 21, 0.4)
    }

    .orderConfirmStatusBadge[data-tone="danger"] {
      background: rgba(248, 113, 113, 0.18);
      color: #fca5a5;
      border-color: rgba(248, 113, 113, 0.35)
    }

    .orderConfirmStatusBadge[data-tone="idle"] {
      background: rgba(148, 163, 184, 0.18);
      color: #e2e8f0;
      border-color: rgba(148, 163, 184, 0.4)
    }

    .orderConfirmEmpty {
      font-size: 0.95rem;
      color: #94a3b8;
      text-align: center;
      padding: 24px
    }

    .orderConfirmTablet {
      display: flex;
      flex-direction: column;
      gap: 14px
    }

    .orderConfirmTabletHeader {
      display: flex;
      align-items: center;
      justify-content: space-between
    }

    .orderConfirmTabletHeader h4 {
      margin: 0;
      font-size: 1rem;
      color: #fff
    }

    .orderConfirmTabletBody {
      display: flex;
      flex-direction: column;
      gap: 12px;
      font-size: 0.92rem;
      color: #cbd5f5
    }

    .orderConfirmTabletBody .orderConfirmStatusBadge {
      align-self: stretch;
      justify-content: center
    }

    .orderConfirmHardwareGroup {
      display: flex;
      flex-direction: column;
      gap: 10px
    }

    .orderConfirmHardwareBtn {
      padding: 11px 14px;
      border-radius: 12px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      background: rgba(16, 24, 58, 0.95);
      color: #e0e7ff;
      font-size: 0.92rem;
      font-weight: 600;
      cursor: pointer
    }

    .orderConfirmHardwareBtn[class*="--primary"] {
      background: #4c5ad4;
      border-color: #6b7ce6;
      color: #fff
    }

    .orderConfirmHardwareBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed
    }

    .orderConfirmReset {
      margin-left: auto
    }

    @media(max-width:1100px) {
      .orderConfirmLayout {
        flex-direction: column
      }

      .orderConfirmAside {
        width: auto;
        min-width: 0
      }
    }

    @media(max-width:640px) {
      .orderConfirmDrawer {
        padding: 12px
      }

      .orderConfirmPanel {
        border-radius: 16px
      }

      .orderConfirmHeader {
        padding: 20px 20px 16px
      }

      .orderConfirmLayout {
        padding: 18px
      }
    }

    .love-button-tooltip.loved:hover {
      background: rgba(236, 72, 153, 0.3)
    }

    @media (max-width:640px) {
      .love-button-tooltip.loved {
        background: rgba(236, 72, 153, 0.3);
        border-color: #ec4899
      }
    }

    .tooltipList {
      margin: 4px 0 0 18px;
      padding: 0;
      list-style: disc
    }

    .tooltipList li {
      margin: 3px 0
    }

    .tooltipDangerText {
      color: var(--bad);
      font-weight: 500
    }

    .tooltipWarnText {
      color: var(--warn);
      font-weight: 500
    }

    .tooltipNeutralText {
      color: #cbd5f5
    }

    .how-tour-coach {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: min(340px, calc(100% - 32px));
      background: rgba(11, 16, 40, 0.96);
      border: 1px solid rgba(124, 156, 255, 0.35);
      border-radius: 24px;
      padding: 20px 24px;
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.55);
      z-index: 4000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px)
    }

    .how-tour-coach.hidden {
      display: none
    }

    .how-tour-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      background: rgba(124, 156, 255, 0.15);
      border: 1px solid rgba(124, 156, 255, 0.35);
      border-radius: 999px;
      padding: 4px 10px;
      color: #dbe2ff
    }

    .how-tour-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px
    }

    .how-tour-close {
      background: rgba(18, 24, 64, 0.8);
      border: 1px solid rgba(124, 156, 255, 0.4);
      color: #e9ecff;
      width: 32px;
      height: 32px;
      border-radius: 10px;
      font-size: 1.2rem;
      cursor: pointer;
      line-height: 1
    }

    .how-tour-close:hover {
      border-color: var(--hover);
      box-shadow: 0 0 8px rgba(124, 156, 255, 0.35)
    }

    .how-tour-title {
      margin: 0;
      font-size: 1.15rem
    }

    .how-tour-body {
      margin: 0;
      color: var(--muted);
      line-height: 1.5
    }

    .how-tour-progress {
      font-size: 0.85rem;
      color: var(--muted)
    }

    .how-tour-controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap
    }

    .how-tour-controls button {
      flex: 1;
      min-width: 120px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid transparent;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s
    }

    .how-tour-prev {
      background: rgba(124, 156, 255, 0.15);
      border-color: rgba(124, 156, 255, 0.4);
      color: #dbe2ff
    }

    .how-tour-next {
      background: #54b17a;
      border-color: #6bd397;
      color: #04150d
    }

    .how-tour-prev:disabled {
      opacity: 0.4;
      cursor: not-allowed
    }

    .how-tour-next:disabled {
      opacity: 0.4;
      cursor: not-allowed
    }

    .how-tour-replay {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: #54b17a;
      color: #04150d;
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      z-index: 4000;
      display: none
    }

    .how-tour-replay.show {
      display: inline-flex
    }

    .how-tour-spotlight {
      position: absolute;
      border: 2px solid rgba(124, 156, 255, 0.95);
      border-radius: 24px;
      box-shadow: 0 0 40px rgba(124, 156, 255, 0.55);
      background: rgba(124, 156, 255, 0.08);
      pointer-events: none;
      z-index: 3998;
      display: none
    }

    .how-tour-spotlight.show {
      display: block
    }

    @media(max-width:640px) {
      .how-tour-coach {
        left: 12px;
        right: 12px;
        bottom: 12px;
        width: auto;
        padding: 18px
      }

      .how-tour-replay {
        left: 12px;
        right: 12px;
        bottom: 12px;
        justify-content: center
      }
    }

    .aiAssistBackdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(7, 11, 28, 0.85);
      z-index: 3600;
      overflow: hidden;
      touch-action: none
    }

    .aiAssistBackdrop.show {
      display: flex
    }

    .aiAssistPanel {
      width: min(95vw, 1200px);
      max-height: 85vh;
      overflow-y: auto;
      overflow-x: hidden;
      background: linear-gradient(180deg, #111a3c, #0d132a);
      border: 1px solid #2a3466;
      border-radius: 20px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      padding: 26px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      touch-action: pan-y;
      position: relative
    }

    .aiAssistHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px
    }

    .aiAssistHead h2 {
      margin: 0;
      font-size: clamp(1.1rem, 1rem + 1vw, 1.6rem)
    }

    .aiAssistClose {
      background: rgba(22, 32, 90, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.4);
      color: var(--ink);
      width: 40px;
      height: 40px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      line-height: 1;
      touch-action: manipulation
    }

    .aiAssistClose:hover {
      border-color: var(--hover);
      box-shadow: 0 0 8px #3651ff
    }

    .aiAssistClose:focus {
      outline: 2px solid var(--hover);
      outline-offset: 2px
    }

    .aiAssistIntro {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem
    }

    .aiAssistInput {
      width: 100%;
      min-height: 160px;
      border-radius: 16px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      background: rgba(10, 16, 36, 0.95);
      color: var(--ink);
      padding: 16px;
      font-size: 1rem;
      resize: vertical
    }

    .aiAssistControls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center
    }

    .aiAssistStatus {
      font-size: 0.9rem;
      color: var(--muted)
    }

    .aiAssistStatus[data-tone="warn"] {
      color: var(--warn)
    }

    .aiAssistStatus[data-tone="error"] {
      color: var(--bad)
    }

    .aiAssistStatus[data-tone="success"] {
      color: var(--ok)
    }

    .aiProgressBar {
      display: none;
      width: 100%;
      height: 4px;
      background: rgba(76, 90, 212, 0.2);
      border-radius: 2px;
      overflow: hidden;
      margin: 8px 0
    }

    .aiProgressBar.show {
      display: block
    }

    .aiProgressBarFill {
      height: 100%;
      background: linear-gradient(90deg, #4c5ad4, #8b5cf6);
      border-radius: 2px;
      transition: width 0.3s ease;
      animation: shimmer 1.5s infinite
    }

    @keyframes shimmer {
      0% {
        background-position: 0% 50%
      }

      50% {
        background-position: 100% 50%
      }

      100% {
        background-position: 0% 50%
      }
    }

    .aiProgressBarFill {
      background-size: 200% 100%
    }

    .aiAssistMedia {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-top: 6px
    }

    .aiAssistMedia button {
      background: #16205a;
      border: 1px solid rgba(76, 90, 212, 0.4);
      color: var(--ink);
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer
    }

    .aiAssistMedia button:hover {
      border-color: var(--hover);
      box-shadow: 0 0 8px #3651ff
    }

    .aiAssistMediaPreview {
      display: none;
      flex-direction: column;
      gap: 12px
    }

    .aiAssistMediaPreview.show {
      display: flex
    }

    .aiAssistMediaPreview video,
    .aiAssistMediaPreview img {
      max-width: 320px;
      border-radius: 12px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      background: #000
    }

    .aiAssistPhotoControls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap
    }

    .aiAssistPhotoControls button {
      background: #16205a;
      border: 1px solid rgba(76, 90, 212, 0.4);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 10px;
      cursor: pointer
    }

    .aiAssistPhotoControls button:hover {
      border-color: var(--hover);
      box-shadow: 0 0 8px #3651ff
    }

    .aiAssistHidden {
      display: none !important
    }

    .aiAssistResults {
      display: none;
      flex-direction: column;
      gap: 16px
    }

    .aiAssistResults.show {
      display: flex
    }

    .aiAssistTableWrapper {
      overflow-x: auto;
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 16px;
      background: rgba(9, 13, 30, 0.9)
    }

    #aiAssistTable {
      width: 100%;
      border-collapse: collapse;
      min-width: 720px;
      font-size: 0.95rem
    }

    #aiAssistTable th,
    #aiAssistTable td {
      padding: 12px;
      border-bottom: 1px solid rgba(76, 90, 212, 0.2);
      vertical-align: top
    }

    #aiAssistTable th {
      text-align: left;
      background: rgba(17, 26, 60, 0.75)
    }

    .aiAssistTableWrapper tr:last-child td {
      border-bottom: none
    }

    .aiBrandCell {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 0;
      overflow: hidden
    }

    .aiBrandsList {
      display: flex;
      flex-direction: column;
      gap: 10px
    }

    .aiBrandItem {
      background: #12183a;
      border: 1px solid rgba(76, 90, 212, 0.3);
      border-radius: 12px;
      padding: 10px
    }

    .aiBrandItemHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px
    }

    .aiBrandItemHeader strong {
      font-size: 0.9rem
    }

    .aiRemoveBrand {
      background: #301424;
      border: 1px solid #4c2138;
      padding: 2px 8px;
      font-size: 1.2rem;
      line-height: 1
    }

    .aiRemoveBrand:hover {
      border-color: #a12525;
      box-shadow: 0 0 8px rgba(220, 82, 120, 0.55)
    }

    .aiNoBrands {
      color: var(--muted);
      font-size: 0.85rem;
      font-style: italic
    }

    .aiBrandCell .aiBrandActions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .aiBrandCell .aiBrandActions .btn {
      padding: 8px 12px;
      font-size: 0.9rem
    }

    .btnSmall {
      padding: 4px 8px !important;
      font-size: 0.85rem !important
    }

    .btnLink {
      background: transparent;
      border: none;
      color: #6b7cff;
      font-size: 0.85rem;
      padding: 4px 0;
      text-decoration: underline;
      text-underline-offset: 2px;
      cursor: pointer;
    }

    .btnLink:hover {
      color: #8b9aff;
    }

    .aiBrandPreview {
      display: flex;
      gap: 10px;
      flex-wrap: wrap
    }

    .aiBrandPreview img {
      width: 150px;
      height: 150px;
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      background: #0b1020;
      cursor: pointer;
      transition: all 0.2s
    }

    .aiBrandPreview img:hover {
      border-color: rgba(76, 90, 212, 0.7);
      box-shadow: 0 0 12px rgba(76, 90, 212, 0.4);
      transform: scale(1.02)
    }

    .imageModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 10000;
      align-items: center;
      justify-content: center;
      padding: 20px
    }

    .imageModal.show {
      display: flex
    }

    .imageModal img {
      max-width: 90vw;
      max-height: 90vh;
      object-fit: contain;
      border-radius: 12px;
      border: 2px solid rgba(76, 90, 212, 0.5);
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8)
    }

    .imageModal .closeModal {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(76, 90, 212, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .imageModal .closeModal:hover {
      background: rgba(76, 90, 212, 1)
    }

    .aiIngredientList {
      color: var(--muted);
      font-size: 0.85rem
    }

    .aiIngredientRowWrapper {
      position: relative
    }

    .aiIngredientRow {
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: opacity 0.2s ease, filter 0.2s ease
    }

    .aiIngredientRow.is-loading {
      opacity: 0.3;
      filter: saturate(0.2);
      pointer-events: none
    }

    .aiRowLoadingOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      border-radius: 18px;
      background: rgba(8, 12, 28, 0.85);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      pointer-events: none;
      padding: 16px;
      text-align: center
    }

    .aiRowLoadingBar {
      width: 80%;
      max-width: 420px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.2);
      overflow: hidden
    }

    .aiRowLoadingBar span {
      display: block;
      width: 40%;
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg, #7c9cff, #54b17a);
      animation: aiRowLoadingSlide 1.2s ease-in-out infinite
    }

    .aiRowLoadingText {
      color: #e9ecff;
      font-weight: 600;
      font-size: 0.9rem
    }

    @keyframes aiRowLoadingSlide {
      0% {
        transform: translateX(-100%)
      }

      50% {
        transform: translateX(50%)
      }

      100% {
        transform: translateX(220%)
      }
    }

    .aiIngredientMain {
      display: grid;
      grid-template-columns: 1.5fr 2fr 1.5fr 1fr auto;
      gap: 12px;
      align-items: start
    }

    .aiIngredientNameCol {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .aiRowBrandResults {
      display: none;
      flex-direction: column;
      gap: 12px;
      padding: 16px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 16px;
      background: rgba(9, 13, 30, 0.9);
      margin-top: 8px
    }

    .aiRowBrandResults.show {
      display: flex
    }

    .aiAllergenChecklist {
      display: flex;
      flex-wrap: wrap;
      gap: 8px
    }

    .aiAllergenChecklist label {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #12183a;
      border: 1px solid rgba(76, 90, 212, 0.3);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.85rem
    }

    .aiAllergenChecklist label.aiDetected {
      background: rgba(34, 139, 34, 0.15) !important;
      border-color: rgba(76, 175, 80, 0.5) !important
    }

    .aiAllergenChecklist label.aiDetected:hover {
      background: rgba(34, 139, 34, 0.25) !important;
      border-color: rgba(76, 175, 80, 0.7) !important
    }

    .aiAllergenChecklist label.aiDetected.manuallyOverridden {
      background: rgba(239, 68, 68, 0.15) !important;
      border-color: #ef4444 !important
    }

    .aiAllergenChecklist label.manuallyOverridden {
      border-color: #ef4444 !important;
      border-width: 2px !important
    }

    .aiAllergenChecklist input {
      margin: 0
    }

    .aiDietChecklist {
      display: flex;
      flex-wrap: wrap;
      gap: 8px
    }

    .aiDietChecklist label {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #12183a;
      border: 1px solid rgba(76, 90, 212, 0.3);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.85rem
    }

    .aiDietChecklist label.aiDetected {
      background: rgba(34, 139, 34, 0.15) !important;
      border-color: rgba(76, 175, 80, 0.5) !important
    }

    .aiDietChecklist label.aiDetected:hover {
      background: rgba(34, 139, 34, 0.25) !important;
      border-color: rgba(76, 175, 80, 0.7) !important
    }

    .aiDietChecklist label.aiDetected.manuallyOverridden {
      background: rgba(239, 68, 68, 0.15) !important;
      border-color: #ef4444 !important
    }

    .aiDietChecklist label.manuallyOverridden {
      border-color: #ef4444 !important;
      border-width: 2px !important
    }

    .aiDietChecklist input {
      margin: 0
    }

    .aiDietConflictMessage {
      margin-top: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(248, 113, 113, 0.08);
      border: 1px solid rgba(248, 113, 113, 0.3);
      color: #fda4af;
      font-size: 0.85rem;
      line-height: 1.4
    }

    .aiDietConflictMessage strong {
      color: #fff
    }

    .aiAssistTableActions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap
    }

    .aiAssistTableActions .aiAssistSpacer {
      flex: 1 1 auto
    }

    .aiAssistBrandResults {
      display: none;
      flex-direction: column;
      gap: 12px;
      padding: 16px;
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 16px;
      background: rgba(9, 13, 30, 0.9);
      max-height: 320px;
      overflow: auto
    }

    .aiAssistBrandResults.show {
      display: flex
    }

    .aiBrandSuggestion {
      border: 1px solid rgba(76, 90, 212, 0.35);
      border-radius: 12px;
      padding: 12px;
      display: flex;
      gap: 12px;
      cursor: pointer;
      align-items: flex-start;
      background: #12183a
    }

    .aiBrandSuggestion:hover {
      border-color: var(--hover);
      box-shadow: 0 0 8px #3651ff
    }

    .aiBrandSuggestion img {
      width: 72px;
      height: 72px;
      border-radius: 10px;
      object-fit: cover;
      border: 1px solid rgba(76, 90, 212, 0.35)
    }

    .aiBrandSuggestion h4 {
      margin: 0;
      font-size: 1rem
    }

    .aiBrandSuggestion p {
      margin: 4px 0 0;
      font-size: 0.85rem;
      color: var(--muted)
    }

    /* Modal (editor) */
    .modalBack {
      position: fixed;
      inset: 0;
      background: #0008;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      overflow: auto;
      padding: 20px
    }

    .modal {
      background: #0f1534;
      border: 1px solid #2a3466;
      border-radius: 14px;
      width: min(980px, 96vw);
      max-height: 82vh;
      overflow: auto;
      box-shadow: var(--shadow);
      position: relative
    }

    .modal .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 14px;
      border-bottom: 1px solid #2a3466
    }

    .modal .body {
      padding: 14px
    }

    .modalCloseBtn {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      background: #16205a;
      border: 2px solid #2a3466;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: #fff;
      font-weight: bold;
      z-index: 10
    }

    .modalCloseBtn:hover {
      background: #1a2660;
      border-color: var(--hover)
    }

    /* Editor Lock Modal */
    .editorLockBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
    }

    .editorLockModal {
      background: linear-gradient(135deg, #1a1f3d 0%, #0f1330 100%);
      border: 1px solid #3a4480;
      border-radius: 16px;
      padding: 32px;
      max-width: 420px;
      width: 100%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .editorLockIcon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .editorLockModal h2 {
      margin: 0 0 16px;
      font-size: 1.4rem;
      color: #fff;
    }

    .editorLockMessage {
      margin: 0 0 8px;
      color: var(--muted);
      font-size: 1rem;
    }

    .editorLockMessage span {
      color: var(--brand);
      font-weight: 600;
    }

    .editorLockSince {
      margin: 0 0 16px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .editorLockSince span {
      color: var(--ink);
    }

    .editorLockInfo {
      margin: 0 0 24px;
      color: #8892b0;
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .editorLockActions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .editorLockActions .btn {
      padding: 10px 20px;
      font-size: 0.95rem;
    }

    .photoCapture {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 20px;
      background: #12183a;
      border-radius: 12px;
      border: 1px solid #2a3466
    }

    .photoPreview {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      border: 1px solid #2a3466
    }

    .videoPreview {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      border: 1px solid #2a3466;
      background: #000
    }

    .logEntry {
      background: #12183a;
      border: 1px solid #2a3466;
      border-radius: 12px;
      padding: 12px;
      margin: 8px 0
    }

    .logEntry .logHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      flex-wrap: wrap;
      gap: 8px
    }

    .logEntry .logTimestamp {
      color: var(--muted);
      font-size: 13px
    }

    .logEntry .logType {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600
    }

    .logType.confirm {
      background: #17663a;
      color: #fff
    }

    .logType.update {
      background: #3651ff;
      color: #fff
    }

    .logEntry .logImage {
      max-width: 100%;
      border-radius: 8px;
      margin-top: 8px;
      cursor: pointer
    }

    .logEntry .logImage:hover {
      opacity: 0.8
    }

    .logEntry .logThumbnail {
      max-width: 120px;
      max-height: 80px;
      object-fit: cover;
      border-radius: 6px;
      margin-top: 6px;
      cursor: pointer;
      border: 1px solid #2a3466
    }

    .logEntry .logThumbnail:hover {
      opacity: 0.85;
      box-shadow: 0 0 8px #3651ff
    }

    .logAuthor {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 8px
    }

    .logItem {
      margin-top: 10px;
      font-weight: 500;
      font-size: 0.95rem;
      color: var(--muted)
    }

    .logList {
      margin: 6px 0 0 18px;
      padding: 0;
      list-style: disc;
      color: var(--muted);
      font-size: 13px
    }

    .logList li {
      margin: 4px 0
    }

    /* Photo preview modal */
    .photoModal {
      position: fixed;
      inset: 0;
      background: #000c;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 4000;
      padding: 20px
    }

    .photoModal img {
      max-width: 90%;
      max-height: 90%;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .5)
    }

    .photoModalClose {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: #16205a;
      border: 2px solid #2a3466;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #fff;
      font-weight: bold
    }

    .photoModalClose:hover {
      background: #1a2660;
      border-color: var(--hover)
    }

    .algRow {
      display: grid;
      grid-template-columns: 180px minmax(180px, 300px) max-content max-content;
      column-gap: 12px;
      row-gap: 6px;
      align-items: center;
      margin: 6px 0
    }

    .algBtn {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #2a3261;
      background: #12183a;
      cursor: pointer;
      text-align: center
    }

    .algBtn.active {
      background: #1a2351;
      box-shadow: 0 0 0 3px #7c9cff33 inset;
      border-color: #4c5ad4
    }

    .algInput {
      background: #0c1230;
      color: var(--ink);
      border: 1px solid #31407f;
      border-radius: 8px;
      padding: 8px 10px;
      width: 100%
    }

    .algChk {
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
      justify-self: end
    }

    .editBox {
      position: absolute;
      border: 2px solid var(--warn);
      border-radius: 6px;
      background: transparent;
      cursor: move;
      transition: background 0.15s ease, border-color 0.15s ease
    }

    .editBox:hover {
      background: rgba(255, 193, 7, 0.08);
      border-color: #ffc107
    }

    .editBox.active {
      background: rgba(76, 175, 80, 0.12);
      border-color: #4CAF50
    }

    .editBadge {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: #3651ff;
      border: 1.5px solid #dbe2ff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      line-height: 1
    }

    .editBadge:hover {
      background: #4e65ff
    }

    .handle {
      position: absolute;
      width: 14px;
      height: 14px;
      background: #3651ff;
      border: 2px solid #dbe2ff;
      border-radius: 4px
    }

    .handle.se {
      right: -7px;
      bottom: -7px;
      cursor: nwse-resize
    }

    .handle.ne {
      right: -7px;
      top: -7px;
      cursor: nesw-resize
    }

    .handle.nw {
      left: -7px;
      top: -7px;
      cursor: nwse-resize
    }

    .handle.sw {
      left: -7px;
      bottom: -7px;
      cursor: nesw-resize
    }

    /* Report inputs */
    input[type="text"],
    input[type="email"],
    textarea {
      color: var(--ink) !important;
      caret-color: var(--ink);
      background: #12183a;
      border: 1px solid #2a3261;
      border-radius: 14px;
      padding: 12px;
    }

    input::placeholder,
    textarea::placeholder {
      color: #cfd5ff88
    }

    /* QR guest promo */
    .qrPromoBackdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(8, 12, 32, .85);
      z-index: 2500;
    }

    .qrPromoBackdrop.show {
      display: flex;
    }

    .qrPromo {
      width: min(420px, calc(100% - 40px));
      background: linear-gradient(180deg, #121a3f, #0d132a);
      border: 1px solid #2a3466;
      border-radius: 20px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, .45);
      padding: 34px 64px 30px 34px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
      text-align: center;
    }

    .qrPromo h2 {
      margin: 0 0 6px;
      font-size: clamp(1.1rem, 1rem + 1vw, 1.6rem);
    }

    .qrPromo p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .qrPromoClose {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 44px;
      height: 44px;
      border: 1px solid #2a3466;
      background: #16205a;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #fff;
      line-height: 1;
      touch-action: manipulation;
      z-index: 10;
    }

    .qrPromoClose:hover {
      border-color: var(--hover);
      box-shadow: 0 0 8px #3651ff;
    }

    .qrPromoClose:active {
      background: #1e2870;
    }

    .qrBanner {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      z-index: 2200;
      background: linear-gradient(180deg, #0f1534, #0b1020);
      border-bottom: 1px solid #2a3466;
      padding: 16px 20px;
      display: none;
      gap: 16px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      box-shadow: 0 4px 20px rgba(0, 0, 0, .4);
      text-align: center;
    }

    .qrBanner.show {
      display: flex;
    }

    /* Manager Invite Banner */
    .managerInviteBanner {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      z-index: 2300;
      background: linear-gradient(135deg, #4c5ad4, #6366f1);
      padding: 14px 20px;
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      box-shadow: 0 4px 20px rgba(76, 90, 212, 0.4);
    }

    .managerInviteBanner-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .managerInviteBanner-icon {
      font-size: 1.5rem;
    }

    .managerInviteBanner-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .managerInviteBanner-text strong {
      color: #fff;
      font-size: 1rem;
    }

    .managerInviteBanner-text span {
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.85rem;
    }

    .managerInviteBanner .btn {
      background: #fff;
      color: #4c5ad4;
      font-weight: 600;
      padding: 10px 20px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      white-space: nowrap;
    }

    .managerInviteBanner .btn:hover {
      background: #f0f0f0;
    }

    body.managerInviteBannerVisible .wrap {
      padding-top: 76px;
    }

    body.managerInviteBannerVisible .topbar {
      top: 76px;
    }

    body.managerInviteBannerVisible .qrBanner {
      top: 76px;
    }

    @media (max-width: 640px) {
      .managerInviteBanner {
        padding: 12px 14px;
        gap: 12px;
        flex-direction: column;
        text-align: center;
      }

      .managerInviteBanner-content {
        flex-direction: column;
        gap: 6px;
      }

      .managerInviteBanner-icon {
        font-size: 1.2rem;
      }

      .managerInviteBanner-text strong {
        font-size: 0.95rem;
      }

      .managerInviteBanner-text span {
        font-size: 0.8rem;
      }

      body.managerInviteBannerVisible .wrap {
        padding-top: 120px;
      }

      body.managerInviteBannerVisible .topbar {
        top: 120px;
      }
    }

    body.qrBannerVisible .wrap {
      padding-top: 80px;
    }

    body.qrBannerVisible .topbar {
      top: 80px;
    }

    body.qrMode .topbar {
      border-bottom: none;
      box-shadow: none;
    }

    body.qrMode .topin {
      padding: 32px 18px;
      gap: 24px;
    }

    @media (max-width:640px) {
      .topin {
        gap: 12px;
        padding: 16px 14px 12px
      }

      .brand {
        gap: 12px
      }

      .brand img {
        width: 40px;
        height: 40px
      }

      .tabs {
        gap: 6px
      }

      .tab {
        padding: 6px 10px;
        font-size: 13px
      }

      .acctBtn {
        padding: 6px 10px;
        font-size: 13px
      }

      .content {
        padding: 10px;
        padding-bottom: 160px
      }

      .legend {
        gap: 10px
      }

      h1 {
        font-size: 1.3rem;
        margin: 4px 0 10px
      }

      .cards {
        gap: 12px
      }

      .card {
        width: calc(100% - 20px);
        max-width: 400px
      }

      .card img {
        height: 140px
      }

      .card .pad {
        padding: 10px
      }

      .card .pad>div:first-child {
        font-size: 16px;
        margin-bottom: 4px
      }

      .note {
        font-size: 12px
      }

      .btn {
        padding: 8px 12px;
        font-size: 13px
      }

      .ovBadge,
      .ovWarning {
        top: 1px;
        width: 6px;
        height: 6px;
        border: 0.5px solid;
        font-size: 5px
      }

      .ovBadge {
        right: 1px;
        border-color: #dbe2ff
      }

      .ovWarning {
        left: 1px;
        border-color: #fef08a
      }

      .ovWarning:hover {
        box-shadow: 0 0 4px #facc15
      }

      .banner {
        flex-direction: column;
        align-items: stretch
      }
    }

    /* Auto-fill Demo Button */
    #autoFillBtn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
      background: linear-gradient(135deg, #ff9800, #f57c00);
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 14px 24px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(255, 152, 0, 0.4);
      display: none;
    }

    #autoFillBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(255, 152, 0, 0.5);
    }

    #autoFillBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Auto-fill Progress Panel - compact sidebar */
    #autoFillProgress {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 10001;
      background: rgba(26, 31, 53, 0.95);
      border: 2px solid rgba(76, 90, 212, 0.5);
      border-radius: 10px;
      padding: 12px;
      width: 240px;
      display: none;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      font-size: 0.8rem;
    }

    #autoFillProgress h3 {
      margin: 0 0 8px 0;
      color: #fff;
      font-size: 1rem;
    }

    .autoFillProgressList {
      display: none;
      /* Hide full list by default */
    }

    #autoFillProgress.expanded .autoFillProgressList {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .autoFillProgressItem {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      background: rgba(11, 16, 40, 0.6);
      border-radius: 4px;
      font-size: 0.75rem;
      color: #e0e0e0;
    }

    .autoFillProgressItem.pending {
      opacity: 0.3;
    }

    .autoFillProgressItem.active {
      background: rgba(76, 90, 212, 0.3);
      border: 1px solid rgba(76, 90, 212, 0.5);
    }

    .autoFillProgressItem.completed {
      color: #6ee7b7;
      opacity: 0.6;
    }

    .autoFillProgressItem.error {
      color: #fca5a5;
    }

    .autoFillProgressStatus {
      width: 16px;
      text-align: center;
      flex-shrink: 0;
      font-size: 0.7rem;
    }

    .autoFillProgressText {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .autoFillProgressOverlay {
      display: none !important;
    }

    #autoFillCurrentStatus {
      background: rgba(76, 90, 212, 0.2);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 8px;
    }

    #autoFillCurrentDish {
      font-weight: 600;
      color: #fff;
      margin-bottom: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #autoFillCurrentAction {
      color: #a8b2d6;
      font-size: 0.75rem;
    }

    #autoFillExpandBtn {
      background: none;
      border: none;
      color: #6b7db3;
      font-size: 0.7rem;
      cursor: pointer;
      padding: 4px;
      margin-top: 4px;
    }

    #autoFillCloseBtn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: none;
      border: none;
      color: #a8b2d6;
      font-size: 1.5rem;
      cursor: pointer;
    }

    #autoFillOverallProgress {
      margin-top: 12px;
      padding: 12px;
      background: rgba(76, 90, 212, 0.15);
      border-radius: 8px;
      text-align: center;
      color: #a8b2d6;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar" id="topbarOuter">
      <div class="topin" id="topbar"></div>
      <div class="mode-toggle-container" id="modeToggleContainer" style="display:none"></div>
    </div>
    <div class="content" id="root"></div>
  </div>

  <div class="tip" id="tip"></div>

  <!-- Auto-fill Demo Button and Progress Panel -->
  <button type="button" id="autoFillBtn"> Auto-Fill All Dishes (Demo)</button>
  <div class="autoFillProgressOverlay" id="autoFillProgressOverlay"></div>
  <div id="autoFillProgress">
    <button type="button" id="autoFillCloseBtn"></button>
    <h3> Auto-Fill</h3>
    <div id="autoFillCurrentStatus">
      <div id="autoFillCurrentDish">Starting...</div>
      <div id="autoFillCurrentAction">Preparing</div>
    </div>
    <div id="autoFillOverallProgress"></div>
    <button type="button" id="autoFillExpandBtn">Show all dishes </button>
    <div class="autoFillProgressList" id="autoFillProgressList"></div>
  </div>

  <div class="orderSidebar" id="orderSidebar">
    <div class="orderSidebarHeader">
      <h3 class="orderSidebarTitle">My order</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <button type="button" class="orderSidebarRefreshBtn" id="orderSidebarRefreshBtn" title="Refresh order status"
          style="background:rgba(76,90,212,0.3);border:1px solid rgba(76,90,212,0.5);border-radius:6px;padding:6px 10px;color:#a5b4fc;cursor:pointer;font-size:0.85rem;font-weight:600;transition:all 0.2s"></button>
        <button type="button" class="orderSidebarToggle" id="orderSidebarToggle"></button>
      </div>
    </div>
    <div class="orderSidebarContent" id="orderSidebarContent">
      <div class="orderSidebarStatus" id="orderSidebarStatus" hidden style="display:none!important">
        <div class="orderSidebarStatusHeader">
          <span class="orderSidebarStatusTitle">Allergy notice status</span>
          <span class="orderSidebarStatusBadge orderConfirmStatusBadge" id="orderSidebarStatusBadge"
            data-tone="idle">Waiting for server code</span>
        </div>
      </div>
      <div class="orderSidebarItems" id="orderSidebarItems"></div>
    </div>
    <div class="orderSidebarFooter">
      <button type="button" class="confirmOrderBtn" id="confirmOrderBtn">Proceed to confirmation</button>
    </div>
  </div>

  <div class="orderConfirmDrawer" id="orderConfirmDrawer" aria-hidden="true">
    <div class="orderConfirmPanel" role="dialog" aria-labelledby="orderConfirmHeading" aria-modal="true">
      <header class="orderConfirmHeader">
        <h2 id="orderConfirmHeading">Send allergy &amp; diet notice</h2>
        <button class="orderConfirmClose" id="orderConfirmClose" type="button"
          aria-label="Close confirmation window"></button>
      </header>
      <div class="orderConfirmLayout">
        <section class="orderConfirmPrimary">
          <div class="orderConfirmSection" id="orderConfirmSummarySection">
            <div>
              <h3>Review your order</h3>
              <ul class="orderConfirmSummaryList" id="orderConfirmSummaryList"></ul>
              <p class="orderConfirmEmpty" id="orderConfirmEmptySummary" hidden>No dishes selected yet.</p>
            </div>
          </div>

          <form class="orderConfirmSection orderConfirmForm" id="orderConfirmForm" autocomplete="off">
            <h3>Diner details</h3>
            <label>
              <span>Your name</span>
              <input id="orderConfirmName" name="orderConfirmName" type="text" placeholder="e.g. John Doe" required>
            </label>
            <div class="orderConfirmRadioGroup" role="group" aria-label="Dining mode">
              <label>
                <input type="radio" name="orderConfirmMode" value="dine-in" checked>
                <span>Dine-in</span>
              </label>
              <label>
                <input type="radio" name="orderConfirmMode" value="delivery">
                <span>Delivery / pickup</span>
              </label>
            </div>
            <div class="orderConfirmConditional">
              <label data-mode="delivery" hidden>
                <span>Delivery / pickup notes</span>
                <textarea id="orderConfirmDelivery" name="orderConfirmDelivery" rows="2"
                  placeholder="Hand off to courier at host stand."></textarea>
              </label>
              <div data-mode="delivery" id="deliveryButtonContainer" hidden style="margin-top: 12px;">
                <a id="deliveryLinkButton" class="btn btnPrimary" target="_blank"
                  style="display: inline-flex; align-items: center; gap: 6px; text-decoration: none; width: 100%; justify-content: center;">
                  <span> Order Delivery / Pickup</span>
                </a>
              </div>
            </div>
            <div>
              <span>Allergies</span>
              <div class="orderConfirmChips" id="orderConfirmAllergyChips"></div>
            </div>
            <div>
              <span>Dietary preferences</span>
              <div class="orderConfirmChips" id="orderConfirmDietChips"></div>
            </div>
            <label>
              <span>Additional notes for the kitchen</span>
              <textarea id="orderConfirmNotes" name="orderConfirmNotes" rows="3" placeholder="Optional"></textarea>
            </label>
            <div class="orderConfirmCodeBlock" id="orderConfirmCodeBlock">
              <div id="dineInCodeSection">
                <p>
                  When your server is ready, they'll share a code that combines their four-digit server ID with your
                  table number.
                  Enter it below to confirm your notice to the server tablet.
                </p>
                <label>
                  <span>Enter the code from your server</span>
                  <input id="orderConfirmCodeInput" name="orderConfirmCodeInput" type="text" inputmode="numeric"
                    maxlength="8" placeholder="#### + table">
                </label>
              </div>
              <div id="deliveryMessageSection"
                style="display: none; padding: 16px; background: rgba(220, 82, 82, 0.1); border: 1px solid rgba(220, 82, 82, 0.3); border-radius: 8px; margin-bottom: 16px;">
                <p style="color: #dc5252; margin: 0; font-weight: 600; line-height: 1.5;"> Please make sure you've
                  placed your order with the delivery service before submitting the notice.</p>
              </div>
              <div class="orderConfirmAuthPrompt" id="orderConfirmAuthPrompt" style="display: none;">
                <p class="orderConfirmAuthText">You need to sign in or create a free account to submit your notice.</p>
                <div class="orderConfirmAuthButtons">
                  <button type="button" class="orderConfirmAuthBtn orderConfirmSignInBtn"
                    id="orderConfirmSignInBtn">Sign in</button>
                  <button type="button" class="orderConfirmAuthBtn orderConfirmSignUpBtn"
                    id="orderConfirmSignUpBtn">Create account</button>
                </div>
              </div>
              <div class="orderConfirmActions">
                <button type="button" class="orderConfirmPrimaryBtn" id="orderConfirmSubmitBtn" disabled>Submit
                  notice</button>
                <div class="orderConfirmStatusText" id="orderConfirmSubmitStatus" role="status" aria-live="polite">
                </div>
              </div>
            </div>
          </form>

          <div class="orderConfirmActions">
            <button type="button" class="orderConfirmSecondaryBtn orderConfirmReset" id="orderConfirmResetBtn"
              hidden>Start another notice</button>
          </div>
        </section>

        <aside class="orderConfirmAside" hidden></aside>
      </div>
    </div>
  </div>

  <div class="modalBack" id="modalBack">
    <div class="modal">
      <button class="modalCloseBtn" id="modalCloseBtn" type="button"></button>
      <div class="head">
        <div id="modalTitle">Edit item</div>
      </div>
      <div class="body" id="modalBody"></div>
    </div>
  </div>

  <div class="photoModal" id="photoModal">
    <div class="photoModalClose" id="photoModalClose"></div>
    <img id="photoModalImage" src="" alt="Confirmation photo">
  </div>

  <div class="qrPromoBackdrop" id="qrPromoBackdrop" aria-hidden="true">
    <div class="qrPromo" role="dialog" aria-labelledby="qrPromoTitle" aria-modal="true">
      <button class="qrPromoClose" id="qrPromoClose" type="button" aria-label="Close promotion"></button>
      <h2 id="qrPromoTitle">Check out all restaurants part of Clarivore</h2>
      <p>Save your allergens and diets once and unlock curated menus at restaurants across the city.</p>
      <p>Creating an account takes less than a minute and is completely free.</p>
      <button class="btn btnPrimary" id="qrPromoSignup" type="button">Create free account</button>
    </div>
  </div>
  <div class="qrBanner" id="qrBanner" aria-hidden="true">
    <div><strong>Keep exploring safely.</strong> Create a free account to save your allergens and diets, and see
      compatible dishes
      everywhere.</div>
    <button class="btn btnPrimary" id="qrBannerSignup" type="button">Create free account</button>
  </div>

  <!-- Manager Invite Banner -->
  <div class="managerInviteBanner" id="managerInviteBanner" style="display:none;">
    <div class="managerInviteBanner-content">
      <div class="managerInviteBanner-icon"></div>
      <div class="managerInviteBanner-text">
        <strong>You've been invited as a Manager</strong>
        <span>Sign up to activate your manager access to this restaurant</span>
      </div>
    </div>
    <button class="btn btnPrimary" id="managerInviteSignupBtn" type="button">Sign up to activate access</button>
  </div>

  <!-- Editor Lock Modal -->
  <div class="editorLockBackdrop" id="editorLockBackdrop" style="display:none;">
    <div class="editorLockModal" role="dialog" aria-modal="true" aria-labelledby="editorLockTitle">
      <div class="editorLockIcon"></div>
      <h2 id="editorLockTitle">Editor Currently in Use</h2>
      <p class="editorLockMessage">
        <span id="editorLockUser">Another user</span> is currently editing this restaurant's menu.
      </p>
      <p class="editorLockSince">Editing since: <span id="editorLockSince">--</span></p>
      <p class="editorLockInfo">To avoid conflicts, only one person can edit at a time. The editor will become available
        when they finish or after 2 minutes of inactivity.</p>
      <div class="editorLockActions">
        <button class="btn btnPrimary" id="editorLockRefresh" type="button">Check again</button>
      </div>
    </div>
  </div>

  <!-- Mobile Zoom UI Elements -->
  <div class="zoomTopOverlay" id="zoomTopOverlay"></div>

  <!-- Zoomed Dish Info Panel -->
  <div class="zoomedDishInfo" id="zoomedDishInfo">
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
      <button class="zoomBackButton" id="zoomBackButton" type="button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"
          stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
      <h3 id="zoomedDishName" style="margin: 0;">Dish Name</h3>
    </div>
    <div class="allergenChips" id="zoomedAllergenChips"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="js/auth-redirect.js" defer></script>
  <script type="module">
    // Initialize Supabase
    const SUPABASE_URL = 'https://fgoiyycctnwnghrvsilt.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZnb2l5eWNjdG53bmdocnZzaWx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MzY1MjYsImV4cCI6MjA3NjAxMjUyNn0.xlSSXr0Gl7j-vsckrj-2anpPmp4BG2SUIdN-_dquSA8';
    const { createClient } = supabase;
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);
    window.supabaseClient = supabaseClient;
    window.SUPABASE_URL = SUPABASE_URL;
    window.SUPABASE_KEY = SUPABASE_KEY;
    // ========== Editor Lock Management ==========
    // Prevents multiple users OR same user in multiple tabs/devices from editing simultaneously
    const EditorLock = {
      heartbeatInterval: null,
      HEARTBEAT_MS: 30000, // Send heartbeat every 30 seconds
      currentRestaurantId: null,
      hasLock: false,
      // Generate a unique session ID for this browser tab (persists across page lifetime only)
      sessionId: crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      // Cache the auth token for synchronous release during page unload
      cachedAuthToken: null,

      async acquire(restaurantId, userEmail, userName) {
        // Cache the auth token for later synchronous release
        try {
          const { data } = await supabaseClient.auth.getSession();
          this.cachedAuthToken = data?.session?.access_token || null;
        } catch (e) {
          console.warn('Could not cache auth token:', e);
        }
        try {
          const { data, error } = await supabaseClient.rpc('acquire_editor_lock', {
            p_restaurant_id: restaurantId,
            p_user_email: userEmail,
            p_user_name: userName || null,
            p_session_id: this.sessionId,
            p_lock_timeout_seconds: 120
          });

          if (error) {
            console.error('Error acquiring editor lock:', error);
            return { success: false, error: error.message };
          }

          if (data?.success) {
            this.currentRestaurantId = restaurantId;
            this.hasLock = true;
            this.startHeartbeat(restaurantId);
            console.log('Editor lock acquired for session:', this.sessionId);
            return { success: true };
          } else if (data?.locked) {
            console.log('Editor is locked by:', data.locked_by_email, 'same_user:', data.same_user);
            return {
              success: false,
              locked: true,
              sameUser: data.same_user || false,
              lockedBy: data.locked_by_name || data.locked_by_email,
              lockedByEmail: data.locked_by_email,
              lockedAt: data.locked_at
            };
          } else {
            return { success: false, error: data?.error || 'Unknown error' };
          }
        } catch (err) {
          console.error('Exception acquiring editor lock:', err);
          return { success: false, error: err.message };
        }
      },

      async release() {
        if (!this.currentRestaurantId) return;

        this.stopHeartbeat();

        try {
          const { data, error } = await supabaseClient.rpc('release_editor_lock', {
            p_restaurant_id: this.currentRestaurantId,
            p_session_id: this.sessionId
          });

          if (error) {
            console.error('Error releasing editor lock:', error);
          } else {
            console.log('Editor lock released for session:', this.sessionId);
          }
        } catch (err) {
          console.error('Exception releasing editor lock:', err);
        }

        this.currentRestaurantId = null;
        this.hasLock = false;
      },

      async heartbeat() {
        if (!this.currentRestaurantId || !this.hasLock) return;

        try {
          const { data, error } = await supabaseClient.rpc('heartbeat_editor_lock', {
            p_restaurant_id: this.currentRestaurantId,
            p_session_id: this.sessionId
          });

          if (error || !data?.success) {
            console.warn('Heartbeat failed, lock may have been lost:', error || data?.error);
            // Lock was lost - could show a warning to the user
            this.hasLock = false;
            this.stopHeartbeat();
          }
        } catch (err) {
          console.error('Exception during heartbeat:', err);
        }
      },

      startHeartbeat(restaurantId) {
        this.stopHeartbeat(); // Clear any existing interval
        this.heartbeatInterval = setInterval(() => this.heartbeat(), this.HEARTBEAT_MS);
        // Also send initial heartbeat
        this.heartbeat();
      },

      stopHeartbeat() {
        if (this.heartbeatInterval) {
          clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        }
      }
    };

    window.EditorLock = EditorLock;

    // Helper to release lock via keepalive fetch (survives page unload)
    function releaseEditorLockSync() {
      if (!EditorLock.hasLock || !EditorLock.currentRestaurantId) return;

      const token = EditorLock.cachedAuthToken;
      if (!token) {
        console.warn('No cached auth token for lock release');
        return;
      }

      // Use fetch with keepalive to ensure request completes even after page unloads
      const url = `${SUPABASE_URL}/rest/v1/rpc/release_editor_lock`;

      fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_KEY,
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          p_restaurant_id: EditorLock.currentRestaurantId,
          p_session_id: EditorLock.sessionId
        }),
        keepalive: true  // Critical: allows request to outlive the page
      }).catch(() => { }); // Ignore errors on unload

      EditorLock.hasLock = false;
      EditorLock.stopHeartbeat();
    }

    // Release lock when page unloads (navigation, tab close, refresh)
    window.addEventListener('pagehide', () => {
      releaseEditorLockSync();
    });

    // Also try on beforeunload as backup
    window.addEventListener('beforeunload', () => {
      releaseEditorLockSync();
    });

    // UI helpers for the lock modal
    function showEditorLockModal(lockedBy, lockedAt, sameUser = false) {
      const backdrop = document.getElementById('editorLockBackdrop');
      const titleEl = document.getElementById('editorLockTitle');
      const messageEl = document.querySelector('.editorLockMessage');
      const userSpan = document.getElementById('editorLockUser');
      const sinceSpan = document.getElementById('editorLockSince');
      const infoEl = document.querySelector('.editorLockInfo');

      if (sameUser) {
        // Same user, different tab/device
        if (titleEl) titleEl.textContent = 'Editor Open in Another Tab';
        if (messageEl) messageEl.innerHTML = 'You already have the editor open in <span>another browser tab or device</span>.';
        if (infoEl) infoEl.textContent = 'To avoid conflicts, please close the other tab or wait for it to time out (2 minutes of inactivity).';
      } else {
        // Different user
        if (titleEl) titleEl.textContent = 'Editor Currently in Use';
        if (messageEl) messageEl.innerHTML = `<span id="editorLockUser">${lockedBy}</span> is currently editing this restaurant's menu.`;
        if (infoEl) infoEl.textContent = 'To avoid conflicts, only one person can edit at a time. The editor will become available when they finish or after 2 minutes of inactivity.';
      }

      if (userSpan && !sameUser) userSpan.textContent = lockedBy;
      if (sinceSpan) {
        const date = new Date(lockedAt);
        sinceSpan.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      if (backdrop) backdrop.style.display = 'flex';
    }

    function hideEditorLockModal() {
      const backdrop = document.getElementById('editorLockBackdrop');
      if (backdrop) backdrop.style.display = 'none';
    }

    // Set up lock modal button handlers
    document.getElementById('editorLockRefresh')?.addEventListener('click', () => {
      // Reload page to try again
      window.location.reload();
    });

    window.showEditorLockModal = showEditorLockModal;
    window.hideEditorLockModal = hideEditorLockModal;
    // ========== End Editor Lock Management ==========

    // Get slug from URL
    const urlParams = new URLSearchParams(window.location.search);
    const slug = urlParams.get('slug');
    const qrParam = urlParams.get('qr');
    const isQrVisit = qrParam ? /^(1|true|yes)$/i.test(qrParam) : false;
    window.__qrVisit = isQrVisit;

    // Check for manager invite token
    const inviteToken = urlParams.get('invite');
    if (inviteToken) {
      // Show manager invite banner
      const managerInviteBanner = document.getElementById('managerInviteBanner');
      const managerInviteSignupBtn = document.getElementById('managerInviteSignupBtn');

      if (managerInviteBanner) {
        managerInviteBanner.style.display = 'flex';
        document.body.classList.add('managerInviteBannerVisible');

        // Handle signup button click - go to account page with invite token preserved
        if (managerInviteSignupBtn) {
          managerInviteSignupBtn.onclick = () => {
            window.location.href = `account.html?invite=${encodeURIComponent(inviteToken)}`;
          };
        }
      }
    }

    // Track recently viewed restaurants
    if (slug) {
      try {
        const recentlyViewed = JSON.parse(localStorage.getItem('recentlyViewedRestaurants') || '[]');
        // Remove if already exists (to move to front)
        const filtered = recentlyViewed.filter(s => s !== slug);
        // Add to front
        filtered.unshift(slug);
        // Keep only most recent 10
        localStorage.setItem('recentlyViewedRestaurants', JSON.stringify(filtered.slice(0, 10)));
      } catch (e) {
        console.warn('Could not track recently viewed restaurant:', e);
      }
    }

    const HOW_IT_WORKS_SLUG = 'how-it-works';
    const HOW_IT_WORKS_MENU_IMAGE = 'images/how-it-works-menu.png';
    const HOW_IT_WORKS_OVERLAYS = [
      {
        id: 'Grilled Tofu',
        name: 'Grilled Tofu',
        title: 'Grilled Tofu',
        description: 'With vegetables and potatoes',
        x: 13,
        y: 21,
        w: 52,
        h: 11,
        allergens: ['soy'],
        removable: [
          { allergen: 'soy', instructions: 'Ask for olive oil dressing instead of soy glaze' }
        ],
        diets: ['Vegan', 'Vegetarian', 'Gluten-free'],
        crossContamination: ['peanut'],
        price: '$18',
        details: {
          description: 'House-marinated tofu served with charred vegetables and crispy potatoes.',
          tags: ['Chef favorite', 'Training example']
        },
        ingredients: [
          { name: 'Tofu', allergens: ['soy'] },
          { name: 'Roasted vegetables', allergens: [] },
          { name: 'Baby potatoes', allergens: [] },
          { name: 'Herb oil', allergens: [] }
        ]
      },
      {
        id: 'Spaghetti Bolognese',
        name: 'Spaghetti Bolognese',
        title: 'Spaghetti Bolognese',
        description: 'With tomato sauce and basil',
        x: 13,
        y: 33.5,
        w: 52,
        h: 11,
        allergens: ['wheat', 'dairy'],
        removable: [
          { allergen: 'dairy', instructions: 'Request no parmesan topping' }
        ],
        diets: ['Pescatarian'],
        crossContamination: ['egg'],
        price: '$22',
        details: {
          description: 'Slow-simmered sauce tossed with spaghetti and finished with basil.',
          tags: ['House classic', 'Training example']
        },
        ingredients: [
          { name: 'Spaghetti', allergens: ['wheat'] },
          { name: 'Parmesan', allergens: ['dairy'] },
          { name: 'Tomato-basil sauce', allergens: [] }
        ]
      }
    ];

    const HOW_IT_WORKS_RESTAURANT = {
      id: 'tour-how-it-works',
      _id: 'tour-how-it-works',
      name: 'How It Works Training Menu',
      slug: HOW_IT_WORKS_SLUG,
      menu_image: HOW_IT_WORKS_MENU_IMAGE,
      last_confirmed: '2025-11-14T00:00:00.000Z',
      overlays: HOW_IT_WORKS_OVERLAYS,
      website: null,
      phone: null,
      delivery_url: null
    };
    const isHowItWorksSlug = slug === HOW_IT_WORKS_SLUG;
    const HOW_IT_WORKS_TOUR_STEPS = [
      {
        id: 'intro',
        title: 'Meet the training menu',
        body: 'This sandbox mirrors a live Clarivore restaurant. Walk through each step here before editing a real menu.',
        selector: '.banner',
        action: 'reset'
      },
      {
        id: 'allergens',
        title: 'Practice allergen filters',
        body: 'Toggle the allergen chips and watch Grilled Tofu update immediately. Well auto-select Peanut for you now.',
        selector: '#savedChips',
        action: 'demoAllergens'
      },
      {
        id: 'diets',
        title: 'Layer a dietary preference',
        body: 'Add Vegan to see how Clarivore combines diet goals with allergens in real time.',
        selector: '#dietChips',
        action: 'demoDiets'
      },
      {
        id: 'details',
        title: 'Open a dish overlay',
        body: 'Tap the outline around Grilled Tofu or press the blue i badge to view its allergen, diet, and ingredient breakdown.',
        selector: '[data-item-id=\"Grilled Tofu\"]',
        action: 'highlightTofu'
      },
      {
        id: 'notice',
        title: 'Send a sample notice',
        body: 'Use the Send allergy & diet notice drawer to practice messaging the kitchen. This simulator is safe to experiment with.',
        selector: '#orderSidebar',
        action: 'openNotice'
      }
    ];

    // Check for editor mode URL parameter
    const editParam = urlParams.get('edit') || urlParams.get('mode');
    const shouldStartInEditor = editParam === 'true' || editParam === 'editor' || editParam === '1';
    window.__startInEditor = shouldStartInEditor;
    if (shouldStartInEditor) console.log('Editor mode requested via URL parameter');

    // Check for openLog parameter to auto-open change log modal
    const openLogParam = urlParams.get('openLog');
    window.__openLogOnLoad = openLogParam === 'true' || openLogParam === '1';
    if (window.__openLogOnLoad) console.log('Change log modal requested via URL parameter');

    if (!slug) {
      document.body.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Error: No restaurant specified</div>';
    } else {
      // Fetch restaurant data
      async function loadRestaurant() {
        const managerRestaurantsList = [];

        if (isHowItWorksSlug) {
          await loadTrainingRestaurant(managerRestaurantsList);
          return;
        }

        const { data: restaurant, error } = await supabaseClient
          .from('restaurants')
          .select('*')
          .eq('slug', slug)
          .single();

        if (error) {
          console.error('Error loading restaurant:', error);
          document.body.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Error loading restaurant</div>';
          return;
        }

        if (!restaurant) {
          document.body.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Restaurant not found</div>';
          return;
        }

        // Get current user
        const { data: { user } } = await supabaseClient.auth.getUser();

        // Get user allergies and diets if logged in
        let allergies = [];
        let diets = [];
        let canEdit = false;
        const OWNER_EMAIL = 'matt.29.ds@gmail.com';
        if (user) {
          const userRole = user.user_metadata?.role || null;
          const isOwner = user.email === OWNER_EMAIL;

          const { data: record } = await supabaseClient
            .from('user_allergies')
            .select('allergens, diets')
            .eq('user_id', user.id)
            .maybeSingle();
          allergies = record?.allergens || [];
          diets = record?.diets || [];

          // Load loved dishes
          try {
            const { data: lovedData } = await supabaseClient
              .from('user_loved_dishes')
              .select('restaurant_id, dish_name')
              .eq('user_id', user.id);
            if (lovedData) {
              window.lovedDishesSet = new Set(lovedData.map(d => `${String(d.restaurant_id)}:${d.dish_name}`));
            } else {
              window.lovedDishesSet = new Set();
            }
          } catch (err) {
            console.warn('Failed to load loved dishes', err);
            window.lovedDishesSet = new Set();
          }

          const { data: managerRecord, error: managerError } = await supabaseClient
            .from('restaurant_managers')
            .select('id')
            .eq('user_id', user.id)
            .eq('restaurant_id', restaurant.id)
            .maybeSingle();
          if (managerError) {
            console.error('Manager lookup failed', managerError);
          }
          console.log('Manager row:', managerRecord, 'error:', managerError);

          if (userRole === 'manager' && !isOwner && !managerRecord) {
            window.location.href = 'restaurants.html';
            return;
          }

          // Admin always has manager access to all restaurants
          // Regular managers need to be in restaurant_managers table
          // TEMPORARY: Make everyone a manager for Falafel Caf
          canEdit = isOwner || !!managerRecord || restaurant.name === 'Falafel Caf';

          // Fetch ALL restaurants the manager has access to (for navigation)
          if (isOwner) {
            // Owner sees all restaurants in nav - fetch all
            const { data: allRestaurants } = await supabaseClient
              .from('restaurants')
              .select('id, slug, name')
              .order('name');
            if (allRestaurants) {
              allRestaurants.forEach(r => managerRestaurantsList.push({ id: r.id, slug: r.slug, name: r.name || 'Restaurant' }));
            }
          } else if (userRole === 'manager') {
            // Fetch all restaurants this manager has access to
            const { data: allAssignments } = await supabaseClient
              .from('restaurant_managers')
              .select('restaurant_id')
              .eq('user_id', user.id);
            if (allAssignments && allAssignments.length > 0) {
              const restaurantIds = allAssignments.map(a => a.restaurant_id).filter(Boolean);
              const { data: managerRestaurants } = await supabaseClient
                .from('restaurants')
                .select('id, slug, name')
                .in('id', restaurantIds)
                .order('name');
              if (managerRestaurants) {
                managerRestaurants.forEach(r => managerRestaurantsList.push({ id: r.id, slug: r.slug, name: r.name || 'Restaurant' }));
              }
            }
          }
        }

        // Send data to the embedded page script
        // Check if editor mode should be activated via URL parameter
        let initialPage = 'restaurant';
        const wantsEditorMode = window.__startInEditor && canEdit;

        // If trying to enter editor mode, check/acquire the lock first
        if (wantsEditorMode && user) {
          const lockResult = await EditorLock.acquire(
            restaurant.id,
            user.email,
            user.user_metadata?.first_name || null
          );

          if (lockResult.success) {
            initialPage = 'editor';
          } else if (lockResult.locked) {
            // Show the lock modal (with different message if same user in another tab)
            showEditorLockModal(lockResult.lockedBy, lockResult.lockedAt, lockResult.sameUser);
            initialPage = 'restaurant';
            // Clear the flag so inner script doesn't try to override
            window.__startInEditor = false;
            // User can still view, just not edit
          } else {
            // Some other error - log it but allow viewing
            console.error('Could not acquire editor lock:', lockResult.error);
            initialPage = 'restaurant';
            window.__startInEditor = false;
          }
        } else if (wantsEditorMode) {
          // No user but wants editor - shouldn't happen but fall back
          initialPage = 'restaurant';
        }

        window.postMessage({
          page: initialPage,
          restaurant,
          user: user ? {
            loggedIn: true,
            email: user.email,
            id: user.id,
            name: user.user_metadata?.first_name || null,
            role: user.user_metadata?.role || null,
            managerRestaurants: managerRestaurantsList
          } : { loggedIn: false },
          allergies: allergies,
          diets: diets,
          canEdit: canEdit,
          canEditSource: canEdit ? 'manager-row' : 'none',
          qr: isQrVisit,
          isHowItWorks: false
        }, '*');
      }

      loadRestaurant();
    }

    async function loadTrainingRestaurant(managerRestaurantsList) {
      let allergies = [];
      let diets = [];
      let userPayload = { loggedIn: false };

      try {
        const { data: { user } } = await supabaseClient.auth.getUser();
        if (user) {
          userPayload = {
            loggedIn: true,
            email: user.email,
            id: user.id,
            name: user.user_metadata?.first_name || null,
            role: user.user_metadata?.role || null,
            managerRestaurants: managerRestaurantsList
          };

          const { data: record } = await supabaseClient
            .from('user_allergies')
            .select('allergens, diets')
            .eq('user_id', user.id)
            .maybeSingle();
          allergies = record?.allergens || [];
          diets = record?.diets || [];
        }
      } catch (error) {
        console.warn('Training restaurant: failed to load user profile', error);
      }

      window.lovedDishesSet = new Set();

      const restaurantClone = JSON.parse(JSON.stringify(HOW_IT_WORKS_RESTAURANT));
      window.postMessage({
        page: 'restaurant',
        restaurant: restaurantClone,
        user: userPayload,
        allergies,
        diets,
        canEdit: false,
        canEditSource: 'tour',
        qr: isQrVisit,
        isHowItWorks: true
      }, '*');
    }
  </script>

  <script type="module">
    import {
      createInitialState as createTabletInitialState,
      createOrderDraft as createTabletOrderDraft,
      requestServerCode as tabletRequestServerCode,
      submitOrderToServer as tabletSubmitOrderToServer,
      serverApprove as tabletServerApprove,
      serverDispatchToKitchen as tabletServerDispatchToKitchen,
      serverReject as tabletServerReject,
      kitchenAcknowledge as tabletKitchenAcknowledge,
      userRespondToQuestion as tabletUserRespondToQuestion,
      ORDER_STATUSES as TabletOrderStatusesConst
    } from './js/tablet-simulation-logic.mjs';
    import {
      getPersistedTabletState,
      persistTabletState,
      subscribeToTabletState
    } from './js/tablet-sync.js';
    import { saveTabletOrder, deleteTabletOrder, fetchTabletOrders } from './js/tablet-orders-api.js';

    const TABLET_ORDER_STATUSES = TabletOrderStatusesConst ?? {
      DRAFT: 'draft',
      CODE_ASSIGNED: 'awaiting_user_submission',
      SUBMITTED_TO_SERVER: 'awaiting_server_approval',
      QUEUED_FOR_KITCHEN: 'queued_for_kitchen',
      WITH_KITCHEN: 'with_kitchen',
      ACKNOWLEDGED: 'acknowledged',
      AWAITING_USER_RESPONSE: 'awaiting_user_response',
      QUESTION_ANSWERED: 'question_answered'
    };

    // Ensure zoom is always allowed on mobile Safari
    (function () {
      var m = document.querySelector('meta[name="viewport"]');
      if (m && !/maximum-scale/i.test(m.content)) {
        m.content += ', user-scalable=yes, maximum-scale=10';
      }
      ['touchstart', 'touchmove'].forEach(function (t) {
        document.addEventListener(t, function () { }, { passive: true });
      });
    })();
    document.body.style.display = 'none';

    const ALLERGENS = ["dairy", "egg", "peanut", "tree nut", "shellfish", "fish", "soy", "sesame", "wheat"];
    const DIETS = ["Vegan", "Vegetarian", "Pescatarian", "Gluten-free"];
    const ALLERGEN_ALIASES = {
      milk: 'dairy',
      lactose: 'dairy',
      butter: 'dairy',
      eggs: 'egg',
      egg: 'egg',
      peanuts: 'peanut',
      peanut: 'peanut',
      treenut: 'tree nut',
      "tree nut": "tree nut",
      "tree nuts": "tree nut",
      almond: 'tree nut',
      cashew: 'tree nut',
      walnut: 'tree nut',
      shellfish: 'shellfish',
      crustaceans: 'shellfish',
      crustacean: 'shellfish',
      molluscs: 'shellfish',
      fish: 'fish',
      salmon: 'fish',
      tuna: 'fish',
      wheat: 'wheat',
      gluten: 'wheat',
      soy: 'soy',
      soya: 'soy',
      sesame: 'sesame'
    };
    const ALLERGEN_EMOJI = {
      'dairy': '',
      'egg': '',
      'peanut': '',
      'tree nut': '',
      'shellfish': '',
      'fish': '',
      'soy': '',
      'sesame': '',
      'wheat': ''
    };

    function detectAllergensInText(text) {
      if (!text) return [];
      const lower = text.toLowerCase();
      const found = new Set();
      Object.entries(ALLERGEN_ALIASES).forEach(([alias, target]) => {
        if (lower.includes(alias)) found.add(target);
      });
      ALLERGENS.forEach(a => { if (lower.includes(a)) found.add(a); });
      return [...found];
    }
    const state = { page: null, restaurants: [], restaurant: null, allergies: [], diets: [], ack: false, user: { loggedIn: false }, canEdit: false, qr: false, _hydrated: false, aiAssistEndpoint: null, isHowItWorks: false };
    window.lovedDishesSet = window.lovedDishesSet || new Set();
    window.orderItems = window.orderItems || [];

    const ORDER_STATUS_DESCRIPTORS = {
      [TABLET_ORDER_STATUSES.CODE_ASSIGNED]: { label: 'Waiting for server confirmation', tone: 'warn' },
      [TABLET_ORDER_STATUSES.SUBMITTED_TO_SERVER]: { label: 'Waiting for server approval', tone: 'warn' },
      [TABLET_ORDER_STATUSES.QUEUED_FOR_KITCHEN]: { label: 'Ready to send to kitchen', tone: 'warn' },
      [TABLET_ORDER_STATUSES.WITH_KITCHEN]: { label: 'At kitchen tablet', tone: 'idle' },
      [TABLET_ORDER_STATUSES.ACKNOWLEDGED]: { label: 'Acknowledged by kitchen', tone: 'success' },
      [TABLET_ORDER_STATUSES.AWAITING_USER_RESPONSE]: { label: 'Kitchen awaiting diner response', tone: 'warn' },
      [TABLET_ORDER_STATUSES.QUESTION_ANSWERED]: { label: 'Follow-up complete', tone: 'success' },
      [TABLET_ORDER_STATUSES.REJECTED_BY_SERVER]: { label: 'Rejected by server', tone: 'danger' }
    };

    let tabletSimState = createTabletInitialState();
    let tabletSimOrderId = null;
    let tabletStateUpdatedAt = 0;

    const persistedTabletState = getPersistedTabletState();
    if (persistedTabletState) {
      tabletSimState.orders = deepCloneArray(persistedTabletState.orders);
      if (Array.isArray(persistedTabletState.chefs) && persistedTabletState.chefs.length) {
        tabletSimState.chefs = deepCloneArray(persistedTabletState.chefs);
      }
      if (typeof persistedTabletState.lastServerCode === 'string') {
        tabletSimState.lastServerCode = persistedTabletState.lastServerCode;
      }
      tabletStateUpdatedAt = persistedTabletState.updatedAt || Date.now();
      if (persistedTabletState.currentOrderId) {
        tabletSimOrderId = persistedTabletState.currentOrderId;
      } else if (tabletSimState.orders.length > 0) {
        const submittedOrder = tabletSimState.orders.find(o => o.status !== TABLET_ORDER_STATUSES.CODE_ASSIGNED);
        if (submittedOrder) {
          tabletSimOrderId = submittedOrder.id;
        }
      }
    }

    subscribeToTabletState((payload) => {
      if (!payload) return;
      if (payload.updatedAt && payload.updatedAt <= tabletStateUpdatedAt) return;
      tabletStateUpdatedAt = payload.updatedAt || Date.now();
      tabletSimState.orders = deepCloneArray(payload.orders);
      if (Array.isArray(payload.chefs) && payload.chefs.length) {
        tabletSimState.chefs = deepCloneArray(payload.chefs);
      }
      if (typeof payload.lastServerCode === 'string') {
        tabletSimState.lastServerCode = payload.lastServerCode;
      }
      renderOrderConfirm();
    });
    let orderConfirmModeBound = false;
    const serverPanelState = { activeServerId: null };

    const orderConfirmDrawer = document.getElementById('orderConfirmDrawer');
    const orderConfirmCloseBtn = document.getElementById('orderConfirmClose');
    const orderConfirmSummaryList = document.getElementById('orderConfirmSummaryList');
    const orderConfirmEmptySummary = document.getElementById('orderConfirmEmptySummary');
    const orderConfirmStatusBadge = document.getElementById('orderConfirmStatusBadge');
    const orderConfirmForm = document.getElementById('orderConfirmForm');
    const orderConfirmNameInput = document.getElementById('orderConfirmName');
    const orderConfirmDeliveryInput = document.getElementById('orderConfirmDelivery');
    const orderConfirmAllergyChips = document.getElementById('orderConfirmAllergyChips');
    const orderConfirmDietChips = document.getElementById('orderConfirmDietChips');
    const orderConfirmNotesInput = document.getElementById('orderConfirmNotes');
    const orderConfirmCodeBlock = document.getElementById('orderConfirmCodeBlock');
    const orderConfirmCodeInput = document.getElementById('orderConfirmCodeInput');
    const orderConfirmSubmitBtn = document.getElementById('orderConfirmSubmitBtn');
    const orderConfirmSubmitStatus = document.getElementById('orderConfirmSubmitStatus');
    const orderConfirmResetBtn = document.getElementById('orderConfirmResetBtn');
    const orderConfirmAuthPrompt = document.getElementById('orderConfirmAuthPrompt');
    const orderConfirmSignInBtn = document.getElementById('orderConfirmSignInBtn');
    const orderConfirmSignUpBtn = document.getElementById('orderConfirmSignUpBtn');
    const orderConfirmServerPanel = document.getElementById('orderConfirmServerPanel');
    const orderConfirmKitchenPanel = document.getElementById('orderConfirmKitchenPanel');
    const orderSidebarStatus = document.getElementById('orderSidebarStatus');
    const orderSidebarStatusBadge = document.getElementById('orderSidebarStatusBadge');
    const orderSidebarItems = document.getElementById('orderSidebarItems');
    if (orderSidebarItems) {
      orderSidebarItems.dataset.mode = 'cart';
    }

    initializeOrderConfirmDrawer();
    window.__openOrderConfirmDrawer = openOrderConfirmDrawer;

    function getSuggestedUserName() {
      if (!state.user) return '';
      const rawName = typeof state.user.name === 'string' ? state.user.name.trim() : '';
      if (rawName) return rawName;
      const first = state.user.user_metadata?.first_name ? String(state.user.user_metadata.first_name).trim() : '';
      const last = state.user.user_metadata?.last_name ? String(state.user.user_metadata.last_name).trim() : '';
      const combined = `${first} ${last}`.trim();
      if (combined) return combined;
      const email = typeof state.user.email === 'string' ? state.user.email : '';
      if (email) {
        const emailName = (email.split('@')[0] || '').replace(/[_\.]+/g, ' ').trim();
        if (emailName) return emailName;
      }
      return '';
    }

    function applyDefaultUserName(force = false) {
      if (!orderConfirmNameInput) return;
      const current = (orderConfirmNameInput.value || '').trim();
      if (current && !force) return;
      const suggested = getSuggestedUserName();
      if (suggested) {
        orderConfirmNameInput.value = suggested;
      }
    }

    async function checkUserAuth() {
      try {
        const { data: { user } } = await supabaseClient.auth.getUser();
        return !!user;
      } catch (error) {
        return false;
      }
    }

    function saveOrderFormState() {
      if (!orderConfirmForm) return;
      const storageKey = getOrderFormStateStorageKey();
      const formData = {
        name: orderConfirmNameInput?.value || '',
        mode: orderConfirmForm.querySelector('input[name="orderConfirmMode"]:checked')?.value || 'dine-in',
        allergies: Array.from(orderConfirmAllergyChips?.querySelectorAll('.chip.selected') || []).map(c => c.textContent.trim()),
        diets: Array.from(orderConfirmDietChips?.querySelectorAll('.chip.selected') || []).map(c => c.textContent.trim()),
        notes: orderConfirmNotesInput?.value || '',
        code: orderConfirmCodeInput?.value || '',
        dishes: Array.isArray(window.orderItems) ? [...window.orderItems] : [],
        timestamp: Date.now(),
        restaurantSlug: getRestaurantSlug()
      };
      try {
        localStorage.setItem(storageKey, JSON.stringify(formData));
        if (storageKey !== 'orderConfirmFormState') {
          localStorage.removeItem('orderConfirmFormState');
        }
      } catch (error) {
        console.error('Failed to save order form state', error);
      }
    }

    function restoreOrderFormState() {
      try {
        const storageKey = getOrderFormStateStorageKey();
        let saved = localStorage.getItem(storageKey);
        let usedLegacyKey = false;
        if (!saved && storageKey !== 'orderConfirmFormState') {
          saved = localStorage.getItem('orderConfirmFormState');
          if (saved) usedLegacyKey = true;
        }
        if (!saved) return false;
        const formData = JSON.parse(saved);
        const restaurantMatches = !formData?.restaurantSlug || formData.restaurantSlug === getRestaurantSlug();
        if (!formData || Date.now() - formData.timestamp > 3600000 || !restaurantMatches) {
          localStorage.removeItem(storageKey);
          if (usedLegacyKey) localStorage.removeItem('orderConfirmFormState');
          return false;
        }

        // Restore dishes first
        if (formData.dishes && Array.isArray(formData.dishes) && formData.dishes.length > 0) {
          window.orderItems = [...formData.dishes];
          // Visually select dishes in the menu by finding overlays with matching titles
          formData.dishes.forEach(dishName => {
            const overlays = document.querySelectorAll('.overlay');
            overlays.forEach(overlay => {
              const titleEl = overlay.querySelector('.tTitle');
              if (titleEl) {
                const title = titleEl.textContent.trim();
                if (title.toLowerCase() === dishName.toLowerCase() || title === dishName) {
                  overlay.classList.add('selected');
                  // Also update the "Add to order" button if it exists
                  const addBtn = overlay.querySelector(`.addToOrderBtn[data-dish-name]`);
                  if (addBtn) {
                    addBtn.disabled = true;
                    addBtn.textContent = 'Added';
                  }
                }
              }
            });
          });
          updateOrderSidebar();
        }

        // Restore form fields
        if (orderConfirmNameInput) {
          if (formData.name) {
            orderConfirmNameInput.value = formData.name;
          } else if (state.user?.name) {
            orderConfirmNameInput.value = state.user.name;
          } else if (state.user?.email) {
            orderConfirmNameInput.value = (state.user.email.split('@')[0] || '').trim();
          }
        }
        if (formData.mode) {
          const modeRadio = orderConfirmForm?.querySelector(`input[name="orderConfirmMode"][value="${formData.mode}"]`);
          if (modeRadio) modeRadio.checked = true;
        }
        // Note: allergies/diets chips are display-only and will be rendered when state.allergies/diets are loaded
        // They don't need to be "selected" - they just show what's in state.allergies and state.diets
        if (orderConfirmNameInput && !orderConfirmNameInput.value.trim()) {
          applyDefaultUserName();
        }
        if (orderConfirmNotesInput && formData.notes) orderConfirmNotesInput.value = formData.notes;
        if (orderConfirmCodeInput && formData.code) orderConfirmCodeInput.value = formData.code;

        // Acknowledge disclaimer
        const wasAcknowledged = state.ack;
        state.ack = true;
        const ackBtn = document.getElementById('ackBtn');
        if (ackBtn) {
          // Send ack message if not already acknowledged
          if (!wasAcknowledged && typeof send === 'function') {
            send({ type: 'ack' });
          }
          ackBtn.textContent = 'Acknowledged';
          ackBtn.classList.remove('off');
          ackBtn.classList.add('on');
          // Show menu and legend
          const menu = document.getElementById('menu');
          if (menu) menu.classList.add('show');
          const legendRow = document.getElementById('legendRow');
          if (legendRow) legendRow.style.display = 'flex';
          const confirmedRow = document.getElementById('confirmedRow');
          if (confirmedRow) confirmedRow.style.display = 'block';
        }

        // Open sidebar
        openOrderSidebar();

        // Automatically proceed to confirmation if there are dishes
        if (window.orderItems && window.orderItems.length > 0) {
          setTimeout(() => {
            confirmOrder();
            // Ensure summary reflects restored preferences
            setTimeout(() => {
              rerenderOrderConfirmDetails();
            }, 120);
          }, 100);
        }

        localStorage.removeItem(storageKey);
        if (storageKey !== 'orderConfirmFormState') {
          localStorage.removeItem('orderConfirmFormState');
        }
        return true;
      } catch (error) {
        console.error('Failed to restore form state', error);
        return false;
      }
    }

    function handleSignInClick() {
      saveOrderFormState();
      const currentUrl = window.location.href;
      window.location.href = `account.html?redirect=${encodeURIComponent(currentUrl)}&mode=signin`;
    }

    function handleSignUpClick() {
      saveOrderFormState();
      const currentUrl = window.location.href;
      window.location.href = `account.html?redirect=${encodeURIComponent(currentUrl)}&mode=signup`;
    }

    async function updateOrderConfirmAuthState() {
      const isAuthenticated = await checkUserAuth();
      if (orderConfirmAuthPrompt) {
        orderConfirmAuthPrompt.style.display = isAuthenticated ? 'none' : 'block';
      }
      if (orderConfirmSubmitBtn) {
        orderConfirmSubmitBtn.disabled = !isAuthenticated;
      }
      if (isAuthenticated) {
        restoreOrderFormState();
        applyDefaultUserName();
      }
    }

    function rerenderOrderConfirmDetails() {
      if (!orderConfirmDrawer?.classList.contains('show')) return;
      // Re-render everything to reflect current state (especially dish summary cards)
      renderOrderConfirmSummary();
      renderOrderConfirmAllergies();
      renderOrderConfirmDiets();
    }

    function initializeOrderConfirmDrawer() {
      if (!orderConfirmDrawer) return;
      bindOrderConfirmModeSwitcher();
      orderConfirmCloseBtn?.addEventListener('click', closeOrderConfirmDrawer);
      orderConfirmDrawer.addEventListener('click', evt => {
        if (evt.target === orderConfirmDrawer) {
          closeOrderConfirmDrawer();
        }
      });
      document.addEventListener('keydown', evt => {
        if (evt.key === 'Escape' && orderConfirmDrawer.classList.contains('show')) {
          closeOrderConfirmDrawer();
        }
      });
      orderConfirmSubmitBtn?.addEventListener('click', handleOrderConfirmSubmit);
      orderConfirmResetBtn?.addEventListener('click', handleOrderConfirmReset);
      orderConfirmSignInBtn?.addEventListener('click', handleSignInClick);
      orderConfirmSignUpBtn?.addEventListener('click', handleSignUpClick);

      updateOrderConfirmAuthState();
      orderConfirmServerPanel?.addEventListener('click', handleOrderConfirmServerPanel);
      orderConfirmKitchenPanel?.addEventListener('click', handleOrderConfirmKitchenPanel);
    }

    function openOrderConfirmDrawer() {
      if (!orderConfirmDrawer) return;
      console.log('[order-confirm] Opening confirmation drawer');
      renderOrderConfirmSummary();
      resetOrderConfirmFlow();
      applyDefaultUserName();
      renderOrderConfirmAllergies();
      renderOrderConfirmDiets();
      updateOrderConfirmAuthState();
      orderConfirmDrawer.classList.add('show');
      orderConfirmDrawer.setAttribute('aria-hidden', 'false');
      document.body.classList.add('orderConfirmOpen');
      setTimeout(() => orderConfirmNameInput?.focus(), 60);
      // Re-render after a delay to catch any allergies/diets that arrive after drawer opens
      setTimeout(() => {
        if (orderConfirmDrawer?.classList.contains('show')) {
          rerenderOrderConfirmDetails();
          // Also ensure name is populated from user account if not already set
          if (orderConfirmNameInput && !orderConfirmNameInput.value) {
            if (state.user?.name) {
              orderConfirmNameInput.value = state.user.name;
            } else if (state.user?.email) {
              orderConfirmNameInput.value = (state.user.email.split('@')[0] || '').trim();
            }
          }
        }
      }, 1000);
    }

    function closeOrderConfirmDrawer() {
      if (!orderConfirmDrawer) return;
      orderConfirmDrawer.classList.remove('show');
      orderConfirmDrawer.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('orderConfirmOpen');
    }

    function resetOrderConfirmFlow() {
      if (!orderConfirmForm) return;
      tabletSimState = createTabletInitialState();
      tabletSimOrderId = null;
      orderConfirmForm.reset();
      updateOrderConfirmModeVisibility();
      if (orderConfirmCodeInput) {
        orderConfirmCodeInput.value = '';
        orderConfirmCodeInput.disabled = false;
      }
      if (orderConfirmSubmitBtn) {
        orderConfirmSubmitBtn.disabled = false;
      }
      setStatusMessage(orderConfirmSubmitStatus, '');
      setOrderConfirmStatusBadge('Waiting for server code', 'idle');
      renderOrderConfirmServerPanel();
      renderOrderConfirmKitchenPanel();
      orderConfirmResetBtn?.setAttribute('hidden', '');
      if (state.user?.name) {
        orderConfirmNameInput.value = state.user.name;
      } else if (state.user?.email) {
        orderConfirmNameInput.value = (state.user.email.split('@')[0] || '').trim();
      } else if (orderConfirmNameInput) {
        orderConfirmNameInput.value = '';
      }
      if (orderConfirmDeliveryInput) orderConfirmDeliveryInput.value = '';
      if (orderConfirmNotesInput) orderConfirmNotesInput.value = '';
      serverPanelState.activeServerId = null;
      renderOrderSidebarStatus(null);
      persistTabletStateSnapshot();
    }

    function renderOrderConfirmSummary() {
      if (!orderConfirmSummaryList || !orderConfirmEmptySummary) return;
      orderConfirmSummaryList.innerHTML = '';
      const items = Array.isArray(window.orderItems) ? window.orderItems : [];
      if (items.length === 0) {
        orderConfirmEmptySummary.hidden = false;
        return;
      }
      orderConfirmEmptySummary.hidden = true;
      items.forEach(item => {
        const li = document.createElement('li');
        li.innerHTML = createDishSummaryCard(item);
        orderConfirmSummaryList.appendChild(li);
      });
    }

    function renderOrderConfirmAllergies() {
      if (!orderConfirmAllergyChips) return;
      orderConfirmAllergyChips.innerHTML = '';
      const allergies = Array.isArray(state.allergies) ? state.allergies : [];
      if (allergies.length === 0) {
        const chip = document.createElement('span');
        chip.className = 'orderConfirmChip muted';
        chip.textContent = 'No allergens saved';
        orderConfirmAllergyChips.appendChild(chip);
        return;
      }
      allergies.forEach(allergen => {
        const chip = document.createElement('span');
        chip.className = 'orderConfirmChip';
        chip.textContent = formatOrderListLabel(allergen);
        orderConfirmAllergyChips.appendChild(chip);
      });
    }

    function renderOrderConfirmDiets() {
      if (!orderConfirmDietChips) return;
      orderConfirmDietChips.innerHTML = '';
      const diets = Array.isArray(state.diets) ? state.diets : [];
      if (diets.length === 0) {
        const chip = document.createElement('span');
        chip.className = 'orderConfirmChip muted';
        chip.textContent = 'No dietary preferences saved';
        orderConfirmDietChips.appendChild(chip);
        return;
      }
      diets.forEach(diet => {
        const chip = document.createElement('span');
        chip.className = 'orderConfirmChip';
        chip.textContent = formatOrderListLabel(diet);
        orderConfirmDietChips.appendChild(chip);
      });
    }

    function renderOrderSidebarStatus(order) {
      if (!orderSidebarStatus || !orderSidebarStatusBadge) {
        return;
      }
      let targetOrder = order || getTabletOrder();

      // Validate that the order belongs to the current restaurant
      if (targetOrder) {
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        if (restaurantId && targetOrder.restaurantId && targetOrder.restaurantId !== restaurantId) {
          // Order belongs to a different restaurant - clear it
          if (tabletSimOrderId === targetOrder.id) {
            tabletSimOrderId = null;
            stopOrderRefresh();
          }
          const index = tabletSimState.orders.findIndex(o => o.id === targetOrder.id);
          if (index > -1) {
            tabletSimState.orders.splice(index, 1);
          }
          persistTabletStateSnapshot();
          targetOrder = null;
        }
      }

      const isSubmitted = targetOrder && targetOrder.status !== TABLET_ORDER_STATUSES.CODE_ASSIGNED;
      if (!targetOrder || !isSubmitted) {
        orderSidebarStatus.hidden = true;
        orderSidebarStatusBadge.dataset.tone = 'idle';
        orderSidebarStatusBadge.textContent = 'Waiting for server code';
        if (orderSidebarItems) {
          orderSidebarItems.dataset.mode = 'cart';
          updateOrderSidebar();
        }
        return;
      }
      const descriptor = ORDER_STATUS_DESCRIPTORS[targetOrder.status] || { label: targetOrder.status, tone: 'idle' };
      orderSidebarStatus.hidden = true;
      orderSidebarStatusBadge.dataset.tone = descriptor.tone || 'idle';
      orderSidebarStatusBadge.textContent = descriptor.label || 'Updating status';
      renderOrderSidebarPendingOrder(targetOrder, descriptor);
    }

    function getOrderTimestamps(order) {
      const history = Array.isArray(order.history) ? order.history : [];
      const submittedEntry = history.find(e => e.message && (e.message.includes('Submitted') || e.message.includes('submitted')));
      const submittedTime = submittedEntry?.at || order.updatedAt || order.createdAt;
      const updates = history.filter(e => e.at && e.at !== submittedTime).map(e => ({
        actor: e.actor || 'System',
        message: e.message || 'Status update',
        at: e.at
      }));
      return { submittedTime, updates };
    }

    function renderOrderSidebarPendingOrder(order, descriptor) {
      if (!orderSidebarItems) return;
      orderSidebarItems.dataset.mode = 'pending';
      const items = Array.isArray(order.items) && order.items.length ? order.items : (Array.isArray(window.orderItems) ? window.orderItems : []);
      const dishName = items.length ? items.join(', ') : 'No dishes recorded';
      const allergens = Array.isArray(order.allergies) && order.allergies.length ? order.allergies.map(a => formatOrderListLabel(a)).join(', ') : 'None';
      const diets = Array.isArray(order.diets) && order.diets.length ? order.diets.map(d => formatOrderListLabel(d)).join(', ') : 'None';
      const metaParts = [];
      if (order.tableNumber) {
        metaParts.push(`Table ${esc(order.tableNumber)}`);
      }
      if (order.serverCode) {
        metaParts.push(`Code ${esc(order.serverCode)}`);
      }
      const metaLine = metaParts.length ? metaParts.join('  ') : 'Awaiting table assignment';
      const badgeTone = descriptor?.tone || 'idle';
      const badgeLabel = descriptor?.label || 'Updating status';
      const badgeClass = getBadgeClassForTone(badgeTone);
      const { submittedTime, updates } = getOrderTimestamps(order);
      const submittedTimeStr = submittedTime ? formatTabletTimestamp(submittedTime) : '';
      const nonDinerUpdates = updates.filter(u => u.actor !== 'Diner');
      const updatesHtml = nonDinerUpdates.length > 0 ? `
    <div class="orderSidebarTimestamps">
      ${nonDinerUpdates.map(u => `<div class="orderSidebarTimestamp"><span class="orderSidebarTimestampActor">${esc(u.actor)}:</span> ${esc(u.message)} <span class="orderSidebarTimestampTime">${formatTabletTimestamp(u.at)}</span></div>`).join('')}
    </div>
  ` : '';
      const hasKitchenQuestion = order.kitchenQuestion && !order.kitchenQuestion.response;
      const kitchenQuestionHtml = hasKitchenQuestion ? `
    <div class="orderSidebarKitchenQuestion">
      <div class="orderSidebarKitchenQuestionLabel">Kitchen Question</div>
      <div class="orderSidebarKitchenQuestionText">${esc(order.kitchenQuestion.text)}</div>
      <div class="orderSidebarKitchenQuestionActions">
        <button type="button" class="orderSidebarQuestionBtn orderSidebarQuestionYes" data-order-id="${escapeAttribute(order.id)}" data-response="yes">Yes</button>
        <button type="button" class="orderSidebarQuestionBtn orderSidebarQuestionNo" data-order-id="${escapeAttribute(order.id)}" data-response="no">No</button>
      </div>
    </div>
  ` : '';
      orderSidebarItems.innerHTML = `
    <div class="orderSidebarCard orderSidebarPendingCard">
      <div class="orderSidebarPendingLabel">Submitted Notice</div>
      <div class="orderSidebarPendingMeta">${metaLine}</div>
      <div class="orderSidebarPendingBadge">
        <span class="${badgeClass}">${escapeConfirmationHtml(badgeLabel)}</span>
      </div>
      <div class="orderSidebarPendingMeta"><strong>Order:</strong> ${esc(dishName)}</div>
      <div class="orderSidebarPendingMeta"><strong>Allergens:</strong> ${esc(allergens)}</div>
      <div class="orderSidebarPendingMeta"><strong>Diets:</strong> ${esc(diets)}</div>
      ${submittedTimeStr ? `<div class="orderSidebarTimestamp"><span class="orderSidebarTimestampActor">Diner:</span> notice submitted <span class="orderSidebarTimestampTime">${submittedTimeStr}</span></div>` : ''}
      ${kitchenQuestionHtml}
      ${updatesHtml}
      <button type="button" class="orderSidebarRescindBtn" data-order-id="${escapeAttribute(order.id)}">Rescind notice</button>
    </div>
  `;
      const rescindBtn = orderSidebarItems.querySelector('.orderSidebarRescindBtn');
      if (rescindBtn) {
        rescindBtn.addEventListener('click', handleRescindNotice);
      }
      if (hasKitchenQuestion) {
        const yesBtn = orderSidebarItems.querySelector('.orderSidebarQuestionYes');
        const noBtn = orderSidebarItems.querySelector('.orderSidebarQuestionNo');
        if (yesBtn) {
          yesBtn.addEventListener('click', handleKitchenQuestionResponse);
        }
        if (noBtn) {
          noBtn.addEventListener('click', handleKitchenQuestionResponse);
        }
      }
    }

    function renderOrderConfirm() {
      renderOrderConfirmSummary();
      renderOrderConfirmServerPanel();
      renderOrderConfirmKitchenPanel();
      renderOrderConfirmAllergies();
      renderOrderConfirmDiets();
      const order = getTabletOrder();
      renderOrderSidebarStatus(order);
      if (!order) {
        setOrderConfirmStatusBadge('Waiting for server code', 'idle');
        orderConfirmResetBtn?.setAttribute('hidden', '');
        return;
      }
      const descriptor = ORDER_STATUS_DESCRIPTORS[order.status] || { label: order.status, tone: 'idle' };
      setOrderConfirmStatusBadge(descriptor.label, descriptor.tone);
      if (order.status === TABLET_ORDER_STATUSES.ACKNOWLEDGED || order.status === TABLET_ORDER_STATUSES.QUESTION_ANSWERED) {
        orderConfirmResetBtn?.removeAttribute('hidden');
      }
    }

    function renderOrderConfirmServerPanel() {
      if (!orderConfirmServerPanel) return;
      const body = orderConfirmServerPanel.querySelector('.orderConfirmTabletBody');
      if (!body) return;
      const relevantStatuses = [
        TABLET_ORDER_STATUSES.SUBMITTED_TO_SERVER,
        TABLET_ORDER_STATUSES.QUEUED_FOR_KITCHEN,
        TABLET_ORDER_STATUSES.REJECTED_BY_SERVER
      ];

      const serverGroups = new Map();
      tabletSimState.orders.forEach(order => {
        if (!order?.serverCode) return;
        if (!relevantStatuses.includes(order.status)) return;
        ensureOrderServerMetadata(order);
        const serverId = order.serverId || '0000';
        if (!serverGroups.has(serverId)) {
          serverGroups.set(serverId, []);
        }
        serverGroups.get(serverId).push(order);
      });

      if (serverGroups.size === 0) {
        body.innerHTML = '<div class="orderConfirmStatusBadge" data-tone="idle">Waiting for diner</div><p class="orderConfirmEmpty">Share your server code plus their table number when you&rsquo;re ready.</p>';
        return;
      }

      if (!serverPanelState.activeServerId || !serverGroups.has(serverPanelState.activeServerId)) {
        serverPanelState.activeServerId = Array.from(serverGroups.keys())[0];
      }

      const tabsHtml = Array.from(serverGroups.entries()).map(([serverId, orders]) => {
        const name = ensureOrderServerMetadata(orders[0]).serverName || `Server ${serverId}`;
        const isActive = serverId === serverPanelState.activeServerId;
        return `<button type="button" class="orderConfirmServerTab${isActive ? ' is-active' : ''}" data-server-tab="${escapeAttribute(serverId)}">${escapeConfirmationHtml(name)}</button>`;
      }).join('');

      const activeOrders = serverGroups.get(serverPanelState.activeServerId) || [];
      const orderCards = activeOrders.length
        ? activeOrders.map(renderServerOrderCard).join('')
        : '<p class="serverOrderEmpty">No active notices for this server.</p>';

      body.innerHTML = `
    <div class="orderConfirmServerTabs">${tabsHtml}</div>
    <div class="orderConfirmServerOrders">${orderCards}</div>
  `;

    }

    function renderServerOrderCard(order) {
      ensureOrderServerMetadata(order);
      const descriptor = ORDER_STATUS_DESCRIPTORS[order.status] || { label: 'Updating status', tone: 'info' };
      const badgeClass = getBadgeClassForTone(descriptor.tone);
      const dishes = Array.isArray(order.items) && order.items.length ? order.items.map(item => esc(item)).join(', ') : 'No dishes listed';
      const allergies = Array.isArray(order.allergies) && order.allergies.length ? order.allergies.map(a => formatOrderListLabel(a)).join(', ') : 'None saved';
      const diets = Array.isArray(order.diets) && order.diets.length ? order.diets.join(', ') : 'None saved';
      const tableLabel = order.tableNumber ? `Table ${esc(order.tableNumber)}` : 'Table not recorded';
      const codeLabel = order.serverCode ? `Code ${esc(order.serverCode)}` : 'Code unavailable';
      const notes = order.customNotes ? `<div>Notes: ${esc(order.customNotes)}</div>` : '';
      let actionsHtml = '';
      if (order.status === TABLET_ORDER_STATUSES.SUBMITTED_TO_SERVER) {
        actionsHtml = `
      <div class="serverOrderActions">
        <button type="button" data-server-action="approve" data-order-id="${escapeAttribute(order.id)}">Approve &amp; send to kitchen</button>
        <button type="button" data-server-action="reject" data-order-id="${escapeAttribute(order.id)}">Reject notice</button>
    </div>`;
      } else if (order.status === TABLET_ORDER_STATUSES.QUEUED_FOR_KITCHEN) {
        actionsHtml = `
      <div class="serverOrderActions">
        <button type="button" data-server-action="dispatch" data-order-id="${escapeAttribute(order.id)}">Send to kitchen</button>
        <button type="button" data-server-action="reject" data-order-id="${escapeAttribute(order.id)}">Reject notice</button>
    </div>`;
      } else if (order.status === TABLET_ORDER_STATUSES.REJECTED_BY_SERVER) {
        actionsHtml = '<p class="serverOrderEmpty">Rejected. Waiting for diner updates.</p>';
      } else {
        actionsHtml = '<p class="serverOrderEmpty">This notice has moved to the kitchen tablet.</p>';
      }

      return `
    <article class="serverOrderCard" data-order-id="${escapeAttribute(order.id)}">
      <div class="serverOrderHeader">
        <div>
          <div class="serverOrderTitle">${esc(order.customerName || 'Guest')}</div>
          <div class="serverOrderMeta">${tableLabel}  ${codeLabel}</div>
          <div class="serverOrderMeta">Dishes: ${dishes}</div>
        </div>
        <span class="${badgeClass}">${escapeConfirmationHtml(descriptor.label)}</span>
      </div>
      <div class="serverOrderDetails">
        <div>Allergies: ${esc(allergies)}</div>
        <div>Dietary preferences: ${esc(diets)}</div>
        ${notes}
      </div>
      ${actionsHtml}
    </article>
  `;
    }

    async function handleServerOrderAction(action, orderId) {
      const order = getTabletOrderById(orderId);
      if (!order) return;
      try {
        if (action === 'approve') {
          tabletServerApprove(tabletSimState, orderId);
          tabletServerDispatchToKitchen(tabletSimState, orderId);
        } else if (action === 'dispatch') {
          tabletServerDispatchToKitchen(tabletSimState, orderId);
        } else if (action === 'reject') {
          const reason = await showTextPrompt({
            title: 'Reject notice',
            message: 'Let the diner know why this notice cannot be processed.',
            placeholder: 'e.g. We need a manager to assist before sending this through.',
            confirmLabel: 'Send rejection',
            cancelLabel: 'Cancel'
          });
          if (reason === null) return;
          const rejectionReason = reason || 'Rejected the notice.';
          tabletServerReject(tabletSimState, orderId, rejectionReason);
        } else {
          return;
        }
        persistTabletStateAndRender();
      } catch (error) {
        alert(error?.message || 'Unable to update server tablet.');
      }
    }

    function renderKitchenOrderCard(order) {
      ensureOrderServerMetadata(order);
      const descriptor = ORDER_STATUS_DESCRIPTORS[order.status] || { label: 'Updating status', tone: 'info' };
      const badgeClass = getBadgeClassForTone(descriptor.tone);
      const dishes = Array.isArray(order.items) && order.items.length ? order.items.map(item => esc(item)).join(', ') : 'No dishes listed';
      const allergies = Array.isArray(order.allergies) && order.allergies.length ? order.allergies.map(a => formatOrderListLabel(a)).join(', ') : 'None saved';
      const diets = Array.isArray(order.diets) && order.diets.length ? order.diets.join(', ') : 'None saved';
      const tableLabel = order.tableNumber ? `Table ${esc(order.tableNumber)}` : 'Table not recorded';
      const messageLog = Array.isArray(order.kitchenMessages) && order.kitchenMessages.length
        ? `<div class="kitchenOrderNotes">Messages sent: ${order.kitchenMessages.map(msg => `${esc(msg.text)} (${formatTabletTimestamp(msg.at)})`).join('; ')}</div>`
        : '';
      const questionLog = order.kitchenQuestion
        ? `<div class="kitchenOrderNotes">Follow-up: ${esc(order.kitchenQuestion.text)}${order.kitchenQuestion.response ? `  Diner replied ${esc(order.kitchenQuestion.response.toUpperCase())}` : '  Awaiting diner response'}</div>`
        : '';

      const actions = [];
      if (order.status === TABLET_ORDER_STATUSES.WITH_KITCHEN) {
        actions.push(`<button type="button" data-kitchen-action="acknowledge" data-order-id="${escapeAttribute(order.id)}">Acknowledge notice</button>`);
      }
      if (order.status !== TABLET_ORDER_STATUSES.ACKNOWLEDGED) {
        actions.push(`<button type="button" data-kitchen-action="message" data-order-id="${escapeAttribute(order.id)}">Send follow-up message</button>`);
      }

      const actionsHtml = actions.length ? `<div class="kitchenOrderActions">${actions.join('')}</div>` : '';

      return `
    <article class="kitchenOrderCard" data-order-id="${escapeAttribute(order.id)}">
      <div class="kitchenOrderHeader">
        <div>
          <div class="kitchenOrderTitle">${esc(order.customerName || 'Guest')}</div>
          <div class="kitchenOrderMeta">${tableLabel}  Dishes: ${dishes}</div>
        </div>
        <span class="${badgeClass}">${escapeConfirmationHtml(descriptor.label)}</span>
      </div>
      <div class="kitchenOrderMeta">Allergies: ${esc(allergies)}</div>
      <div class="kitchenOrderMeta">Dietary preferences: ${esc(diets)}</div>
      ${messageLog}
      ${questionLog}
      ${actionsHtml}
    </article>
  `;
    }

    function renderOrderConfirmKitchenPanel() {
      if (!orderConfirmKitchenPanel) return;
      const body = orderConfirmKitchenPanel.querySelector('.orderConfirmTabletBody');
      if (!body) return;
      const activeStatuses = [
        TABLET_ORDER_STATUSES.WITH_KITCHEN,
        TABLET_ORDER_STATUSES.ACKNOWLEDGED,
        TABLET_ORDER_STATUSES.AWAITING_USER_RESPONSE,
        TABLET_ORDER_STATUSES.QUESTION_ANSWERED
      ];
      const orders = tabletSimState.orders.filter(order => activeStatuses.includes(order.status));
      if (orders.length === 0) {
        body.innerHTML = '<div class="orderConfirmStatusBadge" data-tone="idle">Kitchen idle</div><p class="orderConfirmEmpty">The request will appear here after the server dispatches it.</p>';
        return;
      }
      const cards = orders.map(renderKitchenOrderCard).join('');
      body.innerHTML = `<div class="kitchenOrderList">${cards}</div>`;
    }

    async function handleOrderConfirmSubmit() {
      if (!orderConfirmForm) return;
      const { data: { user } } = await supabaseClient.auth.getUser();
      if (!user) {
        setStatusMessage(orderConfirmSubmitStatus, 'Please sign in or create an account to submit your notice.', 'error');
        if (orderConfirmAuthPrompt) orderConfirmAuthPrompt.style.display = 'block';
        return;
      }
      setStatusMessage(orderConfirmSubmitStatus, '');
      const name = (orderConfirmNameInput?.value || '').trim();
      if (!name) {
        setStatusMessage(orderConfirmSubmitStatus, 'Enter your name so the team knows who submitted this.', 'error');
        orderConfirmNameInput?.focus();
        return;
      }
      const diningMode = orderConfirmForm.elements['orderConfirmMode']?.value || 'dine-in';
      const codeValue = diningMode === 'dine-in' ? (orderConfirmCodeInput?.value || '').trim() : '';
      if (diningMode === 'dine-in' && !codeValue) {
        setStatusMessage(orderConfirmSubmitStatus, 'Enter the code your server shared when they\'re ready.', 'error');
        orderConfirmCodeInput?.focus();
        return;
      }
      const deliveryValue = (orderConfirmDeliveryInput?.value || '').trim();
      const allergies = Array.isArray(state.allergies) ? [...state.allergies] : [];
      const diets = Array.isArray(state.diets) ? [...state.diets] : [];
      const customNotes = (orderConfirmNotesInput?.value || '').trim();
      const dishesSummary = Array.isArray(window.orderItems) && window.orderItems.length ? window.orderItems.join(', ') : '';
      const codeMeta = diningMode === 'dine-in' ? parseServerCode(codeValue) : null;
      const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
      if (!restaurantId) {
        setStatusMessage(orderConfirmSubmitStatus, 'Unable to identify the restaurant for this notice.', 'error');
        return;
      }
      try {
        let order = getTabletOrder();
        if (!order) {
          const draft = createTabletOrderDraft({
            customerName: name,
            restaurantName: state.restaurant?.name || 'Unknown restaurant',
            diningMode,
            tableOrPickup: '',
            deliveryAddress: diningMode === 'delivery' ? deliveryValue : '',
            allergies,
            customNotes
          });
          if (user) {
            draft.userId = user.id;
          }
          draft.diets = diets;
          if (dishesSummary) {
            draft.history.push({
              at: new Date().toISOString(),
              actor: 'Diner',
              message: `Selected dishes: ${dishesSummary}`
            });
          }
          const allergyMessage = allergies.length
            ? `Flagged allergens: ${allergies.join(', ')}`
            : 'No allergens selected; sending confirmation request.';
          draft.history.push({
            at: new Date().toISOString(),
            actor: 'Diner',
            message: allergyMessage
          });
          const dietsMessage = diets.length
            ? `Dietary preferences: ${diets.join(', ')}`
            : 'No dietary preferences selected.';
          draft.history.push({
            at: new Date().toISOString(),
            actor: 'Diner',
            message: dietsMessage
          });
          if (customNotes) {
            draft.history.push({
              at: new Date().toISOString(),
              actor: 'Diner',
              message: `Additional note: "${customNotes}"`
            });
          }
          if (diningMode === 'dine-in') {
            order = tabletRequestServerCode(tabletSimState, draft, { code: codeValue });
            tabletSimOrderId = order.id;
          } else {
            // For delivery/pickup, create order without server code
            order = {
              ...draft,
              id: 'order_' + Date.now(),
              status: TABLET_ORDER_STATUSES.CODE_ASSIGNED,
              createdAt: new Date().toISOString()
            };
            tabletSimOrderId = order.id;
            tabletSimState.orders.push(order);
          }
        }
        order.items = Array.isArray(window.orderItems) ? [...window.orderItems] : [];
        order.diets = diets;
        if (user && !order.userId) {
          order.userId = user.id;
        }
        if (diningMode === 'dine-in' && codeMeta) {
          order.tableNumber = codeMeta.tableNumber;
          order.serverId = codeMeta.serverId;
          order.serverName = codeMeta.serverName;
          ensureOrderServerMetadata(order);
          serverPanelState.activeServerId = order.serverId;
          tabletSubmitOrderToServer(tabletSimState, tabletSimOrderId, codeValue);
        } else if (diningMode === 'delivery') {
          // For delivery, submit directly without server code
          order.status = TABLET_ORDER_STATUSES.SUBMITTED_TO_SERVER;
          order.submittedAt = new Date().toISOString();
        }
        await saveTabletOrder(order, { restaurantId });
        if (orderConfirmCodeInput) orderConfirmCodeInput.disabled = true;
        if (orderConfirmSubmitBtn) orderConfirmSubmitBtn.disabled = true;
        setStatusMessage(orderConfirmSubmitStatus, 'Order submitted to server station.', 'success');
        state.ack = true;
        const ackBtn = document.getElementById('ackBtn');
        if (ackBtn) {
          ackBtn.textContent = 'Acknowledged';
          ackBtn.classList.remove('off');
          ackBtn.classList.add('on');
        }
        persistTabletStateAndRender();
        // Clear order items from localStorage since notice has been submitted
        window.orderItems = [];
        persistOrderItems();
        updateOrderSidebar();
        closeOrderConfirmDrawer();
        openOrderSidebar();
        renderOrderSidebarStatus(order);
        startOrderRefresh();
      } catch (error) {
        console.error('Failed to submit order to server', error);
        setStatusMessage(orderConfirmSubmitStatus, error?.message || 'Unable to notify the server tablet right now.', 'error');
      }
    }

    function handleOrderConfirmServerPanel(evt) {
      const tabBtn = evt.target.closest?.('[data-server-tab]');
      if (tabBtn) {
        evt.preventDefault();
        const id = tabBtn.getAttribute('data-server-tab');
        if (id && id !== serverPanelState.activeServerId) {
          serverPanelState.activeServerId = id;
          renderOrderConfirmServerPanel();
        }
        return;
      }
      const actionBtn = evt.target.closest?.('[data-server-action]');
      if (actionBtn) {
        evt.preventDefault();
        const action = actionBtn.getAttribute('data-server-action');
        const orderId = actionBtn.getAttribute('data-order-id');
        if (!action || !orderId) return;
        handleServerOrderAction(action, orderId).catch(err => {
          console.error('Server action failed', err);
          alert('Unable to update server tablet at this time.');
        });
      }
    }

    function handleOrderConfirmKitchenPanel(evt) {
      const actionBtn = evt.target.closest?.('[data-kitchen-action]');
      if (!actionBtn) return;
      evt.preventDefault();
      const action = actionBtn.getAttribute('data-kitchen-action');
      const orderId = actionBtn.getAttribute('data-order-id');
      if (!action || !orderId) return;
      handleKitchenOrderAction(action, orderId).catch(err => {
        console.error('Kitchen action failed', err);
        alert('Unable to update the kitchen tablet right now.');
      });
    }

    async function handleKitchenOrderAction(action, orderId) {
      const order = getTabletOrderById(orderId);
      if (!order) return;
      try {
        if (action === 'acknowledge') {
          const chefId = tabletSimState.chefs[0]?.id || null;
          if (!chefId) throw new Error('No FaceID-enrolled chefs found.');
          tabletKitchenAcknowledge(tabletSimState, orderId, chefId);
        } else if (action === 'message') {
          const text = await showTextPrompt({
            title: 'Send follow-up message',
            message: 'What would you like the diner to see on their side?',
            placeholder: 'e.g. Please confirm if sesame oil is okay before we proceed.',
            confirmLabel: 'Send message',
            cancelLabel: 'Cancel'
          });
          if (!text) return;
          recordKitchenMessage(order, text);
        } else {
          return;
        }
        persistTabletStateAndRender();
      } catch (error) {
        throw error;
      }
    }

    function handleOrderConfirmReset() {
      renderOrderConfirmSummary();
      resetOrderConfirmFlow();
      renderOrderConfirmAllergies();
      renderOrderConfirmDiets();
    }

    async function handleRescindNotice(evt) {
      const btn = evt.target.closest('.orderSidebarRescindBtn');
      if (!btn) return;
      const orderId = btn.getAttribute('data-order-id');
      if (!orderId) return;
      const confirmed = confirm('Are you sure you want to rescind this notice? This will cancel the allergy notice submission.');
      if (!confirmed) return;
      try {
        await deleteTabletOrder(orderId);
        const orderIndex = tabletSimState.orders.findIndex(o => o.id === orderId);
        if (orderIndex !== -1) {
          tabletSimState.orders.splice(orderIndex, 1);
        }
        if (tabletSimOrderId === orderId) {
          tabletSimOrderId = null;
          stopOrderRefresh();
        }
        persistTabletStateSnapshot();
        renderOrderSidebarStatus(null);
        updateOrderSidebar();
      } catch (error) {
        console.error('Failed to rescind notice', error);
        alert('Unable to rescind the notice right now. Please try again.');
      }
    }

    async function handleKitchenQuestionResponse(evt) {
      const btn = evt.target.closest('.orderSidebarQuestionBtn');
      if (!btn) return;
      const orderId = btn.getAttribute('data-order-id');
      const response = btn.getAttribute('data-response');
      if (!orderId || !response || !['yes', 'no'].includes(response)) return;
      try {
        const order = getTabletOrderById(orderId);
        if (!order || !order.kitchenQuestion) return;
        tabletUserRespondToQuestion(tabletSimState, orderId, response);
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        if (restaurantId) {
          await saveTabletOrder(order, { restaurantId });
        }
        persistTabletStateAndRender();
        renderOrderSidebarStatus(order);
      } catch (error) {
        console.error('Failed to respond to kitchen question', error);
        alert('Unable to send your response right now. Please try again.');
      }
    }

    async function checkForActiveOrders() {
      try {
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        if (!restaurantId) return;

        // Clear orders from other restaurants
        tabletSimState.orders = tabletSimState.orders.filter(o => {
          if (!o.restaurantId) return false; // Remove orders without restaurantId
          return o.restaurantId === restaurantId;
        });

        // If current order is from a different restaurant, clear it
        if (tabletSimOrderId) {
          const currentOrder = tabletSimState.orders.find(o => o.id === tabletSimOrderId);
          if (!currentOrder || (currentOrder.restaurantId && currentOrder.restaurantId !== restaurantId)) {
            tabletSimOrderId = null;
            stopOrderRefresh();
          }
        }

        const orders = await fetchTabletOrders([restaurantId]);
        const activeOrder = orders.find(o => o.status !== TABLET_ORDER_STATUSES.CODE_ASSIGNED && o.status !== TABLET_ORDER_STATUSES.DRAFT);
        if (activeOrder) {
          const existingOrder = tabletSimState.orders.find(o => o.id === activeOrder.id);
          if (existingOrder) {
            const index = tabletSimState.orders.indexOf(existingOrder);
            tabletSimState.orders[index] = activeOrder;
          } else {
            tabletSimState.orders.push(activeOrder);
          }
          tabletSimOrderId = activeOrder.id;
          persistTabletStateSnapshot();
          state.ack = true;
          const ackBtn = document.getElementById('ackBtn');
          if (ackBtn) {
            ackBtn.textContent = 'Acknowledged';
            ackBtn.classList.remove('off');
            ackBtn.classList.add('on');
          }
          renderOrderSidebarStatus(activeOrder);
          openOrderSidebar();
          startOrderRefresh();
        } else {
          // No active order for this restaurant - clear sidebar
          renderOrderSidebarStatus(null);
        }
      } catch (error) {
        console.error('Failed to check for active orders', error);
      }
    }

    function bindOrderConfirmModeSwitcher() {
      if (orderConfirmModeBound || !orderConfirmForm) return;
      const radios = orderConfirmForm.querySelectorAll('input[name="orderConfirmMode"]');
      radios.forEach(radio => {
        radio.addEventListener('change', () => {
          updateOrderConfirmModeVisibility();
        });
      });
      orderConfirmModeBound = true;
      updateOrderConfirmModeVisibility();
    }

    function updateOrderConfirmModeVisibility() {
      if (!orderConfirmForm) return;
      const conditionalLabels = orderConfirmForm.querySelectorAll('.orderConfirmConditional [data-mode]');
      const active = orderConfirmForm.querySelector('input[name="orderConfirmMode"]:checked');
      const isDelivery = active && active.value === 'delivery';

      conditionalLabels.forEach(label => {
        const mode = label.getAttribute('data-mode');
        label.hidden = !active || active.value !== mode;
      });

      // Update delivery button visibility and link
      const deliveryButtonContainer = document.getElementById('deliveryButtonContainer');
      if (deliveryButtonContainer) {
        deliveryButtonContainer.hidden = !isDelivery;
        const deliveryLinkButton = document.getElementById('deliveryLinkButton');
        if (deliveryLinkButton) {
          if (isDelivery && state.restaurant?.delivery_url) {
            deliveryLinkButton.href = state.restaurant.delivery_url;
            deliveryLinkButton.style.display = 'inline-flex';
            deliveryLinkButton.style.opacity = '1';
            deliveryLinkButton.style.cursor = 'pointer';
            deliveryLinkButton.onclick = null; // Allow default link behavior
          } else if (isDelivery && !state.restaurant?.delivery_url) {
            // Show button but disabled if no URL is set
            deliveryLinkButton.href = '#';
            deliveryLinkButton.style.display = 'inline-flex';
            deliveryLinkButton.style.opacity = '0.5';
            deliveryLinkButton.style.cursor = 'not-allowed';
            deliveryLinkButton.onclick = (e) => {
              e.preventDefault();
              alert('Delivery URL not configured. Please contact the restaurant.');
            };
          } else {
            deliveryLinkButton.style.display = 'none';
          }
        }
      }

      // Update server code section visibility
      const dineInCodeSection = document.getElementById('dineInCodeSection');
      const deliveryMessageSection = document.getElementById('deliveryMessageSection');
      if (dineInCodeSection) {
        dineInCodeSection.style.display = isDelivery ? 'none' : 'block';
      }
      if (deliveryMessageSection) {
        deliveryMessageSection.style.display = isDelivery ? 'block' : 'none';
      }
    }

    function getTabletOrder() {
      if (!tabletSimOrderId) return null;
      const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
      if (!restaurantId) return null;
      const order = tabletSimState.orders.find(order => order.id === tabletSimOrderId) || null;
      // Only return order if it belongs to the current restaurant
      if (order && order.restaurantId && order.restaurantId !== restaurantId) {
        // Order belongs to a different restaurant - clear it
        tabletSimOrderId = null;
        const index = tabletSimState.orders.indexOf(order);
        if (index > -1) {
          tabletSimState.orders.splice(index, 1);
        }
        persistTabletStateSnapshot();
        return null;
      }
      return order;
    }

    function setOrderConfirmStatusBadge(label, tone = 'idle') {
      if (!orderConfirmStatusBadge) return;
      orderConfirmStatusBadge.dataset.tone = tone || 'idle';
      orderConfirmStatusBadge.textContent = label;
    }

    function setStatusMessage(target, message, variant) {
      if (!target) return;
      target.textContent = message || '';
      target.classList.remove('error', 'success');
      if (!message) return;
      if (variant === 'error') {
        target.classList.add('error');
      } else if (variant === 'success') {
        target.classList.add('success');
      }
    }

    function deepCloneArray(value) {
      try {
        return JSON.parse(JSON.stringify(Array.isArray(value) ? value : []));
      } catch (error) {
        console.warn('Failed to clone tablet state array', error);
        return [];
      }
    }

    function persistTabletStateSnapshot() {
      const payload = persistTabletState({
        orders: tabletSimState.orders,
        chefs: tabletSimState.chefs,
        lastServerCode: tabletSimState.lastServerCode,
        currentOrderId: tabletSimOrderId
      });
      if (payload) {
        tabletStateUpdatedAt = payload.updatedAt || Date.now();
      }
      return payload;
    }

    function persistTabletStateAndRender() {
      persistTabletStateSnapshot();
      renderOrderConfirm();
    }

    function formatOrderListLabel(value) {
      return String(value || '')
        .split(' ')
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function getDishOverlayByName(dishName) {
      const overlays = Array.isArray(state.restaurant?.overlays) ? state.restaurant.overlays : [];
      const target = (dishName || '').toString().trim().toLowerCase();
      if (!target) return null;
      return overlays.find(overlay => {
        const candidate = (overlay.id || overlay.name || '').toString().trim().toLowerCase();
        return candidate === target;
      }) || null;
    }

    function renderCompatibilityList(messages, extraClass) {
      if (!messages || messages.length === 0) return '';
      const className = extraClass ? `orderDishStatusList ${extraClass}` : 'orderDishStatusList';
      const items = messages.map(msg => {
        const type = msg.type || 'info';
        return `<li class="${type}">${esc(msg.text)}</li>`;
      }).join('');
      return `<ul class="${className}">${items}</ul>`;
    }

    function getDishCompatibilityDetails(dishName) {
      const userAllergies = Array.isArray(state.allergies) ? state.allergies : [];
      const userDiets = Array.isArray(state.diets) ? state.diets : [];
      const dish = getDishOverlayByName(dishName);
      const details = {
        dish,
        severity: 'success',
        badgeLabel: 'Meets all requirements',
        allergenMessages: [],
        dietMessages: [],
        hasPreferences: userAllergies.length > 0 || userDiets.length > 0,
        issues: {
          allergens: [],
          diets: []
        }
      };

      const severityRank = { success: 0, warn: 1, danger: 2 };
      let highestRank = -1;
      const trackSeverity = (type) => {
        const rank = severityRank[type];
        if (rank !== undefined && rank > highestRank) {
          highestRank = rank;
        }
      };

      if (!dish) {
        if (details.hasPreferences) {
          details.severity = 'warn';
          details.badgeLabel = 'Check with staff';
          if (userAllergies.length) {
            details.allergenMessages.push({ type: 'warn', text: 'Allergen details unavailable for this item.' });
            trackSeverity('warn');
          } else {
            details.allergenMessages.push({ type: 'info', text: 'Allergen details unavailable for this item.' });
          }
          if (userDiets.length) {
            details.dietMessages.push({ type: 'warn', text: 'Dietary compatibility unknown.' });
            trackSeverity('warn');
          }
        } else {
          details.severity = 'info';
          details.badgeLabel = 'No saved preferences';
          details.allergenMessages.push({ type: 'info', text: 'No allergies saved' });
          details.dietMessages.push({ type: 'info', text: 'No dietary preferences saved' });
        }
        return details;
      }

      const dishAllergens = Array.isArray(dish.allergens) ? dish.allergens : [];
      const dishDietSet = new Set(Array.isArray(dish.diets) ? dish.diets : []);
      const removableAllergens = new Set((dish.removable || []).map(r => norm(r.allergen || '')));

      if (userAllergies.length === 0) {
        details.allergenMessages.push({ type: 'info', text: 'No allergies saved' });
      } else {
        userAllergies.forEach(allergen => {
          const normalized = norm(allergen);
          const friendly = formatOrderListLabel(allergen);
          const hasAllergen = dishAllergens.some(a => norm(a) === normalized);
          if (!hasAllergen) {
            details.allergenMessages.push({ type: 'success', text: `Doesn't contain ${friendly}` });
          } else if (removableAllergens.has(normalized)) {
            details.allergenMessages.push({ type: 'warn', text: `Contains ${friendly} but can be accommodated` });
            trackSeverity('warn');
          } else {
            details.allergenMessages.push({ type: 'danger', text: `Contains ${friendly}` });
            trackSeverity('danger');
            details.issues.allergens.push(friendly);
          }
        });
      }

      const allergenConflicts = {
        Vegan: ['dairy', 'egg', 'fish', 'shellfish'],
        Vegetarian: ['fish', 'shellfish'],
        Pescatarian: [],
        'Gluten-free': ['wheat']
      };

      if (userDiets.length === 0) {
        details.dietMessages.push({ type: 'info', text: 'No dietary preferences saved' });
      } else {
        userDiets.forEach(diet => {
          const friendlyDiet = formatOrderListLabel(diet);
          const conflicts = allergenConflicts[diet] || [];
          const blockingAllergens = conflicts.filter(allergen => dishAllergens.some(a => norm(a) === norm(allergen)));
          const allBlockingRemovable = blockingAllergens.length > 0 &&
            blockingAllergens.every(allergen => removableAllergens.has(norm(allergen)));

          if (dishDietSet.has(diet)) {
            details.dietMessages.push({ type: 'success', text: `Meets ${friendlyDiet.toLowerCase()}` });
          } else if (allBlockingRemovable) {
            details.dietMessages.push({ type: 'warn', text: `Can be made ${friendlyDiet.toLowerCase()}` });
            trackSeverity('warn');
          } else if (blockingAllergens.length > 0) {
            details.dietMessages.push({ type: 'danger', text: `Not ${friendlyDiet.toLowerCase()}` });
            trackSeverity('danger');
            details.issues.diets.push(friendlyDiet);
          } else {
            details.dietMessages.push({ type: 'danger', text: `Not ${friendlyDiet.toLowerCase()}` });
            trackSeverity('danger');
            details.issues.diets.push(friendlyDiet);
          }
        });
      }

      if (details.issues.allergens.length > 0 || details.issues.diets.length > 0) {
        details.severity = 'danger';
        details.badgeLabel = 'Cannot be accommodated';
      } else if (highestRank === 1) {
        details.severity = 'warn';
        details.badgeLabel = 'Can be accommodated';
      } else if (details.hasPreferences) {
        details.severity = 'success';
        details.badgeLabel = 'Meets all requirements';
      } else {
        details.severity = 'info';
        details.badgeLabel = 'No saved preferences';
      }

      return details;
    }

    function renderCompatibilitySection(title, messages) {
      const list = renderCompatibilityList(messages);
      if (!list) return '';
      return `<div class="orderConfirmDishSection">
    <div class="orderConfirmDishSectionTitle">${esc(title)}</div>
    ${list}
  </div>`;
    }

    function createDishSummaryCard(dishName) {
      const details = getDishCompatibilityDetails(dishName);
      const severityClass = {
        success: 'orderConfirmDishBadge--success',
        warn: 'orderConfirmDishBadge--warn',
        danger: 'orderConfirmDishBadge--danger',
        info: 'orderConfirmDishBadge--info'
      }[details.severity] || 'orderConfirmDishBadge--info';
      const allergenSection = renderCompatibilitySection('Allergens', details.allergenMessages);
      const dietSection = renderCompatibilitySection('Dietary preferences', details.dietMessages);
      const sections = [allergenSection, dietSection].filter(Boolean).join('');
      const body = sections || '<p class="orderConfirmDishNote">No saved allergies or dietary preferences.</p>';
      return `
    <article class="orderConfirmDishCard" data-severity="${details.severity}">
      <div class="orderConfirmDishCardHeader">
        <div class="orderConfirmDishName">${esc(dishName)}</div>
        <span class="orderConfirmDishBadge ${severityClass}">${esc(details.badgeLabel)}</span>
      </div>
      ${body}
    </article>
  `;
    }

    function getBadgeClassForTone(tone) {
      switch (tone) {
        case 'success':
          return 'orderConfirmDishBadge orderConfirmDishBadge--success';
        case 'warn':
          return 'orderConfirmDishBadge orderConfirmDishBadge--warn';
        case 'danger':
          return 'orderConfirmDishBadge orderConfirmDishBadge--danger';
        default:
          return 'orderConfirmDishBadge orderConfirmDishBadge--info';
      }
    }

    function buildAddToOrderWarningMessage(dishName, details) {
      const parts = [];
      if (details.issues?.allergens?.length) {
        const list = details.issues.allergens.join(', ');
        parts.push(`${dishName} contains ${list} that cannot be accommodated.`);
      }
      if (details.issues?.diets?.length) {
        const list = details.issues.diets.map(d => d.toLowerCase()).join(', ');
        parts.push(`${dishName} does not meet your ${list} preference${details.issues.diets.length > 1 ? 's' : ''}.`);
      }
      const intro = parts.length ? parts.join(' ') : 'This dish may not align with your saved preferences.';
      return `${intro} Are you sure you want to add this to your order?`;
    }

    function ensureAddToOrderConfirmContainer(tipEl) {
      let container = tipEl.querySelector('.addToOrderConfirm');
      if (container) return container;
      container = document.createElement('div');
      container.className = 'addToOrderConfirm';
      container.style.display = 'none';
      container.innerHTML = `
    <p data-role="message"></p>
    <div class="addToOrderConfirmActions">
      <button type="button" class="addToOrderConfirmCancel">Keep browsing</button>
      <button type="button" class="addToOrderConfirmProceed">Add anyway</button>
    </div>
  `;
      tipEl.appendChild(container);
      const cancelBtn = container.querySelector('.addToOrderConfirmCancel');
      const proceedBtn = container.querySelector('.addToOrderConfirmProceed');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', (event) => {
          if (event) { event.preventDefault(); event.stopPropagation(); }
          hideAddToOrderConfirmation(container);
        });
      }
      if (proceedBtn) {
        proceedBtn.addEventListener('click', (event) => {
          if (event) { event.preventDefault(); event.stopPropagation(); }
          const dishName = container.dataset.dishName;
          if (!dishName) return;
          const result = addDishToOrder(dishName, { force: true });
          if (result?.success) {
            hideAddToOrderConfirmation(container);
            const btn = container.__addBtn;
            if (btn) {
              btn.disabled = true;
              btn.textContent = 'Added';
            }
          }
        });
      }
      return container;
    }

    function showAddToOrderConfirmation(container, dishName, details, addButton) {
      if (!container) return;
      container.__addBtn = addButton || null;
      const messageEl = container.querySelector('[data-role="message"]');
      const proceedBtn = container.querySelector('.addToOrderConfirmProceed');
      container.dataset.dishName = dishName;
      container.dataset.severity = details.severity || 'warn';
      if (messageEl) {
        messageEl.textContent = buildAddToOrderWarningMessage(dishName, details);
      }
      if (proceedBtn) {
        const isWarn = details.severity === 'warn';
        proceedBtn.classList.toggle('warn', isWarn);
        proceedBtn.textContent = isWarn ? 'Add with adjustments' : 'Add anyway';
      }
      container.style.display = 'flex';
    }

    function hideAddToOrderConfirmation(container) {
      if (!container) return;
      container.style.display = 'none';
      container.dataset.dishName = '';
      container.dataset.severity = '';
    }

    const SERVER_CODE_PREFIX_LENGTH = 4;
    function parseServerCode(code) {
      const raw = String(code || '').trim();
      if (!raw) {
        return {
          serverId: '0000',
          tableNumber: '',
          serverName: 'Server'
        };
      }
      const prefix = raw.slice(0, SERVER_CODE_PREFIX_LENGTH) || '0000';
      const remainder = raw.slice(SERVER_CODE_PREFIX_LENGTH).trim();
      return {
        serverId: prefix,
        tableNumber: remainder || '',
        serverName: `Server ${prefix}`
      };
    }

    function ensureOrderServerMetadata(order) {
      if (!order) return null;
      if (order.serverId && order.serverName) return order;
      const parsed = parseServerCode(order.serverCode);
      order.serverId = order.serverId || parsed.serverId;
      order.serverName = order.serverName || parsed.serverName;
      if (typeof order.tableNumber === 'undefined') {
        order.tableNumber = parsed.tableNumber;
      }
      return order;
    }

    function getTabletOrderById(orderId) {
      if (!orderId) return null;
      return tabletSimState.orders.find(order => order.id === orderId) || null;
    }

    function recordKitchenMessage(order, message) {
      if (!order || !message?.trim()) return;
      const text = message.trim();
      const entry = {
        text,
        at: new Date().toISOString()
      };
      if (!Array.isArray(order.kitchenMessages)) {
        order.kitchenMessages = [];
      }
      order.kitchenMessages.push(entry);
      order.history.push({
        actor: 'Kitchen',
        message: `Sent message to diner: "${text}"`,
        at: entry.at
      });
      order.status = TABLET_ORDER_STATUSES.AWAITING_USER_RESPONSE;
      order.updatedAt = entry.at;
    }

    function showTextPrompt({ title = 'Input', message = '', placeholder = '', confirmLabel = 'Confirm', cancelLabel = 'Cancel' } = {}) {
      return new Promise((resolve) => {
        const backdrop = document.createElement('div');
        backdrop.className = 'appPromptBackdrop';
        const modal = document.createElement('div');
        modal.className = 'appPromptModal';
        const heading = document.createElement('h3');
        heading.textContent = title;
        modal.appendChild(heading);
        if (message) {
          const desc = document.createElement('p');
          desc.textContent = message;
          modal.appendChild(desc);
        }
        const textarea = document.createElement('textarea');
        textarea.placeholder = placeholder;
        modal.appendChild(textarea);
        const actions = document.createElement('div');
        actions.className = 'appPromptModalActions';
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'appPromptCancel';
        cancelBtn.textContent = cancelLabel;
        const confirmBtn = document.createElement('button');
        confirmBtn.type = 'button';
        confirmBtn.className = 'appPromptConfirm';
        confirmBtn.textContent = confirmLabel;
        actions.appendChild(cancelBtn);
        actions.appendChild(confirmBtn);
        modal.appendChild(actions);
        backdrop.appendChild(modal);
        document.body.appendChild(backdrop);

        const cleanup = () => {
          backdrop.remove();
        };

        cancelBtn.addEventListener('click', () => {
          cleanup();
          resolve(null);
        });
        confirmBtn.addEventListener('click', () => {
          const value = textarea.value.trim();
          cleanup();
          resolve(value);
        });
        backdrop.addEventListener('click', (event) => {
          if (event.target === backdrop) {
            cleanup();
            resolve(null);
          }
        });
        textarea.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            event.preventDefault();
            cleanup();
            resolve(null);
          } else if (event.key === 'Enter' && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            const value = textarea.value.trim();
            cleanup();
            resolve(value);
          }
        });
        setTimeout(() => textarea.focus(), 50);
      });
    }

    function formatTabletTimestamp(iso) {
      if (!iso) return '';
      const date = new Date(iso);
      if (Number.isNaN(date.getTime())) return '';
      return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
    }

    function escapeConfirmationHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function escapeAttribute(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;');
    }

    function getRestaurantSlug() {
      if (state.restaurant?.slug) return state.restaurant.slug;
      if (typeof slug === 'string' && slug) return slug;
      return '';
    }

    function getOrderItemsStorageKey() {
      const restaurantSlug = getRestaurantSlug();
      return restaurantSlug ? `orderItems:${restaurantSlug}` : 'orderItems';
    }

    function getOrderFormStateStorageKey() {
      const restaurantSlug = getRestaurantSlug();
      return restaurantSlug ? `orderConfirmFormState:${restaurantSlug}` : 'orderConfirmFormState';
    }

    // Order management functions
    function persistOrderItems() {
      const storageKey = getOrderItemsStorageKey();
      try {
        if (window.orderItems && Array.isArray(window.orderItems) && window.orderItems.length > 0) {
          localStorage.setItem(storageKey, JSON.stringify({
            items: window.orderItems,
            timestamp: Date.now()
          }));
        } else {
          localStorage.removeItem(storageKey);
        }
        if (storageKey !== 'orderItems') {
          localStorage.removeItem('orderItems');
        }
      } catch (error) {
        console.error('Failed to persist order items', error);
      }
    }

    function restoreOrderItems() {
      const storageKey = getOrderItemsStorageKey();
      try {
        let saved = localStorage.getItem(storageKey);
        let usedLegacyKey = false;
        if (!saved && storageKey !== 'orderItems') {
          saved = localStorage.getItem('orderItems');
          if (saved) usedLegacyKey = true;
        }
        if (saved) {
          const data = JSON.parse(saved);
          const isValidArray = data && Array.isArray(data.items);
          const isFresh = data && data.timestamp && Date.now() - data.timestamp < 86400000;
          if (isValidArray && isFresh && data.items.length) {
            window.orderItems = [...data.items];
            if (usedLegacyKey) {
              localStorage.removeItem('orderItems');
              localStorage.setItem(storageKey, saved);
            }
            return true;
          } else {
            localStorage.removeItem(storageKey);
            if (usedLegacyKey) localStorage.removeItem('orderItems');
          }
        }
      } catch (error) {
        console.error('Failed to restore order items', error);
        localStorage.removeItem(storageKey);
        if (storageKey !== 'orderItems') localStorage.removeItem('orderItems');
      }
      window.orderItems = [];
      return false;
    }

    function addDishToOrder(dishName, options = {}) {
      if (!window.orderItems) window.orderItems = [];
      if (window.orderItems.includes(dishName)) {
        return { success: false, message: 'already-added' };
      }

      const force = !!options.force;

      // Check if dish can be accommodated with user's allergens and diets
      const userAllergies = state.allergies || [];
      const userDiets = state.diets || [];
      const issues = {
        allergens: [],
        diets: []
      };

      // Get dish data from overlays (use same function as getDishCompatibilityDetails for consistency)
      const dish = getDishOverlayByName(dishName);

      if (dish) {
        const dishAllergens = dish.allergens || [];
        const removableAllergens = new Set((dish.removable || []).map(r => norm(r.allergen || '')));

        // Check if any user allergen is present and cannot be accommodated
        if (userAllergies.length > 0) {
          const nonAccommodatableAllergens = userAllergies.filter(allergen => {
            const normalizedAllergen = norm(allergen);
            const hasAllergen = dishAllergens.some(a => norm(a) === normalizedAllergen);
            return hasAllergen && !removableAllergens.has(normalizedAllergen);
          });

          if (nonAccommodatableAllergens.length > 0) {
            issues.allergens = nonAccommodatableAllergens.map(a => formatOrderListLabel(a));
          }
        }

        // Check diet incompatibilities (check even if no allergies)
        if (userDiets.length > 0) {
          const dishDietSet = new Set(dish.diets || []);
          const allergenConflicts = {
            Vegan: ['dairy', 'egg', 'fish', 'shellfish'],
            Vegetarian: ['fish', 'shellfish'],
            Pescatarian: []
          };
          userDiets.forEach(diet => {
            const conflicts = allergenConflicts[diet] || [];
            // Use exact same logic as getDishCompatibilityDetails
            const blockingAllergens = conflicts.filter(allergen => dishAllergens.some(a => norm(a) === norm(allergen)));
            const friendlyDiet = formatOrderListLabel(diet);
            const meetsDiet = dishDietSet.has(diet);
            const allBlockingRemovable = blockingAllergens.length > 0 &&
              blockingAllergens.every(allergen => removableAllergens.has(norm(allergen)));

            // Match the exact logic from getDishCompatibilityDetails:
            // - If diet is explicitly met, no issue
            // - If all blocking allergens are removable, no issue (can be made)
            // - Otherwise, add to issues (cannot be made or unknown)
            if (meetsDiet) {
              // Diet is explicitly met, no issue
            } else if (allBlockingRemovable) {
              // Can be made vegan, no issue
            } else {
              // Cannot be made or unknown, require confirmation
              issues.diets.push(friendlyDiet);
            }
          });
        }

        if ((issues.allergens.length > 0 || issues.diets.length > 0) && !force) {
          return {
            success: false,
            needsConfirmation: true,
            issues
          };
        }
      }
      // If dish not found in overlays, allow adding (user can decide)

      // Add to order if it can be accommodated
      window.orderItems.push(dishName);
      persistOrderItems();
      updateOrderSidebar();
      openOrderSidebar();
      return { success: true };
    }

    function removeDishFromOrder(dishName) {
      if (!window.orderItems) window.orderItems = [];
      const index = window.orderItems.indexOf(dishName);
      if (index > -1) {
        window.orderItems.splice(index, 1);
        persistOrderItems();
        updateOrderSidebar();
        // Re-enable "Add to order" button if item is removed while tooltip is open
        const addBtn = document.querySelector(`.addToOrderBtn[data-dish-name="${esc(dishName)}"]`);
        if (addBtn) {
          addBtn.disabled = false;
          addBtn.textContent = 'Add to order';
        }
      }
    }

    function updateOrderSidebar() {
      const sidebarItemsContainer = document.getElementById('orderSidebarItems');
      const confirmBtn = document.getElementById('confirmOrderBtn');
      if (!sidebarItemsContainer) return;
      if (sidebarItemsContainer.dataset.mode === 'pending') return;
      if (!sidebarItemsContainer.dataset.mode) {
        sidebarItemsContainer.dataset.mode = 'cart';
      }

      if (!window.orderItems || window.orderItems.length === 0) {
        sidebarItemsContainer.innerHTML = '<div class="orderSidebarEmpty">No items added yet</div>';
        if (confirmBtn) confirmBtn.disabled = true;
      } else {
        const itemsHTML = window.orderItems.map(dishName => `
      <div class="orderSidebarCard">
        <div class="orderItem">
          <div style="flex:1">
            <div class="orderItemName">${esc(dishName)}</div>
          </div>
          <button type="button" class="orderItemRemove" data-dish-name="${esc(dishName)}">Remove</button>
        </div>
      </div>
    `).join('');
        sidebarItemsContainer.innerHTML = itemsHTML;

        // Attach remove handlers
        sidebarItemsContainer.querySelectorAll('.orderItemRemove').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const dishName = btn.getAttribute('data-dish-name');
            if (dishName) removeDishFromOrder(dishName);
          });
        });

        if (confirmBtn) confirmBtn.disabled = false;
      }

      if (orderConfirmDrawer?.classList.contains('show')) {
        renderOrderConfirmSummary();
      }
    }

    function openOrderSidebar() {
      const sidebar = document.getElementById('orderSidebar');
      const toggleBtn = document.getElementById('orderSidebarToggle');
      if (sidebar) {
        sidebar.classList.add('open');
        sidebar.classList.remove('minimized');
        if (toggleBtn) toggleBtn.innerHTML = '';
      }
    }

    function toggleOrderSidebar() {
      const sidebar = document.getElementById('orderSidebar');
      const toggleBtn = document.getElementById('orderSidebarToggle');
      if (sidebar) {
        if (sidebar.classList.contains('minimized')) {
          sidebar.classList.remove('minimized');
          sidebar.classList.add('open');
          if (toggleBtn) toggleBtn.innerHTML = '';
        } else {
          sidebar.classList.add('minimized');
          if (toggleBtn) toggleBtn.innerHTML = '+ View order';
        }
      }
    }

    function confirmOrder() {
      if (!window.orderItems || window.orderItems.length === 0) {
        alert('Please add items to your order first.');
        return;
      }
      openOrderConfirmDrawer();
    }

    // Initialize order sidebar handlers
    let orderRefreshTimerId = null;
    const ORDER_REFRESH_INTERVAL_MS = 15000;

    async function refreshOrderStatus() {
      if (!tabletSimOrderId) return;
      try {
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        if (!restaurantId) return;
        const orders = await fetchTabletOrders([restaurantId]);
        const currentOrder = orders.find(o => o.id === tabletSimOrderId);
        if (currentOrder) {
          const existingOrder = tabletSimState.orders.find(o => o.id === tabletSimOrderId);
          if (existingOrder) {
            const index = tabletSimState.orders.indexOf(existingOrder);
            tabletSimState.orders[index] = currentOrder;
          } else {
            tabletSimState.orders.push(currentOrder);
          }
          persistTabletStateSnapshot();
          renderOrderSidebarStatus(currentOrder);
        }
      } catch (error) {
        console.error('Failed to refresh order status', error);
      }
    }

    function startOrderRefresh() {
      stopOrderRefresh();
      if (!tabletSimOrderId) return;
      orderRefreshTimerId = setInterval(() => {
        refreshOrderStatus().catch(err => {
          console.error('[order-refresh] periodic refresh failed', err);
        });
      }, ORDER_REFRESH_INTERVAL_MS);
    }

    function stopOrderRefresh() {
      if (orderRefreshTimerId) {
        clearInterval(orderRefreshTimerId);
        orderRefreshTimerId = null;
      }
    }

    function initOrderSidebar() {
      // Filter orders by current restaurant when sidebar initializes
      const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
      if (restaurantId) {
        tabletSimState.orders = tabletSimState.orders.filter(o => {
          if (!o.restaurantId) return false;
          return o.restaurantId === restaurantId;
        });
        // Clear current order if it's from a different restaurant
        if (tabletSimOrderId) {
          const currentOrder = tabletSimState.orders.find(o => o.id === tabletSimOrderId);
          if (!currentOrder || (currentOrder.restaurantId && currentOrder.restaurantId !== restaurantId)) {
            tabletSimOrderId = null;
            stopOrderRefresh();
          }
        }
        persistTabletStateSnapshot();
      }

      const toggleBtn = document.getElementById('orderSidebarToggle');
      const confirmBtn = document.getElementById('confirmOrderBtn');
      const refreshBtn = document.getElementById('orderSidebarRefreshBtn');

      if (toggleBtn) {
        toggleBtn.addEventListener('click', (e) => {
          e.preventDefault();
          toggleOrderSidebar();
        });
      }

      if (confirmBtn) {
        confirmBtn.addEventListener('click', (e) => {
          e.preventDefault();
          confirmOrder();
        });
      }

      if (refreshBtn) {
        refreshBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          refreshBtn.disabled = true;
          refreshBtn.textContent = '';
          refreshBtn.style.opacity = '0.6';
          try {
            await refreshOrderStatus();
          } finally {
            setTimeout(() => {
              refreshBtn.disabled = false;
              refreshBtn.style.opacity = '1';
            }, 500);
          }
        });
      }

      // Restore order items from localStorage if they exist
      const hasRestoredItems = restoreOrderItems();
      if (hasRestoredItems && window.orderItems && window.orderItems.length > 0) {
        // Visually restore selected dishes in the menu
        const waitForMenu = () => {
          const menu = document.getElementById('menu');
          if (menu && menu.querySelectorAll('.overlay').length > 0) {
            window.orderItems.forEach(dishName => {
              const overlays = document.querySelectorAll('.overlay');
              overlays.forEach(overlay => {
                const titleEl = overlay.querySelector('.tTitle');
                if (titleEl) {
                  const title = titleEl.textContent.trim();
                  if (title.toLowerCase() === dishName.toLowerCase() || title === dishName) {
                    overlay.classList.add('selected');
                    const addBtn = overlay.querySelector(`.addToOrderBtn[data-dish-name]`);
                    if (addBtn) {
                      addBtn.disabled = true;
                      addBtn.textContent = 'Added';
                    }
                  }
                }
              });
            });
            updateOrderSidebar();
            openOrderSidebar();
          } else {
            setTimeout(waitForMenu, 100);
          }
        };
        setTimeout(waitForMenu, 500);
      } else {
        // Initialize sidebar state
        updateOrderSidebar();
      }

      // Start periodic refresh if there's an active order
      if (tabletSimOrderId) {
        startOrderRefresh();
        const order = getTabletOrderById(tabletSimOrderId);
        if (order) {
          state.ack = true;
          const ackBtn = document.getElementById('ackBtn');
          if (ackBtn) {
            ackBtn.textContent = 'Acknowledged';
            ackBtn.classList.remove('off');
            ackBtn.classList.add('on');
          }
          renderOrderSidebarStatus(order);
          openOrderSidebar();
        }
      } else if (state.restaurant) {
        // Check for active orders if no order is currently loaded
        setTimeout(() => checkForActiveOrders(), 1000);
      }
    }

    let mobileInfoPanel = null;
    let currentMobileInfoItem = null;
    let mobileViewerChrome = null;
    let mobileZoomLevel = 1;
    let mobileViewerKeyHandler = null;

    // ========== Mobile Overlay Zoom ==========
    let isOverlayZoomed = false;
    let zoomedOverlayItem = null;
    let preZoomScrollPos = { x: 0, y: 0 };

    // Diet emoji mapping
    const DIET_EMOJI = {
      'vegan': '',
      'vegetarian': '',
      'gluten-free': '',
      'halal': '',
      'kosher': '',
      'pescatarian': '',
      'keto': '',
      'paleo': ''
    };

    let currentZoomScale = 1;

    function zoomToOverlay(item, overlayEl, isTransition = false) {
      const menuWrap = document.querySelector('.menuWrap');
      const menuInner = menuWrap?.querySelector('.menuInner');
      const menuImg = menuInner?.querySelector('.menuImg');
      if (!menuWrap || !menuInner || !menuImg || !overlayEl) return;

      // Save scroll position only on first zoom (not transitions)
      if (!isTransition) {
        preZoomScrollPos = { x: window.scrollX, y: window.scrollY };
      }

      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;

      // First, add zoomed class to get the correct layout
      // Clear any existing transform first
      menuInner.style.transition = 'none';
      menuInner.style.transform = '';
      menuWrap.classList.add('zoomed');

      // Set zoomed state immediately to prevent resize handler from re-rendering overlays
      isOverlayZoomed = true;
      zoomedOverlayItem = item;

      // Force reflow to apply zoomed layout before measuring
      void menuWrap.offsetWidth;

      // Update overlayLayer to match new image dimensions (image may have resized)
      const overlayLayer = menuInner.querySelector('.overlayLayer');
      if (overlayLayer) {
        overlayLayer.style.width = menuImg.clientWidth + 'px';
        overlayLayer.style.height = menuImg.clientHeight + 'px';
        // Force reflow so overlay percentages resolve correctly
        void overlayLayer.offsetWidth;
      }

      // Now get the actual overlay position from the DOM (after layer resize)
      const overlayRect = overlayEl.getBoundingClientRect();
      const imgRect = menuImg.getBoundingClientRect();

      // Calculate overlay center relative to the image origin
      const relX = (overlayRect.left - imgRect.left) + overlayRect.width / 2;
      const relY = (overlayRect.top - imgRect.top) + overlayRect.height / 2;

      // Get overlay dimensions for zoom calculation
      const overlayWidthPx = overlayRect.width;
      const overlayHeightPx = overlayRect.height;

      // Calculate zoom to fit overlay with padding
      // Leave space for info panel at bottom
      const topPadding = 20;
      const bottomUIHeight = 220; // info panel + back button
      const availableWidth = screenWidth * 0.92;
      const availableHeight = screenHeight - topPadding - bottomUIHeight;

      const scaleByWidth = availableWidth / overlayWidthPx;
      const scaleByHeight = availableHeight / overlayHeightPx;
      const zoomScale = Math.min(Math.max(Math.min(scaleByWidth, scaleByHeight), 1.5), 3.5);

      // Store zoom scale for pulse animation
      currentZoomScale = zoomScale;

      // Update CSS custom property for scaled animations
      document.documentElement.style.setProperty('--overlay-zoom-scale', zoomScale);

      // Target position: center of available viewing area
      const targetX = screenWidth / 2;
      const targetY = topPadding + (availableHeight / 2);

      // Calculate translation to center the overlay
      // After transform translate(tx,ty) scale(s) with origin 0,0:
      // Point at (relX, relY) moves to (tx + relX*s, ty + relY*s)
      // We want this to equal (targetX, targetY)
      const translateX = targetX - relX * zoomScale;
      const translateY = targetY - relY * zoomScale;

      // Re-enable transition and apply the transform
      menuInner.style.transition = '';
      menuInner.style.transformOrigin = '0 0';

      // Use requestAnimationFrame to apply the transform
      requestAnimationFrame(() => {
        menuInner.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoomScale})`;
      });

      // Start pulse animation after a delay to let the layout change settle
      // On first click, there's a major layout shift (position:fixed) plus transform transition
      // RAF alone isn't enough - we need to wait for the browser to stabilize
      const animationDelay = isTransition ? 50 : 150; // Longer delay on first zoom
      setTimeout(() => {
        // Clear selected and reset animation on all overlays
        document.querySelectorAll('.overlay').forEach(ov => {
          ov.classList.remove('selected');
          ov.style.animation = 'none';
        });

        if (overlayEl) {
          // Set pulse colors before adding selected class
          if (typeof setOverlayPulseColor === 'function') {
            setOverlayPulseColor(overlayEl);
          }

          // Force reflow to ensure animation reset takes effect
          void overlayEl.offsetWidth;

          // Clear animation:none and add selected class to trigger animation
          overlayEl.style.animation = '';
          overlayEl.classList.add('selected');

          // Force another reflow to ensure animation starts
          void overlayEl.offsetWidth;
        }
      }, animationDelay);

      // Show back button and top overlay
      const backBtn = document.getElementById('zoomBackButton');
      if (backBtn) backBtn.classList.add('show');
      const topOverlay = document.getElementById('zoomTopOverlay');
      if (topOverlay) topOverlay.classList.add('show');

      // Show zoomed dish info
      showZoomedDishInfo(item);

      // Prevent body scroll while zoomed
      document.body.style.overflow = 'hidden';
    }

    function zoomOutOverlay() {
      const menuWrap = document.querySelector('.menuWrap');
      const menuInner = menuWrap?.querySelector('.menuInner');
      if (!menuWrap || !menuInner) return;

      // Reset zoom scale
      currentZoomScale = 1;
      document.documentElement.style.setProperty('--overlay-zoom-scale', 1);

      // Disable transition temporarily for instant reset
      menuInner.style.transition = 'none';
      menuInner.style.transform = '';
      menuWrap.classList.remove('zoomed');

      // Force reflow to apply changes immediately
      void menuInner.offsetWidth;

      // Re-enable transition
      menuInner.style.transition = '';

      // Hide back button and top overlay
      const backBtn = document.getElementById('zoomBackButton');
      if (backBtn) backBtn.classList.remove('show');
      const topOverlay = document.getElementById('zoomTopOverlay');
      if (topOverlay) topOverlay.classList.remove('show');

      // Hide zoomed dish info
      const dishInfo = document.getElementById('zoomedDishInfo');
      if (dishInfo) dishInfo.classList.remove('show');

      // Re-enable body scroll
      document.body.style.overflow = '';

      // Clear selection
      document.querySelectorAll('.overlay.selected').forEach(ov => ov.classList.remove('selected'));

      // Update state
      isOverlayZoomed = false;
      zoomedOverlayItem = null;

      // Fix overlay alignment: Re-render overlay layer after zoom-out
      // Use double RAF to ensure layout has fully settled after removing zoomed class
      // First RAF waits for the zoomed class removal to take effect
      requestAnimationFrame(() => {
        // Force layout recalculation
        void document.body.offsetHeight;

        // Second RAF ensures the new layout is fully computed
        requestAnimationFrame(() => {
          // Re-render the overlay layer to fix alignment
          if (typeof window.__rerenderLayer__ === 'function') {
            window.__rerenderLayer__();
          }

          // Restore scroll position after re-render
          window.scrollTo(preZoomScrollPos.x, preZoomScrollPos.y);
        });
      });
    }

    function showZoomedDishInfo(item) {
      const dishInfo = document.getElementById('zoomedDishInfo');
      const nameEl = document.getElementById('zoomedDishName');
      const chipsEl = document.getElementById('zoomedAllergenChips');
      if (!dishInfo || !nameEl || !chipsEl) return;

      nameEl.textContent = item.name || item.id || 'Dish';

      // Use compact mobile design for zoomed view
      const userAllergens = state.allergies || [];
      const userDiets = state.diets || [];
      chipsEl.innerHTML = mobileCompactBodyHTML(item, userAllergens, userDiets);
      dishInfo.classList.add('show');
    }

    // Set up back button handler
    document.getElementById('zoomBackButton')?.addEventListener('click', () => {
      zoomOutOverlay();
    });

    // Also zoom out when clicking outside the overlay (on the zoomed menu)
    document.addEventListener('click', (e) => {
      if (!isOverlayZoomed) return;
      const clickedOverlay = e.target.closest('.overlay');
      const clickedBackBtn = e.target.closest('.zoomBackButton');
      const clickedDishInfo = e.target.closest('.zoomedDishInfo');
      if (!clickedOverlay && !clickedBackBtn && !clickedDishInfo) {
        zoomOutOverlay();
      }
    });
    // ========== End Mobile Overlay Zoom ==========

    function ensureMobileInfoPanel() {
      if (mobileInfoPanel && mobileInfoPanel.isConnected) return mobileInfoPanel;
      if (!mobileInfoPanel) {
        mobileInfoPanel = document.createElement('div');
        mobileInfoPanel.id = 'mobileInfoPanel';
        mobileInfoPanel.className = 'mobileInfoPanel';
        mobileInfoPanel.setAttribute('aria-live', 'polite');
        mobileInfoPanel.style.position = 'fixed';
        mobileInfoPanel.style.width = 'auto';
        mobileInfoPanel.style.zIndex = '3500';
        mobileInfoPanel.style.background = 'rgba(11,16,32,0.94)';
        mobileInfoPanel.style.backdropFilter = 'blur(14px)';
        mobileInfoPanel.style.webkitBackdropFilter = 'blur(14px)';
        mobileInfoPanel.style.paddingBottom = 'calc(24px + env(safe-area-inset-bottom,0))';
        mobileInfoPanel.style.borderRadius = '20px';
        mobileInfoPanel.style.display = 'none';
      }
      // Set positioning based on full-screen mode
      if (document.body.classList.contains('mobileViewerActive')) {
        mobileInfoPanel.style.setProperty('left', '0', 'important');
        mobileInfoPanel.style.setProperty('right', '0', 'important');
        mobileInfoPanel.style.setProperty('bottom', '0', 'important');
      } else {
        mobileInfoPanel.style.left = '12px';
        mobileInfoPanel.style.right = '12px';
        mobileInfoPanel.style.bottom = '12px';
      }
      mobileInfoPanel.innerHTML = '';
      mobileInfoPanel.classList.remove('show');
      mobileInfoPanel.style.display = 'none';
      document.body.appendChild(mobileInfoPanel);
      adjustMobileInfoPanelForZoom();
      return mobileInfoPanel;
    }

    function adjustMobileInfoPanelForZoom() {
      // No longer needed since pinch-to-zoom is disabled
      // Keeping function for compatibility
    }

    function getMenuState() {
      if (!window.__menuState) window.__menuState = {};
      return window.__menuState;
    }

    function captureMenuBaseDimensions(force = false) {
      const state = getMenuState();
      const img = state?.img;
      if (!img) return;
      if (force || !state.baseWidth) {
        state.baseWidth = img.clientWidth || img.naturalWidth || img.width || 0;
        state.baseHeight = img.clientHeight || img.naturalHeight || img.height || 0;
      }
    }

    function ensureMobileViewerChrome() {
      if (mobileViewerChrome && mobileViewerChrome.isConnected) return mobileViewerChrome;
      let chrome = document.getElementById('mobileViewerChrome');
      if (!chrome) {
        chrome = document.createElement('div');
        chrome.id = 'mobileViewerChrome';
        chrome.innerHTML = `
      <div class="chromeTop">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;pointer-events:auto;">
          <button type="button" class="mobileViewerControlBtn" id="mobileViewerCloseBtn">Close</button>
          <div class="mobileZoomGroup">
            <button type="button" id="mobileZoomOutBtn" aria-label="Zoom out"></button>
            <span id="mobileZoomValue">100%</span>
            <button type="button" id="mobileZoomInBtn" aria-label="Zoom in">+</button>
          </div>
        </div>
        <div class="mobileViewerSummary" id="mobileViewerAllergySummary" aria-live="polite"></div>
      </div>`;
        document.body.appendChild(chrome);
      }
      if (!chrome.style.display) chrome.style.display = 'none';
      if (!chrome.hasAttribute('aria-hidden')) chrome.setAttribute('aria-hidden', 'true');
      mobileViewerChrome = chrome;
      const closeBtn = chrome.querySelector('#mobileViewerCloseBtn');
      const zoomOutBtn = chrome.querySelector('#mobileZoomOutBtn');
      const zoomInBtn = chrome.querySelector('#mobileZoomInBtn');
      if (closeBtn) closeBtn.onclick = () => closeMobileViewer();
      if (zoomOutBtn) zoomOutBtn.onclick = () => setMobileZoom(mobileZoomLevel - 0.25);
      if (zoomInBtn) zoomInBtn.onclick = () => setMobileZoom(mobileZoomLevel + 0.25);
      updateFullScreenAllergySummary();
      return mobileViewerChrome;
    }

    function updateZoomIndicator() {
      const indicator = document.getElementById('mobileZoomValue');
      if (indicator) indicator.textContent = `${Math.round(mobileZoomLevel * 100)}%`;
    }

    function updateFullScreenAllergySummary() {
      const summary = document.getElementById('mobileViewerAllergySummary');
      if (!summary) return;
      const uniqueKeys = Array.from(new Set((state.allergies || []).map(norm))).filter(Boolean);
      const selectedDiets = (state.diets || []);

      let html = '';
      if (uniqueKeys.length || selectedDiets.length) {
        html = '<div class="mobileViewerSummaryInner">';

        // Allergens with emoji badges
        if (uniqueKeys.length) {
          const allergenBadges = uniqueKeys.map(a => {
            const emoji = ALLERGEN_EMOJI[a] || '';
            return `<span style="display:inline-flex;align-items:center;gap:3px;background:rgba(76,90,212,0.25);border:1px solid rgba(76,90,212,0.4);border-radius:999px;padding:3px 8px;font-size:0.8rem;white-space:nowrap;"><span>${emoji}</span><span>${esc(cap(a))}</span></span>`;
          }).join('');
          html += `<div style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;"><span class="label">Allergens:</span>${allergenBadges}</div>`;
        }

        // Dietary preferences with emoji
        if (selectedDiets.length) {
          const dietBadges = selectedDiets.map(d => {
            const emoji = d === 'Vegan' ? '' : d === 'Vegetarian' ? '' : d === 'Pescatarian' ? '' : d === 'Gluten-free' ? '' : '';
            return `<span style="display:inline-flex;align-items:center;gap:3px;background:rgba(34,197,94,0.15);border:1px solid rgba(34,197,94,0.4);border-radius:999px;padding:3px 8px;font-size:0.8rem;white-space:nowrap;"><span>${emoji}</span><span>${esc(d)}</span></span>`;
          }).join('');
          html += `<div style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;margin-top:${uniqueKeys.length ? '5px' : '0'}"><span class="label">Diets:</span>${dietBadges}</div>`;
        }

        html += '</div>';
      } else {
        html = `<div class="mobileViewerSummaryInner"><span class="values">No allergens or dietary preferences selected</span></div>`;
      }
      summary.innerHTML = html;
    }

    function setMobileZoom(level, resetBase = false) {
      const state = getMenuState();
      const img = state?.img;
      if (!img) return;
      if (resetBase) {
        state.baseWidth = null;
        state.baseHeight = null;
      }
      captureMenuBaseDimensions(resetBase);
      if (!state.baseWidth) {
        updateZoomIndicator();
        return;
      }
      mobileZoomLevel = Math.min(Math.max(level, 1), 4);
      const width = state.baseWidth * mobileZoomLevel;
      const inner = state.inner;
      const layer = state.layer;
      img.style.width = width + 'px';
      if (inner) inner.style.width = width + 'px';
      if (layer) layer.style.width = width + 'px';
      requestAnimationFrame(() => {
        if (window.__rerenderLayer__) window.__rerenderLayer__();
        updateZoomIndicator();
      });
    }

    function resetMobileZoom() {
      const state = getMenuState();
      mobileZoomLevel = 1;
      const img = state?.img;
      if (img) {
        img.style.width = '';
        if (state.inner) state.inner.style.width = '';
        if (state.layer) state.layer.style.width = '';
      }
      requestAnimationFrame(() => {
        if (window.__rerenderLayer__) window.__rerenderLayer__();
        captureMenuBaseDimensions(true);
        updateZoomIndicator();
      });
    }

    function openMobileViewer() {
      const chrome = ensureMobileViewerChrome();
      if (chrome) {
        chrome.style.display = 'block';
        chrome.setAttribute('aria-hidden', 'false');
      }
      captureMenuBaseDimensions(true);
      document.body.classList.add('mobileViewerActive');
      updateFullScreenAllergySummary();
      setMobileZoom(1, true);
      if (prefersMobileInfo()) {
        // Force re-render to update panel size for full-screen mode
        // Use multiple timing approaches to ensure it updates
        const updatePanel = () => {
          if (currentMobileInfoItem && mobileInfoPanel) {
            // Update positioning to full width for full-screen mode - use setProperty with important
            mobileInfoPanel.style.setProperty('left', '0', 'important');
            mobileInfoPanel.style.setProperty('right', '0', 'important');
            mobileInfoPanel.style.setProperty('bottom', '0', 'important');
            // Force re-render to apply full width
            renderMobileInfo(currentMobileInfoItem);
          } else {
            renderMobileInfo(null);
          }
        };
        // Try immediately
        requestAnimationFrame(() => {
          requestAnimationFrame(updatePanel);
        });
        // Also try after a short delay as backup
        setTimeout(updatePanel, 50);
        setTimeout(updatePanel, 150);
        // Re-apply selected class to overlay if one was selected before (for dish search navigation)
        // This is needed because setMobileZoom calls renderLayer which removes all selected classes
        if (currentMobileInfoItem && window.__lastSelectedOverlay) {
          const reapplySelection = () => {
            const layer = document.querySelector('.overlayLayer');
            if (layer) {
              const boxes = layer.querySelectorAll('.overlay');
              boxes.forEach((box, idx) => {
                if (idx === window.__lastSelectedOverlay.index) {
                  document.querySelectorAll('.overlay').forEach(ov => ov.classList.remove('selected'));
                  box.classList.add('selected');
                  setOverlayPulseColor(box);
                }
              });
            }
          };
          // Reapply after renderLayer has finished (which runs in requestAnimationFrame after setMobileZoom)
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              requestAnimationFrame(reapplySelection);
            });
          });
        }
      }
      const wrap = document.getElementById('menu');
      if (wrap) {
        wrap.scrollTop = 0;
      }
      const closeBtn = document.getElementById('mobileViewerCloseBtn');
      if (closeBtn) {
        setTimeout(() => closeBtn.focus(), 150);
      }
      if (!mobileViewerKeyHandler) {
        mobileViewerKeyHandler = (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            closeMobileViewer();
          }
        };
        document.addEventListener('keydown', mobileViewerKeyHandler);
      }
    }

    function closeMobileViewer() {
      document.body.classList.remove('mobileViewerActive');
      if (mobileViewerChrome) {
        mobileViewerChrome.style.display = 'none';
        mobileViewerChrome.setAttribute('aria-hidden', 'true');
      }
      resetMobileZoom();
      // Close the mobile info panel if it's open
      if (mobileInfoPanel) {
        mobileInfoPanel.classList.remove('show');
        mobileInfoPanel.style.display = 'none';
        mobileInfoPanel.innerHTML = '';
        currentMobileInfoItem = null;
      }
      if (prefersMobileInfo()) {
        if (currentMobileInfoItem) {
          renderMobileInfo(currentMobileInfoItem);
        } else {
          renderMobileInfo(null);
        }
      }
      const openBtn = document.querySelector('#mobileMenuNotice .mobileMenuOpenBtn');
      if (openBtn) {
        setTimeout(() => openBtn.focus(), 150);
      }
      const notice = document.getElementById('mobileMenuNotice');
      if (notice && notice.dataset.enabled === '1') {
        notice.style.display = 'flex';
        notice.setAttribute('aria-hidden', 'false');
      }
      if (mobileViewerKeyHandler) {
        document.removeEventListener('keydown', mobileViewerKeyHandler);
        mobileViewerKeyHandler = null;
      }
    }

    const urlQR = typeof window.__qrVisit === 'boolean'
      ? window.__qrVisit
      : (() => { const v = new URLSearchParams(location.search).get('qr'); return v && /^(1|true|yes)$/i.test(v); })();

    const QR_PROMO_STORAGE_KEY = 'qrPromoDismissed';
    function shouldShowQrPromo() {
      try { return !sessionStorage.getItem(QR_PROMO_STORAGE_KEY); } catch (_) { return true; }
    }
    function dismissQrPromo() {
      try { sessionStorage.setItem(QR_PROMO_STORAGE_KEY, '1'); } catch (_) { }
    }
    function shouldShowQrBanner() {
      return !state.user?.loggedIn;
    }
    function showQrBanner() {
      const banner = document.getElementById('qrBanner');
      if (!banner) return;
      if (!shouldShowQrBanner()) return;
      banner.classList.add('show');
      banner.setAttribute('aria-hidden', 'false');
      document.body.classList.add('qrBannerVisible');
    }
    function hideQrBanner() {
      const banner = document.getElementById('qrBanner');
      if (!banner) return;
      banner.classList.remove('show');
      banner.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('qrBannerVisible');
    }
    let qrPromoTimerId = null;
    function cancelQrPromoTimer() {
      if (qrPromoTimerId) { clearTimeout(qrPromoTimerId); qrPromoTimerId = null; }
    }
    function queueQrPromoTimer() {
      cancelQrPromoTimer();
      qrPromoTimerId = setTimeout(() => {
        qrPromoTimerId = null;
        if (!state.user?.loggedIn && shouldShowQrPromo()) {
          openQrPromo();
        }
      }, 10000);
    }
    function isDishInfoPopupOpen() {
      // Check if mobile info panel is showing
      const mobilePanel = document.getElementById('mobileInfoPanel');
      if (mobilePanel && mobilePanel.classList.contains('show')) return true;
      // Check if desktop tooltip is pinned open (tipPinned is declared later, check via window or direct)
      if (typeof tipPinned !== 'undefined' && tipPinned) return true;
      return false;
    }
    function openQrPromo() {
      const backdrop = document.getElementById('qrPromoBackdrop');
      if (!backdrop || backdrop.classList.contains('show')) return;
      // If a dish info popup is open, wait for it to close before showing promo
      if (isDishInfoPopupOpen()) {
        // Re-check in 2 seconds
        setTimeout(() => {
          if (!state.user?.loggedIn && shouldShowQrPromo()) {
            openQrPromo();
          }
        }, 2000);
        return;
      }
      hideQrBanner();
      backdrop.classList.add('show');
      backdrop.setAttribute('aria-hidden', 'false');
    }
    function closeQrPromo(reason = 'dismiss') {
      const backdrop = document.getElementById('qrPromoBackdrop');
      if (backdrop && backdrop.classList.contains('show')) {
        backdrop.classList.remove('show');
        backdrop.setAttribute('aria-hidden', 'true');
      }
      if (reason !== 'login') dismissQrPromo();
      cancelQrPromoTimer();
      if (reason === 'dismiss' && shouldShowQrBanner()) {
        showQrBanner();
      }
      if (reason === 'signup' || reason === 'login') {
        hideQrBanner();
      }
    }

    // Handle navigation in standalone mode
    const isStandalone = (window === window.parent);
    const send = (p) => {
      if (isStandalone) {
        // Handle navigation directly in standalone mode
        if (p.type === 'navigate') {
          if (p.to === '/restaurants') window.location.href = 'restaurants.html';
          else if (p.to === '/favorites') window.location.href = 'favorites.html';
          else if (p.to === '/dish-search') window.location.href = 'dish-search.html';
          else if (p.to === '/my-dishes') window.location.href = 'my-dishes.html';
          else if (p.to === '/report-issue') window.location.href = 'report-issue.html';
          else if (p.to === '/accounts') {
            const params = new URLSearchParams();
            if (p.slug) params.set('returnSlug', p.slug);
            if (p.redirect) params.set('redirect', p.redirect);
            const url = 'account.html' + (params.toString() ? `?${params.toString()}` : '');
            window.location.href = url;
          }
          else window.location.href = p.to;
        } else if (p.type === 'signIn') {
          const params = new URLSearchParams();
          if (p.slug) params.set('returnSlug', p.slug);
          if (p.redirect) params.set('redirect', p.redirect);
          const url = 'account.html' + (params.toString() ? `?${params.toString()}` : '');
          window.location.href = url;
        } else if (p.type === 'openRestaurant') {
          window.location.href = `restaurant.html?slug=${p.slug}`;
        } else if (p.type === 'saveOverlays') {
          (async () => {
            // Declare variables outside try block so they're accessible in catch
            let payload = {};
            let overlaysToSave = [];

            try {
              const client = window.supabaseClient;
              if (!client) throw new Error('Supabase client not ready.');
              const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
              if (!restaurantId) throw new Error('Restaurant not loaded yet.');

              // Ensure aiIngredients and aiIngredientSummary are preserved on all overlays
              overlaysToSave = (p.overlays || []).map(overlay => {
                // Create a new object to ensure all fields are preserved
                const savedOverlay = { ...overlay };
                // Explicitly preserve aiIngredients if it exists
                if (overlay.aiIngredients !== undefined) {
                  savedOverlay.aiIngredients = overlay.aiIngredients;
                }
                // Explicitly preserve aiIngredientSummary if it exists
                if (overlay.aiIngredientSummary !== undefined) {
                  savedOverlay.aiIngredientSummary = overlay.aiIngredientSummary;
                }
                // Explicitly preserve recipeDescription if it exists
                if (overlay.recipeDescription !== undefined) {
                  savedOverlay.recipeDescription = overlay.recipeDescription;
                }
                return savedOverlay;
              });

              payload = { overlays: overlaysToSave };
              // Support both single image (backward compatible) and multiple images
              if (p.menuImages && Array.isArray(p.menuImages) && p.menuImages.length > 0) {
                // Save array to menu_images column (JSONB)
                payload.menu_images = p.menuImages;
                // Also save first image to menu_image for backward compatibility
                payload.menu_image = p.menuImages[0] || '';
              } else if (p.menuImage) {
                payload.menu_image = p.menuImage;
                // If menu_image is set but menu_images isn't, ensure menu_images is also set
                if (!p.menuImages) {
                  payload.menu_images = [p.menuImage];
                }
              }
              // Include restaurant settings if they were changed
              if (p.restaurantSettings) {
                payload.website = p.restaurantSettings.website;
                payload.phone = p.restaurantSettings.phone;
                payload.delivery_url = p.restaurantSettings.delivery_url;
                console.log('Saving restaurant settings:', p.restaurantSettings);
              }

              console.log('Saving overlays with aiIngredients preservation:', overlaysToSave.map(o => ({
                id: o.id,
                hasAiIngredients: !!o.aiIngredients,
                aiIngredientsLength: o.aiIngredients ? (typeof o.aiIngredients === 'string' ? o.aiIngredients.length : JSON.stringify(o.aiIngredients).length) : 0
              })));

              const { data, error } = await client
                .from('restaurants')
                .update(payload)
                .eq('id', restaurantId)
                .select()
                .single();

              if (error) {
                console.error('Supabase update error:', error);
                console.error('Error details:', {
                  message: error.message,
                  code: error.code,
                  details: error.details,
                  hint: error.hint,
                  payloadSize: JSON.stringify(payload).length,
                  overlaysCount: overlaysToSave.length,
                  payloadKeys: Object.keys(payload),
                  restaurantId: restaurantId,
                  sampleOverlay: overlaysToSave[0] ? {
                    id: overlaysToSave[0].id,
                    hasAiIngredients: !!overlaysToSave[0].aiIngredients,
                    aiIngredientsLength: overlaysToSave[0].aiIngredients ? (typeof overlaysToSave[0].aiIngredients === 'string' ? overlaysToSave[0].aiIngredients.length : JSON.stringify(overlaysToSave[0].aiIngredients).length) : 0,
                    keys: Object.keys(overlaysToSave[0])
                  } : null,
                  fullPayload: JSON.stringify(payload, null, 2)
                });
                throw error;
              }

              console.log('Saved overlays response:', data.overlays?.map(o => ({
                id: o.id,
                hasAiIngredients: !!o.aiIngredients,
                aiIngredientsLength: o.aiIngredients ? (typeof o.aiIngredients === 'string' ? o.aiIngredients.length : JSON.stringify(o.aiIngredients).length) : 0
              })));

              const updatedRestaurant = normalizeRestaurant(data);
              // Update state.restaurant with the saved data
              if (state.restaurant) {
                state.restaurant = updatedRestaurant;
              }
              // Update originalRestaurantSettings after successful save if settings were included
              // Access it through the message handler's closure
              if (p.restaurantSettings && typeof window.updateOriginalRestaurantSettings === 'function') {
                window.updateOriginalRestaurantSettings({
                  website: p.restaurantSettings.website,
                  phone: p.restaurantSettings.phone,
                  delivery_url: p.restaurantSettings.delivery_url
                });
              }
              window.postMessage({ type: 'overlaysSaved', restaurant: updatedRestaurant }, '*');

              const rawChangePayload = p.changes;
              let changePayload = null;
              if (rawChangePayload && typeof rawChangePayload === 'object' && !Array.isArray(rawChangePayload)) {
                changePayload = rawChangePayload;
              } else if (typeof rawChangePayload === 'string') {
                try { changePayload = JSON.parse(rawChangePayload); }
                catch (_) { changePayload = null; }
              }

              let authorName = 'Manager';
              if (state.user?.name) {
                authorName = state.user.name;
              } else if (state.user?.user_metadata?.first_name || state.user?.user_metadata?.last_name) {
                const first = state.user.user_metadata.first_name || '';
                const last = state.user.user_metadata.last_name || '';
                authorName = `${first} ${last}`.trim();
              } else if (state.user?.email) {
                authorName = state.user.email.split('@')[0];
              }

              if (changePayload && changePayload.author) {
                authorName = changePayload.author;
              }

              const storedChanges = changePayload
                ? JSON.stringify(changePayload)
                : (typeof rawChangePayload === 'string' ? rawChangePayload : 'Menu overlays updated.');

              try {
                await insertChangeLogEntry({
                  restaurantId,
                  timestamp: new Date().toISOString(),
                  type: 'update',
                  description: authorName,
                  changes: storedChanges,
                  userEmail: state.user?.email || null
                });
                console.log('Change log entry saved successfully:', { restaurantId, authorName, changesLength: storedChanges.length });
              } catch (logError) {
                console.error('Change log insert failed:', logError);
                console.error('Change log insert context:', {
                  restaurantId,
                  authorName,
                  userEmail: state.user?.email,
                  isAuthenticated: !!state.user,
                  changesLength: storedChanges?.length || 0
                });
              }
            } catch (err) {
              console.error('Saving overlays failed', err);
              const errorPayload = payload || {};
              console.error('Error details:', {
                message: err.message,
                code: err.code,
                details: err.details,
                hint: err.hint,
                stack: err.stack,
                payloadSize: JSON.stringify(errorPayload).length,
                overlaysCount: overlaysToSave.length,
                payloadKeys: Object.keys(payload),
                samplePayload: payload.overlays ? payload.overlays[0] : null
              });
              window.postMessage({ type: 'saveFailed', message: err.message || 'Unknown error occurred', error: err }, '*');
            }
          })();
          return;
        } else if (p.type === 'confirmAllergens') {
          (async () => {
            try {
              const client = window.supabaseClient;
              if (!client) throw new Error('Supabase client not ready.');
              const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
              if (!restaurantId) throw new Error('Restaurant not loaded yet.');
              const timestamp = p.timestamp || new Date().toISOString();

              const { data: updated, error } = await client
                .from('restaurants')
                .update({ last_confirmed: timestamp })
                .eq('id', restaurantId)
                .select()
                .single();
              if (error) throw error;

              try {
                let userName = 'Manager';
                if (state.user?.name) {
                  userName = state.user.name;
                } else if (state.user?.user_metadata?.first_name || state.user?.user_metadata?.last_name) {
                  const first = state.user.user_metadata.first_name || '';
                  const last = state.user.user_metadata.last_name || '';
                  userName = `${first} ${last}`.trim();
                } else if (state.user?.email) {
                  userName = state.user.email.split('@')[0];
                }
                const confirmPayload = {
                  author: userName,
                  general: ['Allergen information confirmed'],
                  items: {}
                };
                await insertChangeLogEntry({
                  restaurantId,
                  timestamp,
                  type: 'confirm',
                  description: userName,
                  changes: JSON.stringify(confirmPayload),
                  userEmail: state.user?.email || null,
                  photos: p.photos || (p.photo ? [p.photo] : [])
                });
              } catch (logError) {
                console.error('Change log insert failed', logError);
              }

              window.postMessage({ type: 'confirmationSaved', restaurant: normalizeRestaurant(updated), timestamp }, '*');
            } catch (err) {
              console.error('Confirmation failed', err);
              window.postMessage({ type: 'confirmationFailed', message: err.message }, '*');
            }
          })();
          return;
        } else if (p.type === 'getChangeLog') {
          (async () => {
            try {
              const logs = await fetchChangeLogEntries(p.restaurantId || state.restaurant?._id || state.restaurant?.id || null);
              window.postMessage({ type: 'changeLog', logs: logs || [] }, '*');
            } catch (err) {
              console.error('Loading change log failed', err);
              window.postMessage({ type: 'changeLog', logs: [], error: err.message }, '*');
            }
          })();
          return;
        }
        // For other message types, just log them in standalone mode
        console.log('Message sent:', p);
      } else {
        // In iframe mode, use postMessage
        parent.postMessage(p, "*");
      }
    };
    function requestSignIn(origin) {
      const slugParam = (state.restaurant && state.restaurant.slug) || slug || '';
      const payload = { type: 'signIn' };
      if (slugParam) payload.slug = slugParam;
      if (origin === 'restaurants') payload.redirect = 'restaurants';
      if (origin === 'qr') payload.from = 'qr';
      send(payload);
    }
    const qrPromoBackdrop = document.getElementById('qrPromoBackdrop');
    const qrPromoCloseBtn = document.getElementById('qrPromoClose');
    const qrPromoSignupBtn = document.getElementById('qrPromoSignup');
    const qrBanner = document.getElementById('qrBanner');
    const qrBannerSignupBtn = document.getElementById('qrBannerSignup');

    if (qrPromoBackdrop) {
      qrPromoBackdrop.addEventListener('click', (e) => { if (e.target === qrPromoBackdrop) closeQrPromo('dismiss'); });
    }
    if (qrPromoCloseBtn) {
      qrPromoCloseBtn.onclick = () => closeQrPromo('dismiss');
    }
    if (qrPromoSignupBtn) {
      qrPromoSignupBtn.onclick = () => {
        closeQrPromo('signup');
        // Check for invite token and redirect directly to preserve it
        const inviteParam = new URLSearchParams(window.location.search).get('invite');
        if (inviteParam) {
          window.location.href = `account.html?invite=${encodeURIComponent(inviteParam)}`;
        } else {
          requestSignIn('qr');
        }
      };
    }
    if (qrBannerSignupBtn) {
      qrBannerSignupBtn.onclick = () => {
        hideQrBanner();
        // Check for invite token and redirect directly to preserve it
        const inviteParam = new URLSearchParams(window.location.search).get('invite');
        if (inviteParam) {
          window.location.href = `account.html?invite=${encodeURIComponent(inviteParam)}`;
        } else {
          requestSignIn('qr');
        }
      };
    }
    const norm = s => (s || '').toString().trim().toLowerCase();
    const esc = s => (s ?? '').toString().replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
    const cap = s => (s || '').split(' ').map(w => w ? w[0].toUpperCase() + w.slice(1) : '').join(' ');

    // Helper function to normalize ingredients for comparison
    function normalizeIngredientsForComparison(text) {
      return (text || '').toLowerCase().replace(/[^\w\s]/g, ' ').replace(/\s+/g, ' ').trim();
    }

    // Helper function to check if two ingredient lists are similar (65%+ word overlap)
    function areIngredientsSimilar(text1, text2) {
      const n1 = normalizeIngredientsForComparison(text1);
      const n2 = normalizeIngredientsForComparison(text2);
      if (n1 === n2) return true;
      const w1 = new Set(n1.split(' ').filter(w => w.length > 2));
      const w2 = new Set(n2.split(' ').filter(w => w.length > 2));
      const intersection = [...w1].filter(w => w2.has(w)).length;
      const union = new Set([...w1, ...w2]).size;
      return union > 0 && (intersection / union) >= 0.65;
    }

    // Helper function to group sources by ingredient similarity
    function groupSourcesByIngredientSimilarity(sources) {
      const groups = [];
      for (const source of sources) {
        let addedToGroup = false;
        for (const group of groups) {
          if (areIngredientsSimilar(source.ingredientsText, group[0].ingredientsText)) {
            group.push(source);
            addedToGroup = true;
            break;
          }
        }
        if (!addedToGroup) {
          groups.push([source]);
        }
      }
      // Sort groups by size (largest first)
      groups.sort((a, b) => b.length - a.length);
      return groups;
    }

    // Helper function to parse ingredients into bullet points
    // Only splits on commas/semicolons that are NOT inside parentheses
    function parseIngredientsToBullets(ingredientsText) {
      if (!ingredientsText) return [];

      const text = ingredientsText.replace(/ingredients:/i, '').trim();
      const ingredients = [];
      let current = '';
      let parenDepth = 0;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];

        if (char === '(' || char === '[') {
          parenDepth++;
          current += char;
        } else if (char === ')' || char === ']') {
          parenDepth = Math.max(0, parenDepth - 1);
          current += char;
        } else if ((char === ',' || char === ';') && parenDepth === 0) {
          // Split here - we're not inside parentheses
          const trimmed = current.trim();
          if (trimmed.length > 0 && trimmed.length < 200) {
            ingredients.push(trimmed);
          }
          current = '';
        } else if (char === '.' && parenDepth === 0 && i + 1 < text.length && /\s+[A-Z]/.test(text.slice(i + 1, i + 4))) {
          // Period followed by space and capital letter - MIGHT be sentence break
          // BUT don't split if this looks like a bacterial species abbreviation (L., S., B., etc.)
          // Check if the text before the period is a single letter (bacterial genus abbreviation)
          const beforePeriod = current.trim();
          const isBacterialAbbrev = /^[A-Za-z]$/.test(beforePeriod) || /\s[A-Za-z]$/.test(beforePeriod);

          if (isBacterialAbbrev) {
            // Keep the period - this is likely "L. Acidophilus", "S. Thermophilus", etc.
            current += char;
          } else {
            // Real sentence break
            const trimmed = beforePeriod;
            if (trimmed.length > 0 && trimmed.length < 200) {
              ingredients.push(trimmed);
            }
            current = '';
          }
        } else {
          current += char;
        }
      }

      // Don't forget the last ingredient
      const trimmed = current.trim();
      if (trimmed.length > 0 && trimmed.length < 200) {
        ingredients.push(trimmed);
      }

      return ingredients;
    }

    // Helper function to find ingredients that differ between two lists
    function findDifferingIngredients(primaryIngredients, altIngredients) {
      const normalizedPrimary = new Set(primaryIngredients.map(i => normalizeIngredientsForComparison(i)));
      const differing = [];
      for (const ing of altIngredients) {
        const normalized = normalizeIngredientsForComparison(ing);
        // Check if this ingredient (or something very similar) exists in primary
        let found = false;
        for (const pNorm of normalizedPrimary) {
          // Check for exact match or if one contains the other
          if (pNorm === normalized || pNorm.includes(normalized) || normalized.includes(pNorm)) {
            found = true;
            break;
          }
        }
        if (!found) {
          differing.push(ing);
        }
      }
      return new Set(differing);
    }

    // Helper function to render grouped sources HTML
    function renderGroupedSourcesHtml(sources, options = {}) {
      if (!sources || sources.length === 0) return '';

      const groups = groupSourcesByIngredientSimilarity(sources);
      const showConfirmButtons = options.showConfirmButtons !== false;

      // Use AI-extracted ingredient names if provided, otherwise fall back to parsing
      const aiIngredientNames = options.ingredientNames || null;

      // Get primary ingredients for comparison
      const primaryIngredients = aiIngredientNames || (groups.length > 0 ? parseIngredientsToBullets(groups[0][0].ingredientsText) : []);

      return groups.map((group, groupIdx) => {
        // For the primary group, use AI ingredient names if available
        // For alternate groups, parse their own ingredients to show differences
        const representativeIngredients = (groupIdx === 0 && aiIngredientNames)
          ? aiIngredientNames
          : parseIngredientsToBullets(group[0].ingredientsText);
        const groupColor = groupIdx === 0 ? 'rgba(76,212,90,0.4)' : 'rgba(255,152,0,0.4)';
        const groupBgColor = groupIdx === 0 ? 'rgba(76,212,90,0.1)' : 'rgba(255,152,0,0.1)';
        const groupHeaderColor = groupIdx === 0 ? '#4caf50' : '#ff9800';

        // Find differing ingredients for alternate lists
        const differingIngredients = groupIdx > 0 ? findDifferingIngredients(primaryIngredients, representativeIngredients) : new Set();

        return `
          <div style="
            background: ${groupBgColor};
            border: 2px solid ${groupColor};
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
          " data-group-idx="${groupIdx}" data-ingredients-text="${esc(group[0].ingredientsText)}">
            <div style="margin-bottom: 16px;">
              <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                <div>
                  <span style="font-weight: 700; color: ${groupHeaderColor}; font-size: 1.1rem;">
                    ${groupIdx === 0 ? ' Primary Ingredient List' : ` Alternate List`}
                  </span>
                  <span style="font-weight: 400; font-size: 0.9rem; color: #a0a0a0; margin-left: 8px;">
                    (${group.length} source${group.length !== 1 ? 's' : ''} agree)
                  </span>
                </div>
                ${showConfirmButtons ? `
                  <button type="button" class="confirmGroupIngredientListBtn" data-group-idx="${groupIdx}" style="
                    padding: 8px 16px;
                    background: ${groupIdx === 0 ? '#4c5ad4' : '#ff9800'};
                    border: none;
                    border-radius: 6px;
                    color: #fff;
                    font-weight: 600;
                    cursor: pointer;
                    font-size: 0.85rem;
                    white-space: nowrap;
                    flex-shrink: 0;
                  ">
                    Confirm & Apply
                  </button>
                ` : ''}
              </div>

              ${representativeIngredients.length > 0 ? `
                <div style="
                  background: rgba(0,0,0,0.2);
                  border-radius: 8px;
                  padding: 16px;
                  margin-bottom: 16px;
                ">
                  <div style="font-weight: 600; color: #a0a0a0; font-size: 0.85rem; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;">
                    Ingredients:
                  </div>
                  <ul style="
                    margin: 0;
                    padding-left: 20px;
                    color: #e0e0e0;
                    font-size: 0.9rem;
                    line-height: 1.7;
                  ">
                    ${representativeIngredients.slice(0, 30).map(ing => {
          const isDifferent = differingIngredients.has(ing);
          return `<li style="margin-bottom: 4px; ${isDifferent ? 'color: #ff9800; font-weight: 600;' : ''}">${esc(ing)}${isDifferent ? ' <span style="font-size: 0.75rem; background: rgba(255,152,0,0.3); padding: 2px 6px; border-radius: 4px; margin-left: 6px;">DIFFERS</span>' : ''}</li>`;
        }).join('')}
                    ${representativeIngredients.length > 30 ? `<li style="color: #a0a0a0; font-style: italic;">...and ${representativeIngredients.length - 30} more ingredients</li>` : ''}
                  </ul>
                </div>
              ` : ''}
            </div>

            <div style="font-weight: 600; color: #a0a0a0; font-size: 0.85rem; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px;">
              Sources (${group.length}):
            </div>

            ${group.map((source, sourceIdx) => {
          const urlObj = source.url ? (() => {
            try { return new URL(source.url); } catch { return null; }
          })() : null;
          const domain = urlObj ? urlObj.hostname.replace('www.', '') : '';
          const faviconUrl = domain ? `https://www.google.com/s2/favicons?domain=${domain}&sz=32` : '';

          return `
                <div style="
                  background: rgba(0,0,0,0.2);
                  border-radius: 8px;
                  padding: 16px;
                  margin-bottom: ${sourceIdx < group.length - 1 ? '12px' : '0'};
                ">
                  <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                    ${faviconUrl ? `
                      <img src="${esc(faviconUrl)}" alt="${esc(source.sourceName || '')}"
                           style="width: 32px; height: 32px; border-radius: 4px; flex-shrink: 0;"
                           onerror="this.style.display='none';">
                    ` : ''}
                    <div style="flex: 1;">
                      <div style="font-weight: 600; color: #fff; font-size: 1rem; margin-bottom: 2px;">
                        ${esc(source.sourceName || `Source ${sourceIdx + 1}`)}
                      </div>
                      ${source.productName ? `
                        <div style="font-size: 0.85rem; color: #9ca3af; margin-bottom: 4px;">
                           ${esc(source.productName)}
                        </div>
                      ` : ''}
                      ${source.url ? `
                        <div style="font-size: 0.8rem; word-break: break-all;">
                          <a href="${esc(source.url)}" target="_blank"
                             style="color: ${source.urlValid === false ? '#999' : '#6b7ce6'}; text-decoration: ${source.urlValid === false ? 'line-through' : 'none'};"
                             rel="noopener noreferrer"
                             title="${source.urlValid === false ? 'Link may be inaccessible' : ''}">
                            ${esc(source.url)}
                          </a>
                          ${source.urlValid === false ? '<span style="color: #ff9800; font-size: 0.75rem; margin-left: 8px;">(Link may be dead)</span>' : ''}
                        </div>
                      ` : ''}
                    </div>
                  </div>

                  <div style="display: grid; grid-template-columns: 1fr; gap: 12px;">
                    <!-- Exact Ingredients Text -->
                    <div style="
                      background: rgba(0,0,0,0.3);
                      border-radius: 6px;
                      padding: 12px;
                    ">
                      <div style="font-weight: 600; color: #a0a0a0; font-size: 0.8rem; margin-bottom: 6px;">
                        Exact Ingredient Text:
                      </div>
                      <div style="
                        font-size: 0.85rem;
                        color: #e0e0e0;
                        line-height: 1.5;
                        font-family: 'Monaco', 'Courier New', monospace;
                        white-space: pre-wrap;
                        word-wrap: break-word;
                      ">
                        ${esc(source.ingredientsText || 'Not available')}
                      </div>
                    </div>

                    <!-- Allergen Statement -->
                    <div style="
                      background: rgba(255,152,0,0.1);
                      border: 1px solid rgba(255,152,0,0.3);
                      border-radius: 6px;
                      padding: 12px;
                    ">
                      <div style="font-weight: 600; color: #ff9800; font-size: 0.8rem; margin-bottom: 6px;">
                         Allergen Statement:
                      </div>
                      <div style="font-size: 0.85rem; color: #e0e0e0; line-height: 1.5;">
                        ${source.allergenStatement ? esc(source.allergenStatement) : '<span style="color: #888;">None</span>'}
                      </div>
                    </div>

                    <!-- Cross-Contamination Statement -->
                    <div style="
                      background: rgba(156,39,176,0.1);
                      border: 1px solid rgba(156,39,176,0.3);
                      border-radius: 6px;
                      padding: 12px;
                    ">
                      <div style="font-weight: 600; color: #ce93d8; font-size: 0.8rem; margin-bottom: 6px;">
                         Cross-Contamination / Facility:
                      </div>
                      <div style="font-size: 0.85rem; color: #e0e0e0; line-height: 1.5;">
                        ${source.crossContaminationStatement ? esc(source.crossContaminationStatement) : '<span style="color: #888;">None</span>'}
                      </div>
                    </div>
                  </div>
                </div>
              `;
        }).join('')}
          </div>
        `;
      }).join('');
    }
    function normalizeDietLabel(diet) {
      if (!diet) return '';
      const lower = diet.toString().trim().toLowerCase();
      const match = DIETS.find(d => d.toLowerCase() === lower);
      return match || diet.toString().trim();
    }
    const fmtDate = d => { try { const x = new Date(d); return isNaN(x) ? '' : x.toLocaleDateString(); } catch (_) { return ''; } };
    const fmtDateTime = d => { try { const x = new Date(d); return isNaN(x) ? '' : x.toLocaleDateString() + ' at ' + x.toLocaleTimeString(); } catch (_) { return ''; } };

    // Single-ingredient items that NEVER need a barcode scan (spices, herbs, basic seasonings)
    const SINGLE_INGREDIENT_EXEMPTIONS = /^(salt|sea salt|kosher salt|pepper|black pepper|white pepper|paprika|smoked paprika|cumin|coriander|turmeric|garlic powder|onion powder|oregano|basil|thyme|rosemary|cinnamon|nutmeg|ginger|ground ginger|cloves|cayenne|cayenne pepper|chili powder|red pepper flakes|crushed red pepper|bay leaves?|parsley|dill|mint|sage|tarragon|chives|marjoram|allspice|cardamom|curry powder|mustard powder|mustard seed|fennel seed|caraway seed|celery seed|poppy seed|sesame seeds?|vanilla|vanilla extract|cocoa powder|baking soda|baking powder|cornstarch|arrowroot|cream of tartar|yeast|active dry yeast|instant yeast|garlic|fresh garlic|minced garlic|onion|fresh onion|lemon juice|lime juice|olive oil|vegetable oil|canola oil|coconut oil|sesame oil|vinegar|apple cider vinegar|white vinegar|balsamic vinegar|rice vinegar|honey|maple syrup|sugar|brown sugar|powdered sugar|molasses)$/i;

    const PROCESSED_INGREDIENT_PATTERN = /\b(flour|flours|starch|starchs|mix|mixes|blend|blends|paste|pastes|pasteurized|processed|cultured|fermented|packaged|bread|breads|bun|buns|roll|rolls|bagel|bagels|baguette|wrap|tortilla|pita|flatbread|biscuit|biscuits)\b/;
    const PROCESSED_MEATS_PATTERN = /\b(prosciutto|salami|soppressata|pepperoni|chorizo|bacon|ham|cured|smoked|sausage|sausages|bratwurst|kielbasa|mortadella|pancetta|guanciale|coppa|capicola|nduja|bresaola|speck|jamon|serrano|pastrami|corned beef|biltong|jerky)\b/;
    const CONDIMENT_PATTERN = /\b(butter|butters|spread|spreads|margarine|nutella|tahini|hummus|mayonnaise|mayo|ketchup|mustard|barbecue|bbq|sauce|sauces|salsa|dressing|dressings|vinaigrette|aioli|syrup|syrups|jam|jams|jelly|jellies|preserve|preserves|glaze|condiment|condiments|peanut butter|almond butter|cashew butter|hazelnut spread)\b/;
    function requiresBarcodeScan(name) {
      const lower = (name || '').toLowerCase().trim();
      if (!lower) return false;
      // Single-ingredient items never need barcode scans
      if (SINGLE_INGREDIENT_EXEMPTIONS.test(lower)) return false;
      return PROCESSED_INGREDIENT_PATTERN.test(lower) || PROCESSED_MEATS_PATTERN.test(lower) || CONDIMENT_PATTERN.test(lower);
    }

    function enforceDietAllergenConsistency(entry) {
      if (!entry) return;
      const allergenSet = new Set((entry.allergens || []).map(norm));
      const aiAllergenSet = new Set((entry.aiDetectedAllergens || []).map(norm));
      const diets = (entry.diets || []).map(normalizeDietLabel).filter(Boolean);
      const aiDiets = (entry.aiDetectedDiets || []).map(normalizeDietLabel).filter(Boolean);
      const conflictMap = {
        'Vegan': ['dairy', 'egg', 'fish', 'shellfish'],
        'Vegetarian': ['fish', 'shellfish'],
        'Gluten-free': ['wheat']
      };
      const conflicts = [];

      diets.forEach(diet => {
        const restricted = conflictMap[diet];
        if (!restricted) return;
        const hits = restricted.filter(a => allergenSet.has(a));
        if (hits.length) {
          conflicts.push({ diet, allergens: hits });
        }
      });

      entry.allergens = Array.from(allergenSet);
      entry.aiDetectedAllergens = Array.from(aiAllergenSet);
      entry.diets = diets;
      entry.aiDetectedDiets = aiDiets;
      entry.dietAllergenConflicts = conflicts;
    }

    let aiAssistBackdrop = null;
    let aiAssistPanel = null;
    let aiAssistCloseBtn = null;
    let aiAssistInput = null;
    let aiAssistDictateBtn = null;
    let aiAssistGenerateBtn = null;
    let aiAssistProcessBtn = null;
    let aiAssistStatusEl = null;
    let aiAssistResultsEl = null;
    let aiAssistTableBody = null;
    let aiAssistAddRowBtn = null;
    let aiAssistApplyBtn = null;
    let aiAssistBrandResults = null;
    let aiAssistUploadBtn = null;
    let aiAssistCameraBtn = null;
    let aiAssistFileInput = null;
    let aiAssistImagePreview = null;
    let aiAssistVideo = null;
    let aiAssistCaptureBtn = null;
    let aiAssistCancelCameraBtn = null;
    let aiAssistClearImageBtn = null;
    let aiAssistMediaPreview = null;
    let aiAssistElementsBound = false;

    const aiAssistState = {
      context: null,
      recognition: null,
      listening: false,
      pendingRequestId: null,
      brandSuggestions: {},
      imageData: null,
      imageFileName: null,
      mediaStream: null,
      detectedDietaryOptions: [],
      barcodeResults: {}, // Store barcode lookup results by rowIdx
      originalDishName: null, // Store original dish name when modal opens
      dishNameModified: false // Track if dish name has been modified and saved locally but not applied to dish
    };

    const AI_BRAND_LIMIT = 6;
    const AI_BRAND_MEMORY_KEY = 'cle:aiBrandMemory:v1';

    // Global tracking of active barcode lookups to preserve state across table re-renders
    // Key: rowIdx, Value: { barcode, ingredientName, startTime, promise }
    const activeBarcodeLookups = new Map();

    let aiBrandMemoryCache = null;

    function loadAiBrandMemory() {
      if (aiBrandMemoryCache) return aiBrandMemoryCache;
      try {
        const raw = localStorage.getItem(AI_BRAND_MEMORY_KEY);
        aiBrandMemoryCache = raw ? JSON.parse(raw) : {};
      } catch (_) {
        aiBrandMemoryCache = {};
      }
      return aiBrandMemoryCache;
    }

    function persistAiBrandMemory() {
      try {
        localStorage.setItem(AI_BRAND_MEMORY_KEY, JSON.stringify(aiBrandMemoryCache || {}));
      } catch (_) { }
    }

    function normalizeIngredientKey(name) {
      return norm(name || '').replace(/[^a-z0-9]+/g, ' ').trim();
    }

    function rememberBrand(name, data = {}) {
      const key = normalizeIngredientKey(name);
      if (!key) return;
      const store = loadAiBrandMemory();
      const brand = (data.brand || '').trim();
      if (!brand) {
        delete store[key];
        persistAiBrandMemory();
        return;
      }
      store[key] = {
        brand,
        brandImage: data.brandImage || '',
        ingredientsImage: data.ingredientsImage || '',
        ingredientsList: Array.isArray(data.ingredientsList) ? data.ingredientsList.slice() : [],
        allergens: Array.isArray(data.allergens) ? data.allergens.slice() : [],
        diets: Array.isArray(data.diets) ? data.diets.slice() : [],
      };
      persistAiBrandMemory();
    }

    function forgetBrand(name) {
      const key = normalizeIngredientKey(name);
      if (!key) return;
      const store = loadAiBrandMemory();
      if (store[key]) {
        delete store[key];
        persistAiBrandMemory();
      }
    }

    function getRememberedBrand(name) {
      const key = normalizeIngredientKey(name);
      if (!key) return null;
      const store = loadAiBrandMemory();

      // Try exact match first
      if (store[key]) {
        console.log(`Looking up brand for "${name}" (key: "${key}"): Found exact match: ${store[key].brand}`);
        return store[key];
      }

      // No exact match - try fuzzy matching
      // Look for stored keys where most of the stored key's words appear in the search
      const searchWords = key.split(/\s+/).filter(w => w.length > 2);
      const storeKeys = Object.keys(store);

      let bestMatch = null;
      let bestScore = 0;

      for (const storeKey of storeKeys) {
        const storeWords = storeKey.split(/\s+/).filter(w => w.length > 2);
        if (storeWords.length === 0) continue;

        // Count how many of the STORED key's words are covered by the search
        // This ensures "vegetable broth" matches "100% all natural whole vegetable broth"
        // but "vegetable oil" does NOT match "vegetable broth" (only 1 of 2 words match)
        const matchedStoreWords = storeWords.filter(stw =>
          searchWords.some(sw => stw === sw || stw.includes(sw) || sw.includes(stw))
        );

        // Calculate score as percentage of stored key words that are matched
        const score = matchedStoreWords.length / storeWords.length;

        // Require ALL of the stored key's words to be present in the search
        // This prevents false positives like "vegetable oil" matching "vegetable broth"
        if (score >= 1.0 && score > bestScore) {
          bestScore = score;
          bestMatch = { key: storeKey, data: store[storeKey] };
        }
      }

      if (bestMatch) {
        console.log(`Looking up brand for "${name}" (key: "${key}"): Found fuzzy match "${bestMatch.key}" (score: ${bestScore.toFixed(2)}): ${bestMatch.data.brand}`);
        return bestMatch.data;
      }

      console.log(`Looking up brand for "${name}" (key: "${key}"): Not found`);
      console.log('Available keys in brand memory:', storeKeys);
      return null;
    }

    function rebuildBrandMemoryFromRestaurant() {
      // Clear all existing brand memory
      console.log('=== REBUILDING BRAND MEMORY ===');
      console.log('Old brand memory:', JSON.stringify(aiBrandMemoryCache));
      aiBrandMemoryCache = {};

      // Rebuild from actual dishes in database
      if (!state.restaurant || !Array.isArray(state.restaurant.overlays)) {
        console.log('No restaurant or overlays found, clearing memory');
        persistAiBrandMemory();
        return;
      }

      console.log(`Scanning ${state.restaurant.overlays.length} dishes for brands...`);

      // Scan through all overlays/dishes
      state.restaurant.overlays.forEach((overlay, overlayIdx) => {
        const dishName = overlay.id || overlay.name || 'unnamed';

        // Parse aiIngredients if it exists (it's stored as a JSON string)
        let ingredients = [];
        if (overlay.aiIngredients) {
          try {
            ingredients = JSON.parse(overlay.aiIngredients);
            console.log(`Dish ${overlayIdx} (${dishName}): Found aiIngredients with ${ingredients.length} ingredients`);
          } catch (e) {
            console.log(`Dish ${overlayIdx} (${dishName}): Failed to parse aiIngredients:`, e);
          }
        }

        // Also check for legacy ingredients array format
        if (!ingredients.length && Array.isArray(overlay.ingredients)) {
          ingredients = overlay.ingredients;
          console.log(`Dish ${overlayIdx} (${dishName}): Using legacy ingredients array with ${ingredients.length} ingredients`);
        }

        if (!ingredients.length) {
          console.log(`Dish ${overlayIdx} (${dishName}): No ingredients found`);
          return;
        }

        console.log(`Dish ${overlayIdx} (${dishName}): Processing ${ingredients.length} ingredients`);

        ingredients.forEach(ingredient => {
          if (!ingredient.name || !Array.isArray(ingredient.brands) || ingredient.brands.length === 0) {
            return;
          }

          console.log(`  - Ingredient "${ingredient.name}" has ${ingredient.brands.length} brand(s)`);

          // Save each brand to memory
          ingredient.brands.forEach(brand => {
            if (brand.name) {
              console.log(`    -> Saving brand "${brand.name}" for "${ingredient.name}"`);
              rememberBrand(ingredient.name, {
                brand: brand.name,
                brandImage: brand.brandImage || '',
                ingredientsImage: brand.ingredientsImage || '',
                ingredientsList: Array.isArray(brand.ingredientsList) ? brand.ingredientsList : [],
                allergens: Array.isArray(brand.allergens) ? brand.allergens : [],
                diets: Array.isArray(brand.diets) ? brand.diets : []
              });
            }
          });
        });
      });

      console.log('=== BRAND MEMORY REBUILD COMPLETE ===');
      console.log('New brand memory:', JSON.stringify(aiBrandMemoryCache));
    }

    function fillRowFromMemory(rowElement, force) {
      if (!rowElement) return;
      const nameInput = rowElement.querySelector('.aiIngredientName');
      const brandInput = rowElement.querySelector('.aiIngredientBrand');
      const name = (nameInput?.value || '').trim();
      if (!name) return;
      const memory = getRememberedBrand(name);
      if (!memory) return;
      if (brandInput && (force || !(brandInput.value || '').trim()) && memory.brand) {
        brandInput.value = memory.brand;
      }
      if (memory.brandImage) {
        rowElement.dataset.brandImage = memory.brandImage;
      }
      if (memory.ingredientsImage) {
        rowElement.dataset.ingredientsImage = memory.ingredientsImage;
      }
      if (memory.ingredientsList && memory.ingredientsList.length) {
        rowElement.dataset.ingredientsList = JSON.stringify(memory.ingredientsList);
      }
      if (memory.allergens && memory.allergens.length) {
        const allergenSet = new Set(memory.allergens.map(norm));
        rowElement.querySelectorAll('.aiAllergenChecklist input').forEach(input => {
          if (allergenSet.has(norm(input.value))) input.checked = true;
        });
      }
      updateAiBrandPreview(rowElement);
    }

    function aiAssistSetStatus(message = '', tone = 'info') {
      if (!aiAssistStatusEl) return;
      aiAssistStatusEl.textContent = message;
      if (message) {
        aiAssistStatusEl.setAttribute('data-tone', tone);
      } else {
        aiAssistStatusEl.removeAttribute('data-tone');
      }
    }

    function ensureAiAssistElements() {
      if (aiAssistBackdrop && aiAssistBackdrop.isConnected) return;
      if (aiAssistBackdrop && !aiAssistBackdrop.isConnected) {
        aiAssistBackdrop = null;
        aiAssistPanel = null;
        aiAssistCloseBtn = null;
        aiAssistInput = null;
        aiAssistDictateBtn = null;
        aiAssistProcessBtn = null;
        aiAssistStatusEl = null;
        aiAssistResultsEl = null;
        aiAssistTableBody = null;
        aiAssistAddRowBtn = null;
        aiAssistApplyBtn = null;
        aiAssistBrandResults = null;
        aiAssistUploadBtn = null;
        aiAssistCameraBtn = null;
        aiAssistFileInput = null;
        aiAssistImagePreview = null;
        aiAssistVideo = null;
        aiAssistCaptureBtn = null;
        aiAssistCancelCameraBtn = null;
        aiAssistClearImageBtn = null;
        aiAssistMediaPreview = null;
        aiAssistElementsBound = false;
      }
      if (!aiAssistBackdrop) {
        const backdrop = document.createElement('div');
        backdrop.className = 'aiAssistBackdrop';
        backdrop.id = 'aiAssistBackdrop';
        backdrop.setAttribute('aria-hidden', 'true');
        backdrop.innerHTML = `
      <div class="aiAssistPanel" id="aiAssistPanel" role="dialog" aria-modal="true" aria-labelledby="aiAssistTitle">
        <!-- Floating Replacement Progress Card -->
        <div id="aiAssistReplacementProgress" style="display:none;position:fixed;top:20px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg, #4c5ad4 0%, #5d6ae5 100%);border:2px solid rgba(76,90,212,0.8);border-radius:12px;padding:16px 24px;box-shadow:0 8px 24px rgba(0,0,0,0.4);z-index:10000;min-width:320px;max-width:90vw;text-align:center;white-space:nowrap">
          <div style="font-size:1.1rem;font-weight:600;color:#fff;margin-bottom:4px">Replace Removed Item</div>
          <div style="font-size:0.95rem;color:rgba(255,255,255,0.9)" id="aiAssistReplacementProgressText">Dish 1 of 3</div>
        </div>
        <div class="aiAssistHead">
          <div style="display:flex;align-items:center;gap:12px">
            <h2 id="aiAssistTitle" style="margin:0">Dish editor</h2>
          </div>
          <div style="display:flex;gap:8px">
            <button type="button" class="btn btnDanger" id="aiAssistDeleteBtn" aria-label="Delete overlay" style="display:none;padding:8px 12px;font-size:0.9rem"> Delete</button>
            <button type="button" class="aiAssistClose" id="aiAssistClose" aria-label="Close AI assistant"></button>
          </div>
        </div>

        <!-- Unsaved Changes Warning -->
        <div id="aiAssistUnsavedWarning" style="display:none;background:#2a1a0a;border:2px solid #f59e0b;border-radius:8px;padding:20px;margin:16px 0">
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
            <span style="font-size:2rem"></span>
            <div>
              <div style="font-size:1.1rem;font-weight:600;color:#f59e0b">You have unsaved work in the dish editor</div>
            </div>
          </div>
          <div style="display:flex;gap:12px">
            <button type="button" class="btn btnPrimary" id="aiAssistSaveAndExitBtn" style="flex:1;padding:12px;font-size:1rem"> Save Changes</button>
            <button type="button" class="btn" id="aiAssistExitWithoutSavingBtn" style="flex:1;padding:12px;font-size:1rem;background:#4a1a1a;border-color:#721c24">Exit Without Saving</button>
          </div>
          <button type="button" class="btn" id="aiAssistCancelExitBtn" style="width:100%;margin-top:12px;padding:8px;font-size:0.9rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
        </div>

        <!-- Delete Overlay Warning -->
        <div id="aiAssistDeleteWarning" style="display:none;background:#1a0a0a;border:2px solid #dc2626;border-radius:8px;padding:20px;margin:16px 0">
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
            <span style="font-size:2rem"></span>
            <div>
              <div style="font-size:1.1rem;font-weight:600;color:#dc2626;margin-bottom:4px">Delete this dish?</div>
              <div style="font-size:0.95rem;color:#d1d5db">This action cannot be undone.</div>
            </div>
          </div>
          <div style="display:flex;gap:12px">
            <button type="button" class="btn btnDanger" id="aiAssistConfirmDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:#dc2626;border-color:#b91c1c"> Delete</button>
            <button type="button" class="btn" id="aiAssistCancelDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
          </div>
        </div>

        <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;position:relative">
          <label for="aiAssistNameInput" style="font-size:0.95rem;color:#a8b2d6;white-space:nowrap">Dish name:</label>
          <input type="text" id="aiAssistNameInput" placeholder="Enter dish name" style="flex:1;padding:10px;font-size:1rem;font-weight:600;border-radius:8px;border:1px solid rgba(76,90,212,0.35);background:rgba(10,16,36,0.95);color:var(--ink)">
          <button type="button" id="aiAssistSaveNameBtn" style="position:absolute;right:8px;padding:6px 12px;font-size:0.85rem;background:#4c5ad4;border-color:#4c5ad4;color:white;border-radius:6px;border:none;cursor:pointer;display:none;z-index:10"> Save</button>
        </div>
        <p class="aiAssistIntro">Upload recipe photos or describe the dish ingredients below.</p>

        <!-- Photo Upload Section -->
        <div class="aiAssistMedia" id="aiAssistMedia">
          <button type="button" class="btn" id="aiAssistUploadRecipeBtn" style="flex:1"> Upload photos</button>
          <button type="button" class="btn" id="aiAssistCameraRecipeBtn" style="flex:1"> Take photo</button>
          <input type="file" id="aiAssistRecipeFileInput" class="aiAssistHidden" accept="image/*" multiple>
        </div>

        <!-- Photo Previews Container -->
        <div id="aiAssistPhotosContainer" style="display:none;margin:16px 0;padding:12px;background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:8px;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <strong style="color:var(--ink)">Recipe Photos</strong>
            <button type="button" class="btn" id="aiAssistClearAllPhotosBtn" style="font-size:0.85rem;padding:4px 12px">Clear All</button>
          </div>
          <div id="aiAssistPhotosList" style="display:flex;flex-wrap:wrap;gap:8px;"></div>
        </div>

        <div class="aiAssistMediaPreview" id="aiAssistMediaPreview">
          <video id="aiAssistVideo" class="aiAssistHidden" playsinline muted></video>
          <div class="aiAssistPhotoControls">
            <button type="button" class="btn" id="aiAssistCaptureBtn">Capture photo</button>
            <button type="button" class="btn" id="aiAssistCancelCameraBtn">Cancel camera</button>
          </div>
        </div>

        <!-- OR Divider -->
        <div style="display: flex; align-items: center; gap: 16px; margin: 20px 0;">
          <div style="flex: 1; height: 1px; background: rgba(76,90,212,0.3);"></div>
          <span style="color: #a0a0a0; font-weight: 600; font-size: 1rem;">OR</span>
          <div style="flex: 1; height: 1px; background: rgba(76,90,212,0.3);"></div>
        </div>

        <!-- Text Input Section -->
        <div style="position:relative;">
          <textarea id="aiAssistInput" class="aiAssistInput" placeholder="Example: Grilled chicken marinated in yogurt, lemon juice, garlic, served with toasted pita and tahini sauce."></textarea>
          <button type="button" class="btn" id="aiAssistDictateBtn" style="position:absolute;bottom:12px;left:12px;padding:6px 12px;font-size:0.9rem"> Dictate</button>
          <button type="button" class="btn" id="aiAssistGenerateBtn" style="position:absolute;bottom:12px;right:12px;padding:6px 12px;font-size:0.9rem;background:#4c5ad4;border-color:#4c5ad4;color:white"></button>
        </div>

        <!-- Process Button -->
        <button type="button" class="btn" id="aiAssistProcessBtn" style="width:100%;margin-top:16px;padding:14px;font-size:1.1rem;font-weight:600;background:#2d7d46;border-color:#3a9d5a;color:white">
           Process Input
        </button>
        <span class="aiAssistStatus" id="aiAssistStatus" style="display:block;margin-top:8px;text-align:center"></span>
        <div class="aiProgressBar" id="aiProgressBar">
          <div class="aiProgressBarFill" id="aiProgressBarFill" style="width:0%"></div>
        </div>
        <div class="aiAssistResults" id="aiAssistResults" aria-live="polite">
          <h3 style="margin:0">Ingredients</h3>
          <div class="aiAssistTableWrapper">
            <table id="aiAssistTable">
              <tbody id="aiAssistTableBody"></tbody>
            </table>
          </div>

          <div class="aiAssistTableActions">
            <button type="button" class="btn" id="aiAssistAddRowBtn">Add ingredient</button>
          </div>

          <!-- Cross-Contamination Risk Section -->
          <div id="aiAssistCrossContamination" style="margin-top:24px;padding-top:24px;border-top:2px solid rgba(76,90,212,0.3)">
            <h3 style="margin:0 0 12px 0;font-size:1.1rem;color:#a8b2d6">Cross-Contamination Risk</h3>
            <p style="color:#a8b2d6;font-size:0.9rem;margin-bottom:16px;">Select any allergens that may have cross-contamination risk during preparation:</p>

            <div id="aiAssistCrossAllergenCheckboxes" style="display:flex;flex-wrap:wrap;gap:12px;margin-bottom:16px;">
              <!-- Allergen checkboxes will be inserted here -->
            </div>

            <div style="margin-top:16px;">
              <label style="display:flex;align-items:center;gap:12px;padding:16px;background:rgba(76,90,212,0.1);border:2px solid rgba(76,90,212,0.3);border-radius:8px;cursor:pointer;transition:all 0.2s;" id="aiAssistNoCrossContaminationLabel">
                <input type="checkbox" id="aiAssistNoCrossContamination" style="width:20px;height:20px;cursor:pointer;">
                <span style="flex:1;color:#d1d5db;font-size:1rem;font-weight:500;">No cross-contamination risk with any of the above allergens</span>
              </label>
            </div>

            <p id="aiAssistCrossContaminationError" style="display:none;color:#ef4444;font-size:0.9rem;margin-top:12px;padding:12px;background:rgba(239,68,68,0.1);border:1px solid #ef4444;border-radius:6px;">
               Please select "No cross-contamination risk" or check at least one allergen before saving.
            </p>

            <!-- Validation Error Message (shown when trying to save without confirming all ingredients) -->
            <div id="aiAssistSaveError" style="display:none;background:#2a1a0a;border:2px solid #f59e0b;border-radius:8px;padding:16px;margin:16px 0">
              <div style="display:flex;align-items:center;gap:12px">
                <span style="font-size:1.5rem"></span>
                <div>
                  <div style="font-size:1rem;font-weight:600;color:#f59e0b;margin-bottom:4px">Cannot save - not all ingredients are confirmed</div>
                  <div id="aiAssistSaveErrorDetails" style="font-size:0.9rem;color:#d1d5db"></div>
                </div>
              </div>
            </div>

            <div class="aiAssistTableActions" style="margin-top:20px;">
              <button type="button" class="btn btnPrimary" id="aiAssistApplyBtn"> Save to Dish</button>
            </div>
          </div>

          <!-- Dish Overlay Preview -->
          <div id="aiAssistPreview" style="margin-top:24px;padding-top:24px;border-top:2px solid rgba(76,90,212,0.3)">
            <h3 style="margin:0 0 12px 0;font-size:1.1rem;color:#a8b2d6">Preview: What customers will see</h3>
            <div id="aiAssistPreviewBox" style="background:rgba(76,90,212,0.05);border:1px solid rgba(76,90,212,0.3);border-radius:8px;padding:16px;color:#d1d5db;font-size:0.95rem;line-height:1.6">
              <!-- Preview content will be inserted here -->
            </div>
          </div>

          <div class="aiAssistBrandResults" id="aiAssistBrandResults" aria-live="polite"></div>
        </div>
      </div>`;
        document.body.appendChild(backdrop);
        aiAssistBackdrop = backdrop;
        aiAssistPanel = backdrop.querySelector('#aiAssistPanel');

        // Create image modal
        if (!document.getElementById('imageModal')) {
          const modal = document.createElement('div');
          modal.id = 'imageModal';
          modal.className = 'imageModal';
          modal.innerHTML = `
        <button type="button" class="closeModal" onclick="closeImageModal()" aria-label="Close"></button>
        <img id="imageModalImg" src="" alt="Full size image">
      `;
          modal.addEventListener('click', (e) => {
            if (e.target.classList.contains('imageModal')) {
              closeImageModal();
            }
          });
          document.body.appendChild(modal);
        }
        aiAssistCloseBtn = backdrop.querySelector('#aiAssistClose');
        aiAssistInput = backdrop.querySelector('#aiAssistInput');
        aiAssistDictateBtn = backdrop.querySelector('#aiAssistDictateBtn');
        aiAssistGenerateBtn = backdrop.querySelector('#aiAssistGenerateBtn');
        aiAssistProcessBtn = backdrop.querySelector('#aiAssistProcessBtn');
        aiAssistStatusEl = backdrop.querySelector('#aiAssistStatus');
        aiAssistResultsEl = backdrop.querySelector('#aiAssistResults');
        aiAssistTableBody = backdrop.querySelector('#aiAssistTableBody');
        aiAssistAddRowBtn = backdrop.querySelector('#aiAssistAddRowBtn');
        aiAssistApplyBtn = backdrop.querySelector('#aiAssistApplyBtn');
        aiAssistBrandResults = backdrop.querySelector('#aiAssistBrandResults');
        aiAssistVideo = backdrop.querySelector('#aiAssistVideo');
        aiAssistCaptureBtn = backdrop.querySelector('#aiAssistCaptureBtn');
        aiAssistCancelCameraBtn = backdrop.querySelector('#aiAssistCancelCameraBtn');
        aiAssistMediaPreview = backdrop.querySelector('#aiAssistMediaPreview');
        window.aiAssistPhotos = []; // Store multiple photos

        // Initialize cross-contamination allergen checkboxes
        const crossAllergenContainer = backdrop.querySelector('#aiAssistCrossAllergenCheckboxes');
        if (crossAllergenContainer && crossAllergenContainer.children.length === 0) {
          console.log('Creating cross-contamination checkboxes for the first time');
          ALLERGENS.forEach(allergen => {
            const label = document.createElement('label');
            label.style.cssText = 'display:flex;align-items:center;gap:8px;padding:10px 16px;background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:6px;cursor:pointer;transition:all 0.2s;white-space:nowrap;';
            label.className = 'aiCrossAllergenLabel';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'aiCrossAllergenCheckbox';
            checkbox.dataset.allergen = allergen;
            checkbox.style.cssText = 'width:18px;height:18px;cursor:pointer;';

            // Add change listener to log when checkbox is clicked
            checkbox.addEventListener('change', (e) => {
              console.log(`Cross-contamination checkbox ${allergen} changed to:`, e.target.checked, 'element:', e.target);
            });

            const emoji = {
              'dairy': '',
              'egg': '',
              'peanut': '',
              'tree nut': '',
              'shellfish': '',
              'fish': '',
              'soy': '',
              'sesame': '',
              'wheat': ''
            }[allergen] || '';

            const span = document.createElement('span');
            span.style.cssText = 'color:#d1d5db;font-size:0.95rem;';
            span.textContent = `${emoji} ${allergen.charAt(0).toUpperCase() + allergen.slice(1)}`;

            label.appendChild(checkbox);
            label.appendChild(span);
            crossAllergenContainer.appendChild(label);
          });
        }

        // Add mutual exclusivity event listeners for cross-contamination section
        const noCrossCheckbox = backdrop.querySelector('#aiAssistNoCrossContamination');
        const crossAllergenCheckboxes = backdrop.querySelectorAll('.aiCrossAllergenCheckbox');
        const crossErrorEl = backdrop.querySelector('#aiAssistCrossContaminationError');

        if (noCrossCheckbox && crossAllergenCheckboxes.length > 0) {
          // When "no risk" is checked, disable and uncheck all allergen checkboxes
          noCrossCheckbox.addEventListener('change', () => {
            if (noCrossCheckbox.checked) {
              crossAllergenCheckboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
                cb.parentElement.style.opacity = '0.5';
                cb.parentElement.style.pointerEvents = 'none';
              });
            } else {
              crossAllergenCheckboxes.forEach(cb => {
                cb.disabled = false;
                cb.parentElement.style.opacity = '1';
                cb.parentElement.style.pointerEvents = 'auto';
              });
            }
            // Hide error when selection changes
            if (crossErrorEl) crossErrorEl.style.display = 'none';
            // Update preview to reflect cross-contamination selection
            updateAiPreview();
          });

          // When any allergen checkbox is checked, uncheck "no risk"
          crossAllergenCheckboxes.forEach(cb => {
            cb.addEventListener('change', () => {
              if (cb.checked) {
                noCrossCheckbox.checked = false;
              }
              // Hide error when selection changes
              if (crossErrorEl) crossErrorEl.style.display = 'none';
              // Update preview to reflect cross-contamination selection
              updateAiPreview();
            });
          });
        }

        aiAssistElementsBound = false;
      }
      if (!aiAssistElementsBound) {
        aiAssistBackdrop.addEventListener('click', (event) => {
          if (event.target === aiAssistBackdrop) closeAiAssistant();
        });
        aiAssistCloseBtn.addEventListener('click', () => closeAiAssistant());
        aiAssistDictateBtn.addEventListener('click', () => toggleAiDictation());
        if (aiAssistGenerateBtn) {
          aiAssistGenerateBtn.addEventListener('click', () => generateRecipeDescription());

          // Create update function that we can call from multiple places
          const updateGenerateButtonText = () => {
            const nameInput = document.getElementById('aiAssistNameInput');
            if (nameInput && aiAssistGenerateBtn) {
              const dishName = nameInput.value?.trim() || 'recipe';
              aiAssistGenerateBtn.textContent = ` Generate generic ${dishName} recipe`;
            }
          };

          // Get save button and name input
          const nameInput = aiAssistBackdrop.querySelector('#aiAssistNameInput');
          const saveNameBtn = aiAssistBackdrop.querySelector('#aiAssistSaveNameBtn');

          if (nameInput) {
            // Initialize original dish name if not already set
            if (aiAssistState.originalDishName === null || aiAssistState.originalDishName === undefined) {
              aiAssistState.originalDishName = nameInput.value?.trim() || '';
            }
            let originalDishName = aiAssistState.originalDishName;

            // Function to check if dish name has changed and show/hide save button
            const checkForChanges = () => {
              const currentValue = nameInput.value?.trim() || '';
              if (saveNameBtn) {
                // Show save button if value changed from original
                if (currentValue !== originalDishName && currentValue.length > 0) {
                  saveNameBtn.style.display = 'block';
                } else {
                  saveNameBtn.style.display = 'none';
                }
              }
            };

            // Save button click handler - updates generate button and hides save button
            if (saveNameBtn) {
              saveNameBtn.addEventListener('click', () => {
                const newDishName = nameInput.value?.trim() || '';
                const wasChanged = newDishName !== originalDishName;

                originalDishName = newDishName;
                aiAssistState.originalDishName = originalDishName; // Update global state

                // Mark that dish name has been modified (needs to be saved to dish)
                if (wasChanged && newDishName.length > 0) {
                  aiAssistState.dishNameModified = true;
                  console.log('Dish name saved locally - marking as modified. Will prompt on close unless saved to dish.');
                }

                updateGenerateButtonText();
                saveNameBtn.style.display = 'none';
              });
            }

            // Check for changes on input events
            nameInput.addEventListener('input', checkForChanges);
            nameInput.addEventListener('change', checkForChanges);
            nameInput.addEventListener('keyup', checkForChanges);
            nameInput.addEventListener('paste', () => {
              setTimeout(checkForChanges, 10); // Small delay to let paste complete
            });

            // Update generate button text on input (but don't save yet)
            nameInput.addEventListener('input', () => {
              // Don't update generate button automatically - wait for save
            });

            // Set initial text right away
            updateGenerateButtonText();

            // Initialize save button state
            checkForChanges();
          }

          // Store the update function globally so we can call it when modal opens
          window.updateGenerateButtonText = updateGenerateButtonText;
        }
        aiAssistProcessBtn.addEventListener('click', () => handleAiProcess());

        // Recipe photo upload/camera handlers
        const uploadRecipeBtn = aiAssistBackdrop.querySelector('#aiAssistUploadRecipeBtn');
        const cameraRecipeBtn = aiAssistBackdrop.querySelector('#aiAssistCameraRecipeBtn');
        const recipeFileInput = aiAssistBackdrop.querySelector('#aiAssistRecipeFileInput');

        if (uploadRecipeBtn && recipeFileInput) {
          uploadRecipeBtn.addEventListener('click', () => {
            recipeFileInput.value = '';
            recipeFileInput.click();
          });
          recipeFileInput.addEventListener('change', () => {
            const files = recipeFileInput.files;
            if (files && files.length) handleMultipleRecipePhotoUpload(files);
          });
        }
        if (cameraRecipeBtn) {
          cameraRecipeBtn.addEventListener('click', () => handleRecipePhotoCamera());
        }

        const clearAllPhotosBtn = aiAssistBackdrop.querySelector('#aiAssistClearAllPhotosBtn');
        if (clearAllPhotosBtn) {
          clearAllPhotosBtn.addEventListener('click', () => {
            window.aiAssistPhotos = [];
            renderPhotoPreviews();
          });
        }

        aiAssistAddRowBtn.addEventListener('click', () => {
          const data = collectAiTableData();
          data.push({
            name: '',
            allergens: [],
            diets: [],
            brands: [],
            confirmed: false,
            requiresApply: true,
            aiDetectionCompleted: false
          });
          renderAiTable(data);
        });

        // New confirmation workflow buttons
        // Save Draft button removed per user request

        console.log('Binding aiAssistApplyBtn:', aiAssistApplyBtn);
        if (aiAssistApplyBtn) {
          aiAssistApplyBtn.addEventListener('click', () => {
            console.log('Save to Dish button clicked!');
            applyAiIngredientsToOverlay();
          });
        } else {
          console.error('aiAssistApplyBtn not found!');
        }
        if (aiAssistUploadBtn && aiAssistFileInput) {
          aiAssistUploadBtn.addEventListener('click', () => {
            aiAssistFileInput.value = '';
            aiAssistFileInput.click();
          });
          aiAssistFileInput.addEventListener('change', () => {
            const file = aiAssistFileInput.files && aiAssistFileInput.files[0];
            if (file) handleAiFileSelection(file);
          });
        }
        if (aiAssistCameraBtn) {
          aiAssistCameraBtn.addEventListener('click', () => startAiCamera());
        }
        if (aiAssistCaptureBtn) {
          aiAssistCaptureBtn.addEventListener('click', () => captureAiPhoto());
        }
        if (aiAssistCancelCameraBtn) {
          aiAssistCancelCameraBtn.addEventListener('click', () => stopAiCamera(true));
        }
        if (aiAssistClearImageBtn) {
          aiAssistClearImageBtn.addEventListener('click', () => clearAiImage());
        }
        aiAssistTableBody.addEventListener('click', (event) => {
          if (event.target.classList.contains('aiIngredientApply') || event.target.closest('.aiIngredientApply')) {
            const rowIdx = Number(event.target.dataset.rowIdx || idx);
            const data = collectAiTableData();
            const tr = aiAssistTableBody.querySelector(`tr[data-index="${rowIdx}"]`);
            const nameInput = tr ? tr.querySelector('.aiIngredientName') : null;
            const ingredientName = (nameInput?.value || '').trim();
            if (!ingredientName) {
              aiAssistSetStatus('Enter an ingredient name first.', 'warn');
              return;
            }

            // Compute needsScan from simple heuristics (processed foods/meats require scan)
            const lower = ingredientName.toLowerCase();
            const computedNeedsScan = requiresBarcodeScan(lower);

            // Update row fields
            if (data[rowIdx]) {
              data[rowIdx].name = ingredientName;
              data[rowIdx].needsScan = computedNeedsScan;
              data[rowIdx].scanDecisionSource = 'heuristic';
              data[rowIdx].userOverriddenScan = false;
              data[rowIdx].analysisPending = true;
              data[rowIdx].analysisMessage = 'Analyzing ingredient';
              data[rowIdx].aiDetectionCompleted = false;
              // Reset confirmed since data changed
              data[rowIdx].confirmed = false;
              data[rowIdx].requiresApply = false;
            }

            // Optimistically render scan status change + loading state
            renderAiTable(data);

            // Kick off AI analysis for allergens/diets based on name text
            (async () => {
              try {
                aiAssistSetStatus(`Checking scan requirements for "${ingredientName}"...`, 'info');
                const { data: analysisData, error } = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
                  body: { ingredientText: ingredientName }
                });
                if (error) {
                  console.error('AI analysis error:', error);
                  const errored = collectAiTableData();
                  if (errored[rowIdx]) {
                    errored[rowIdx].analysisPending = false;
                    errored[rowIdx].analysisMessage = '';
                    renderAiTable(errored);
                  }
                  aiAssistSetStatus(`Automatic scan analysis failed for "${ingredientName}". Using fallback.`, 'warn');
                  return;
                }
                const aiAllergens = Array.isArray(analysisData?.allergens) ? [...analysisData.allergens] : [];
                const aiDiets = Array.isArray(analysisData?.diets) ? [...analysisData.diets] : [];
                const aiNeedsScan = typeof analysisData?.needsScan === 'boolean' ? analysisData.needsScan : null;

                const refreshed = collectAiTableData();
                if (refreshed[rowIdx]) {
                  refreshed[rowIdx].allergens = aiAllergens.slice();
                  refreshed[rowIdx].diets = aiDiets.slice();
                  // Mark these as AI-detected so they get green outline
                  refreshed[rowIdx].aiDetectedAllergens = aiAllergens.slice();
                  refreshed[rowIdx].aiDetectedDiets = aiDiets.slice();
                  refreshed[rowIdx].aiDetectionCompleted = true;
                  refreshed[rowIdx].confirmed = false;
                  if (aiNeedsScan !== null) {
                    refreshed[rowIdx].needsScan = aiNeedsScan;
                    refreshed[rowIdx].scanDecisionSource = 'haiku';
                    refreshed[rowIdx].userOverriddenScan = false;
                  }
                  refreshed[rowIdx].analysisPending = false;
                  refreshed[rowIdx].analysisMessage = '';
                  enforceDietAllergenConsistency(refreshed[rowIdx]);
                  renderAiTable(refreshed);
                  if (aiNeedsScan === true) {
                    aiAssistSetStatus(`Scan required for "${ingredientName}".`, 'warn');
                  } else if (aiNeedsScan === false) {
                    aiAssistSetStatus(`Scan optional for "${ingredientName}".`, 'success');
                  } else {
                    aiAssistSetStatus(`Updated allergens/diets for "${ingredientName}".`, 'success');
                  }
                  aiAssistState.savedToDish = false;
                }
              } catch (err) {
                console.error('Failed to analyze allergens/diets:', err);
                const errored = collectAiTableData();
                if (errored[rowIdx]) {
                  errored[rowIdx].analysisPending = false;
                  errored[rowIdx].analysisMessage = '';
                  renderAiTable(errored);
                }
                aiAssistSetStatus(`Could not complete scan analysis for "${ingredientName}".`, 'warn');
              }
            })();

            return;
          }
          const row = event.target.closest('tr');
          if (!row) return;
          const idx = Number(row.dataset.index || '0');
          if (event.target.classList.contains('aiDeleteRow') || event.target.closest('.aiDeleteRow')) {
            const data = collectAiTableData();
            data.splice(idx, 1);
            renderAiTable(data);
            // Mark as unsaved when user deletes a row
            aiAssistState.savedToDish = false;
            return;
          }
          if (event.target.classList.contains('aiBrandBarcodeBtn') || event.target.closest('.aiBrandBarcodeBtn')) {
            openBrandIdentificationChoice(idx);
            return;
          }
          if (event.target.classList.contains('aiAppealScanBtn') || event.target.closest('.aiAppealScanBtn')) {
            const rowIdx = Number(event.target.dataset.rowIdx || event.target.closest('.aiAppealScanBtn')?.dataset.rowIdx || idx);
            openAiAppealModal(rowIdx);
            return;
          }
          if (event.target.classList.contains('aiRemoveAppealBtn') || event.target.closest('.aiRemoveAppealBtn')) {
            const rowIdx = Number(event.target.dataset.rowIdx || event.target.closest('.aiRemoveAppealBtn')?.dataset.rowIdx || idx);
            removeAppeal(rowIdx);
            return;
          }
          if (event.target.classList.contains('aiRemoveBrand') || event.target.closest('.aiRemoveBrand')) {
            const brandIdx = Number(event.target.dataset.brandIdx || event.target.closest('.aiRemoveBrand')?.dataset.brandIdx);
            console.log('=== DELETE BRAND CLICKED ===');
            console.log('Row idx:', idx);
            console.log('Brand idx:', brandIdx);
            if (!isNaN(brandIdx)) {
              const data = collectAiTableData();
              console.log('Current data before delete:', JSON.stringify(data[idx]));
              if (data[idx] && data[idx].brands) {
                console.log(`Removing brand at index ${brandIdx} from ingredient "${data[idx].name}"`);
                console.log('Brands before:', data[idx].brands.map(b => b.name));
                data[idx].brands.splice(brandIdx, 1);
                console.log('Brands after:', data[idx].brands.map(b => b.name));
                // Reset confirmed state since allergens/diets may have changed
                data[idx].confirmed = false;
                console.log('Re-rendering table with updated data');
                renderAiTable(data);
                aiAssistSetStatus('Brand removed from this ingredient.', 'info');
                // Mark as unsaved when user removes a brand
                aiAssistState.savedToDish = false;
              }
            }
            return;
          }
          if (event.target.classList.contains('viewBarcodeResultsBtn') || event.target.closest('.viewBarcodeResultsBtn')) {
            const btn = event.target.closest('.viewBarcodeResultsBtn');
            const rowIdx = Number(btn?.dataset.rowIdx || idx);
            const stored = aiAssistState.barcodeResults?.[rowIdx];
            if (stored) {
              showBarcodeSourcesModal(rowIdx, stored.suggestion, stored.barcodeResult);
              const banner = btn.closest('.barcodeLoadingArea');
              if (banner && banner.parentNode) banner.remove();
            } else {
              aiAssistSetStatus('Results are not available for this row yet.', 'warn');
            }
            return;
          }
          if (event.target.classList.contains('aiAddRememberedBrand') || event.target.closest('.aiAddRememberedBrand')) {
            console.log('=== ADD REMEMBERED BRAND CLICKED ===');
            const data = collectAiTableData();
            const ingredientName = data[idx]?.name;
            if (ingredientName) {
              const memory = getRememberedBrand(ingredientName);
              if (memory && memory.brand) {
                console.log(`Adding remembered brand "${memory.brand}" for "${ingredientName}"`);
                // Initialize brands array if needed
                if (!data[idx].brands) {
                  data[idx].brands = [];
                }
                // Check if this brand is already added
                const brandExists = data[idx].brands.some(b => b.name === memory.brand);
                if (!brandExists) {
                  // IMPORTANT: Only copy brand name and image - NOT ingredient data!
                  // The same brand makes different products with different ingredients.
                  // E.g., Pacific vegetable broth vs Pacific pita bread are completely different.
                  // User needs to scan the actual product to get correct ingredients.
                  data[idx].brands.push({
                    name: memory.brand,
                    brandImage: memory.brandImage || '',
                    ingredientsImage: '', // Don't copy - needs fresh scan
                    ingredientsList: [],  // Don't copy - needs fresh scan
                    allergens: [],        // Don't copy - needs fresh scan
                    diets: []             // Don't copy - needs fresh scan
                  });
                  // Don't reset confirmed state since we haven't added allergen/diet info yet
                  renderAiTable(data);
                  aiAssistSetStatus(`Added brand "${memory.brand}". Scan barcode to get ingredients for this product.`, 'info');
                  // Mark as unsaved when user adds a brand
                  aiAssistState.savedToDish = false;
                } else {
                  aiAssistSetStatus(`Brand "${memory.brand}" is already added.`, 'info');
                }
              }
            }
            return;
          }
          if (event.target.classList.contains('aiConfirmBtn')) {
            const btn = event.target;

            // Check if button is disabled (scan required but not completed)
            if (btn.disabled) {
              aiAssistSetStatus('Please complete barcode scan or appeal before confirming this ingredient.', 'warn');
              return;
            }

            const isConfirmed = btn.dataset.confirmed === 'true';

            // Toggle state
            if (isConfirmed) {
              // Unconfirm
              btn.dataset.confirmed = 'false';
              btn.classList.remove('confirmed');
              btn.classList.add('unconfirmed');
              btn.style.background = '#f59e0b';
              btn.style.borderColor = '#f59e0b';
              btn.textContent = 'Confirm';
            } else {
              // Confirm
              btn.dataset.confirmed = 'true';
              btn.classList.remove('unconfirmed');
              btn.classList.add('confirmed');
              btn.style.background = '#4caf50';
              btn.style.borderColor = '#4caf50';
              btn.textContent = ' Confirmed';

              // Hide save error message if shown (since user is now confirming)
              const saveErrorEl = document.getElementById('aiAssistSaveError');
              if (saveErrorEl) saveErrorEl.style.display = 'none';
            }

            // Mark as unsaved when confirmation status changes
            aiAssistState.savedToDish = false;
            return;
          }
        });
        aiAssistTableBody.addEventListener('input', (event) => {
          const row = event.target.closest('tr');
          if (!row) return;
          if (event.target.classList.contains('aiIngredientName')) {
            // Do not re-render on each keystroke; processing happens on Apply button click
          }
          // Reset confirm button when user makes changes
          resetConfirmButton(row);
          // Mark as unsaved when user makes changes
          aiAssistState.savedToDish = false;
          // Update preview
          updateAiPreview();
        });
        aiAssistTableBody.addEventListener('change', (event) => {
          const row = event.target.closest('tr');
          if (!row) return;

          // If allergen or diet checkbox changed, re-render to show override status
          if (event.target.classList.contains('aiAllergenCheckbox') || event.target.classList.contains('aiDietCheckbox')) {
            // Small delay to ensure checkbox state is updated before collecting data
            setTimeout(() => {
              const data = collectAiTableData();
              renderAiTable(data);
              // Update preview after re-render
              updateAiPreview();
            }, 0);
          }

          // Reset confirm button when checkboxes/radios change
          resetConfirmButton(row);
          // Mark as unsaved when checkboxes/radios change
          aiAssistState.savedToDish = false;
          // Update preview
          updateAiPreview();
        });
        aiAssistBrandResults.addEventListener('click', (event) => {
          const card = event.target.closest('.aiBrandSuggestion');
          if (!card) return;
          const rowIdx = Number(card.dataset.row || '0');
          const suggestionIdx = Number(card.dataset.index || '0');
          applyBrandSuggestion(rowIdx, suggestionIdx);
        });
        updateAiAssistMediaPreview();
        aiAssistElementsBound = true;
      }
    }

    let scrollLockPosition = 0;

    function toggleAiAssistBackdrop(show) {
      ensureAiAssistElements();
      if (!aiAssistBackdrop) return;
      if (show) {
        // Update generate button text when assistant opens
        if (typeof window.updateGenerateButtonText === 'function') {
          window.updateGenerateButtonText();
        } else if (aiAssistGenerateBtn) {
          const nameInput = document.getElementById('aiAssistNameInput');
          if (nameInput) {
            const dishName = nameInput.value?.trim() || 'recipe';
            aiAssistGenerateBtn.textContent = ` Generate generic ${dishName} recipe`;
          }
        }
        // Re-bind the Save to Dish button every time we show the panel
        // This ensures the handler is attached even if the button was recreated
        const applyBtn = document.getElementById('aiAssistApplyBtn');
        console.log('toggleAiAssistBackdrop: Re-binding Save to Dish button:', applyBtn);
        if (applyBtn) {
          // Remove any existing listeners by cloning the button
          const newApplyBtn = applyBtn.cloneNode(true);
          applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
          newApplyBtn.addEventListener('click', () => {
            console.log('Save to Dish button clicked!');
            applyAiIngredientsToOverlay();
          });
          aiAssistApplyBtn = newApplyBtn;
        } else {
          console.error('toggleAiAssistBackdrop: aiAssistApplyBtn not found!');
        }

        aiAssistBackdrop.classList.add('show');
        aiAssistBackdrop.setAttribute('aria-hidden', 'false');
        // Mobile-safe scroll lock: store position and fix body
        scrollLockPosition = window.pageYOffset || document.documentElement.scrollTop;
        document.body.style.position = 'fixed';
        document.body.style.top = `-${scrollLockPosition}px`;
        document.body.style.width = '100%';
        document.body.style.overflow = 'hidden';
      } else {
        aiAssistBackdrop.classList.remove('show');
        aiAssistBackdrop.setAttribute('aria-hidden', 'true');
        // Restore scroll position and body styles
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.style.overflow = '';
        window.scrollTo(0, scrollLockPosition);
      }
    }

    function updateAiAssistMediaPreview() {
      ensureAiAssistElements();
      const hasImage = !!aiAssistState.imageData;
      const hasStream = !!aiAssistState.mediaStream;
      if (aiAssistMediaPreview) {
        aiAssistMediaPreview.classList.toggle('show', hasImage || hasStream);
      }
      if (aiAssistVideo) {
        if (hasStream) {
          aiAssistVideo.classList.remove('aiAssistHidden');
          if (aiAssistVideo.srcObject !== aiAssistState.mediaStream) {
            aiAssistVideo.srcObject = aiAssistState.mediaStream;
          }
          aiAssistVideo.play().catch(() => { });
        } else {
          try { aiAssistVideo.pause(); } catch (_) { }
          aiAssistVideo.srcObject = null;
          aiAssistVideo.classList.add('aiAssistHidden');
        }
      }
      if (aiAssistCaptureBtn) {
        aiAssistCaptureBtn.classList.toggle('aiAssistHidden', !hasStream);
      }
      if (aiAssistCancelCameraBtn) {
        aiAssistCancelCameraBtn.classList.toggle('aiAssistHidden', !hasStream);
      }
      if (aiAssistImagePreview) {
        if (hasImage) {
          aiAssistImagePreview.src = aiAssistState.imageData;
          aiAssistImagePreview.classList.remove('aiAssistHidden');
        } else {
          aiAssistImagePreview.src = '';
          aiAssistImagePreview.classList.add('aiAssistHidden');
        }
      }
      if (aiAssistClearImageBtn) {
        aiAssistClearImageBtn.classList.toggle('aiAssistHidden', !hasImage);
      }
    }

    function handleAiFileSelection(file) {
      ensureAiAssistElements();
      if (!file) {
        aiAssistSetStatus('No file selected.', 'warn');
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        aiAssistState.imageData = typeof reader.result === 'string' ? reader.result : null;
        aiAssistState.imageFileName = file.name || 'label.jpg';
        stopAiCamera();
        updateAiAssistMediaPreview();
        aiAssistSetStatus('Label photo attached. Review before processing.', 'info');
      };
      reader.onerror = () => {
        aiAssistSetStatus('Could not read the selected image.', 'warn');
      };
      reader.readAsDataURL(file);
    }

    async function startAiCamera() {
      ensureAiAssistElements();
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        aiAssistSetStatus('Camera capture is not supported in this browser.', 'warn');
        return;
      }
      try {
        if (aiAssistState.mediaStream) {
          stopAiCamera();
        }
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        aiAssistState.mediaStream = stream;
        aiAssistState.imageData = null;
        aiAssistState.imageFileName = null;
        updateAiAssistMediaPreview();
        aiAssistSetStatus('Camera ready. Capture the label when it looks clear.', 'info');
      } catch (err) {
        console.error('Camera error', err);
        aiAssistSetStatus('Could not access the camera: ' + (err.message || err), 'warn');
      }
    }

    function stopAiCamera(notify) {
      ensureAiAssistElements();
      if (aiAssistState.mediaStream) {
        try { aiAssistState.mediaStream.getTracks().forEach(track => track.stop()); } catch (_) { }
      }
      aiAssistState.mediaStream = null;
      if (aiAssistVideo) {
        try { aiAssistVideo.pause(); } catch (_) { }
        aiAssistVideo.srcObject = null;
      }
      updateAiAssistMediaPreview();
      if (notify) {
        aiAssistSetStatus('Camera closed.', 'info');
      }
    }

    async function captureAiPhoto() {
      ensureAiAssistElements();
      if (!aiAssistVideo || !aiAssistState.mediaStream) {
        aiAssistSetStatus('Start the camera before capturing a photo.', 'warn');
        return;
      }
      const width = aiAssistVideo.videoWidth || 1280;
      const height = aiAssistVideo.videoHeight || 720;
      if (!width || !height) {
        aiAssistSetStatus('Camera is still focusing. Try capturing again in a moment.', 'warn');
        return;
      }
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        aiAssistSetStatus('Could not capture the photo.', 'warn');
        return;
      }
      ctx.drawImage(aiAssistVideo, 0, 0, width, height);
      const rawImage = canvas.toDataURL('image/jpeg', 0.92);

      // Compress the captured photo
      const compressed = await compressImage(rawImage);

      // Add to photos array for multi-photo workflow
      if (!window.aiAssistPhotos) window.aiAssistPhotos = [];
      window.aiAssistPhotos.push(compressed);

      stopAiCamera();
      renderPhotoPreviews();
      aiAssistSetStatus('Photo captured. Review before processing.', 'success');
    }

    function clearAiImage() {
      ensureAiAssistElements();
      aiAssistState.imageData = null;
      aiAssistState.imageFileName = null;
      if (aiAssistFileInput) {
        aiAssistFileInput.value = '';
      }
      updateAiAssistMediaPreview();
      aiAssistSetStatus('Label image cleared.', 'info');
    }

    function getRowIngredientsList(rowElement) {
      if (!rowElement || !rowElement.dataset.ingredientsList) return [];
      try {
        const parsed = JSON.parse(rowElement.dataset.ingredientsList);
        return Array.isArray(parsed) ? parsed : [];
      } catch (_) {
        return [];
      }
    }

    function updateAiBrandPreview(rowElement) {
      if (!rowElement) return;
      const brandPreview = rowElement.querySelector('.aiBrandPreview');
      if (brandPreview) {
        const parts = [];
        const brandImage = rowElement.dataset.brandImage || '';
        // Only show brandImage (product front photo) in thumbnail, not ingredientsImage
        if (brandImage) parts.push(`<img src="${esc(brandImage)}" alt="Brand preview" loading="lazy" onclick="openImageModal('${esc(brandImage)}')" title="Click to enlarge">`);
        brandPreview.innerHTML = parts.join('');
      }
      const listNote = rowElement.querySelector('.aiIngredientList');
      if (listNote) {
        const list = getRowIngredientsList(rowElement);
        listNote.textContent = list.length ? `Label ingredients: ${list.join(', ')}` : '';
      }
    }

    function collectAiTableData() {
      ensureAiAssistElements();
      if (!aiAssistTableBody) return [];
      const data = [];
      aiAssistTableBody.querySelectorAll('tr').forEach(row => {
        const idx = Number(row.dataset.index || '0');
        const name = row.querySelector('.aiIngredientName')?.value.trim() || '';
        const allergens = [...row.querySelectorAll('.aiAllergenChecklist input:checked')].map(input => input.value);
        const diets = [...row.querySelectorAll('.aiDietChecklist input:checked')].map(input => input.value);
        const confirmed = row.querySelector('.aiConfirmBtn')?.dataset.confirmed === 'true';

        // Collect removable status from checkbox (unchecked by default = not substitutable)
        const removableCheckbox = row.querySelector('.aiRemovableCheckbox');
        const removable = removableCheckbox?.checked || false;

        console.log(`collectAiTableData row ${idx} (${name}): removable=${removable}, removableCheckbox=`, removableCheckbox, 'checked=', removableCheckbox?.checked);

        // Collect multiple brands
        const brands = [];
        if (row.dataset.brands) {
          try {
            const parsed = JSON.parse(row.dataset.brands);
            console.log(`Row ${idx} brands from dataset:`, parsed);
            brands.push(...parsed);
          } catch (e) {
            console.error(`Failed to parse brands for row ${idx}:`, e);
          }
        }

        // Preserve AI-detected allergens and diets (originally detected by AI from recipe)
        const aiDetectedAllergens = row.dataset.aiDetectedAllergens ? JSON.parse(row.dataset.aiDetectedAllergens) : [];
        const aiDetectedDiets = row.dataset.aiDetectedDiets ? JSON.parse(row.dataset.aiDetectedDiets) : [];

        // Preserve needsScan and userOverriddenScan fields
        const needsScan = row.dataset.needsScan === 'true' || row.dataset.needsScan === true;
        const userOverriddenScan = row.dataset.userOverriddenScan === 'true' || row.dataset.userOverriddenScan === true;
        const appealReviewStatus = row.dataset.appealReviewStatus || null;
        const appealReviewNotes = row.dataset.appealReviewNotes || null;
        const scanDecisionSource = row.dataset.scanDecisionSource || null;
        const analysisPending = row.dataset.analysisPending === 'true';
        const analysisMessage = row.dataset.analysisMessage || '';
        const requiresApply = row.dataset.requiresApply === 'true';
        const issueReported = row.dataset.issueReported === 'true';
        console.log(`COLLECT row ${idx}: dataset.needsScan="${row.dataset.needsScan}", dataset.userOverriddenScan="${row.dataset.userOverriddenScan}" -> boolean needsScan=${needsScan}, userOverriddenScan=${userOverriddenScan}`);

        // IMPORTANT: Merge brand allergens/diets into the collected allergens/diets
        // This ensures that brand allergens are always included even if checkboxes weren't checked yet

        // Helper function to normalize allergen using aliases
        const normalizeAllergen = (allergen) => {
          const lower = allergen.toLowerCase().trim();
          // Check if it's in the aliases map
          if (ALLERGEN_ALIASES[lower]) {
            return ALLERGEN_ALIASES[lower];
          }
          // Check if it's already a standard allergen
          if (ALLERGENS.includes(lower)) {
            return lower;
          }
          return lower;
        };

        // Helper function to normalize diet casing
        const normalizeDiet = (diet) => {
          const lower = diet.toLowerCase().trim();
          // Find the properly-cased version from DIETS constant
          const properDiet = DIETS.find(d => d.toLowerCase() === lower);
          return properDiet || diet;
        };

        // Get all checkbox states (both checked and unchecked) to track user overrides
        const allCheckboxStates = {
          allergens: new Map(),
          diets: new Map()
        };
        row.querySelectorAll('.aiAllergenChecklist input').forEach(input => {
          allCheckboxStates.allergens.set(normalizeAllergen(input.value), input.checked);
        });
        row.querySelectorAll('.aiDietChecklist input').forEach(input => {
          allCheckboxStates.diets.set(normalizeDiet(input.value), input.checked);
        });

        const allAllergens = new Set(allergens.map(a => normalizeAllergen(a)));
        const allDiets = new Set(diets.map(d => normalizeDiet(d)));

        // Merge brand allergens/diets, but ONLY if user hasn't explicitly unchecked them
        brands.forEach(brand => {
          if (Array.isArray(brand.allergens)) {
            brand.allergens.forEach(a => {
              const normalized = normalizeAllergen(a);
              // Only add if user hasn't explicitly unchecked it
              const checkboxState = allCheckboxStates.allergens.get(normalized);
              if (checkboxState !== false) {
                allAllergens.add(normalized);
                console.log(`Brand allergen: "${a}" -> normalized: "${normalized}" (added because not explicitly unchecked)`);
              } else {
                console.log(`Brand allergen: "${a}" -> normalized: "${normalized}" (skipped - user explicitly unchecked)`);
              }
            });
          }
          if (Array.isArray(brand.diets)) {
            brand.diets.forEach(d => {
              const normalized = normalizeDiet(d);
              // Only add if user hasn't explicitly unchecked it
              const checkboxState = allCheckboxStates.diets.get(normalized);
              if (checkboxState !== false) {
                allDiets.add(normalized);
                console.log(`Brand diet: "${d}" -> normalized: "${normalized}" (added because not explicitly unchecked)`);
              } else {
                console.log(`Brand diet: "${d}" -> normalized: "${normalized}" (skipped - user explicitly unchecked)`);
              }
            });
          }
        });

        // Convert back to arrays (allergens are already normalized to standard names)
        const mergedAllergens = Array.from(allAllergens);
        const mergedDiets = Array.from(allDiets);

        console.log(`Row ${idx} merged allergens:`, mergedAllergens, 'merged diets:', mergedDiets);

        const entry = { index: idx, name, allergens: mergedAllergens, diets: mergedDiets, brands, confirmed, removable, aiDetectedAllergens, aiDetectedDiets, needsScan, userOverriddenScan, appealReviewStatus, appealReviewNotes, scanDecisionSource, analysisPending, analysisMessage, requiresApply, issueReported };
        enforceDietAllergenConsistency(entry);
        data.push(entry);
      });
      console.log('collectAiTableData final data:', data);
      return data;
    }

    // Make collectAiTableData globally accessible for auto-fill
    window.collectAiTableData = collectAiTableData;

    function resetConfirmButton(rowElement) {
      if (!rowElement) return;
      const btn = rowElement.querySelector('.aiConfirmBtn');
      if (!btn) return;

      const wasConfirmed = btn.dataset.confirmed === 'true';
      if (!wasConfirmed) return; // Already unconfirmed, no need to reset

      // Reset to unconfirmed state
      btn.dataset.confirmed = 'false';
      btn.classList.remove('confirmed');
      btn.classList.add('unconfirmed');
      btn.style.background = '#f59e0b';
      btn.style.borderColor = '#f59e0b';
      btn.textContent = 'Confirm';
    }

    function updateAiPreview() {
      const previewBox = document.getElementById('aiAssistPreviewBox');
      if (!previewBox) return;

      const rows = collectAiTableData();
      if (!rows || rows.length === 0) {
        previewBox.innerHTML = '<div style="color:#8891b0;font-style:italic">Add ingredients to see preview</div>';
        return;
      }

      // Build a temporary overlay object from the AI table data
      const tempOverlay = {
        id: document.getElementById('aiAssistNameInput')?.value || 'Dish Name',
        allergens: [],
        diets: [],
        details: {},
        removable: [],
        crossContamination: [],
        ingredientsBlockingDiets: {}
      };

      // Aggregate allergens from all ingredients (OR logic - any ingredient with allergen adds it to dish)
      const allergenDetails = {};
      rows.forEach(row => {
        if (Array.isArray(row.allergens)) {
          row.allergens.forEach(allergen => {
            const key = norm(allergen);
            if (key && !tempOverlay.allergens.includes(key)) {
              tempOverlay.allergens.push(key);
            }
            // Add ingredient detail
            const ingredientLabel = row.name || '';
            const brandLabel = (row.brands && row.brands.length > 0) ? row.brands[0].name : '';
            const fullLabel = brandLabel ? `${ingredientLabel} (${brandLabel})` : ingredientLabel;
            if (fullLabel) {
              if (!allergenDetails[key]) allergenDetails[key] = [];
              if (!allergenDetails[key].includes(fullLabel)) {
                allergenDetails[key].push(fullLabel);
              }
            }

            // Track removable allergens
            if (row.removable === true) {
              const detail = allergenDetails[key] && allergenDetails[key].length > 0 ?
                allergenDetails[key].join(', ') : key;
              // Only add if not already in the removable array
              if (!tempOverlay.removable.some(r => r.allergen === key)) {
                tempOverlay.removable.push({ allergen: key, component: detail });
              }
            }
          });
        }
      });

      // For dietary preferences, use AND logic - dish is only vegan if ALL ingredients are vegan
      // Start with all possible diets, then remove any that aren't supported by ALL ingredients
      let dishDiets = new Set(['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free']);

      // Track which ingredients block each diet and whether they're removable
      const ingredientsBlockingDiets = {
        'Vegan': [],
        'Vegetarian': [],
        'Pescatarian': [],
        'Gluten-free': []
      };

      rows.forEach(row => {
        const ingredientDiets = new Set(row.diets || []);
        const hasGlutenAllergen = Array.isArray(row.allergens) && row.allergens.some(al => {
          const key = norm(al);
          return key === 'wheat' || key === 'gluten';
        });
        if (!hasGlutenAllergen) {
          ingredientDiets.add('Gluten-free');
        }
        const isIngredientRemovable = row.removable === true;
        const ingredientName = row.name || '';

        // Track which diets this ingredient blocks
        dishDiets.forEach(diet => {
          if (!ingredientDiets.has(diet)) {
            // This ingredient doesn't support this diet - track it
            if (!ingredientsBlockingDiets[diet]) {
              ingredientsBlockingDiets[diet] = [];
            }
            ingredientsBlockingDiets[diet].push({
              name: ingredientName,
              removable: isIngredientRemovable
            });
          }
        });
      });

      // Validate dietary preferences against allergens AND blocking ingredients
      // Build set of removable allergens for quick lookup
      const removableAllergenSet = new Set(tempOverlay.removable.map(r => norm(r.allergen)));

      const allergenConflicts = {
        'Vegan': ['dairy', 'egg', 'fish', 'shellfish'],
        'Vegetarian': ['fish', 'shellfish'],
        'Pescatarian': [],
        'Gluten-free': ['wheat']
      };

      dishDiets.forEach(diet => {
        const conflicts = allergenConflicts[diet] || [];
        const conflictingAllergens = conflicts.filter(allergen => {
          const normalizedAllergen = norm(allergen);
          return tempOverlay.allergens.some(a => norm(a) === normalizedAllergen);
        });

        // Check if ALL blocking ingredients are removable
        const blockingIngredients = ingredientsBlockingDiets[diet] || [];
        const allBlockingIngredientsRemovable = blockingIngredients.length > 0 &&
          blockingIngredients.every(ing => ing.removable);

        // Check if ALL conflicting allergens are removable
        const allConflictingAllergensRemovable = conflictingAllergens.length > 0 &&
          conflictingAllergens.every(allergen => removableAllergenSet.has(norm(allergen)));

        // Only keep diet if:
        // 1. There are NO blocking ingredients AND no conflicting allergens, OR
        // 2. ALL blocking ingredients are removable AND all conflicting allergens are removable
        const hasBlockers = blockingIngredients.length > 0 || conflictingAllergens.length > 0;
        const allBlockersRemovable =
          (blockingIngredients.length === 0 || allBlockingIngredientsRemovable) &&
          (conflictingAllergens.length === 0 || allConflictingAllergensRemovable);

        if (hasBlockers && !allBlockersRemovable) {
          dishDiets.delete(diet);
        }
      });

      // Store information about which ingredients block diets for use in preview
      tempOverlay.diets = Array.from(dishDiets);
      tempOverlay.ingredientsBlockingDiets = ingredientsBlockingDiets;

      // Add details text
      Object.keys(allergenDetails).forEach(key => {
        const items = allergenDetails[key];
        if (items.length > 0) {
          tempOverlay.details[key] = `Contains ${items.join(', ')}`;
        }
      });

      // Collect cross-contamination data from checkboxes
      const noCrossCheckbox = document.getElementById('aiAssistNoCrossContamination');
      const crossAllergenCheckboxes = document.querySelectorAll('.aiCrossAllergenCheckbox');

      if (noCrossCheckbox && noCrossCheckbox.checked) {
        tempOverlay.crossContamination = [];
        tempOverlay.noCrossContamination = true;
      } else {
        const selectedCrossAllergens = [];
        crossAllergenCheckboxes.forEach(cb => {
          if (cb.checked) {
            selectedCrossAllergens.push(cb.dataset.allergen);
          }
        });
        tempOverlay.crossContamination = selectedCrossAllergens;
        tempOverlay.noCrossContamination = false;
      }

      // Use the same tooltip HTML generator that's used for the actual overlays
      const allAllergens = ALLERGENS.slice();
      const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];
      let html = tooltipBodyHTML(tempOverlay, allAllergens, allDiets, true);

      // Note: Cross-contamination information is already included in tooltipBodyHTML,
      // so we don't need to add it again here

      previewBox.innerHTML = html || '<div style="color:#8891b0;font-style:italic">No preview available</div>';
    }

    function renderAiTable(rows) {
      ensureAiAssistElements();
      if (!aiAssistTableBody || !aiAssistResultsEl) return;
      const source = Array.isArray(rows) ? rows : collectAiTableData();
      const data = source.map(item => {
        const copy = { ...item };
        copy.aiDetectionCompleted = copy.aiDetectionCompleted === true;

        if (copy.aiDetectedAllergens === undefined) {
          copy.aiDetectedAllergens = Array.isArray(copy.allergens) ? copy.allergens.slice() : [];
        } else if (Array.isArray(copy.aiDetectedAllergens)) {
          copy.aiDetectedAllergens = copy.aiDetectedAllergens.slice();
        } else {
          copy.aiDetectedAllergens = [];
        }

        if (copy.aiDetectedDiets === undefined) {
          copy.aiDetectedDiets = Array.isArray(copy.diets) ? copy.diets.slice() : [];
        } else if (Array.isArray(copy.aiDetectedDiets)) {
          copy.aiDetectedDiets = copy.aiDetectedDiets.slice();
        } else {
          copy.aiDetectedDiets = [];
        }

        enforceDietAllergenConsistency(copy);
        return copy;
      });
      console.log('renderAiTable called with rows:', rows && rows.length ? rows.map(r => ({ name: r.name, needsScan: r.needsScan, userOverriddenScan: r.userOverriddenScan })) : 'no rows');

      // Preserve loading states and barcode results before clearing
      const loadingStates = {};
      const existingRows = aiAssistTableBody.querySelectorAll('tr');
      existingRows.forEach((tr, idx) => {
        const loadingArea = tr.querySelector('.barcodeLoadingArea');
        if (loadingArea) {
          loadingStates[idx] = {
            html: loadingArea.outerHTML,
            rowIdx: idx
          };
        }
      });

      aiAssistTableBody.innerHTML = '';
      aiAssistState.brandSuggestions = {};
      data.forEach((row, idx) => {
        // Initialize brands array if not present
        if (!row.brands) {
          row.brands = [];
        }

        // NOTE: We NO LONGER load brands from memory here during render.
        // Brands from memory are only loaded when:
        // 1. AI returns initial results (in handleAiAssistantResult)
        // 2. User opens a saved draft
        // This prevents the infinite loop where deleting a brand causes it to reload from memory.
        // The memory is now purely for auto-populating NEW ingredients, not re-populating deleted brands.

        const tr = document.createElement('tr');
        tr.dataset.index = idx;
        const allergens = new Set((row.allergens || []).map(norm));

        // Support multiple brands - store in dataset
        const brands = row.brands || [];
        if (brands.length > 0) {
          tr.dataset.brands = JSON.stringify(brands);
        } else {
          delete tr.dataset.brands;
        }

        // Store AI-detected allergens/diets from base ingredient (if this is first render from AI)
        // If row doesn't have aiDetectedAllergens, it means this is the first time rendering from AI results
        // so the current allergens/diets ARE the AI-detected ones
        const baseAiDetectedAllergens = row.aiDetectedAllergens || row.allergens || [];
        const baseAiDetectedDiets = row.aiDetectedDiets || row.diets || [];

        // Store in dataset so we can preserve them across re-renders
        tr.dataset.aiDetectedAllergens = JSON.stringify(baseAiDetectedAllergens);
        tr.dataset.aiDetectedDiets = JSON.stringify(baseAiDetectedDiets);

        // Preserve needsScan and userOverriddenScan in dataset
        if (row.needsScan !== undefined) {
          tr.dataset.needsScan = String(row.needsScan);
        }
        if (row.userOverriddenScan !== undefined) {
          tr.dataset.userOverriddenScan = String(row.userOverriddenScan);
        }
        if (row.scanDecisionSource) {
          tr.dataset.scanDecisionSource = row.scanDecisionSource;
        } else {
          delete tr.dataset.scanDecisionSource;
        }
        if (row.analysisPending) {
          tr.dataset.analysisPending = 'true';
        } else {
          delete tr.dataset.analysisPending;
        }
        if (row.analysisMessage) {
          tr.dataset.analysisMessage = row.analysisMessage;
        } else {
          delete tr.dataset.analysisMessage;
        }
        // Preserve appeal review status and notes
        if (row.appealReviewStatus) {
          tr.dataset.appealReviewStatus = row.appealReviewStatus;
        }
        if (row.appealReviewNotes) {
          tr.dataset.appealReviewNotes = row.appealReviewNotes;
        }
        if (row.dietAllergenConflicts && row.dietAllergenConflicts.length) {
          tr.dataset.dietConflicts = JSON.stringify(row.dietAllergenConflicts);
        } else {
          delete tr.dataset.dietConflicts;
        }
        const requiresApply = row.requiresApply === true;
        if (requiresApply) {
          tr.dataset.requiresApply = 'true';
        } else {
          delete tr.dataset.requiresApply;
        }
        if (row.issueReported) {
          tr.dataset.issueReported = 'true';
        } else {
          delete tr.dataset.issueReported;
        }
        if (row.aiDetectionCompleted === true) {
          tr.dataset.aiDetectionCompleted = 'true';
        } else {
          delete tr.dataset.aiDetectionCompleted;
        }
        const disableSelections = requiresApply;
        const detectionCompleted = row.aiDetectionCompleted === true;

        // Helper function to normalize allergen using aliases (same as in collectAiTableData)
        const normalizeAllergen = (allergen) => {
          const lower = allergen.toLowerCase().trim();
          // Check if it's in the aliases map (e.g., "tree nuts" -> "tree nut")
          if (ALLERGEN_ALIASES[lower]) {
            return ALLERGEN_ALIASES[lower];
          }
          // Check if it's already a standard allergen
          if (ALLERGENS.includes(lower)) {
            return lower;
          }
          return lower;
        };

        // Helper function to normalize diet casing
        const normalizeDiet = (diet) => {
          const lower = diet.toLowerCase().trim();
          // Find the properly-cased version from DIETS constant
          const properDiet = DIETS.find(d => d.toLowerCase() === lower);
          return properDiet || diet;
        };

        // Collect AI-detected allergens and diets from base ingredient AND brand labels
        const aiDetectedAllergens = new Set(baseAiDetectedAllergens.map(normalizeAllergen));
        const aiDetectedDiets = new Set(baseAiDetectedDiets.map(normalizeDiet));

        // Add allergens and diets from brand labels (with normalization)
        brands.forEach(brand => {
          console.log('Brand data:', brand);
          if (Array.isArray(brand.allergens)) {
            brand.allergens.forEach(a => {
              const normalized = normalizeAllergen(a);
              console.log('Adding allergen to aiDetected:', a, '=> normalized:', normalized);
              aiDetectedAllergens.add(normalized);
            });
          }
          if (Array.isArray(brand.diets)) {
            brand.diets.forEach(d => {
              const normalized = normalizeDiet(d);
              console.log('Adding diet to aiDetected:', d, '=> normalized:', normalized);
              aiDetectedDiets.add(normalized);
            });
          }
        });
        console.log('aiDetectedAllergens:', Array.from(aiDetectedAllergens));
        console.log('aiDetectedDiets:', Array.from(aiDetectedDiets));

        const brandsHTML = brands.length > 0 ? brands.map((brand, brandIdx) => {
          console.log(`Rendering brand ${brandIdx}:`, brand);
          console.log(`  - brandImage: ${brand.brandImage}`);
          console.log(`  - ingredientsImage: ${brand.ingredientsImage}`);
          console.log(`  - ingredientsList: ${brand.ingredientsList ? brand.ingredientsList.length : 0} items`);

          const brandImages = [];
          const seenImageUrls = new Set(); // Track unique image URLs to avoid duplicates

          console.log(`  - Checking brand.brandImage: "${brand.brandImage}", truthy: ${!!brand.brandImage}, type: ${typeof brand.brandImage}`);
          console.log(`  - Checking brand.ingredientsImage: "${brand.ingredientsImage}", truthy: ${!!brand.ingredientsImage}, type: ${typeof brand.ingredientsImage}`);

          // Only show brandImage (product front photo) in thumbnail, not ingredientsImage
          if (brand.brandImage) {
            const imgTag = `<img src="${esc(brand.brandImage)}" alt="${esc(brand.name || 'Brand')}" loading="lazy" onclick="openImageModal('${esc(brand.brandImage)}')" title="Click to enlarge">`;
            console.log(`  - Adding brandImage tag (length: ${imgTag.length})`);
            brandImages.push(imgTag);
            seenImageUrls.add(brand.brandImage); // Track this URL
          } else {
            console.log(`  - SKIPPED brandImage (falsy value)`);
          }

          // Don't show ingredientsImage in thumbnail - only brandImage (product front photo)
          // The ingredientsImage is still stored and can be viewed in the modal/details view
          const ingredientsNote = brand.ingredientsList && brand.ingredientsList.length ? `Label ingredients: ${brand.ingredientsList.map(i => esc(i)).join(', ')}` : '';

          // Show message if no images are available
          const imagesDisplay = brandImages.length > 0 ? brandImages.join('') : '<div style="color:var(--muted);font-size:0.85rem;font-style:italic">No product images available</div>';
          console.log(`  - Final imagesDisplay length: ${imagesDisplay.length}, brandImages count: ${brandImages.length}`);
          console.log(`  - imagesDisplay HTML: ${imagesDisplay.substring(0, 200)}...`);

          const brandItemHTML = `
        <div class="aiBrandItem" data-brand-idx="${brandIdx}">
          <div class="aiBrandItemHeader">
            <strong>${esc(brand.name || 'Brand ' + (brandIdx + 1))}</strong>
            <button type="button" class="btn btnSmall aiRemoveBrand" data-brand-idx="${brandIdx}"></button>
          </div>
          <div class="aiBrandPreview">${imagesDisplay}</div>
          ${ingredientsNote ? `<div class="aiIngredientList">${ingredientsNote}</div>` : '<div style="color:var(--muted);font-size:0.85rem;font-style:italic">No ingredient list available</div>'}
        </div>
      `;
          console.log(`  - Brand item HTML length: ${brandItemHTML.length}`);
          return brandItemHTML;
        }).join('') : '';

        console.log(`Total brandsHTML length: ${brandsHTML.length}`);

        // If appeal was rejected and scan is required, force unconfirmed state
        // This ensures managers must scan again after a denied appeal
        let isConfirmed = row.confirmed || false;

        // Normalize needsScan to boolean for consistent comparison
        const needsScan = row.needsScan === true || row.needsScan === 'true';
        const needsScanDefined = row.needsScan !== undefined && row.needsScan !== null;
        const userOverriddenScan = row.userOverriddenScan === true || row.userOverriddenScan === 'true';
        const issueReported = row.issueReported === true || row.issueReported === 'true';

        console.log(`DEBUG CONFIRM: row.confirmed=${row.confirmed}, appealReviewStatus="${row.appealReviewStatus}", needsScan=${row.needsScan}->${needsScan}, brands.length=${brands.length}`);
        if (row.appealReviewStatus === 'rejected' && needsScan && brands.length === 0) {
          isConfirmed = false;
          console.log(`FORCE UNCONFIRMED: Appeal rejected, needsScan=${needsScan}, brands.length=${brands.length}`);
        }
        // Only show scan recommendation if AI recommended it AND user hasn't overridden it AND no issue reported
        const showScanRecommendation = needsScan && !userOverriddenScan && !issueReported;
        // Check if scan requirement is satisfied (either scan completed, appealed/overridden, or issue reported)
        const hasBrandsOrOverridden = brands.length > 0 || userOverriddenScan || issueReported;
        const scanRequirementSatisfied = !needsScan || hasBrandsOrOverridden;
        // Disable confirm button if scan is required but not completed
        const canConfirm = scanRequirementSatisfied;

        // Use allergens/diets from collected data (which already includes merged brands respecting unchecked checkboxes)
        // Don't merge brands again here - collectAiTableData already did that
        const allAllergens = new Set((row.allergens || []).map(normalizeAllergen));
        const allDiets = new Set((row.diets || []).map(normalizeDiet));

        // Check if there's a remembered brand for this ingredient
        // Only show it if it hasn't already been added to the brands array
        const rememberedBrand = getRememberedBrand(row.name);
        const brandAlreadyAdded = rememberedBrand && rememberedBrand.brand && brands.some(b => b.name === rememberedBrand.brand);
        const rememberBrandHTML = rememberedBrand && rememberedBrand.brand && !brandAlreadyAdded ? `
      <div class="aiRememberedBrand" data-row-idx="${idx}" style="margin-top:8px;margin-bottom:12px;display:flex;align-items:start;gap:8px;padding:8px;background:rgba(76,175,80,0.05);border-radius:6px;border:1px dashed #4caf50">
        <div style="position:relative;flex-shrink:0">
          ${rememberedBrand.brandImage ?
            `<img src="${esc(rememberedBrand.brandImage)}" alt="${esc(rememberedBrand.brand)}" style="width:60px;height:60px;object-fit:contain;border-radius:4px;background:white">` :
            `<div style="width:60px;height:60px;background:#f0f0f0;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:0.7rem;color:#999;text-align:center">No image</div>`
          }
          <button type="button" class="btn aiAddRememberedBrand" data-row-idx="${idx}" style="position:absolute;top:-6px;right:-6px;width:24px;height:24px;border-radius:50%;background:#4caf50;border:2px solid white;color:white;font-size:1.2rem;font-weight:bold;padding:0;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,0.2)" title="Add this brand">+</button>
        </div>
        <div style="flex:1;min-width:0">
          <div style="font-weight:600;font-size:0.85rem;color:#2c5530">Previously used brand:</div>
          <div style="font-size:0.9rem;color:#333;margin-top:2px">${esc(rememberedBrand.brand)}</div>
          <div style="font-size:0.75rem;color:#888;margin-top:4px;font-style:italic">Tap + to add, then scan for ingredients</div>
        </div>
      </div>
    ` : '';

        const scanDecisionNote = '';
        const selectionGuardMessage = disableSelections
          ? `<div class="aiSelectionGuard" style="margin-top:8px;padding:10px 12px;border:1px dashed rgba(245,158,11,0.6);border-radius:6px;background:rgba(245,158,11,0.12);color:#fbbf24;font-size:0.85rem;">
              Enter the ingredient name and tap Apply before editing allergens or diets.
            </div>`
          : '';

        const rowLoadingClass = row.analysisPending ? ' is-loading' : '';
        const rowLoadingOverlay = row.analysisPending ? `
      <div class="aiRowLoadingOverlay">
        <div class="aiRowLoadingBar">
          <span></span>
        </div>
        <div class="aiRowLoadingText">${esc(row.analysisMessage || 'Analyzing ingredient')}</div>
      </div>
    ` : '';

        tr.innerHTML = `
      <td colspan="7">
        <div class="aiIngredientRowWrapper">
          <div class="aiIngredientRow${rowLoadingClass}">
          <div class="aiIngredientMain">
            <div class="aiIngredientNameCol">
              <div style="position:relative;display:flex;align-items:center">
                <input type="text" class="aiIngredientName" placeholder="Ingredient name" value="${esc((row.name || '').toLowerCase())}" style="line-height:1;vertical-align:top;padding-right:90px">
                <button type="button" class="btn aiIngredientApply" data-row-idx="${idx}" style="position:absolute;right:6px;top:50%;transform:translateY(-50%);padding:6px 12px;font-size:0.85rem">Apply</button>
              </div>
              <div class="aiBrandCell" style="${brands.length === 0 && (showScanRecommendation || (needsScanDefined && needsScan === false && !userOverriddenScan)) ? 'gap:0;align-items:flex-start' : ''}">
                ${brandsHTML ? `<div class="aiBrandsList">${brandsHTML}</div>` : ''}
              ${showScanRecommendation && brands.length === 0 && row.appealReviewStatus !== 'rejected' ? `<div style="background:#f59e0b;border:2px solid #f59e0b;border-radius:6px;padding:8px 12px;margin-bottom:12px;margin-top:0;line-height:1;vertical-align:top;max-width:100%">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap">
                  <div style="display:flex;align-items:center;gap:8px;min-width:0">
                    <span style="font-size:1.2rem"></span>
                    <span style="font-weight:600;color:#fff;font-size:0.85rem;white-space:nowrap">Brand ID required</span>
                  </div>
                  <div style="display:flex;gap:6px;flex-shrink:0">
                    <button type="button" class="btn aiAppealScanBtn" data-row-idx="${idx}" style="background:#dc2626;border-color:#dc2626;padding:6px 10px;font-size:0.8rem;white-space:nowrap">Appeal</button>
                    <button type="button" class="btn aiBrandBarcodeBtn" style="background:#17663a;border-color:#1a7b46;padding:6px 10px;font-size:0.8rem;white-space:nowrap">Add</button>
                  </div>
                </div>
                ${scanDecisionNote}
              </div>` : needsScanDefined && needsScan === false && !userOverriddenScan && brands.length === 0 ? `<div style="background:#6b7280;border:2px solid #6b7280;border-radius:6px;padding:8px 12px;margin-bottom:12px;margin-top:0;line-height:1;vertical-align:top;max-width:100%">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap">
                  <div style="display:flex;align-items:center;gap:8px;min-width:0">
                    <span style="font-size:1rem"></span>
                    <span style="color:#fff;font-weight:500;font-size:0.85rem;white-space:nowrap">Brand ID optional</span>
                  </div>
                  <button type="button" class="btn aiBrandBarcodeBtn" style="background:#17663a;border-color:#1a7b46;padding:6px 10px;font-size:0.8rem;white-space:nowrap">Add</button>
                </div>
                ${scanDecisionNote}
              </div>` : userOverriddenScan && !row.appealReviewStatus ? `<div style="background:#6b7280;border:2px solid #6b7280;border-radius:6px;padding:6px 12px;margin-bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:8px;font-size:0.85rem">
                <div style="display:flex;align-items:center;gap:8px">
                  <span style="font-size:1rem"></span>
                  <span style="color:#fff;font-weight:500">Scan recommendation overridden by manager</span>
                </div>
                <button type="button" class="btn aiRemoveAppealBtn" data-row-idx="${idx}" style="background:#ef4444;border-color:#dc2626;color:#fff;padding:4px 12px;font-size:0.8rem;white-space:nowrap;margin-left:8px">Remove appeal</button>
              </div>` : ''}
              ${issueReported && brands.length === 0 ? `<div style="background:#3b82f6;border:2px solid #3b82f6;border-radius:6px;padding:8px 12px;margin-bottom:12px;margin-top:0;line-height:1.4">
                <div style="display:flex;align-items:center;gap:8px">
                  <span style="font-size:1.2rem"></span>
                  <div style="flex:1">
                    <div style="font-weight:600;color:#fff;font-size:0.9rem">Report sent</div>
                    <div style="color:rgba(255,255,255,0.8);font-size:0.8rem;margin-top:2px">Will be addressed as soon as possible</div>
                  </div>
                </div>
              </div>` : ''}
              ${row.appealReviewStatus ? `
                <div style="background:${row.appealReviewStatus === 'approved' ? '#d1fae5' : '#fee2e2'};border:2px solid ${row.appealReviewStatus === 'approved' ? '#6ee7b7' : '#fca5a5'};border-radius:6px;padding:8px 12px;margin-bottom:12px;font-size:0.85rem">
                  <div style="display:flex;align-items:center;gap:8px;margin-bottom:${row.appealReviewNotes ? '8px' : '0'};">
                    <span style="font-size:1rem">${row.appealReviewStatus === 'approved' ? '' : ''}</span>
                    <span style="color:${row.appealReviewStatus === 'approved' ? '#065f46' : '#991b1b'};font-weight:600">Appeal ${row.appealReviewStatus === 'approved' ? 'approved' : 'denied'}</span>
                  </div>
                  ${row.appealReviewNotes ? `<div style="color:${row.appealReviewStatus === 'approved' ? '#047857' : '#7f1d1d'};font-size:0.8rem;margin-top:4px;font-style:italic">${esc(row.appealReviewNotes)}</div>` : ''}
                </div>
                ${row.appealReviewStatus === 'approved' && brands.length === 0 ? `<div style="background:#6b7280;border:2px solid #6b7280;border-radius:6px;padding:8px 12px;margin-bottom:12px;margin-top:0;line-height:1;vertical-align:top;max-width:100%">
                  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap">
                    <div style="display:flex;align-items:center;gap:8px;min-width:0">
                      <span style="font-size:1rem"></span>
                      <span style="color:#fff;font-weight:500;font-size:0.85rem;white-space:nowrap">Brand ID optional</span>
                    </div>
                    <button type="button" class="btn aiBrandBarcodeBtn" style="background:#17663a;border-color:#1a7b46;padding:6px 10px;font-size:0.8rem;white-space:nowrap">Add</button>
                  </div>
                </div>` : ''}
                ${row.appealReviewStatus === 'rejected' && brands.length === 0 ? `<div style="background:#f59e0b;border:2px solid #f59e0b;border-radius:6px;padding:8px 12px;margin-bottom:12px;margin-top:0;line-height:1;vertical-align:top;max-width:100%">
                  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap">
                    <div style="display:flex;align-items:center;gap:8px;min-width:0">
                      <span style="font-size:1.2rem"></span>
                      <span style="font-weight:600;color:#fff;font-size:0.85rem;white-space:nowrap">Brand ID required</span>
                    </div>
                    <div style="display:flex;gap:6px;flex-shrink:0">
                      <button type="button" class="btn aiAppealScanBtn" data-row-idx="${idx}" style="background:#dc2626;border-color:#dc2626;padding:6px 10px;font-size:0.8rem;white-space:nowrap">Appeal</button>
                      <button type="button" class="btn aiBrandBarcodeBtn" style="background:#17663a;border-color:#1a7b46;padding:6px 10px;font-size:0.8rem;white-space:nowrap">Add</button>
                    </div>
                  </div>
                </div>` : ''}
              ` : ''}
              ${!userOverriddenScan && !row.appealReviewStatus && needsScanDefined === false ? `<div style="background:#9ca3af;border:2px solid #9ca3af;border-radius:6px;padding:6px 12px;margin-bottom:12px;display:flex;align-items:center;gap:8px;font-size:0.85rem">
                <span style="font-size:1rem"></span>
                <span style="color:#fff;font-weight:500">Scan status: Not determined by AI (manual ingredient entry)</span>
              </div>` : ''}
              ${rememberBrandHTML}
              </div>
            </div>
            <div style="display:flex;flex-direction:column;gap:12px">
              <div style="display:flex;gap:20px;margin-top:0">
                <div style="flex:1">
                  <div class="aiAllergenChecklist">
                    ${ALLERGENS.map(allergen => {
          const allergenNorm = norm(allergen);
          const checked = allAllergens.has(allergenNorm) ? 'checked' : '';
          const aiDetectedClass = aiDetectedAllergens.has(allergenNorm) ? 'aiDetected' : '';
          const aiWasSelected = aiDetectedAllergens.has(allergenNorm);
          const currentlySelected = allAllergens.has(allergenNorm);
          // Treat any AI suggestion (allergen or diet) as proof that AI ran,
          // so manual allergen overrides remain highlighted even if AI found zero allergens.
          const hasAiDetections = (aiDetectedAllergens.size + aiDetectedDiets.size) > 0;
          const manuallyOverridden = hasAiDetections && aiWasSelected !== currentlySelected;
          const overrideClass = manuallyOverridden ? 'manuallyOverridden' : '';
          const overrideReason = aiWasSelected && !currentlySelected
            ? 'Removed AI selection'
            : (!aiWasSelected && currentlySelected ? 'Added manual selection' : '');
          const tooltipParts = [];
          if (aiDetectedClass) {
            tooltipParts.push('Suggested by AI');
          } else if (manuallyOverridden && overrideReason) {
            tooltipParts.push(overrideReason);
          } else if (manuallyOverridden) {
            tooltipParts.push('Manually overridden');
          }
          if (disableSelections) {
            tooltipParts.push('Enter ingredient name and tap Apply first');
          }
          const tooltipAttr = tooltipParts.length ? `title="${tooltipParts.join('  ')}"` : '';
          const disabledAttr = disableSelections ? 'disabled' : '';
          const disabledClass = disableSelections ? ' selectionsDisabled' : '';
          console.log(`Allergen ${allergen}: aiDetected="${aiDetectedClass}", checked="${checked}", manuallyOverridden="${manuallyOverridden}"`);
          return `<label class="${aiDetectedClass} ${overrideClass}${disabledClass}" ${tooltipAttr}><input type="checkbox" class="aiAllergenCheckbox" value="${esc(allergen)}" data-ai-detected="${aiWasSelected}" ${checked} ${disabledAttr}>${esc(cap(allergen))}</label>`;
        }).join('')}
                  </div>
                </div>
                <div style="flex:1">
                  <div class="aiDietChecklist">
                    ${DIETS.map(diet => {
          const checked = allDiets.has(diet) ? 'checked' : '';
          const aiDetectedClass = aiDetectedDiets.has(diet) ? 'aiDetected' : '';
          const aiWasSelected = aiDetectedDiets.has(diet);
          const currentlySelected = allDiets.has(diet);
          // Likewise, highlight diet overrides if AI detected anything in either category.
          const hasAiDetections = (aiDetectedDiets.size + aiDetectedAllergens.size) > 0;
          const manuallyOverridden = hasAiDetections && aiWasSelected !== currentlySelected;
          const overrideClass = manuallyOverridden ? 'manuallyOverridden' : '';
          const overrideReason = aiWasSelected && !currentlySelected
            ? 'Removed AI selection'
            : (!aiWasSelected && currentlySelected ? 'Added manual selection' : '');
          const tooltipParts = [];
          if (aiDetectedClass) {
            tooltipParts.push('Suggested by AI');
          } else if (manuallyOverridden && overrideReason) {
            tooltipParts.push(overrideReason);
          } else if (manuallyOverridden) {
            tooltipParts.push('Manually overridden');
          }
          if (disableSelections) {
            tooltipParts.push('Enter ingredient name and tap Apply first');
          }
          const tooltipAttr = tooltipParts.length ? `title="${tooltipParts.join('  ')}"` : '';
          const disabledAttr = disableSelections ? 'disabled' : '';
          const disabledClass = disableSelections ? ' selectionsDisabled' : '';
          console.log(`Diet ${diet}: aiDetected="${aiDetectedClass}", checked="${checked}", manuallyOverridden="${manuallyOverridden}"`);
          return `<label class="${aiDetectedClass} ${overrideClass}${disabledClass}" ${tooltipAttr}><input type="checkbox" class="aiDietCheckbox" value="${esc(diet)}" data-ai-detected="${aiWasSelected}" ${checked} ${disabledAttr}>${esc(diet)}</label>`;
        }).join('')}
                  </div>
                </div>
              </div>
              ${selectionGuardMessage}
              ${(() => {
            // Check for manual overrides and build message - show UNDER the checkboxes
            // Only show message if there were AI detections to override
            const hasAiDetections = aiDetectedAllergens.size > 0 || aiDetectedDiets.size > 0;
            if (!hasAiDetections) return '';

            const overriddenItems = [];

            ALLERGENS.forEach(allergen => {
              const allergenNorm = norm(allergen);
              const aiWasSelected = aiDetectedAllergens.has(allergenNorm);
              const currentlySelected = allAllergens.has(allergenNorm);
              // Check for overrides if AI detected anything (allergens or diets)
              // This ensures manual allergen additions are detected even if AI only detected diets
              if (aiWasSelected && !currentlySelected) {
                overriddenItems.push(`${cap(allergen)} (removed)`);
              } else if (!aiWasSelected && currentlySelected) {
                overriddenItems.push(`${cap(allergen)} (added)`);
              }
            });
            DIETS.forEach(diet => {
              const aiWasSelected = aiDetectedDiets.has(diet);
              const currentlySelected = allDiets.has(diet);
              // Check for overrides if AI detected anything (allergens or diets)
              // This ensures manual diet additions are detected even if AI only detected allergens
              if (aiWasSelected && !currentlySelected) {
                overriddenItems.push(`${diet} (removed)`);
              } else if (!aiWasSelected && currentlySelected) {
                overriddenItems.push(`${diet} (added)`);
              }
            });
            if (overriddenItems.length > 0) {
              return `<div style="color:#ef4444;font-size:0.85rem;margin-top:8px;padding:8px;background:rgba(239,68,68,0.1);border-radius:6px;border:1px solid rgba(239,68,68,0.3);width:100%">You have manually overridden the website's selection of ${overriddenItems.map(item => esc(item)).join(', ')}</div>`;
            }
            return '';
          })()}
              ${(() => {
            if (!row.dietAllergenConflicts || row.dietAllergenConflicts.length === 0) return '';
            const details = row.dietAllergenConflicts.map(conflict => {
              const dietLabel = esc(conflict.diet);
              const allergenList = conflict.allergens.map(a => esc(cap(a))).join(', ');
              return `<div><strong>${dietLabel}</strong> conflicts with ${allergenList}</div>`;
            }).join('');
            return `<div class="aiDietConflictMessage">${details}</div>`;
          })()}
            </div>
            <div>
              <div style="display:flex;flex-direction:column;gap:8px">
                <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
                  <input type="checkbox" class="aiRemovableCheckbox" ${row.removable ? 'checked' : ''}>
                  <span style="font-size:0.9rem">Can be accommodated</span>
                </label>
              </div>
            </div>
            <div class="aiConfirmCell" style="text-align:center">
              <button type="button" class="btn aiConfirmBtn ${isConfirmed ? 'confirmed' : 'unconfirmed'}" data-confirmed="${isConfirmed ? 'true' : 'false'}" ${!canConfirm ? 'disabled' : ''} title="${!canConfirm ? 'Please complete barcode scan or appeal before confirming' : ''}" style="padding:8px 16px;font-size:0.9rem;font-weight:600;border-radius:6px;${!canConfirm ? 'background:#6b7280;border-color:#6b7280;color:white;cursor:not-allowed;opacity:0.6;' : isConfirmed ? 'background:#4caf50;border-color:#4caf50;color:white;' : 'background:#f59e0b;border-color:#f59e0b;color:white;'}">${isConfirmed ? ' Confirmed' : 'Confirm'}</button>
              ${!canConfirm && needsScan ? `<div style="font-size:0.75rem;color:#ef4444;margin-top:4px;text-align:center">Scan required</div>` : ''}
            </div>
            <button type="button" class="btn aiDeleteRow">Remove</button>
          </div>
          <div class="aiRowBrandResults" data-row-idx="${idx}"></div>
          </div>
          ${rowLoadingOverlay}
        </div>
      </td>
    `;
        aiAssistTableBody.appendChild(tr);

        // Restore loading state if it existed for this row
        if (loadingStates[idx]) {
          const rowElement = tr.querySelector('.aiIngredientRow');
          if (rowElement && loadingStates[idx].html) {
            // Parse the saved HTML and append it
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = loadingStates[idx].html;
            const loadingArea = tempDiv.firstElementChild;
            if (loadingArea) {
              rowElement.appendChild(loadingArea);
            }
          }
        }

        // NOTE: updateAiBrandPreview() is obsolete now that we support multiple brands
        // It was overwriting the brand images we just rendered. Removed.
      });
      aiAssistResultsEl.classList.toggle('show', data.length > 0);
      if (aiAssistBrandResults) {
        aiAssistBrandResults.classList.remove('show');
        aiAssistBrandResults.innerHTML = '';
      }

      // Restore loading states for any active barcode lookups (from global tracking)
      // This ensures parallel lookups continue to show their loading UI after table re-render
      if (activeBarcodeLookups.size > 0) {
        console.log(`Restoring ${activeBarcodeLookups.size} active barcode lookup loading states`);
        for (const [rowIdx, lookupInfo] of activeBarcodeLookups.entries()) {
          // Re-create the loading UI for this row
          // First remove any existing loading area that was restored from HTML (it won't have animations)
          const tr = aiAssistTableBody.querySelector(`tr[data-index="${rowIdx}"]`);
          if (tr) {
            const existingLoadingArea = tr.querySelector('.barcodeLoadingArea');
            if (existingLoadingArea) {
              existingLoadingArea.remove();
            }
          }
          // Now create a fresh loading UI with proper animations
          // Pass the same startTime so the progress bar continues from where it was
          showBarcodeLoadingInRowWithTime(rowIdx, lookupInfo.ingredientName, lookupInfo.startTime);
        }
      }

      // Update the preview whenever the table is rendered
      updateAiPreview();
    }

    function normalizeIngredientName(name) {
      const lower = name.toLowerCase().trim();
      // Map common variations to standard names
      const aliases = {
        'mayo': 'mayonnaise',
        'cuke': 'cucumber',
        'cukes': 'cucumber',
        'pickles': 'pickle',
        'tomatoes': 'tomato',
        'onions': 'onion',
        'peppers': 'pepper',
        'mushrooms': 'mushroom',
        'olives': 'olive',
        'carrots': 'carrot',
        'potatoes': 'potato',
        'celery stalk': 'celery',
        'celery stalks': 'celery'
      };
      return aliases[lower] || lower;
    }

    function heuristicallyExtractIngredients(text) {
      if (!text) return [];
      const tokens = text
        .split(/\r?\n|\.|;/)
        .map(part => part.split(/\band\b|\bwith\b|,/i))
        .flat()
        .map(part => part.trim())
        .filter(Boolean);
      const unique = new Map();
      tokens.forEach(token => {
        const cleaned = token.replace(/[\d/]+/g, '').replace(/\b(teaspoons?|tablespoons?|cups?|ounces?|grams?|lbs?|pounds?|ml|l|kg)\b/gi, '').replace(/[\(\)]/g, '').replace(/\s+/g, ' ').trim();
        if (!cleaned) return;
        const normalized = normalizeIngredientName(cleaned);
        const key = norm(normalized);
        if (unique.has(key)) return;
        const detectedAllergens = ALLERGENS.filter(a => token.toLowerCase().includes(a));
        unique.set(key, { name: normalized, brand: '', allergens: detectedAllergens, ingredientsList: [normalized] });
      });
      if (unique.size === 0) {
        return [{ name: '', brand: '', allergens: [] }];
      }
      return Array.from(unique.values());
    }

    async function openAiAssistant(context) {
      console.log('!!! openAiAssistant called', new Error().stack);
      ensureAiAssistElements();
      if (!aiAssistBackdrop) return;

      // IMPORTANT: Clear previous state completely before setting new state
      aiAssistState.context = null;
      aiAssistState.pendingRequestId = null;
      aiAssistState.brandSuggestions = {};
      aiAssistState.imageData = null;
      aiAssistState.imageFileName = null;
      aiAssistState.detectedDietaryOptions = null;
      aiAssistState.savedToDish = false;
      aiAssistState.initialData = null;

      stopAiCamera();
      updateAiAssistMediaPreview();
      aiAssistSetStatus('');

      // Check if AI Assistant is already open - if so, don't reset checkboxes (preserve user edits)
      const isAlreadyOpen = aiAssistBackdrop && aiAssistBackdrop.style.display === 'flex';

      // Reset cross-contamination checkboxes ONLY if:
      // 1. Assistant is not already open (new opening), AND
      // 2. Context has explicit data to load
      // This preserves user's manual checkbox selections when assistant is re-opened
      const noCrossCheckbox = document.getElementById('aiAssistNoCrossContamination');
      const crossAllergenCheckboxes = document.querySelectorAll('.aiCrossAllergenCheckbox');
      const crossErrorEl = document.getElementById('aiAssistCrossContaminationError');

      // Only reset if we're opening fresh AND have context data to load
      const hasExplicitCrossData = context?.noCrossContamination === true ||
        (context?.crossContamination && Array.isArray(context.crossContamination) && context.crossContamination.length > 0);

      console.log('openAiAssistant: Cross-contamination reset logic:', {
        isAlreadyOpen,
        hasExplicitCrossData,
        noCrossContamination: context?.noCrossContamination,
        crossContamination: context?.crossContamination
      });

      if (!isAlreadyOpen && hasExplicitCrossData) {
        // Reset checkboxes before loading context data (only when opening fresh)
        console.log('  -> Resetting cross-contamination checkboxes to load context data');
        if (noCrossCheckbox) {
          noCrossCheckbox.checked = false;
        }
        if (crossAllergenCheckboxes) {
          crossAllergenCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = false;
            if (cb.parentElement) {
              cb.parentElement.style.opacity = '1';
              cb.parentElement.style.pointerEvents = 'auto';
            }
          });
        }
      } else if (isAlreadyOpen) {
        console.log('  -> AI Assistant already open, preserving current checkbox state');
      } else {
        console.log('  -> No explicit cross-contamination data in context, keeping checkboxes as-is');
      }

      if (crossErrorEl) {
        crossErrorEl.style.display = 'none';
      }

      // Keep the title generic - dish name is shown in the editable field below
      const titleEl = document.getElementById('aiAssistTitle');
      if (titleEl) {
        titleEl.textContent = 'Dish editor';
      }

      // Get the dish name for the input field - MUST be done BEFORE setting context
      const dishName = context?.getCurrentName ? context.getCurrentName() : (context?.dishName || '');
      console.log('openAiAssistant: Setting dish name to:', dishName);

      // Store original dish name to track unsaved changes
      aiAssistState.originalDishName = dishName;
      // Reset dish name modification flag when modal opens
      aiAssistState.dishNameModified = false;

      // Populate the name input field - force the update
      const nameInput = document.getElementById('aiAssistNameInput');
      if (nameInput) {
        // Force clear first, then set new value
        nameInput.value = '';
        setTimeout(() => {
          nameInput.value = dishName;
          console.log('openAiAssistant: Name input field updated to:', nameInput.value);
          // Update original dish name after setting the value
          aiAssistState.originalDishName = dishName;
        }, 0);
      }

      // NOW set the context after the name has been determined
      aiAssistState.context = context || {};

      // Show/hide replacement progress card if in replacement flow
      const replacementProgressCard = document.getElementById('aiAssistReplacementProgress');
      const replacementProgressText = document.getElementById('aiAssistReplacementProgressText');
      if (replacementProgressCard && replacementProgressText) {
        if (context?.replacementFlow && context?.dishNumber && context?.totalDishes) {
          replacementProgressCard.style.display = 'block';
          replacementProgressText.textContent = `Dish ${context.dishNumber} of ${context.totalDishes}`;
        } else {
          replacementProgressCard.style.display = 'none';
        }
      }

      // Load existing cross-contamination data if available (MUST be after context is set)
      // BUT only if assistant was not already open (to preserve user's manual edits)
      console.log('Loading cross-contamination data from context:', {
        isAlreadyOpen,
        noCrossContamination: context?.noCrossContamination,
        crossContamination: context?.crossContamination
      });

      if (!isAlreadyOpen) {
        if (context?.noCrossContamination) {
          console.log('  Setting noCrossContamination checkbox to checked');
          if (noCrossCheckbox) {
            noCrossCheckbox.checked = true;
            // Disable allergen checkboxes when "no cross-contamination" is set
            crossAllergenCheckboxes.forEach(cb => {
              cb.checked = false;
              cb.disabled = true;
              if (cb.parentElement) {
                cb.parentElement.style.opacity = '0.5';
                cb.parentElement.style.pointerEvents = 'none';
              }
            });
          }
        } else if (context?.crossContamination && Array.isArray(context.crossContamination) && context.crossContamination.length > 0) {
          console.log('  Loading cross-contamination allergens:', context.crossContamination);
          // Uncheck "no cross-contamination" since we have specific allergens
          if (noCrossCheckbox) {
            noCrossCheckbox.checked = false;
          }
          // Check the appropriate allergen checkboxes
          context.crossContamination.forEach(allergen => {
            const checkbox = Array.from(crossAllergenCheckboxes).find(cb => cb.dataset.allergen === allergen);
            console.log(`    Looking for checkbox for ${allergen}:`, checkbox);
            if (checkbox) {
              checkbox.checked = true;
              console.log(`    Set ${allergen} checkbox to checked`);
            } else {
              console.warn(`    Could not find checkbox for ${allergen}`);
            }
          });
        } else {
          console.log('  No cross-contamination data to load');
        }
      } else {
        console.log('  Skipping cross-contamination load because assistant is already open');
      }

      // Show/hide delete button and wire up callback
      const deleteBtn = document.getElementById('aiAssistDeleteBtn');
      const deleteWarning = document.getElementById('aiAssistDeleteWarning');
      const confirmDeleteBtn = document.getElementById('aiAssistConfirmDeleteBtn');
      const cancelDeleteBtn = document.getElementById('aiAssistCancelDeleteBtn');

      if (deleteBtn) {
        if (context?.onDelete) {
          deleteBtn.style.display = 'block';
          deleteBtn.onclick = () => {
            // Show inline delete warning instead of browser confirm
            if (deleteWarning) {
              deleteWarning.style.display = 'block';
              deleteWarning.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          };

          // Set up confirm delete handler
          if (confirmDeleteBtn) {
            confirmDeleteBtn.onclick = () => {
              if (deleteWarning) deleteWarning.style.display = 'none';
              toggleAiAssistBackdrop(false);
              context.onDelete();
            };
          }

          // Set up cancel delete handler
          if (cancelDeleteBtn) {
            cancelDeleteBtn.onclick = () => {
              if (deleteWarning) deleteWarning.style.display = 'none';
            };
          }
        } else {
          deleteBtn.style.display = 'none';
          deleteBtn.onclick = null;
        }
      }

      // Check if there are existing ingredients to edit
      const existingIngredients = context?.existingIngredients;
      const hasExistingData = existingIngredients && Array.isArray(existingIngredients) && existingIngredients.length > 0;

      if (hasExistingData) {
        // Restore appeal states from database before rendering
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        if (restaurantId && window.supabaseClient) {
          try {
            // Load appeals for this specific dish (scoped by restaurant_id AND dish_name)
            // Include review_status, review_notes, and reviewed_at to show appeal review information
            let appealsQuery = window.supabaseClient
              .from('ingredient_scan_appeals')
              .select('ingredient_name, ingredient_row_index, review_status, review_notes, reviewed_at, dish_name')
              .eq('restaurant_id', restaurantId);

            // Filter by dish_name to scope appeals to this specific dish
            // Note: dishName was set earlier in openAiAssistant from context.getCurrentName()
            if (dishName) {
              appealsQuery = appealsQuery.eq('dish_name', dishName);
            } else {
              // For legacy appeals without dish_name, only load them if no dish context
              appealsQuery = appealsQuery.is('dish_name', null);
            }

            const { data: appeals } = await appealsQuery;

            if (appeals && appeals.length > 0) {
              // Create a map of ingredient name -> appeal data (including review status)
              const appealMap = new Map();
              appeals.forEach(appeal => {
                const key = appeal.ingredient_name?.toLowerCase().trim() || '';
                if (key) {
                  appealMap.set(key, appeal);
                }
              });

              // Update existing ingredients with appeal state from database
              // BUT preserve any appeal state that's already in aiIngredients (userOverriddenScan/needsScan)
              // The database check is just a fallback for legacy data
              existingIngredients.forEach(ingredient => {
                const ingredientName = (ingredient.name || '').toLowerCase().trim();
                const appealData = appealMap.get(ingredientName);

                // IMPORTANT: Only set appeal state from database if it's not already in aiIngredients
                // The aiIngredients data is the source of truth since it's saved when "Save to Dish" is clicked
                const alreadyHasAppealState = ingredient.userOverriddenScan === true || ingredient.needsScan === false;

                // Load appeal review status if the appeal has been reviewed
                if (appealData && appealData.review_status && (appealData.review_status === 'approved' || appealData.review_status === 'rejected')) {
                  // Only set if not already in ingredient data (preserve existing if present)
                  if (!ingredient.appealReviewStatus) {
                    ingredient.appealReviewStatus = appealData.review_status;
                    ingredient.appealReviewNotes = appealData.review_notes || null;
                    ingredient.appealReviewedAt = appealData.reviewed_at || null;
                    console.log(`LOAD: Loaded appeal review status for "${ingredient.name}": ${appealData.review_status}`);

                    // If appeal was rejected, restore scan requirement and reset confirmed
                    // This ensures managers must re-scan after a denied appeal
                    if (appealData.review_status === 'rejected') {
                      const hasBrands = Array.isArray(ingredient.brands) && ingredient.brands.length > 0;
                      // When appeal is denied, manager must scan again - restore needsScan requirement
                      ingredient.needsScan = true;
                      ingredient.userOverriddenScan = false;
                      ingredient.confirmed = false;
                      console.log(`LOAD: Reset needsScan=true, confirmed=false for "${ingredient.name}" due to rejected appeal`);
                    }
                  }
                }

                if (appealData && !alreadyHasAppealState) {
                  // Only apply appeal state if no brands are added
                  // If brands are added, the scan requirement is already satisfied
                  const hasBrands = Array.isArray(ingredient.brands) && ingredient.brands.length > 0;
                  if (!hasBrands) {
                    ingredient.userOverriddenScan = true;
                    ingredient.needsScan = false;
                    console.log(`LOAD: Restored appeal state from database for "${ingredient.name}"`);
                  } else {
                    // Brand added means scan is satisfied, don't need appeal
                    console.log(`LOAD: Skipping appeal restoration for "${ingredient.name}" - has brands`);
                  }
                } else if (alreadyHasAppealState) {
                  console.log(`LOAD: Preserving existing appeal state from aiIngredients for "${ingredient.name}":`, {
                    userOverriddenScan: ingredient.userOverriddenScan,
                    needsScan: ingredient.needsScan,
                    appealReviewStatus: ingredient.appealReviewStatus
                  });
                }
              });
            }
          } catch (err) {
            console.warn('Failed to load appeals:', err);
            // Continue anyway
          }
        }

        // Skip input screen and go directly to ingredient editing table
        renderAiTable(existingIngredients);
        // Show the results section
        if (aiAssistResultsEl) {
          aiAssistResultsEl.classList.add('show');
        }
        // Set the recipe description textarea for existing items too
        if (aiAssistInput) {
          aiAssistInput.value = context?.seedText || '';
        }
        // Mark as saved since we're just loading existing data
        aiAssistState.savedToDish = true;
        // Store initial data to detect real changes
        aiAssistState.initialData = JSON.stringify(existingIngredients);
      } else {
        // New item - show input screen
        if (aiAssistInput) {
          aiAssistInput.value = context?.seedText || '';
          setTimeout(() => { aiAssistInput.focus(); aiAssistInput.selectionStart = aiAssistInput.value.length; }, 120);
        }
        renderAiTable([]);
        aiAssistState.savedToDish = false;
        aiAssistState.initialData = null;
      }

      toggleAiAssistBackdrop(true);
    }

    function openImageModal(imageSrc) {
      const modal = document.getElementById('imageModal');
      const img = document.getElementById('imageModalImg');
      if (modal && img) {
        img.src = imageSrc;
        modal.classList.add('show');
        document.body.style.overflow = 'hidden';
      }
    }

    function closeImageModal() {
      const modal = document.getElementById('imageModal');
      if (modal) {
        modal.classList.remove('show');
        document.body.style.overflow = '';
      }
    }

    window.openImageModal = openImageModal;
    window.closeImageModal = closeImageModal;

    function closeAiAssistant() {
      ensureAiAssistElements();

      // Hide replacement progress card when closing
      const replacementProgressCard = document.getElementById('aiAssistReplacementProgress');
      if (replacementProgressCard) {
        replacementProgressCard.style.display = 'none';
      }

      // Check for unsaved changes (don't prompt if already saved to dish)
      const data = collectAiTableData();
      const hasData = data.length > 0 && data.some(item => item.name.trim());

      // Check if data has actually changed from initial state
      let dataChanged = false;
      if (aiAssistState.initialData) {
        const currentData = JSON.stringify(data);
        dataChanged = currentData !== aiAssistState.initialData;
      } else {
        // No initial data means this is new work
        dataChanged = hasData;
      }

      // Check if dish name has been changed but not saved
      // This includes both:
      // 1. Dish name was modified and saved locally (dishNameModified flag)
      // 2. Dish name has unsaved local changes (current value differs from original)
      const nameInput = document.getElementById('aiAssistNameInput');
      let dishNameHasUnsavedChanges = false;

      // Check if dish name was modified via Save button but not yet applied to dish
      if (aiAssistState.dishNameModified) {
        dishNameHasUnsavedChanges = true;
        console.log('Dish name was modified and needs to be saved to dish');
      }

      // Also check if there are current unsaved changes in the input field
      if (nameInput && aiAssistState.originalDishName !== null && aiAssistState.originalDishName !== undefined) {
        const currentDishName = nameInput.value?.trim() || '';
        if (currentDishName !== aiAssistState.originalDishName && currentDishName.length > 0) {
          dishNameHasUnsavedChanges = true;
          console.log('Dish name has unsaved local changes');
        }
      }

      const hasUnsavedChanges = (dataChanged && !aiAssistState.savedToDish) || dishNameHasUnsavedChanges;

      if (hasUnsavedChanges) {
        // Show inline warning instead of confirm dialog
        const warningEl = document.getElementById('aiAssistUnsavedWarning');
        if (warningEl) {
          warningEl.style.display = 'block';

          // Scroll warning into view
          warningEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

          // Set up button handlers
          const saveAndExitBtn = document.getElementById('aiAssistSaveAndExitBtn');
          const exitWithoutSavingBtn = document.getElementById('aiAssistExitWithoutSavingBtn');
          const cancelExitBtn = document.getElementById('aiAssistCancelExitBtn');

          const handleSaveAndExit = () => {
            warningEl.style.display = 'none';

            // Save dish name changes if any (if there are unsaved local changes)
            if (nameInput) {
              const currentDishName = nameInput.value?.trim() || '';
              const saveNameBtn = document.getElementById('aiAssistSaveNameBtn');

              // If there are unsaved changes in the input field, save them first
              if (currentDishName !== aiAssistState.originalDishName && currentDishName.length > 0) {
                aiAssistState.originalDishName = currentDishName;
                aiAssistState.dishNameModified = true; // Mark as modified
                // Update generate button text to reflect saved name
                if (typeof window.updateGenerateButtonText === 'function') {
                  window.updateGenerateButtonText();
                }
                // Hide save button
                if (saveNameBtn) saveNameBtn.style.display = 'none';
              }
            }

            // Apply ingredients to dish (same as clicking "Save to Dish" button)
            // This will also mark dishNameModified as false
            applyAiIngredientsToOverlay();
          };

          const handleExitWithoutSaving = () => {
            warningEl.style.display = 'none';
            // Continue with the actual close
            performAiAssistClose();
          };

          const handleCancelExit = () => {
            warningEl.style.display = 'none';
          };

          // Remove old listeners and add new ones
          if (saveAndExitBtn) {
            saveAndExitBtn.replaceWith(saveAndExitBtn.cloneNode(true));
            document.getElementById('aiAssistSaveAndExitBtn').onclick = handleSaveAndExit;
          }
          if (exitWithoutSavingBtn) {
            exitWithoutSavingBtn.replaceWith(exitWithoutSavingBtn.cloneNode(true));
            document.getElementById('aiAssistExitWithoutSavingBtn').onclick = handleExitWithoutSaving;
          }
          if (cancelExitBtn) {
            cancelExitBtn.replaceWith(cancelExitBtn.cloneNode(true));
            document.getElementById('aiAssistCancelExitBtn').onclick = handleCancelExit;
          }

          return; // Stop here, don't close yet
        }
      }

      // If no unsaved changes, close directly
      performAiAssistClose();
    }

    function performAiAssistClose() {
      // Hide warning if visible
      const warningEl = document.getElementById('aiAssistUnsavedWarning');
      if (warningEl) warningEl.style.display = 'none';

      if (aiAssistState.recognition) {
        try { aiAssistState.recognition.stop(); } catch (_) { }
      }
      aiAssistState.recognition = null;
      aiAssistState.listening = false;
      aiAssistState.pendingRequestId = null;
      aiAssistState.brandSuggestions = {};
      aiAssistState.savedToDish = false;
      aiAssistState.originalDishName = null; // Reset dish name tracking on close
      aiAssistState.dishNameModified = false; // Reset dish name modification flag on close
      aiAssistSetStatus('');
      stopAiCamera();
      aiAssistState.imageData = null;
      aiAssistState.imageFileName = null;
      updateAiAssistMediaPreview();
      if (aiAssistResultsEl) {
        aiAssistResultsEl.classList.remove('show');
      }
      if (aiAssistTableBody) {
        aiAssistTableBody.innerHTML = '';
      }
      if (aiAssistBrandResults) {
        aiAssistBrandResults.classList.remove('show');
        aiAssistBrandResults.innerHTML = '';
      }
      const finalConfirmation = document.getElementById('aiAssistFinalConfirmation');
      if (finalConfirmation) {
        finalConfirmation.classList.add('aiAssistHidden');
      }
      if (aiAssistDictateBtn) aiAssistDictateBtn.textContent = ' Dictate';
      toggleAiAssistBackdrop(false);
    }

    // Save draft functionality
    function saveAiDraft() {
      const data = collectAiTableData();
      if (data.length === 0 || !data.some(item => item.name.trim())) {
        aiAssistSetStatus('No ingredients to save.', 'warn');
        return;
      }

      const dishName = document.getElementById('aiAssistNameInput')?.value || 'Untitled Dish';
      const draftKey = `aiAssistDraft_${Date.now()}`;

      try {
        localStorage.setItem(draftKey, JSON.stringify({
          dishName: dishName,
          ingredients: data,
          timestamp: Date.now()
        }));
        aiAssistSetStatus(` Draft saved for "${dishName}"! You can load it later.`, 'info');
      } catch (err) {
        console.error('Failed to save draft:', err);
        aiAssistSetStatus('Failed to save draft. Please try again.', 'error');
      }
    }

    // Confirm all ingredients workflow
    function confirmAllIngredients() {
      const data = collectAiTableData();

      // Check if there are any ingredients
      if (data.length === 0 || !data.some(item => item.name.trim())) {
        alert('Please add ingredients before confirming.');
        return;
      }

      // Check if all ingredients are confirmed
      const unconfirmed = data.filter(item => item.name.trim() && !item.confirmed);
      if (unconfirmed.length > 0) {
        const ingredientNames = unconfirmed.map(item => ` ${item.name}`).join('\n');
        alert(
          ` Please confirm allergens for all ingredients first.\n\n` +
          `Unconfirmed ingredients:\n${ingredientNames}\n\n` +
          `Check the "Confirmed" checkbox for each ingredient after verifying its allergens.`
        );
        return;
      }

      // Show final confirmation section
      const finalConfirmation = document.getElementById('aiAssistFinalConfirmation');
      if (finalConfirmation) {
        finalConfirmation.classList.remove('aiAssistHidden');
        finalConfirmation.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    function toggleAiDictation() {
      ensureAiAssistElements();
      if (aiAssistState.listening) {
        if (aiAssistState.recognition) {
          try { aiAssistState.recognition.stop(); } catch (_) { }
        }
        aiAssistState.listening = false;
        aiAssistSetStatus('Dictation stopped.', 'info');
        if (aiAssistDictateBtn) aiAssistDictateBtn.textContent = ' Dictate';
        return;
      }
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        aiAssistSetStatus('Dictation is not supported in this browser.', 'warn');
        return;
      }
      try {
        const recognition = new SpeechRecognition();
        recognition.lang = 'en-US';
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.onresult = (event) => {
          let transcript = '';
          for (let i = 0; i < event.results.length; i++) {
            transcript += event.results[i][0].transcript;
          }
          if (aiAssistInput) aiAssistInput.value = transcript.trim();
        };
        recognition.onerror = (evt) => {
          aiAssistSetStatus('Dictation error: ' + (evt.error || 'unknown'), 'warn');
        };
        recognition.onend = () => {
          aiAssistState.listening = false;
          aiAssistState.recognition = null;
          if (aiAssistDictateBtn) aiAssistDictateBtn.textContent = ' Dictate';
        };
        recognition.start();
        aiAssistState.recognition = recognition;
        aiAssistState.listening = true;
        aiAssistSetStatus('Dictation active speak now.');
        if (aiAssistDictateBtn) aiAssistDictateBtn.textContent = ' Stop dictation';
      } catch (err) {
        console.error('Dictation failed', err);
        aiAssistSetStatus('Could not start dictation: ' + (err.message || err), 'error');
      }
    }

    async function generateRecipeDescription() {
      ensureAiAssistElements();

      const nameInput = document.getElementById('aiAssistNameInput');
      const dishName = nameInput?.value?.trim() || '';

      if (!dishName) {
        aiAssistSetStatus('Please enter a dish name first.', 'warn');
        return;
      }

      if (!aiAssistInput) {
        aiAssistSetStatus('Text input field not found.', 'error');
        return;
      }

      // Disable button and show loading
      if (aiAssistGenerateBtn) {
        aiAssistGenerateBtn.disabled = true;
        aiAssistGenerateBtn.textContent = 'Generating recipe...';
      }
      aiAssistSetStatus('Generating recipe description...', 'info');

      try {
        // Use Supabase Edge Function to call Claude for description generation
        const payload = {
          text: `Generate a detailed recipe description for "${dishName}".`,
          dishName: dishName,
          generateDescription: true  // Flag to indicate this is a description generation request
        };

        const result = await requestAiExtraction(payload);

        // Extract description from the result
        let generatedDescription = '';

        if (result?.error) {
          throw new Error(result.error);
        }

        // The Edge Function returns {description: "...", text: "..."} for description generation
        if (result?.description) {
          generatedDescription = result.description;
        } else if (result?.text) {
          generatedDescription = result.text;
        } else if (typeof result === 'string') {
          generatedDescription = result;
        } else {
          // Fallback if response format is unexpected
          generatedDescription = `A delicious ${dishName} prepared with fresh ingredients and traditional cooking methods.`;
          aiAssistSetStatus('Generated a basic description. You can edit it to add more details.', 'warn');
        }

        if (generatedDescription && generatedDescription.trim()) {
          // Insert the generated description into the textarea
          aiAssistInput.value = generatedDescription.trim();
          aiAssistSetStatus('Recipe description generated! Review and edit if needed.', 'success');
        } else {
          aiAssistSetStatus('Could not generate description. Please try again.', 'warn');
        }
      } catch (error) {
        console.error('Error generating recipe description:', error);
        aiAssistSetStatus('Failed to generate description: ' + (error.message || 'Unknown error'), 'error');
      } finally {
        // Re-enable button
        if (aiAssistGenerateBtn) {
          const nameInput = document.getElementById('aiAssistNameInput');
          const dishName = nameInput?.value?.trim() || 'recipe';
          aiAssistGenerateBtn.disabled = false;
          aiAssistGenerateBtn.textContent = ` Generate generic ${dishName} recipe`;
        }
      }
    }

    async function correctSpellingWithAI(query, ingredientName) {
      try {
        // Use proxy to avoid CORS issues
        const response = await fetch('/api/ai-proxy', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            functionName: 'spelling-corrector',
            payload: {
              query: query,
              ingredientName: ingredientName
            }
          })
        });

        if (!response.ok) {
          console.warn('Spelling correction failed:', response.status);
          return query;
        }

        const data = await response.json();
        const corrected = data?.corrected || query;
        return corrected;
      } catch (err) {
        console.warn('AI spelling correction failed', err);
      }
      return query;
    }

    async function fetchBrandSuggestions(query, ingredientName, onProgress) {
      ensureAiAssistElements();
      if (!ingredientName) return [];

      // Extract brand filter from query if present
      const brandQuery = query !== ingredientName ? query.replace(ingredientName, '').trim() : '';

      console.log('Fetching brand suggestions:', { ingredientName, brandQuery });

      try {
        // Call the new AI-powered brand search Supabase edge function
        if (onProgress) onProgress(30, 'Searching for products...', 'Querying product database');

        const response = await window.supabaseClient.functions.invoke('ai-brand-search', {
          body: {
            ingredientName,
            brandQuery
          }
        });

        if (response.error) {
          console.error('AI brand search error:', response.error);
          return [];
        }

        const { products, aiReasoning, searchCount, totalFound, withImages } = response.data || {};

        console.log('AI Brand Search Results:', {
          aiReasoning,
          searchCount,
          totalFound,
          withImages,
          productsReturned: products?.length || 0
        });

        if (aiReasoning) {
          console.log('AI reasoning:', aiReasoning);
        }

        if (!products || products.length === 0) {
          console.log('No brand products found with required images');
          return [];
        }

        if (onProgress) onProgress(50, 'Products found', `Analyzing ${products.length} product${products.length > 1 ? 's' : ''} with AI...`);

        // Filter products to only include those with BOTH ingredient label image AND text ingredient list
        const filteredProducts = products.filter(product => {
          // Must have ingredient label image for visual verification
          const hasImage = product.ingredientsImage && product.ingredientsImage.trim().length > 0;
          // Must have text ingredient list for allergen/diet detection
          const hasIngredientsList = product.ingredientsList && product.ingredientsList.length > 0;
          // Both are required
          return hasImage && hasIngredientsList;
        });

        if (onProgress) onProgress(60, 'Analyzing ingredients...', `Using Claude AI to analyze ${filteredProducts.length} product${filteredProducts.length > 1 ? 's' : ''}`);

        // Show progress bar for AI analysis (for top-level progress bar)
        const progressBar = document.getElementById('aiProgressBar');
        const progressBarFill = document.getElementById('aiProgressBarFill');
        if (progressBar && progressBarFill && filteredProducts.length > 0) {
          progressBar.classList.add('show');
          progressBarFill.style.width = '30%';
        }

        // Use Claude AI to analyze each product's ingredients
        const analyzedProducts = await Promise.all(filteredProducts.map(async (product) => {
          let allergens = [];
          let diets = [];

          try {
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: {
                ingredientText: product.ingredientsList.join(', '),
                productName: product.name || '',
                labels: product.labels_tags || [],
                categories: product.categories_tags || []
              }
            });

            if (analysisResult.error) {
              console.error('Claude AI analysis error for product:', product.name, analysisResult.error);
            } else {
              const { allergens: aiAllergens, diets: aiDiets } = analysisResult.data || {};
              allergens = aiAllergens || [];
              diets = aiDiets || [];
              console.log('Claude AI analyzed:', product.name, { allergens, diets });
            }
          } catch (aiError) {
            console.error('Failed to analyze product with Claude AI:', product.name, aiError);
          }

          return {
            name: product.name || '',
            brand: product.brand || '',
            image: product.image || '',
            ingredientsImage: product.ingredientsImage || '',
            ingredientsList: product.ingredientsList || [],
            allergens,
            diets,
            productUrl: product.productUrl || ''
          };
        }));

        // Complete progress bar
        if (progressBarFill) progressBarFill.style.width = '100%';
        setTimeout(() => {
          if (progressBar) progressBar.classList.remove('show');
          if (progressBarFill) progressBarFill.style.width = '0%';
        }, 300);

        return analyzedProducts;

      } catch (err) {
        console.error('Failed to fetch brand suggestions:', err);
        return [];
      }
    }

    async function openAiBrandSearch(rowIdx) {
      ensureAiAssistElements();
      const rows = collectAiTableData();
      if (!rows[rowIdx]) {
        aiAssistSetStatus('Select an ingredient first.', 'warn');
        return;
      }

      const ingredientName = rows[rowIdx].name;
      if (!ingredientName) {
        aiAssistSetStatus('Add an ingredient name before searching for a brand.', 'warn');
        return;
      }

      // Find the row-specific brand results container
      const rowElement = aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!rowElement) return;
      const rowBrandResults = rowElement.querySelector('.aiRowBrandResults');
      if (!rowBrandResults) return;

      // Show search form
      rowBrandResults.classList.add('show');
      rowBrandResults.innerHTML = `
    <div class="aiBrandSearchForm">
      <div style="margin-bottom:12px">
        <label style="display:block;margin-bottom:6px;font-weight:500">Ingredient: <strong>${esc(ingredientName)}</strong></label>
        <input type="text" class="aiBrandSearchInput" placeholder="Optional: brand name (e.g., 'Chobani', 'Once Again')" style="width:100%;padding:8px;background:#0c102a;border:1px solid rgba(76,90,212,0.4);border-radius:8px;color:#fff">
      </div>
      <div style="display:flex;gap:8px">
        <button type="button" class="btn aiBrandSearchSubmit">Search</button>
        <button type="button" class="btn aiBrandSearchCancel" style="background:#301424;border-color:#4c2138">Cancel</button>
      </div>
    </div>
  `;

      const searchInput = rowBrandResults.querySelector('.aiBrandSearchInput');
      const submitBtn = rowBrandResults.querySelector('.aiBrandSearchSubmit');
      const cancelBtn = rowBrandResults.querySelector('.aiBrandSearchCancel');

      const performSearch = async () => {
        const brandFilter = searchInput.value.trim();
        const query = brandFilter ? `${ingredientName} ${brandFilter}` : ingredientName;

        aiAssistSetStatus('Searching for brand suggestions');
        rowBrandResults.innerHTML = `
      <div style="padding:20px;text-align:center">
        <div id="brandSearchStatus" style="font-size:1rem;margin-bottom:12px;color:#a8b2d6">Searching for products...</div>
        <div class="aiProgressBar show" style="display:block;margin:0 auto;max-width:300px">
          <div id="brandSearchProgress" class="aiProgressBarFill" style="width:10%;animation:shimmer 1.5s infinite"></div>
        </div>
        <div id="brandSearchSubtext" style="font-size:0.85rem;margin-top:8px;color:#8891b0">Querying product database</div>
      </div>
    `;

        // Helper to update progress
        const updateProgress = (percent, status, subtext) => {
          const progressBar = document.getElementById('brandSearchProgress');
          const statusEl = document.getElementById('brandSearchStatus');
          const subtextEl = document.getElementById('brandSearchSubtext');
          if (progressBar) progressBar.style.width = percent + '%';
          if (statusEl && status) statusEl.textContent = status;
          if (subtextEl && subtext) subtextEl.textContent = subtext;
        };

        try {
          // Small delay to let DOM update
          await new Promise(resolve => setTimeout(resolve, 50));
          updateProgress(20, 'Searching for products...', 'Querying product database');

          const suggestions = await fetchBrandSuggestions(query, ingredientName, updateProgress);

          updateProgress(100, 'Complete!', 'Products analyzed');
          aiAssistState.brandSuggestions[rowIdx] = suggestions;
          if (!suggestions.length) {
            rowBrandResults.innerHTML = `
          <div style="text-align:center;padding:20px">
            <p style="margin-bottom:12px">No brands found.</p>
            <button type="button" class="btn aiBrandSearchAgain">Try a different search</button>
          </div>
        `;
            rowBrandResults.querySelector('.aiBrandSearchAgain').addEventListener('click', () => {
              openAiBrandSearch(rowIdx);
            });
            return;
          }
          rowBrandResults.innerHTML = `
        <div style="background:rgba(220,82,82,0.15);border:1px solid rgba(220,82,82,0.4);border-radius:12px;padding:12px;margin-bottom:16px">
          <strong style="color:#dc5252"> Safety Warning</strong>
          <p style="margin:8px 0 0 0;font-size:0.9rem;line-height:1.4">Data is crowdsourced and may be outdated or incorrect. ALWAYS verify ingredient labels match the actual product image before relying on allergen information.</p>
        </div>
        ${suggestions.map((item, idx) => `
        <div class="aiBrandSuggestion" data-row="${rowIdx}" data-index="${idx}">
          ${item.image ? `<img src="${esc(item.image)}" alt="${esc(item.name)}" loading="lazy">` : ''}
          <div class="aiBrandSuggestionInfo">
            <strong>${esc(item.name)}</strong>
            ${item.brand ? `<span>${esc(item.brand)}</span>` : ''}
            ${item.ingredientsImage ? '<span style="color:#4c5ad4"> Has label image - click to verify</span>' : '<span style="color:#dc5252"> No label image available</span>'}
            ${item.productUrl ? `<a href="${esc(item.productUrl)}" target="_blank" rel="noopener" style="font-size:0.85rem;color:#4c5ad4">View on Open Food Facts</a>` : ''}
            <button type="button" class="btn btnSmall aiBrandApply" data-row="${rowIdx}" data-index="${idx}" style="margin-top:8px">Add this brand</button>
          </div>
        </div>
      `).join('')}
      <div style="text-align:center;margin-top:16px;padding-top:16px;border-top:1px solid rgba(76,90,212,0.2)">
        <button type="button" class="btn aiBrandSearchAgain">Search again</button>
      </div>
      `;

          // Add click handlers for "Add this brand" buttons
          rowBrandResults.querySelectorAll('.aiBrandApply').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const suggestionIdx = Number(e.target.dataset.index);
              applyBrandSuggestion(rowIdx, suggestionIdx);
            });
          });

          // Add click handler for "Search again" button
          rowBrandResults.querySelector('.aiBrandSearchAgain').addEventListener('click', () => {
            openAiBrandSearch(rowIdx);
          });

          aiAssistSetStatus('Review images carefully before applying. Click images to verify ingredient labels match.', 'warn');
        } catch (err) {
          console.error('Brand lookup failed', err);
          rowBrandResults.innerHTML = '<div>Could not retrieve brand information.</div>';
          aiAssistSetStatus('Brand lookup failed. Try again later.', 'warn');
        }
      };

      submitBtn.addEventListener('click', performSearch);
      cancelBtn.addEventListener('click', () => {
        rowBrandResults.classList.remove('show');
        rowBrandResults.innerHTML = '';
      });
      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          performSearch();
        }
      });

      // Focus the input
      setTimeout(() => searchInput.focus(), 100);
    }

    async function removeAppeal(rowIdx) {
      const rows = collectAiTableData();
      if (!rows[rowIdx]) {
        aiAssistSetStatus('Could not find ingredient to remove appeal from.', 'warn');
        return;
      }

      const ingredientName = rows[rowIdx].name;
      if (!ingredientName) {
        aiAssistSetStatus('Could not find ingredient name.', 'warn');
        return;
      }

      // Confirm removal
      if (!confirm(`Remove the appeal for "${ingredientName}"? This will restore the scan requirement.`)) {
        return;
      }

      // Delete appeal from database
      const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
      if (restaurantId && window.supabaseClient) {
        try {
          // Get current dish name to scope the delete to this specific dish
          const dishName = aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '';

          let deleteQuery = window.supabaseClient
            .from('ingredient_scan_appeals')
            .delete()
            .eq('restaurant_id', restaurantId)
            .eq('ingredient_name', ingredientName)
            .eq('ingredient_row_index', rowIdx);

          // Also filter by dish_name to ensure we only delete appeals for this dish
          if (dishName) {
            deleteQuery = deleteQuery.eq('dish_name', dishName);
          } else {
            deleteQuery = deleteQuery.is('dish_name', null);
          }

          const { error: deleteError } = await deleteQuery;

          if (deleteError) {
            console.error('Failed to delete appeal from database:', deleteError);
            // Continue with UI update even if database delete fails
          } else {
            console.log('Appeal deleted from database successfully');
          }
        } catch (deleteErr) {
          console.error('Exception deleting appeal from database:', deleteErr);
          // Continue with UI update even if database delete fails
        }
      }

      // Remove the appeal state
      const data = collectAiTableData();
      if (data[rowIdx]) {
        data[rowIdx].userOverriddenScan = false;
        // Restore needsScan to true (the AI originally recommended scanning)
        data[rowIdx].needsScan = true;
        // Reset confirmed state since we're changing the scan requirement
        data[rowIdx].confirmed = false;
        console.log('REMOVE APPEAL: Removed appeal state for row', rowIdx, data[rowIdx]);
        renderAiTable(data);

        // Ensure the confirm button UI is reset
        setTimeout(() => {
          const tableRows = document.querySelectorAll('#aiIngredientList tr');
          if (tableRows[rowIdx]) {
            resetConfirmButton(tableRows[rowIdx]);
          }
        }, 100);
      }

      // Email notification removed per user request - don't send emails when appeals are removed

      aiAssistSetStatus(`Appeal removed for "${ingredientName}". Scan requirement restored.`, 'success');

      // Mark as unsaved so manager is prompted to save changes
      aiAssistState.savedToDish = false;
    }

    async function openAiAppealModal(rowIdx) {
      ensureAiAssistElements();
      const rows = collectAiTableData();
      if (!rows[rowIdx]) {
        aiAssistSetStatus('Select an ingredient first.', 'warn');
        return;
      }

      const ingredientName = rows[rowIdx].name;
      if (!ingredientName) {
        aiAssistSetStatus('Add an ingredient name before appealing.', 'warn');
        return;
      }

      // Create a full-screen modal overlay for the appeal
      const appealModal = document.createElement('div');
      appealModal.id = 'appealScanModal';
      appealModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.95);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;

      appealModal.innerHTML = `
    <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px">
      <div style="text-align:center">
        <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Appeal AI Scanning Decision</h3>
        <div style="margin:0;color:#a8b2d6;font-size:0.95rem">
          Ingredient: <strong style="color:#fff">${esc(ingredientName)}</strong>
        </div>
        <p style="margin:8px 0 0 0;color:#a8b2d6;font-size:0.9rem">Please take a photo of the food product(s) used for this part of the dish</p>
      </div>
      <div style="position:relative;background:#000;border-radius:12px;overflow:hidden;margin:16px 0">
        <video id="appealCameraVideo" autoplay playsinline muted style="width:100%;height:60vh;max-height:500px;display:none;object-fit:cover"></video>
        <canvas id="appealCameraCanvas" style="display:none"></canvas>
        <img id="appealPhotoPreview" style="width:100%;height:60vh;max-height:500px;object-fit:contain;display:none" alt="Preview">
        <div id="appealCameraPlaceholder" style="width:100%;height:60vh;max-height:500px;display:flex;align-items:center;justify-content:center;background:#1a1a1a;color:#a8b2d6;font-size:1.1rem">No photo taken yet</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px">
        <label for="appealMessage" style="color:#fff;font-weight:600;font-size:0.95rem">Add a message (optional)</label>
        <textarea id="appealMessage" placeholder="Explain why you disagree with the AI scan recommendation..." style="width:100%;padding:12px;border:2px solid #4c5ad4;border-radius:8px;font-size:0.95rem;font-family:inherit;min-height:80px;resize:vertical;box-sizing:border-box;background:#1a1a1a;color:#fff" maxlength="500"></textarea>
        <div style="text-align:right;color:#a8b2d6;font-size:0.85rem" id="appealMessageCharCount">0/500</div>
      </div>
      <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
        <button type="button" class="btn aiAppealCameraBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:12px 32px;font-size:1rem"> Use Camera</button>
        <button type="button" class="btn aiAppealUploadBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:12px 32px;font-size:1rem"> Upload Photo</button>
        <button type="button" class="btn aiAppealCaptureBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:12px 32px;font-size:1rem;display:none">Capture Photo</button>
        <button type="button" class="btn aiAppealSubmitBtn" style="background:#17663a;border-color:#1a7b46;padding:12px 32px;font-size:1rem;display:none">Submit Appeal</button>
        <button type="button" class="btn aiAppealCancelBtn" style="background:#ef4444;border-color:#dc2626;padding:12px 32px;font-size:1rem">Cancel</button>
      </div>
      <div id="appealStatus" style="text-align:center;color:#a8b2d6;font-size:0.9rem;min-height:24px"></div>
      <input type="file" id="appealImageUpload" accept="image/*" style="display:none">
    </div>
  `;

      // Lock background scrolling
      scrollLockPosition = window.pageYOffset || document.documentElement.scrollTop;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${scrollLockPosition}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';
      document.body.appendChild(appealModal);

      const video = appealModal.querySelector('#appealCameraVideo');
      const canvas = appealModal.querySelector('#appealCameraCanvas');
      const preview = appealModal.querySelector('#appealPhotoPreview');
      const placeholder = appealModal.querySelector('#appealCameraPlaceholder');
      const cameraBtn = appealModal.querySelector('.aiAppealCameraBtn');
      const uploadBtn = appealModal.querySelector('.aiAppealUploadBtn');
      const captureBtn = appealModal.querySelector('.aiAppealCaptureBtn');
      const submitBtn = appealModal.querySelector('.aiAppealSubmitBtn');
      const cancelBtn = appealModal.querySelector('.aiAppealCancelBtn');
      const fileInput = appealModal.querySelector('#appealImageUpload');
      const statusDiv = appealModal.querySelector('#appealStatus');
      const messageTextarea = appealModal.querySelector('#appealMessage');
      const charCountDiv = appealModal.querySelector('#appealMessageCharCount');

      let mediaStream = null;
      let capturedPhoto = null;

      // Character counter for message textarea
      if (messageTextarea && charCountDiv) {
        messageTextarea.addEventListener('input', () => {
          const length = messageTextarea.value.length;
          charCountDiv.textContent = `${length}/500`;
        });
      }

      const stopCamera = () => {
        if (mediaStream) {
          mediaStream.getTracks().forEach(track => track.stop());
          mediaStream = null;
        }
        if (video) video.srcObject = null;
      };

      const closeModal = () => {
        stopCamera();
        if (appealModal && appealModal.parentNode) {
          appealModal.parentNode.removeChild(appealModal);
        }
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.style.overflow = '';
        window.scrollTo(0, scrollLockPosition);
      };

      const showPreview = (dataUrl) => {
        capturedPhoto = dataUrl;
        placeholder.style.display = 'none';
        video.style.display = 'none';
        preview.style.display = 'block';
        preview.src = dataUrl;
        captureBtn.style.display = 'none';
        submitBtn.style.display = 'inline-block';
        cameraBtn.style.display = 'inline-block';
        uploadBtn.style.display = 'inline-block';
      };

      cameraBtn.addEventListener('click', async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
          mediaStream = stream;
          video.srcObject = stream;
          video.play();
          placeholder.style.display = 'none';
          video.style.display = 'block';
          preview.style.display = 'none';
          captureBtn.style.display = 'inline-block';
          submitBtn.style.display = 'none';
          statusDiv.textContent = 'Position the ingredient in view and click Capture';
        } catch (err) {
          console.error('Camera access failed', err);
          statusDiv.textContent = 'Could not access camera: ' + (err.message || err);
          statusDiv.style.color = '#ef4444';
        }
      });

      captureBtn.addEventListener('click', () => {
        if (video && video.videoWidth > 0) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
          showPreview(dataUrl);
          stopCamera();
        }
      });

      uploadBtn.addEventListener('click', () => {
        fileInput.click();
      });

      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            showPreview(event.target.result);
          };
          reader.readAsDataURL(file);
        }
      });

      submitBtn.addEventListener('click', async () => {
        if (!capturedPhoto) {
          statusDiv.textContent = 'Please take or upload a photo first';
          statusDiv.style.color = '#ef4444';
          return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';
        statusDiv.textContent = 'Submitting appeal...';
        statusDiv.style.color = '#a8b2d6';

        try {
          // Wait for Supabase client to be available
          let client = null;
          if (window.supabaseClient) {
            client = window.supabaseClient;
          } else if (window.getSupabaseClient) {
            client = await window.getSupabaseClient();
          } else {
            // Wait a bit for client to initialize
            await new Promise(resolve => {
              const check = setInterval(() => {
                if (window.supabaseClient) {
                  clearInterval(check);
                  client = window.supabaseClient;
                  resolve();
                }
              }, 50);
              setTimeout(() => {
                clearInterval(check);
                resolve();
              }, 2000);
            });
            if (!client) throw new Error('Supabase client not available');
          }

          const restaurantId = state.restaurant?._id || state.restaurant?.id || null;

          // Upload photo to Supabase storage
          // Convert data URL to blob
          const photoBlob = await (await fetch(capturedPhoto)).blob();
          const fileName = `appeal-${Date.now()}-${Math.random().toString(36).substring(7)}.jpg`;

          // Try to upload to storage
          let photoUrl = null;
          try {
            const { data: uploadData, error: uploadError } = await client.storage
              .from('ingredient-appeals')
              .upload(fileName, photoBlob, {
                contentType: 'image/jpeg',
                upsert: false
              });

            if (uploadError) {
              console.error('Storage upload failed (400 Bad Request), using data URL instead:', uploadError);
              console.error('Upload error details:', {
                message: uploadError.message,
                statusCode: uploadError.statusCode,
                error: uploadError.error
              });
              // Fallback: use data URL directly if storage fails
              // This is fine - the database can store data URLs
              photoUrl = capturedPhoto;
            } else {
              // Get public URL
              const { data: urlData } = client.storage
                .from('ingredient-appeals')
                .getPublicUrl(fileName);
              photoUrl = urlData.publicUrl;
              console.log('Photo uploaded successfully to storage:', photoUrl);
            }
          } catch (storageErr) {
            console.error('Storage operation failed with exception, using data URL instead:', storageErr);
            // Fallback: use data URL directly if storage bucket doesn't exist or other error
            photoUrl = capturedPhoto;
          }

          // Always ensure we have a photo URL before proceeding
          if (!photoUrl) {
            console.warn('No photo URL available, using data URL');
            photoUrl = capturedPhoto;
          }

          // Save appeal to database
          // Note: Even if this fails, we'll still update the UI state
          let dbSuccess = false;
          try {
            const managerMessage = messageTextarea ? messageTextarea.value.trim() : '';
            // Get current dish name to scope appeals per dish
            const dishName = aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '';
            const { error: dbError } = await client
              .from('ingredient_scan_appeals')
              .insert([{
                restaurant_id: restaurantId,
                dish_name: dishName || null,
                ingredient_name: ingredientName,
                ingredient_row_index: rowIdx,
                photo_url: photoUrl,
                ai_recommended_scan: true,
                manager_disagrees: true,
                manager_message: managerMessage || null,
                submitted_at: new Date().toISOString()
              }]);

            if (dbError) {
              console.error('Database insert failed (RLS policy?), but continuing with UI update:', dbError);
              console.error('Database error details:', {
                message: dbError.message,
                code: dbError.code,
                details: dbError.details,
                hint: dbError.hint
              });
              // Don't throw - we'll still update the UI state
            } else {
              dbSuccess = true;
              console.log('Appeal record saved to database successfully');
            }
          } catch (dbErr) {
            console.error('Database insert exception (RLS policy?), but continuing with UI update:', dbErr);
            // Don't throw - we'll still update the UI state
          }

          // Send email notification
          try {
            const restaurantName = state.restaurant?.name || 'Unknown Restaurant';
            const restaurantSlug = state.restaurant?.slug || slug || '';

            const SUPABASE_URL = 'https://fgoiyycctnwnghrvsilt.supabase.co';
            await fetch(`${SUPABASE_URL}/functions/v1/send-notification-email`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SUPABASE_KEY}`,
                'apikey': SUPABASE_KEY
              },
              body: JSON.stringify({
                type: 'appeal',
                restaurantName: restaurantName,
                ingredientName: ingredientName,
                photoUrl: photoUrl,
                restaurantSlug: restaurantSlug
              })
            }).catch(err => {
              console.warn('Failed to send email notification:', err);
              // Don't fail the appeal submission if email fails
            });
          } catch (emailErr) {
            console.warn('Email notification error:', emailErr);
            // Don't fail the appeal submission if email fails
          }

          if (dbSuccess) {
            statusDiv.textContent = ' Appeal submitted successfully! We will review it.';
          } else {
            statusDiv.textContent = ' Appeal recorded locally (database save failed, but your changes are saved). Please save your dish to persist changes.';
            console.warn('Appeal was not saved to database, but UI state was updated. Manager should save dish to persist.');
          }
          statusDiv.style.color = '#4caf50';

          // Update the row to remove the scan recommendation
          const data = collectAiTableData();
          console.log('APPEAL: After appeal, before update - data[rowIdx]:', data[rowIdx]);
          if (data[rowIdx]) {
            data[rowIdx].needsScan = false;
            data[rowIdx].userOverriddenScan = true;
            // Reset confirmed state - user needs to confirm again after appealing
            data[rowIdx].confirmed = false;
            console.log('APPEAL: After setting userOverriddenScan - data[rowIdx]:', JSON.stringify(data[rowIdx], null, 2));
            renderAiTable(data);

            // Ensure the confirm button UI is reset
            setTimeout(() => {
              const tableRows = document.querySelectorAll('#aiIngredientList tr');
              if (tableRows[rowIdx]) {
                resetConfirmButton(tableRows[rowIdx]);
              }
            }, 100);
          }

          // Re-collect after re-render to verify it's saved
          const verifyData = collectAiTableData();
          console.log('APPEAL: After renderAiTable - verifyData[rowIdx]:', JSON.stringify(verifyData[rowIdx], null, 2));
          console.log('APPEAL: Verifying needsScan and userOverriddenScan are preserved:', {
            needsScan: verifyData[rowIdx]?.needsScan,
            userOverriddenScan: verifyData[rowIdx]?.userOverriddenScan,
            confirmed: verifyData[rowIdx]?.confirmed
          });

          // Mark as unsaved so manager is prompted to save changes
          aiAssistState.savedToDish = false;

          setTimeout(() => {
            closeModal();
            aiAssistSetStatus('Appeal submitted. You can continue working on this ingredient.', 'success');
          }, 2000);

        } catch (err) {
          console.error('Appeal submission failed', err);
          statusDiv.textContent = 'Failed to submit appeal: ' + (err.message || err);
          statusDiv.style.color = '#ef4444';
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit Appeal';
        }
      });

      cancelBtn.addEventListener('click', closeModal);
      appealModal.addEventListener('click', (e) => {
        if (e.target === appealModal) closeModal();
      });
    }

    // Show photo upload modal when barcode not found
    function showIngredientPhotoUploadModal(rowIdx, ingredientName, barcode) {
      ensureAiAssistElements();

      // Create a full-screen modal overlay
      const photoModal = document.createElement('div');
      photoModal.id = 'ingredientPhotoModal';
      photoModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.95);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 20px;
    padding-top: max(20px, env(safe-area-inset-top));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  `;

      photoModal.innerHTML = `
    <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px;margin-top:auto;margin-bottom:auto;padding-top:20px;padding-bottom:20px">
      <div style="text-align:center">
        <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Capture Ingredient List</h3>
        <div style="margin:0;color:#a8b2d6;font-size:0.95rem">
          Ingredient: <strong style="color:#fff">${esc(ingredientName)}</strong>
        </div>
        <p id="photoInstructionText" style="margin:8px 0 0 0;color:#a8b2d6;font-size:0.9rem">Step 1: Please take a photo of the ingredient list on the product packaging</p>
      </div>
      <div style="position:relative;background:#000;border-radius:12px;overflow:hidden;margin:16px 0">
        <video id="ingredientCameraVideo" autoplay playsinline muted style="width:100%;height:40vh;max-height:400px;min-height:200px;display:none;object-fit:cover"></video>
        <canvas id="ingredientCameraCanvas" style="display:none"></canvas>
        <img id="ingredientPhotoPreview" style="width:100%;height:40vh;max-height:400px;min-height:200px;object-fit:contain;display:none" alt="Ingredient Label Preview">
        <img id="productFrontPhotoPreview" style="width:100%;height:40vh;max-height:400px;min-height:200px;object-fit:contain;display:none" alt="Product Front Preview">
        <div id="ingredientCameraPlaceholder" style="display:none"></div>
      </div>
      <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
        <button type="button" class="btn ingredientCameraBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px"> Use Camera</button>
        <button type="button" class="btn ingredientUploadBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px"> Upload Photo</button>
        <button type="button" class="btn ingredientCaptureBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px;display:none">Capture Photo</button>
        <button type="button" class="btn ingredientExtractBtn" style="background:#17663a;border-color:#1a7b46;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px;display:none">Extract Ingredients</button>
        <button type="button" class="btn ingredientNextBtn" style="background:#4c5ad4;border-color:#4c5ad4;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px;display:none">Next: Product Front</button>
        <button type="button" class="btn ingredientCompleteBtn" style="background:#17663a;border-color:#1a7b46;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px;display:none">Complete</button>
        <button type="button" class="btn ingredientCancelBtn" style="background:#ef4444;border-color:#dc2626;padding:10px 20px;font-size:0.95rem;flex:1;min-width:120px">Cancel</button>
      </div>
      <div id="ingredientStatus" style="text-align:center;color:#a8b2d6;font-size:0.9rem;min-height:24px"></div>
      <div id="extractedTextSection" style="display:none;margin-top:16px">
        <div style="margin-bottom:16px">
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:12px">
            <span style="color:#4ade80;font-size:1.2rem"></span>
            <div style="font-weight:600;color:#fff;font-size:0.95rem">Ingredients extracted! Please verify the text below matches the photo.</div>
          </div>
        </div>

        <!-- Visual verification section -->
        <div id="lineByLineSection" style="display:none;margin-bottom:16px">
          <div style="background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:12px;padding:16px">
            <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:12px">
              <div style="font-weight:600;color:#fff;font-size:0.95rem">Visual Verification</div>
              <div style="color:#cbd5f5;font-size:0.85rem;max-width:360px;line-height:1.4">Each line is cropped from your photo. Confirm the AI text under each crop matches the image.</div>
            </div>
            <div id="ingredientLineLayout" style="display:flex;gap:16px;flex-wrap:wrap;align-items:flex-start">
              <div id="ingredientReferenceColumn" style="flex:1;min-width:260px;display:flex;flex-direction:column;gap:10px">
                <div style="color:#e2e8f0;font-weight:600;font-size:0.9rem">Original photo</div>
                <div style="position:relative;border-radius:10px;overflow:hidden;background:#0b1020;border:1px solid rgba(148,163,184,0.35);box-shadow:0 15px 35px rgba(0,0,0,0.35);min-height:240px">
                  <img id="ingredientReferenceImage" alt="Original ingredient list" style="width:100%;height:100%;max-height:360px;object-fit:contain;display:block;background:#000">
                  <div id="ingredientReferenceFallback" style="position:absolute;inset:0;display:none;align-items:center;justify-content:center;color:#a8b2d6;font-size:0.9rem;text-align:center;padding:12px">Original photo unavailable</div>
                  <div id="ingredientReferenceOverlay" style="position:absolute;border:2px dashed rgba(124,156,255,0.65);border-radius:6px;box-shadow:0 0 0 1px rgba(124,156,255,0.3);pointer-events:none;display:none"></div>
                </div>
                <div style="color:#94a3b8;font-size:0.82rem;line-height:1.4">Keep this visible while you check each cropped line.</div>
              </div>
              <div style="flex:1.4;min-width:280px;display:flex;flex-direction:column;gap:10px">
                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap">
                  <span style="color:#e2e8f0;font-weight:600;font-size:0.9rem">Cropped lines</span>
                  <span style="color:#a8b2d6;font-size:0.82rem">Flag anything that does not match.</span>
                </div>
                <div id="ingredientLinesContainer" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Full extracted text section -->
        <div style="background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:12px;padding:16px">
          <div style="font-weight:600;color:#fff;margin-bottom:8px;font-size:0.95rem">Extracted Ingredient List:</div>
          <p id="extractedTextDisplay" style="color:#e2e8f0;font-size:0.9rem;line-height:1.6;margin:0;white-space:pre-wrap"></p>
        </div>

        <!-- Dietary Compliance Section -->
        <div id="extractedAllergenDietSection" style="display:none;margin-top:16px"></div>

        <p style="color:#a8b2d6;font-size:0.85rem;margin:12px 0 0 0;text-align:center">Please confirm this matches the ingredient list in the photo above.</p>
        <div style="display:flex;justify-content:center;align-items:center;flex-wrap:wrap;gap:10px;margin-top:16px">
          <button type="button" class="btn useNewPhotoBtn" style="background:#6b7280;border-color:#6b7280;padding:10px 16px;font-size:0.9rem">Use New Photo</button>
          <button type="button" class="btn reportExtractionIssueBtn" style="background:#ef4444;border-color:#dc2626;padding:10px 16px;font-size:0.9rem">Report an Issue</button>
          <button type="button" class="btn confirmMatchBtn" style="background:#17663a;border-color:#1a7b46;padding:10px 16px;font-size:0.9rem">Confirm Match</button>
          <button type="button" class="btn addBrandPhotoBtn" style="background:#374151;border-color:#374151;padding:10px 16px;font-size:0.9rem;cursor:not-allowed;opacity:0.5" disabled>Add photo of brand</button>
        </div>
      </div>
      <div id="frontPhotoConfirmSection" style="display:none;margin-top:16px">
        <p style="color:#a8b2d6;font-size:0.85rem;margin:0 0 16px 0;text-align:center">Please confirm this photo shows the front of the product clearly.</p>
        <div style="display:flex;justify-content:center;align-items:center;flex-wrap:wrap;gap:10px">
          <button type="button" class="btn frontCancelBtn" style="background:#ef4444;border-color:#dc2626;padding:10px 16px;font-size:0.9rem">Cancel</button>
          <button type="button" class="btn frontReportBtn" style="background:#f59e0b;border-color:#d97706;padding:10px 16px;font-size:0.9rem">Report an Issue</button>
          <button type="button" class="btn frontNewPhotoBtn" style="background:#6b7280;border-color:#6b7280;padding:10px 16px;font-size:0.9rem">Use New Photo</button>
          <button type="button" class="btn frontConfirmBtn" style="background:#17663a;border-color:#1a7b46;padding:10px 16px;font-size:0.9rem">Confirm and Apply</button>
        </div>
      </div>
      <input type="file" id="ingredientImageUpload" accept="image/*" style="display:none">
      <input type="file" id="productFrontImageUpload" accept="image/*" style="display:none">
    </div>
  `;

      // Lock background scrolling
      let scrollLockPosition = window.pageYOffset || document.documentElement.scrollTop;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${scrollLockPosition}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';
      document.body.appendChild(photoModal);

      const video = photoModal.querySelector('#ingredientCameraVideo');
      const canvas = photoModal.querySelector('#ingredientCameraCanvas');
      const ingredientPreview = photoModal.querySelector('#ingredientPhotoPreview');
      const productFrontPreview = photoModal.querySelector('#productFrontPhotoPreview');
      const placeholder = photoModal.querySelector('#ingredientCameraPlaceholder');
      const instructionText = photoModal.querySelector('#photoInstructionText');
      const cameraBtn = photoModal.querySelector('.ingredientCameraBtn');
      const uploadBtn = photoModal.querySelector('.ingredientUploadBtn');
      const captureBtn = photoModal.querySelector('.ingredientCaptureBtn');
      const nextBtn = photoModal.querySelector('.ingredientNextBtn');
      const extractBtn = photoModal.querySelector('.ingredientExtractBtn');
      const completeBtn = photoModal.querySelector('.ingredientCompleteBtn');
      const cancelBtn = photoModal.querySelector('.ingredientCancelBtn');
      const ingredientFileInput = photoModal.querySelector('#ingredientImageUpload');
      const productFrontFileInput = photoModal.querySelector('#productFrontImageUpload');
      const statusDiv = photoModal.querySelector('#ingredientStatus');
      const extractedTextSection = photoModal.querySelector('#extractedTextSection');
      const extractedTextDisplay = photoModal.querySelector('#extractedTextDisplay');
      const lineByLineSection = photoModal.querySelector('#lineByLineSection');
      const ingredientReferenceImage = photoModal.querySelector('#ingredientReferenceImage');
      const ingredientReferenceFallback = photoModal.querySelector('#ingredientReferenceFallback');
      const ingredientReferenceOverlay = photoModal.querySelector('#ingredientReferenceOverlay');
      const ingredientLinesContainer = photoModal.querySelector('#ingredientLinesContainer');
      const useNewPhotoBtn = photoModal.querySelector('.useNewPhotoBtn');
      const reportExtractionIssueBtn = photoModal.querySelector('.reportExtractionIssueBtn');
      const confirmMatchBtn = photoModal.querySelector('.confirmMatchBtn');
      const addBrandPhotoBtn = photoModal.querySelector('.addBrandPhotoBtn');
      const extractedAllergenDietSection = photoModal.querySelector('#extractedAllergenDietSection');
      const frontPhotoConfirmSection = photoModal.querySelector('#frontPhotoConfirmSection');
      const frontCancelBtn = photoModal.querySelector('.frontCancelBtn');
      const frontReportBtn = photoModal.querySelector('.frontReportBtn');
      const frontNewPhotoBtn = photoModal.querySelector('.frontNewPhotoBtn');
      const frontConfirmBtn = photoModal.querySelector('.frontConfirmBtn');

      let mediaStream = null;
      let capturedIngredientPhoto = null;
      let capturedProductFrontPhoto = null;
      let currentStep = 'ingredient'; // 'ingredient' or 'front'
      let extractedIngredientData = null; // Store extracted ingredient data to use when completing
      let extractionConfirmed = false; // Track if user confirmed the extraction matches

      const stopCamera = () => {
        if (mediaStream) {
          mediaStream.getTracks().forEach(track => track.stop());
          mediaStream = null;
        }
        if (video) video.srcObject = null;
      };

      const closeModal = () => {
        stopCamera();
        if (photoModal && photoModal.parentNode) {
          photoModal.parentNode.removeChild(photoModal);
        }
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.style.overflow = '';
        window.scrollTo(0, scrollLockPosition);
      };

      // Function to render ingredient region verification
      const renderIngredientRegion = async (ingredientRegion, imageData, ingredientLines) => {
        // Debug logging
        console.log('renderIngredientRegion called with:', {
          hasRegion: !!ingredientRegion,
          linesCount: ingredientLines?.length,
          lines: ingredientLines
        });

        ingredientLinesContainer.innerHTML = '';
        const unavailableMessage = '<div style="color:#a8b2d6;font-size:0.85rem;padding:12px;border:1px solid rgba(148,163,184,0.25);border-radius:8px;background:rgba(76,90,212,0.05)">We could not load the image for line-by-line verification. Please retake or re-upload the ingredient photo.</div>';

        const sourceImage = imageData || capturedIngredientPhoto || '';

        if (ingredientReferenceImage) {
          if (sourceImage) {
            ingredientReferenceImage.src = sourceImage;
            ingredientReferenceImage.style.display = 'block';
            if (ingredientReferenceFallback) ingredientReferenceFallback.style.display = 'none';
          } else {
            ingredientReferenceImage.removeAttribute('src');
            ingredientReferenceImage.style.display = 'none';
            if (ingredientReferenceFallback) ingredientReferenceFallback.style.display = 'flex';
          }
        }

        if (!sourceImage) {
          ingredientLinesContainer.innerHTML = unavailableMessage;
          lineByLineSection.style.display = 'block';
          return;
        }

        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = sourceImage;

        try {
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = reject;
          });
        } catch (err) {
          console.error('Failed to load ingredient image for cropping:', err);
          ingredientLinesContainer.innerHTML = unavailableMessage;
          lineByLineSection.style.display = 'block';
          return;
        }

        const imgWidth = img.naturalWidth || img.width;
        const imgHeight = img.naturalHeight || img.height;
        console.log('Image dimensions:', imgWidth, 'x', imgHeight);

        if (!imgWidth || !imgHeight) {
          ingredientLinesContainer.innerHTML = unavailableMessage;
          lineByLineSection.style.display = 'block';
          return;
        }

        // Helper to handle both 0-1 and 0-100 ranges
        const normalizeRatio = (value) => {
          if (typeof value !== 'number' || Number.isNaN(value)) return 0;
          if (value > 1 && value <= 100) return value / 100;
          if (value > 100) return value / 1000;
          return value;
        };

        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        // --- VISUAL DEBUGGING START ---
        // (Debug removed for production)
        if (ingredientReferenceOverlay) {
          const oldDebug = ingredientReferenceOverlay.querySelector('canvas.debug-layer');
          if (oldDebug) oldDebug.remove();
          const oldInfo = ingredientReferenceOverlay.querySelector('div'); // Potential info box
          if (oldInfo && oldInfo.textContent && oldInfo.textContent.includes('Img:')) oldInfo.remove();
        }
        // --- VISUAL DEBUGGING END ---

        const lines = Array.isArray(ingredientLines)
          ? ingredientLines.filter(line => line && typeof line.x === 'number' && line.text)
          : [];

        const fragment = document.createDocumentFragment();

        let minX = imgWidth;
        let minY = imgHeight;
        let maxX = 0;
        let maxY = 0;
        let hasValidLines = false;

        // Calculate full bounds first
        lines.forEach((line) => {
          // Handle flat structure
          const normX = normalizeRatio(line.x);
          const normY = normalizeRatio(line.y);
          const normW = normalizeRatio(line.w || line.width);
          const normH = normalizeRatio(line.h || line.height);

          const pixelX = Math.round(normX * imgWidth);
          const pixelY = Math.round(normY * imgHeight);
          const pixelW = Math.round(normW * imgWidth);
          const pixelH = Math.round(normH * imgHeight);

          const cx = clamp(pixelX, 0, imgWidth);
          const cy = clamp(pixelY, 0, imgHeight);
          const cw = clamp(pixelW, 1, imgWidth - cx);
          const ch = clamp(pixelH, 1, imgHeight - cy);

          if (cw < 2 || ch < 2) return;

          hasValidLines = true;
          minX = Math.min(minX, cx);
          minY = Math.min(minY, cy);
          maxX = Math.max(maxX, cx + cw);
          maxY = Math.max(maxY, cy + ch);
        });

        // 1. Create Layout Changes (Vertical Stack)
        // 1. Reset Layout (ensure it's not overridden)
        const layoutContainer = document.getElementById('ingredientLineLayout');
        if (layoutContainer) {
          // Reset to defaults defined in HTML/CSS
          layoutContainer.style.removeProperty('flex-direction');
          layoutContainer.style.removeProperty('align-items');
        }

        ingredientLinesContainer.style.display = 'flex';
        ingredientLinesContainer.style.flexDirection = 'column';
        ingredientLinesContainer.style.gap = '24px';
        ingredientLinesContainer.style.gridTemplateColumns = 'none'; // Overwrite grid

        // 2. Add Full Ingredient List Crop at the top
        if (hasValidLines) {
          const fullW = maxX - minX;
          const fullH = maxY - minY;

          // Add some padding to the full crop
          const padding = 20;
          const paddedX = clamp(minX - padding, 0, imgWidth);
          const paddedY = clamp(minY - padding, 0, imgHeight);
          const paddedW = clamp(fullW + (padding * 2), 1, imgWidth - paddedX);
          const paddedH = clamp(fullH + (padding * 2), 1, imgHeight - paddedY);

          const fullCanvas = document.createElement('canvas');
          fullCanvas.width = paddedW;
          fullCanvas.height = paddedH;
          const fCtx = fullCanvas.getContext('2d');
          fCtx.drawImage(img, paddedX, paddedY, paddedW, paddedH, 0, 0, paddedW, paddedH);

          const fullCropElement = document.createElement('div');
          fullCropElement.style.cssText = `
              display:flex;
              flex-direction:column;
              gap:12px;
              padding:16px;
              background:rgba(23, 102, 58, 0.2);
              border-radius:12px;
              border:1px solid rgba(74, 222, 128, 0.3);
              margin-bottom: 24px;
            `;

          const fullHeader = document.createElement('div');
          fullHeader.innerHTML = '<span style="font-size:1.1rem"> Full Ingredient List</span>';
          fullHeader.style.cssText = `
              color:#86efac;
              font-weight:600;
              letter-spacing:0.02em;
              border-bottom: 1px solid rgba(74, 222, 128, 0.2);
              padding-bottom: 8px;
            `;

          const fullImg = document.createElement('img');
          fullImg.src = fullCanvas.toDataURL();
          fullImg.style.cssText = `
              width:100%;
              max-height:300px;
              object-fit:contain;
              border-radius:8px;
              border:1px solid rgba(148,163,184,0.4);
              background:#000;
            `;

          fullCropElement.appendChild(fullHeader);
          fullCropElement.appendChild(fullImg);
          ingredientLinesContainer.appendChild(fullCropElement);
        }

        // 3. Render Individual Lines
        lines.forEach((line, idx) => {

          // Convert normalized/percentage coordinates to GLOBAL pixel coordinates
          const normX = normalizeRatio(line.x);
          const normY = normalizeRatio(line.y);
          const normW = normalizeRatio(line.w || line.width);
          const normH = normalizeRatio(line.h || line.height);

          const pixelX = Math.round(normX * imgWidth);
          const pixelY = Math.round(normY * imgHeight);
          const pixelW = Math.round(normW * imgWidth);
          const pixelH = Math.round(normH * imgHeight);

          console.log(`Line ${idx + 1} coords:`, { line, pixel: { x: pixelX, y: pixelY, w: pixelW, h: pixelH } });

          // Add moderate padding to ensure text isn't cut off
          const padding = 10;
          const paddedX = pixelX - padding;
          const paddedY = pixelY - padding;
          const paddedW = pixelW + (padding * 2);
          const paddedH = pixelH + (padding * 2);

          // Validate bounds
          const cx = clamp(paddedX, 0, imgWidth);
          const cy = clamp(paddedY, 0, imgHeight);
          const cw = clamp(paddedW, 1, imgWidth - cx);
          const ch = clamp(paddedH, 1, imgHeight - cy);

          if (cw < 2 || ch < 2) return;

          hasValidLines = true;
          minX = Math.min(minX, cx);
          minY = Math.min(minY, cy);
          maxX = Math.max(maxX, cx + cw);
          maxY = Math.max(maxY, cy + ch);

          const lineCanvas = document.createElement('canvas');
          lineCanvas.width = cw;
          lineCanvas.height = ch;
          const ctx = lineCanvas.getContext('2d');

          // Draw the crop from the ORIGINAL global image
          ctx.drawImage(img, cx, cy, cw, ch, 0, 0, cw, ch);

          const lineElement = document.createElement('div');
          lineElement.style.cssText = `
              display:flex;
              flex-direction:column;
              gap:10px;
              padding:16px;
              background:rgba(30, 41, 59, 0.4);
              border-radius:10px;
              border:1px solid rgba(148,163,184,0.2);
            `;

          const header = document.createElement('div');
          header.style.cssText = `
              color:#94a3b8;
              font-size:0.8rem;
              letter-spacing:0.05em;
              text-transform:uppercase;
              font-weight: 600;
            `;
          header.textContent = `Line ${idx + 1}`;

          const croppedImg = document.createElement('img');
          croppedImg.src = lineCanvas.toDataURL();
          croppedImg.style.cssText = `
              width:100%;
              max-height:180px;
              object-fit:contain;
              border-radius:6px;
              border:1px solid rgba(148,163,184,0.4);
              background:#000;
            `;

          const label = document.createElement('div');
          label.style.cssText = `
              color:#fff;
              font-size:1.1rem;
              font-weight:500;
              line-height:1.4;
              text-align:center;
              word-wrap:break-word;
              padding: 8px;
              background: rgba(0,0,0,0.2);
              border-radius: 6px;
            `;
          label.textContent = line.text;

          lineElement.appendChild(header);
          lineElement.appendChild(croppedImg);
          lineElement.appendChild(label);
          fragment.appendChild(lineElement);
        });

        if (fragment.childNodes.length === 0) {
          ingredientLinesContainer.innerHTML = '<div style="color:#a8b2d6;font-size:0.85rem;padding:12px;border:1px solid rgba(148,163,184,0.25);border-radius:8px;background:rgba(76,90,212,0.05)">No line-level crops were returned. Please retake the photo if the text looks off.</div>';
        } else {
          ingredientLinesContainer.appendChild(fragment);
        }

        // We skip the old bounding box logic since we now use the full debug overlay
        lineByLineSection.style.display = 'block';
      };

      // Function to clean up extracted text using Haiku
      const cleanupExtractedText = async (rawText) => {
        try {
          const cleanupResult = await window.supabaseClient.functions.invoke('cleanup-ingredient-text', {
            body: { rawText }
          });
          if (cleanupResult.error || !cleanupResult.data?.cleanedText) {
            console.log('Cleanup failed or no cleaned text, using original');
            return rawText;
          }
          return cleanupResult.data.cleanedText;
        } catch (err) {
          console.error('Error calling cleanup function:', err);
          return rawText;
        }
      };

      // Function to render allergen/diet results in the same format as barcode scanner UI
      const renderAllergenDietResults = (allergenData, dietData) => {
        const allTop9 = ['Dairy', 'Egg', 'Peanut', 'Tree Nut', 'Soy', 'Wheat', 'Fish', 'Shellfish', 'Sesame'];
        const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];

        const escText = (text) => {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        };

        // Dietary Compliance first (to match barcode scanner UI order)
        let dietHtml = '<div style="margin-bottom: 16px;"><h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1rem; font-weight: 600;">Dietary Compliance</h3><div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
        allDiets.forEach(diet => {
          const data = dietData[diet] || { is_compliant: true, reason: '' };
          // dietary_compliance uses is_compliant (true = compliant, false = violation)
          const isCompliant = data.is_compliant !== false;
          const reason = data.reason || '';
          const bgColor = isCompliant ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)';
          const borderColor = isCompliant ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
          const titleColor = isCompliant ? '#fff' : '#fca5a5';
          const icon = isCompliant ? '' : '';
          const iconBg = isCompliant ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
          const iconColor = isCompliant ? '#4ade80' : '#f87171';

          dietHtml += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:4px;">';
          dietHtml += '<div style="display:flex;justify-content:space-between;align-items:center;">';
          dietHtml += '<span style="font-weight:600;color:' + titleColor + ';font-size:0.9rem;">' + diet + '</span>';
          dietHtml += '<span style="background:' + iconBg + ';color:' + iconColor + ';width:20px;height:20px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:0.8rem;font-weight:bold;">' + icon + '</span>';
          dietHtml += '</div>';
          if (!isCompliant && reason) {
            dietHtml += '<div style="font-size:0.8rem;color:#fca5a5;line-height:1.3;"> ' + escText(reason) + '</div>';
          } else {
            dietHtml += '<div style="font-size:0.8rem;color:#86efac;">Complies with diet</div>';
          }
          dietHtml += '</div>';
        });
        dietHtml += '</div></div>';

        // Allergen Check second
        let allergenHtml = '<div><h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1rem; font-weight: 600;">Allergen Check</h3><div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
        allTop9.forEach(allergen => {
          // allergens is an array of {name, triggers} objects from analyze-brand-allergens
          const allergenObj = Array.isArray(allergenData) ? allergenData.find(a => a.name === allergen) : null;
          const flagged = allergenObj && allergenObj.triggers && allergenObj.triggers.length > 0;
          const triggers = allergenObj ? allergenObj.triggers || [] : [];
          const bgColor = flagged ? 'rgba(239,68,68,0.1)' : 'rgba(34,197,94,0.1)';
          const borderColor = flagged ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)';
          const titleColor = flagged ? '#fca5a5' : '#fff';
          const icon = flagged ? '' : '';
          const iconBg = flagged ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)';
          const iconColor = flagged ? '#f87171' : '#4ade80';

          allergenHtml += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:4px;">';
          allergenHtml += '<div style="display:flex;justify-content:space-between;align-items:center;">';
          allergenHtml += '<span style="font-weight:600;color:' + titleColor + ';font-size:0.9rem;">' + allergen + '</span>';
          allergenHtml += '<span style="background:' + iconBg + ';color:' + iconColor + ';width:20px;height:20px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:0.8rem;font-weight:bold;">' + icon + '</span>';
          allergenHtml += '</div>';
          if (flagged && triggers.length > 0) {
            allergenHtml += '<div style="font-size:0.8rem;color:#fca5a5;line-height:1.3;">' + triggers.map(t => ' ' + escText(t)).join('<br>') + '</div>';
          } else {
            allergenHtml += '<div style="font-size:0.8rem;color:#86efac;">Not detected</div>';
          }
          allergenHtml += '</div>';
        });
        allergenHtml += '</div></div>';

        return dietHtml + allergenHtml;
      };

      // Function to extract ingredients from photo
      const extractIngredients = async () => {
        if (!capturedIngredientPhoto) {
          statusDiv.textContent = 'Please take a photo of the ingredient list first';
          statusDiv.style.color = '#ef4444';
          return;
        }

        // Show extracting status
        statusDiv.textContent = 'Extracting ingredient list from photo...';
        statusDiv.style.color = '#a8b2d6';
        cameraBtn.style.display = 'none';
        uploadBtn.style.display = 'none';

        try {
          // Call the extract-ingredients-from-photo edge function
          const result = await window.supabaseClient.functions.invoke('extract-ingredients-from-photo', {
            body: {
              imageData: capturedIngredientPhoto,
              barcode: barcode || ''
            }
          });

          if (result.error) {
            console.error('Extraction error:', result.error);
            statusDiv.textContent = 'Failed to extract ingredients: ' + (result.error.message || 'Unknown error');
            statusDiv.style.color = '#ef4444';
            cameraBtn.style.display = 'inline-block';
            uploadBtn.style.display = 'inline-block';
            return;
          }

          const data = result.data;

          // Check if photo needs to be retaken
          if (data.needsRetake) {
            statusDiv.innerHTML = `
          <div style="color:#ef4444;margin-bottom:12px;font-weight:600">${data.message || 'The photo is too blurry or unclear to read.'}</div>
          <div style="color:#a8b2d6;font-size:0.9rem;margin-bottom:12px">
            <strong>Tips for a better photo:</strong><br>
             Ensure good lighting<br>
             Hold the camera steady<br>
             Make sure the text is in focus<br>
             Get close enough to read the text clearly
          </div>
        `;
            statusDiv.style.color = '#ef4444';
            // Clear the captured photo so user can retake
            capturedIngredientPhoto = null;
            ingredientPreview.style.display = 'none';
            resetToStep('ingredient');
            return;
          }

          if (!data.success || !data.ingredientList) {
            statusDiv.innerHTML = `
          <div style="color:#ef4444;margin-bottom:12px;font-weight:600">${data.message || 'Could not extract ingredient list from photo'}</div>
          <div style="color:#a8b2d6;font-size:0.9rem">
            Please try taking a new photo with better focus and lighting.
          </div>
        `;
            statusDiv.style.color = '#ef4444';
            // Clear the captured photo so user can retake
            capturedIngredientPhoto = null;
            ingredientPreview.style.display = 'none';
            resetToStep('ingredient');
            return;
          }

          // Success! Clean up the extracted text with Haiku
          statusDiv.textContent = 'Cleaning up extracted text...';
          const cleanedText = await cleanupExtractedText(data.ingredientList);

          // Store the extracted and cleaned data
          extractedIngredientData = { ...data, ingredientList: cleanedText };

          // Show the extracted text for user confirmation
          extractedTextDisplay.textContent = cleanedText || '';
          extractedTextSection.style.display = 'block';

          // Render ingredient region verification if available
          const hasVerificationImage = data.imageData || capturedIngredientPhoto;
          if ((data.ingredientRegion || (data.ingredientLines && data.ingredientLines.length > 0)) && hasVerificationImage) {
            try {
              await renderIngredientRegion(data.ingredientRegion, data.imageData || capturedIngredientPhoto, data.ingredientLines);
            } catch (regionRenderErr) {
              console.error('Failed to render ingredient region:', regionRenderErr);
              // Continue without region display
            }
          }

          // Analyze allergens and diets using same function as barcode scanner
          statusDiv.textContent = 'Analyzing allergens and dietary compliance...';
          try {
            // Use analyze-brand-allergens (same as barcode scanner) - pass full text, not array
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: { ingredientText: cleanedText }
            });

            console.log('Raw API response:', JSON.stringify(analysisResult.data, null, 2));
            if (!analysisResult.error && analysisResult.data) {
              const { allergens, dietary_compliance } = analysisResult.data;
              console.log('Parsed allergens:', JSON.stringify(allergens, null, 2));
              console.log('Parsed dietary_compliance:', JSON.stringify(dietary_compliance, null, 2));
              // Store for later use when completing
              extractedIngredientData.allergenData = allergens;
              extractedIngredientData.dietData = dietary_compliance;
              // Display the results
              extractedAllergenDietSection.innerHTML = renderAllergenDietResults(allergens, dietary_compliance);
              extractedAllergenDietSection.style.display = 'block';
            }
          } catch (analysisErr) {
            console.error('Failed to analyze allergens/diets:', analysisErr);
            // Continue without allergen/diet display
          }

          statusDiv.textContent = ' Ingredients extracted! Please verify the text below matches the photo.';
          statusDiv.style.color = '#4ade80';

          // Reset confirmation state
          extractionConfirmed = false;
          addBrandPhotoBtn.disabled = true;
          addBrandPhotoBtn.style.opacity = '0.5';
          addBrandPhotoBtn.style.cursor = 'not-allowed';
          addBrandPhotoBtn.style.background = '#374151';
          addBrandPhotoBtn.style.borderColor = '#374151';

          // Hide buttons
          extractBtn.style.display = 'none';
          nextBtn.style.display = 'none';
          cameraBtn.style.display = 'none';
          uploadBtn.style.display = 'none';
          cancelBtn.style.display = 'none';

        } catch (error) {
          console.error('Error extracting ingredients:', error);
          statusDiv.textContent = 'Error extracting ingredients: ' + (error.message || 'Unknown error');
          statusDiv.style.color = '#ef4444';
          cameraBtn.style.display = 'inline-block';
          uploadBtn.style.display = 'inline-block';
        }
      };

      const showPreview = (dataUrl, step) => {
        if (step === 'ingredient') {
          capturedIngredientPhoto = dataUrl;
          placeholder.style.display = 'none';
          video.style.display = 'none';
          productFrontPreview.style.display = 'none';
          ingredientPreview.style.display = 'block';
          ingredientPreview.src = dataUrl;
          captureBtn.style.display = 'none';
          extractBtn.style.display = 'none'; // Hide extract button - auto-extract
          nextBtn.style.display = 'none';
          cameraBtn.style.display = 'none';
          uploadBtn.style.display = 'none';
          // Auto-extract ingredients
          extractIngredients();
        } else if (step === 'front') {
          capturedProductFrontPhoto = dataUrl;
          placeholder.style.display = 'none';
          video.style.display = 'none';
          ingredientPreview.style.display = 'none';
          productFrontPreview.style.display = 'block';
          productFrontPreview.src = dataUrl;
          captureBtn.style.display = 'none';
          nextBtn.style.display = 'none';
          extractBtn.style.display = 'none';
          completeBtn.style.display = 'none';
          cameraBtn.style.display = 'none';
          uploadBtn.style.display = 'none';
          cancelBtn.style.display = 'none';
          // Show front photo confirmation buttons
          frontPhotoConfirmSection.style.display = 'block';
          statusDiv.textContent = '';
        }
      };

      const resetToStep = (step) => {
        currentStep = step;
        if (step === 'ingredient') {
          instructionText.textContent = 'Step 1: Please take a photo of the ingredient list on the product packaging';
          ingredientPreview.style.display = 'none';
          productFrontPreview.style.display = 'none';
          placeholder.style.display = 'flex';
          nextBtn.style.display = 'none';
          extractBtn.style.display = 'none';
          completeBtn.style.display = 'none';
          cameraBtn.style.display = 'inline-block';
          uploadBtn.style.display = 'inline-block';
          uploadBtn.textContent = ' Upload Photo';
          cameraBtn.textContent = ' Use Camera';
          ingredientFileInput.value = '';
          extractedIngredientData = null; // Reset extracted data
          extractionConfirmed = false; // Reset confirmation state
          extractedTextSection.style.display = 'none'; // Hide extracted text section
          extractedAllergenDietSection.style.display = 'none'; // Hide allergen/diet section
          lineByLineSection.style.display = 'none'; // Hide line-by-line section
          ingredientLinesContainer.innerHTML = ''; // Clear line-by-line content
          if (ingredientReferenceImage) {
            ingredientReferenceImage.removeAttribute('src');
            ingredientReferenceImage.style.display = 'none';
          }
          if (ingredientReferenceFallback) {
            ingredientReferenceFallback.style.display = 'none';
          }
          // Reset confirm match button visibility
          confirmMatchBtn.style.display = 'inline-block';
          // Reset add brand photo button to disabled state
          addBrandPhotoBtn.disabled = true;
          addBrandPhotoBtn.style.opacity = '0.5';
          addBrandPhotoBtn.style.cursor = 'not-allowed';
          addBrandPhotoBtn.style.background = '#374151';
          addBrandPhotoBtn.style.borderColor = '#374151';
        } else if (step === 'front') {
          instructionText.textContent = 'Step 2: Please take a photo of the front of the product (this will be used as the thumbnail)';
          ingredientPreview.style.display = 'none';
          productFrontPreview.style.display = 'none';
          placeholder.style.display = 'flex';
          nextBtn.style.display = 'none';
          extractBtn.style.display = 'none';
          completeBtn.style.display = 'none';
          cameraBtn.style.display = 'inline-block';
          uploadBtn.style.display = 'inline-block';
          cancelBtn.style.display = 'inline-block';
          uploadBtn.textContent = ' Upload Photo';
          cameraBtn.textContent = ' Use Camera';
          productFrontFileInput.value = '';
          frontPhotoConfirmSection.style.display = 'none';
        }
      };

      cameraBtn.addEventListener('click', async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
          mediaStream = stream;
          video.srcObject = stream;
          video.play();
          placeholder.style.display = 'none';
          video.style.display = 'block';
          ingredientPreview.style.display = 'none';
          productFrontPreview.style.display = 'none';
          captureBtn.style.display = 'inline-block';
          nextBtn.style.display = 'none';
          extractBtn.style.display = 'none';
          if (currentStep === 'ingredient') {
            statusDiv.textContent = 'Position the ingredient list in view and click Capture';
          } else {
            statusDiv.textContent = 'Position the front of the product in view and click Capture';
          }
        } catch (err) {
          console.error('Camera access failed', err);
          statusDiv.textContent = 'Could not access camera: ' + (err.message || err);
          statusDiv.style.color = '#ef4444';
        }
      });

      captureBtn.addEventListener('click', () => {
        if (video && video.videoWidth > 0) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
          showPreview(dataUrl, currentStep);
          stopCamera();
        }
      });

      uploadBtn.addEventListener('click', () => {
        if (currentStep === 'ingredient') {
          ingredientFileInput.click();
        } else {
          productFrontFileInput.click();
        }
      });

      ingredientFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            showPreview(event.target.result, 'ingredient');
          };
          reader.readAsDataURL(file);
        }
      });

      productFrontFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            showPreview(event.target.result, 'front');
          };
          reader.readAsDataURL(file);
        }
      });

      nextBtn.addEventListener('click', () => {
        if (extractedIngredientData && capturedIngredientPhoto) {
          resetToStep('front');
          statusDiv.textContent = ' Ingredients extracted. Now take a photo of the product front.';
          statusDiv.style.color = '#4ade80';
        } else {
          statusDiv.textContent = 'Please extract ingredients first before proceeding';
          statusDiv.style.color = '#ef4444';
        }
      });

      // Use New Photo button handler - reset to take a new photo
      useNewPhotoBtn.addEventListener('click', () => {
        extractedTextSection.style.display = 'none';
        extractedAllergenDietSection.style.display = 'none';
        lineByLineSection.style.display = 'none';
        ingredientLinesContainer.innerHTML = '';
        if (ingredientReferenceOverlay) {
          ingredientReferenceOverlay.style.display = 'none';
        }
        extractionConfirmed = false;
        extractedIngredientData = null;
        capturedIngredientPhoto = null;
        statusDiv.textContent = '';
        resetToStep('ingredient');
        cancelBtn.style.display = 'inline-block';
      });

      // Report an Issue button handler
      reportExtractionIssueBtn.addEventListener('click', () => {
        const reportModal = document.createElement('div');
        reportModal.style.cssText = `
          position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.8); z-index: 10002;
          display: flex; align-items: center; justify-content: center;
        `;

        reportModal.innerHTML = `
          <div style="background: #1e293b; padding: 24px; border-radius: 12px; width: 90%; max-width: 500px; border: 1px solid rgba(148, 163, 184, 0.2);">
            <h3 style="color: #fff; margin: 0 0 16px 0;">Report Extraction Issue</h3>
            <p style="color: #94a3b8; margin-bottom: 16px; font-size: 0.9rem;">Please describe what's wrong with the extracted text.</p>
            <textarea style="width: 100%; height: 100px; background: rgba(0,0,0,0.2); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #fff; padding: 12px; margin-bottom: 16px; resize: vertical; box-sizing: border-box;" placeholder="e.g. The extracted text is missing some ingredients, text is garbled, etc."></textarea>
            <div style="display: flex; justify-content: flex-end; gap: 12px;">
              <button class="cancelReportBtn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 6px; cursor: pointer;">Cancel</button>
              <button class="sendReportBtn" style="padding: 8px 16px; background: #f87171; border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600;">Send Report</button>
            </div>
          </div>
        `;

        document.body.appendChild(reportModal);

        reportModal.querySelector('.cancelReportBtn').onclick = () => document.body.removeChild(reportModal);

        reportModal.querySelector('.sendReportBtn').onclick = async function () {
          const msg = reportModal.querySelector('textarea').value;
          if (!msg) return;

          this.textContent = 'Sending...';
          this.disabled = true;

          try {
            await fetch('https://fgoiyycctnwnghrvsilt.supabase.co/functions/v1/report-issue', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                message: msg,
                productName: ingredientName,
                barcode: null,
                analysisDetails: {
                  extractedText: extractedIngredientData?.ingredientList || '',
                  source: 'Photo extraction'
                }
              })
            });

            document.body.removeChild(reportModal);
            statusDiv.textContent = 'Issue reported. Thank you! You can try a new photo or close this window.';
            statusDiv.style.color = '#4ade80';
          } catch (e) {
            console.error('Failed to report issue:', e);
            this.textContent = 'Error';
            setTimeout(() => {
              document.body.removeChild(reportModal);
            }, 1000);
          }
        };
      });

      // Confirm Match button handler - enables the Add Brand Photo button
      confirmMatchBtn.addEventListener('click', () => {
        extractionConfirmed = true;
        addBrandPhotoBtn.disabled = false;
        addBrandPhotoBtn.style.opacity = '1';
        addBrandPhotoBtn.style.cursor = 'pointer';
        addBrandPhotoBtn.style.background = '#4c5ad4';
        addBrandPhotoBtn.style.borderColor = '#4c5ad4';
        statusDiv.textContent = ' Confirmed! Now click "Add photo of brand" to take a photo of the product front.';
        statusDiv.style.color = '#4ade80';
        // Grey out and show confirmed state instead of hiding
        confirmMatchBtn.disabled = true;
        confirmMatchBtn.textContent = ' Confirmed';
        confirmMatchBtn.style.background = '#6b7280';
        confirmMatchBtn.style.borderColor = '#6b7280';
        confirmMatchBtn.style.cursor = 'default';
        confirmMatchBtn.style.opacity = '0.7';
      });

      // Add Brand Photo button handler - moves to product front photo step
      addBrandPhotoBtn.addEventListener('click', () => {
        if (!extractionConfirmed) return;

        // Hide extracted text section
        extractedTextSection.style.display = 'none';

        // Move to product front photo step
        currentStep = 'front';
        instructionText.textContent = 'Step 2: Please take a photo of the front of the product (for identification)';

        // Reset preview to show placeholder
        ingredientPreview.style.display = 'none';
        productFrontPreview.style.display = 'none';
        placeholder.style.display = 'flex';
        placeholder.textContent = 'No photo taken yet';

        // Show camera/upload buttons
        cameraBtn.style.display = 'inline-block';
        cameraBtn.textContent = ' Use Camera';
        uploadBtn.style.display = 'inline-block';
        uploadBtn.textContent = ' Upload Photo';
        cancelBtn.style.display = 'inline-block';
        completeBtn.style.display = 'none';

        // Clear product front file input
        productFrontFileInput.value = '';

        statusDiv.textContent = '';
      });

      // Complete button handler - finishes the flow after both photos are taken
      completeBtn.addEventListener('click', async () => {
        if (!extractedIngredientData || !capturedProductFrontPhoto) {
          statusDiv.textContent = 'Please complete both steps: ingredient photo and product front photo';
          statusDiv.style.color = '#ef4444';
          return;
        }

        // Close modal and update row
        closeModal();
        const brand = ingredientName || '';
        const extractedIngredientList = extractedIngredientData.ingredientList || '';

        // Analyze ingredient list for allergens and dietary preferences
        let aiAllergens = [];
        let aiDiets = [];

        try {
          const { data: analysisData, error } = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
            body: { ingredientText: extractedIngredientList }
          });
          if (!error && analysisData) {
            // Extract allergen names from objects {name: "...", triggers: [...]}
            const rawAllergens = Array.isArray(analysisData.allergens) ? analysisData.allergens : [];
            aiAllergens = rawAllergens.map(a => typeof a === 'object' && a.name ? a.name : a);
            aiDiets = Array.isArray(analysisData.diets) ? analysisData.diets : [];
          }
        } catch (err) {
          console.error('Failed to analyze allergens/diets from photo extraction:', err);
        }

        // Create suggestion object with analyzed allergens/diets - use product front photo as brandImage (thumbnail)
        const suggestion = {
          name: ingredientName,
          brand: brand,
          brandImage: capturedProductFrontPhoto || '', // Use product front photo as thumbnail
          ingredientsImage: capturedIngredientPhoto || '', // Use ingredient label photo
          ingredientsList: [extractedIngredientList],
          allergens: aiAllergens,
          diets: aiDiets
        };

        // Directly apply the brand suggestion (skip the "View Results" step)
        applyBrandSuggestionConfirmed(rowIdx, suggestion);

        aiAssistSetStatus(`Ingredients extracted and applied for ${ingredientName}`, 'success');
      });

      // Front photo confirmation button handlers
      frontCancelBtn.addEventListener('click', closeModal);

      frontReportBtn.addEventListener('click', () => {
        // Show report issue modal for front photo
        showAllergenIssueCommentModal(
          ingredientName || 'Unknown Product',
          barcode || '',
          extractedIngredientData?.ingredientList || '',
          [], // allergens
          [], // diets
          [] // sources
        );
      });

      frontNewPhotoBtn.addEventListener('click', () => {
        // Reset to take a new front photo
        frontPhotoConfirmSection.style.display = 'none';
        capturedProductFrontPhoto = null;
        productFrontPreview.style.display = 'none';
        placeholder.style.display = 'flex';
        cameraBtn.style.display = 'inline-block';
        uploadBtn.style.display = 'inline-block';
        cancelBtn.style.display = 'inline-block';
        statusDiv.textContent = 'Take a new photo of the front of the product';
        statusDiv.style.color = '#a8b2d6';
      });

      frontConfirmBtn.addEventListener('click', async () => {
        if (!extractedIngredientData || !capturedProductFrontPhoto) {
          statusDiv.textContent = 'Please complete both steps: ingredient photo and product front photo';
          statusDiv.style.color = '#ef4444';
          return;
        }

        // Close modal and update row (same logic as completeBtn)
        closeModal();
        const brand = ingredientName || '';
        const extractedIngredientList = extractedIngredientData.ingredientList || '';

        // Analyze ingredient list for allergens and dietary preferences
        let aiAllergens = [];
        let aiDiets = [];

        try {
          const { data: analysisData, error } = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
            body: { ingredientText: extractedIngredientList }
          });
          if (!error && analysisData) {
            // Extract allergen names from objects {name: "...", triggers: [...]}
            const rawAllergens = Array.isArray(analysisData.allergens) ? analysisData.allergens : [];
            aiAllergens = rawAllergens.map(a => typeof a === 'object' && a.name ? a.name : a);
            aiDiets = Array.isArray(analysisData.diets) ? analysisData.diets : [];
          }
        } catch (err) {
          console.error('Failed to analyze allergens/diets from photo extraction:', err);
        }

        // Create suggestion object with analyzed allergens/diets
        const suggestion = {
          name: ingredientName,
          brand: brand,
          brandImage: capturedProductFrontPhoto || '',
          ingredientsImage: capturedIngredientPhoto || '',
          ingredientsList: [extractedIngredientList],
          allergens: aiAllergens,
          diets: aiDiets
        };

        // Directly apply the brand suggestion (skip the "View Results" step)
        applyBrandSuggestionConfirmed(rowIdx, suggestion);

        aiAssistSetStatus(`Ingredients extracted and applied for ${ingredientName}`, 'success');
      });

      cancelBtn.addEventListener('click', closeModal);
      photoModal.addEventListener('click', (e) => {
        if (e.target === photoModal) closeModal();
      });
    }

    // Global function to check dietary/allergen flags via edge function
    async function checkDietaryAllergens(ingredients) {
      // Handle both array and comma-separated string formats
      let ingredientArray;
      if (Array.isArray(ingredients)) {
        ingredientArray = ingredients;
      } else if (typeof ingredients === 'string') {
        ingredientArray = ingredients.split(',').map(s => s.trim());
      } else {
        ingredientArray = [];
      }

      if (ingredientArray.length === 0) {
        return {
          allergens: {
            'Dairy': { flagged: false, triggers: [] },
            'Egg': { flagged: false, triggers: [] },
            'Peanut': { flagged: false, triggers: [] },
            'Tree Nut': { flagged: false, triggers: [] },
            'Soy': { flagged: false, triggers: [] },
            'Wheat': { flagged: false, triggers: [] },
            'Fish': { flagged: false, triggers: [] },
            'Shellfish': { flagged: false, triggers: [] },
            'Sesame': { flagged: false, triggers: [] }
          },
          diets: {
            'Vegan': { flagged: false, triggers: [] },
            'Vegetarian': { flagged: false, triggers: [] },
            'Pescatarian': { flagged: false, triggers: [] },
            'Gluten-free': { flagged: false, triggers: [] }
          }
        };
      }

      try {
        const response = await fetch(`${SUPABASE_URL}/functions/v1/check-dietary-allergens`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${SUPABASE_KEY}`
          },
          body: JSON.stringify({ ingredients: ingredientArray })
        });

        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }

        return await response.json();
      } catch (err) {
        console.error('checkDietaryAllergens error:', err);
        // Return empty results on error
        return {
          allergens: {},
          diets: {}
        };
      }
    }

    // Search Open Food Facts for a product by name and return its barcode (US products preferred)
    // Prioritizes common brands with complete data for better lookup success
    async function searchProductBarcodeByName(searchTerm) {
      try {
        // Use US-specific Open Food Facts search API with country filter
        const searchUrl = `https://us.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(searchTerm)}&search_simple=1&action=process&json=1&page_size=30&tagtype_0=countries&tag_contains_0=contains&tag_0=united-states`;
        console.log(`[OpenFoodFacts] Searching US products for: ${searchTerm}`);

        const response = await fetch(searchUrl);
        if (!response.ok) {
          throw new Error(`Open Food Facts search failed: ${response.status}`);
        }

        const data = await response.json();
        console.log(`[OpenFoodFacts] Found ${data.count} US products`);

        // Helper to check if product is from US
        const isUSProduct = (product) => {
          const countries = product.countries_tags || [];
          return countries.some(c => c.includes('united-states') || c.includes('en:united-states'));
        };

        // Known major US brands that have good data coverage
        const majorBrands = [
          'heinz', 'kraft', 'nestle', 'general mills', 'kellogg', 'campbell',
          'pillsbury', 'betty crocker', 'mccormick', 'french\'s', 'lea & perrins',
          'hellmann', 'best foods', 'hidden valley', 'wish-bone', 'newman\'s own',
          'hunts', 'del monte', 'dole', 'ocean spray', 'minute maid',
          'tropicana', 'simply', 'smucker', 'jif', 'skippy', 'peter pan',
          'land o lakes', 'tillamook', 'cabot', 'sargento', 'kraft',
          'barilla', 'de cecco', 'ronzoni', 'san giorgio', 'mueller\'s',
          'classico', 'ragu', 'prego', 'bertolli', 'newman\'s own',
          'swanson', 'pacific foods', 'imagine', 'progresso', 'college inn',
          'fleischmann', 'red star', 'saf', 'bob\'s red mill', 'king arthur',
          'domino', 'c&h', 'dixie crystals', 'imperial', 'morton',
          'mccormick', 'lawry\'s', 'old bay', 'tony chachere', 'zatarains',
          'frank\'s', 'tabasco', 'cholula', 'sriracha', 'huy fong',
          'kikkoman', 'la choy', 'house of tsang', 'lee kum kee',
          'goya', 'la preferida', 'ortega', 'old el paso', 'taco bell',
          'philadelphia', 'daisy', 'breakstone', 'friendship',
          'tyson', 'perdue', 'foster farms', 'pilgrim\'s', 'butterball',
          'oscar mayer', 'hillshire', 'johnsonville', 'jimmy dean', 'hormel',
          'spam', 'armour', 'libby\'s', 'bumble bee', 'starkist', 'chicken of the sea'
        ];

        // Score a product based on data quality and brand recognition
        const scoreProduct = (product) => {
          let score = 0;

          // Must have valid barcode
          if (!product.code || product.code.length < 8) return -1;

          // Ingredients text is critical (required for allergen analysis)
          if (product.ingredients_text && product.ingredients_text.length > 20) {
            score += 50;
          } else if (product.ingredients_text) {
            score += 20;
          } else {
            return -1; // No ingredients = unusable
          }

          // US product preferred
          if (isUSProduct(product)) score += 30;

          // Has product image (indicates well-documented product)
          if (product.image_url || product.image_front_url) score += 15;

          // Has brand name
          if (product.brands) {
            score += 10;
            // Bonus for major/common brands
            const brandLower = product.brands.toLowerCase();
            if (majorBrands.some(b => brandLower.includes(b))) {
              score += 25;
              console.log(`[OpenFoodFacts] Major brand detected: ${product.brands}`);
            }
          }

          // Has allergens data
          if (product.allergens_tags && product.allergens_tags.length > 0) score += 10;

          // Has nutrition data (indicates complete entry)
          if (product.nutriments && Object.keys(product.nutriments).length > 5) score += 10;

          // Product name relevance to search term
          const searchLower = searchTerm.toLowerCase();
          const nameLower = (product.product_name || '').toLowerCase();
          if (nameLower.includes(searchLower) || searchLower.includes(nameLower.split(' ')[0])) {
            score += 15;
          }

          return score;
        };

        if (data.products && data.products.length > 0) {
          // Score all products and sort by score
          const scoredProducts = data.products
            .map(p => ({ product: p, score: scoreProduct(p) }))
            .filter(p => p.score > 0)
            .sort((a, b) => b.score - a.score);

          console.log(`[OpenFoodFacts] Scored ${scoredProducts.length} valid products`);

          if (scoredProducts.length > 0) {
            const best = scoredProducts[0];
            console.log(`[OpenFoodFacts] Selected: ${best.product.product_name} by ${best.product.brands || 'unknown'} (score: ${best.score}, barcode: ${best.product.code})`);
            return best.product.code;
          }
        }

        console.log('[OpenFoodFacts] No US products found, trying world search...');

        // Fallback to world search if no US products found
        const worldUrl = `https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(searchTerm)}&search_simple=1&action=process&json=1&page_size=20`;
        const worldResponse = await fetch(worldUrl);
        if (worldResponse.ok) {
          const worldData = await worldResponse.json();
          if (worldData.products && worldData.products.length > 0) {
            const scoredWorld = worldData.products
              .map(p => ({ product: p, score: scoreProduct(p) }))
              .filter(p => p.score > 0)
              .sort((a, b) => b.score - a.score);

            if (scoredWorld.length > 0) {
              const best = scoredWorld[0];
              console.log(`[OpenFoodFacts] World fallback: ${best.product.product_name} by ${best.product.brands || 'unknown'} (score: ${best.score})`);
              return best.product.code;
            }
          }
        }

        console.log('[OpenFoodFacts] No products with valid barcode found');
        return null;
      } catch (err) {
        console.error('[OpenFoodFacts] Search error:', err);
        throw err;
      }
    }

    // Make searchProductBarcodeByName globally accessible for auto-fill
    window.searchProductBarcodeByName = searchProductBarcodeByName;

    // Open barcode scanner with a pre-filled barcode that auto-triggers
    async function openAiBarcodeScannerWithBarcode(rowIdx, barcode) {
      // First open the scanner normally
      await openAiBarcodeScanner(rowIdx);

      // Wait for modal to be ready, then fill in the barcode and trigger
      setTimeout(() => {
        const testInput = document.getElementById('barcodeTestInput');
        const testBtn = document.getElementById('barcodeTestBtn');
        const statusDiv = document.getElementById('barcodeScannerStatus');

        if (testInput && testBtn) {
          testInput.value = barcode;
          if (statusDiv) {
            statusDiv.textContent = `Auto-lookup: ${barcode}`;
            statusDiv.style.background = 'rgba(255,152,0,0.9)';
          }
          // Trigger the lookup
          testBtn.click();
        }
      }, 500);
    }

    // Make openAiBarcodeScannerWithBarcode globally accessible for auto-fill
    window.openAiBarcodeScannerWithBarcode = openAiBarcodeScannerWithBarcode;

    // Choice dialog for brand identification - scan barcode or photo ingredient list
    function openBrandIdentificationChoice(rowIdx) {
      ensureAiAssistElements();
      const rows = collectAiTableData();
      if (!rows[rowIdx]) {
        aiAssistSetStatus('Select an ingredient first.', 'warn');
        return;
      }

      const ingredientName = rows[rowIdx].name;
      if (!ingredientName) {
        aiAssistSetStatus('Add an ingredient name before identifying a brand.', 'warn');
        return;
      }

      // Prevent multiple scans - only allow if no items have been scanned yet
      const brands = rows[rowIdx].brands || [];
      if (brands.length > 0) {
        aiAssistSetStatus('An item has already been added for this ingredient. Remove it first if you want to add a different one.', 'warn');
        return;
      }

      // Create choice dialog modal
      const choiceModal = document.createElement('div');
      choiceModal.id = 'brandIdentificationChoiceModal';
      choiceModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.85);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;

      choiceModal.innerHTML = `
        <div style="width:100%;max-width:400px;background:#1a1f35;border-radius:16px;padding:24px;display:flex;flex-direction:column;gap:20px">
          <div style="text-align:center">
            <h3 style="margin:0 0 8px 0;font-size:1.3rem;color:#fff">Add Brand Item</h3>
            <p style="margin:0;color:#a8b2d6;font-size:0.95rem">
              Ingredient: <strong style="color:#fff">${esc(ingredientName)}</strong>
            </p>
            <p style="margin:12px 0 0 0;color:#a8b2d6;font-size:0.9rem">How would you like to identify this brand?</p>
          </div>
          <div style="display:flex;flex-direction:column;gap:12px">
            <button type="button" class="btn brandChoiceScanBarcode" style="background:#4c5ad4;border:none;padding:16px 24px;border-radius:12px;color:#fff;font-size:1.1rem;font-weight:500;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:10px">
              <span style="font-size:1.4rem"></span> Scan Barcode
            </button>
            <button type="button" class="btn brandChoicePhotoIngredients" style="background:#17663a;border:none;padding:16px 24px;border-radius:12px;color:#fff;font-size:1.1rem;font-weight:500;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:10px">
              <span style="font-size:1.4rem"></span> Photo of Ingredient List
            </button>
            <button type="button" class="btn brandChoiceFindOnline" style="background:#ff9800;border:none;padding:16px 24px;border-radius:12px;color:#fff;font-size:1.1rem;font-weight:500;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:10px">
              <span style="font-size:1.4rem"></span> Find Brand Online (Demo)
            </button>
          </div>
          <button type="button" class="btn brandChoiceCancel" style="background:transparent;border:1px solid rgba(255,255,255,0.2);padding:12px 24px;border-radius:8px;color:#a8b2d6;font-size:0.95rem;cursor:pointer">Cancel</button>
        </div>
      `;

      // Lock background scrolling
      const scrollPos = window.pageYOffset || document.documentElement.scrollTop;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${scrollPos}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';

      document.body.appendChild(choiceModal);

      function closeChoiceModal() {
        if (choiceModal.parentNode) {
          choiceModal.parentNode.removeChild(choiceModal);
        }
        // Restore scroll
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.style.overflow = '';
        window.scrollTo(0, scrollPos);
      }

      // Scan barcode button
      choiceModal.querySelector('.brandChoiceScanBarcode').addEventListener('click', () => {
        closeChoiceModal();
        openAiBarcodeScanner(rowIdx);
      });

      // Photo ingredients button
      choiceModal.querySelector('.brandChoicePhotoIngredients').addEventListener('click', () => {
        closeChoiceModal();
        showIngredientPhotoUploadModal(rowIdx, ingredientName, null);
      });

      // Find brand online button (demo)
      choiceModal.querySelector('.brandChoiceFindOnline').addEventListener('click', () => {
        // Close modal immediately - search will run in background with inline loading
        closeChoiceModal();

        // Show loading in the row right away
        showBarcodeLoadingInRow(rowIdx, ingredientName, '');

        // Run search in background (don't await - allows parallel searches)
        (async () => {
          try {
            console.log(`[FindBrandOnline] Searching for "${ingredientName}"...`);
            const barcode = await searchProductBarcodeByName(ingredientName);

            if (barcode) {
              console.log(`[FindBrandOnline] Found barcode ${barcode} for "${ingredientName}"`);
              // Open scanner and auto-fill the test barcode (continues with its own loading)
              openAiBarcodeScannerWithBarcode(rowIdx, barcode);
            } else {
              console.log(`[FindBrandOnline] No product found for "${ingredientName}"`);
              hideBarcodeLoadingInRow(rowIdx);
              showBarcodeErrorInRow(rowIdx, 'No product found in database');
            }
          } catch (err) {
            console.error('Find brand online error:', err);
            hideBarcodeLoadingInRow(rowIdx);
            showBarcodeErrorInRow(rowIdx, 'Search failed - try again');
          }
        })();
      });

      // Cancel button
      choiceModal.querySelector('.brandChoiceCancel').addEventListener('click', closeChoiceModal);

      // Click outside to close
      choiceModal.addEventListener('click', (e) => {
        if (e.target === choiceModal) closeChoiceModal();
      });
    }

    async function openAiBarcodeScanner(rowIdx) {
      ensureAiAssistElements();
      const rows = collectAiTableData();
      if (!rows[rowIdx]) {
        aiAssistSetStatus('Select an ingredient first.', 'warn');
        return;
      }

      const ingredientName = rows[rowIdx].name;
      if (!ingredientName) {
        aiAssistSetStatus('Add an ingredient name before scanning a barcode.', 'warn');
        return;
      }

      // Prevent multiple scans - only allow scanning if no items have been scanned yet
      const brands = rows[rowIdx].brands || [];
      if (brands.length > 0) {
        aiAssistSetStatus('An item has already been scanned for this ingredient. Remove the scanned item first if you want to scan a different one.', 'warn');
        return;
      }

      // Create a full-screen modal overlay for the scanner
      const scannerModal = document.createElement('div');
      scannerModal.id = 'barcodeScannerModal';
      scannerModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.95);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;

      scannerModal.innerHTML = `
    <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px">
      <div style="text-align:center">
        <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Scan Barcode</h3>
        <div style="margin:0;color:#a8b2d6;font-size:0.95rem">
          Ingredient: <strong style="color:#fff">${esc(ingredientName)}</strong>
          <div id="barcodeLoadingBar" style="display:none;margin-top:8px">
            <div style="background:rgba(76,90,212,0.2);border-radius:4px;height:6px;width:100%;overflow:hidden">
              <div id="barcodeLoadingBarFill" style="background:#4c5ad4;height:100%;width:0%;transition:width 0.3s;animation:pulse 1.5s infinite"></div>
            </div>
            <div style="font-size:0.8rem;color:#6b7ce6;margin-top:4px">Looking up product...</div>
          </div>
        </div>
        <p style="margin:8px 0 0 0;color:#a8b2d6;font-size:0.9rem">Point your camera at the product barcode</p>
      </div>
      <style>
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
      </style>
      <div style="position:relative;background:#000;border-radius:16px;overflow:hidden;width:100%">
        <video id="barcodeScannerVideo" autoplay playsinline muted style="width:100%;height:60vh;max-height:500px;display:block;object-fit:cover"></video>
        <div id="barcodeScannerOverlay" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70%;height:40%;border:3px solid #4c5ad4;border-radius:12px;pointer-events:none;box-shadow:0 0 0 9999px rgba(0,0,0,0.5)"></div>
        <div id="barcodeScannerStatus" style="position:absolute;top:16px;left:16px;right:16px;background:rgba(11,16,32,0.95);padding:12px 16px;border-radius:12px;color:#fff;text-align:center;font-size:1rem;font-weight:500">Initializing camera...</div>
      </div>
      <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
        <button type="button" class="btn aiBarcodeScannerUpload" style="background:#17663a;border-color:#1a7b46;padding:12px 32px;font-size:1rem"> Upload Image</button>
        <button type="button" class="btn aiBarcodeScannerCancel" style="background:#ef4444;border-color:#dc2626;padding:12px 32px;font-size:1rem">Cancel</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:center;align-items:center;padding:12px;background:rgba(76,90,212,0.15);border-radius:8px;border:1px solid rgba(76,90,212,0.4)">
        <span style="color:#a8b2d6;font-size:0.9rem">No barcode?</span>
        <button type="button" class="btn aiSkipToIngredientPhoto" style="background:#4c5ad4;border:none;padding:8px 16px;border-radius:6px;color:#fff;font-size:0.9rem;font-weight:500;cursor:pointer"> Photo Ingredient List</button>
      </div>
      <div style="display:flex;gap:8px;justify-content:center;align-items:center;padding:12px;background:rgba(255,152,0,0.1);border-radius:8px;border:1px solid rgba(255,152,0,0.3)">
        <label style="color:#ffb84d;font-size:0.85rem;font-weight:500"> Test Mode:</label>
        <input type="text" id="barcodeTestInput" placeholder="Enter barcode (e.g., 041570147078)" style="flex:1;max-width:250px;padding:8px 12px;border:1px solid rgba(255,255,255,0.2);border-radius:6px;background:rgba(0,0,0,0.3);color:#fff;font-size:0.9rem" maxlength="20">
        <button type="button" id="barcodeTestBtn" style="background:#ff9800;border:none;padding:8px 16px;border-radius:6px;color:#fff;font-size:0.9rem;font-weight:500;cursor:pointer">Test Lookup</button>
      </div>
      <input type="file" id="barcodeImageUpload" accept="image/*" style="display:none">
    </div>
  `;

      // Lock background scrolling (mobile-safe)
      scrollLockPosition = window.pageYOffset || document.documentElement.scrollTop;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${scrollLockPosition}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';

      document.body.appendChild(scannerModal);

      const video = scannerModal.querySelector('#barcodeScannerVideo');
      const statusDiv = scannerModal.querySelector('#barcodeScannerStatus');
      const loadingBar = scannerModal.querySelector('#barcodeLoadingBar');
      const loadingBarFill = scannerModal.querySelector('#barcodeLoadingBarFill');
      const cancelBtn = scannerModal.querySelector('.aiBarcodeScannerCancel');
      const uploadBtn = scannerModal.querySelector('.aiBarcodeScannerUpload');
      const fileInput = scannerModal.querySelector('#barcodeImageUpload');

      // Track active lookups per barcode; value is a shared in-flight Promise
      // This allows multiple rows to await the same network request without interference
      let activeLookups = new Map();

      // Ensure video attributes are set for mobile compatibility
      video.setAttribute('autoplay', '');
      video.setAttribute('playsinline', '');
      video.setAttribute('muted', '');

      let codeReader = null;
      let scanning = false;

      const stopScanning = () => {
        if (codeReader) {
          codeReader.reset();
          codeReader = null;
        }
        scanning = false;

        // Stop video stream tracks
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.stop());
          video.srcObject = null;
        }
      };

      const closeModal = () => {
        stopScanning();
        if (scannerModal && scannerModal.parentNode) {
          scannerModal.parentNode.removeChild(scannerModal);
        }
        // Restore scroll position and body styles
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.style.overflow = '';
        window.scrollTo(0, scrollLockPosition);
      };

      // Helper to update allergen and dietary display in modal (async - calls edge function)
      const updateAllergenDisplay = async (rowIdx, ingredients) => {
        console.log('=== CALLING CHECK-DIETARY-ALLERGENS ===');
        console.log('Ingredients count:', ingredients.length);
        console.log('Ingredients:', JSON.stringify(ingredients));

        // Show loading overlay on both sections
        const dietarySection = document.getElementById('dietary-compliance-section');
        const allergenSection = document.getElementById('allergen-check-section');

        const addLoadingOverlay = (section) => {
          if (!section) return;
          // Remove existing overlay if any
          const existingOverlay = section.querySelector('.loading-overlay');
          if (existingOverlay) existingOverlay.remove();

          const overlay = document.createElement('div');
          overlay.className = 'loading-overlay';
          overlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            z-index: 10;
          `;
          overlay.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px; color: #94a3b8;">
              <div style="
                width: 20px;
                height: 20px;
                border: 2px solid #475569;
                border-top-color: #60a5fa;
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
              "></div>
              <span style="font-size: 0.9rem;">Updating...</span>
            </div>
          `;

          // Ensure section has relative positioning for absolute overlay
          section.style.position = 'relative';
          section.appendChild(overlay);
        };

        const removeLoadingOverlay = (section) => {
          if (!section) return;
          const overlay = section.querySelector('.loading-overlay');
          if (overlay) overlay.remove();
        };

        // Add loading overlays
        addLoadingOverlay(dietarySection);
        addLoadingOverlay(allergenSection);

        // Call edge function to get analysis
        const result = await checkDietaryAllergens(ingredients);

        // Remove loading overlays
        removeLoadingOverlay(dietarySection);
        removeLoadingOverlay(allergenSection);
        console.log('=== API RESPONSE ===');
        console.log('Full result:', JSON.stringify(result, null, 2));

        const allergenData = result.allergens || {};
        const dietData = result.diets || {};

        // Update the visual allergen display in the modal (allergenSection already declared above)
        if (allergenSection) {
          const allTop9 = ['Dairy', 'Egg', 'Peanut', 'Tree Nut', 'Soy', 'Wheat', 'Fish', 'Shellfish', 'Sesame'];

          const gridHtml = allTop9.map(allergen => {
            const data = allergenData[allergen] || { flagged: false, triggers: [] };
            const flagged = data.flagged;
            const triggers = data.triggers || [];

            const bgColor = flagged ? 'rgba(239,68,68,0.1)' : 'rgba(34,197,94,0.1)';
            const borderColor = flagged ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)';
            const titleColor = flagged ? '#fca5a5' : '#fff';
            const icon = flagged ? '' : '';
            const iconBg = flagged ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)';
            const iconColor = flagged ? '#f87171' : '#4ade80';

            return `
              <div style="
                background: ${bgColor};
                border: 1px solid ${borderColor};
                border-radius: 12px;
                padding: 16px;
                display: flex;
                flex-direction: column;
                gap: 8px;
              ">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                  <span style="font-weight: 600; color: ${titleColor}; font-size: 1rem;">${allergen}</span>
                  <span style="
                    background: ${iconBg};
                    color: ${iconColor};
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.9rem;
                    font-weight: bold;
                  ">${icon}</span>
                </div>
                ${flagged && triggers.length > 0 ? `
                  <div style="font-size: 0.85rem; color: #fca5a5; opacity: 0.9; line-height: 1.4;">
                    ${triggers.map(t => ` ${t}`).join('<br>')}
                  </div>
                ` : ''}
                ${!flagged ? `
                  <div style="font-size: 0.85rem; color: #86efac;">
                    Safe for this allergen
                  </div>
                ` : ''}
              </div>
            `;
          }).join('');

          let grid = allergenSection.querySelector('div[style*="grid"]');
          if (grid) {
            grid.innerHTML = gridHtml;
          }
          console.log('Updated allergen display');
        }

        // Update dietary compliance section (dietarySection already declared above, reuse it)
        if (dietarySection) {
          const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];

          const dietGridHtml = allDiets.map(diet => {
            const data = dietData[diet] || { flagged: false, triggers: [] };
            const flagged = data.flagged;
            const triggers = data.triggers || [];

            // For diets, flagged = NOT compliant
            const bgColor = !flagged ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)';
            const borderColor = !flagged ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
            const titleColor = !flagged ? '#fff' : '#fca5a5';
            const icon = !flagged ? '' : '';
            const iconBg = !flagged ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
            const iconColor = !flagged ? '#4ade80' : '#f87171';

            return `
              <div style="
                background: ${bgColor};
                border: 1px solid ${borderColor};
                border-radius: 12px;
                padding: 16px;
                display: flex;
                flex-direction: column;
                gap: 8px;
              ">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                  <span style="font-weight: 600; color: ${titleColor}; font-size: 1rem;">${diet}</span>
                  <span style="
                    background: ${iconBg};
                    color: ${iconColor};
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.9rem;
                    font-weight: bold;
                  ">${icon}</span>
                </div>
                ${flagged && triggers.length > 0 ? `
                  <div style="font-size: 0.85rem; color: #fca5a5; opacity: 0.9; line-height: 1.4;">
                    ${triggers.map(t => ` ${t}`).join('<br>')}
                  </div>
                ` : ''}
                ${!flagged ? `
                  <div style="font-size: 0.85rem; color: #86efac;">
                    Complies with diet
                  </div>
                ` : ''}
              </div>
            `;
          }).join('');

          let dietGrid = dietarySection.querySelector('div[style*="grid"]');
          if (dietGrid) {
            dietGrid.innerHTML = dietGridHtml;
          }
          console.log('Updated dietary compliance display');
        }
      };

      // Toggle ingredient in unified list based on discrepancy checkbox
      window.toggleDiscrepancyIngredient = function (checkbox, ingredientName, rowIdx) {
        console.log('=== INGREDIENT TOGGLE ===');
        console.log('Toggling ingredient:', ingredientName, 'Row:', rowIdx, 'Checked:', checkbox.checked);
        const listEl = document.getElementById(`unified-ingredient-list-${rowIdx}`);
        if (!listEl) {
          console.error('Unified list element not found:', `unified-ingredient-list-${rowIdx}`);
          return;
        }

        try {
          // Use decodeURIComponent for robust string handling
          let ingredients = JSON.parse(decodeURIComponent(listEl.dataset.ingredients || '[]'));

          // Self-healing: If data is a single string with commas (legacy bug), split it
          if (ingredients.length === 1 && typeof ingredients[0] === 'string' && ingredients[0].includes(',')) {
            console.log('Detected malformed ingredient list, fixing...');
            ingredients = ingredients[0].split(',').map(s => s.trim()).filter(s => s.length > 0);
          }

          console.log('Current ingredients:', ingredients);

          if (checkbox.checked) {
            // Add if not present
            if (!ingredients.some(i => i === ingredientName || i.trim() === ingredientName.trim())) {
              ingredients.push(ingredientName);
              console.log('Added ingredient');
            } else {
              console.log('Ingredient already present');
            }
          } else {
            // Remove if present
            const initialLength = ingredients.length;
            ingredients = ingredients.filter(i => i !== ingredientName && i.trim() !== ingredientName.trim());
            console.log('Removed ingredient. New length:', ingredients.length, 'Removed count:', initialLength - ingredients.length);
          }

          // Update data attribute and text
          listEl.dataset.ingredients = encodeURIComponent(JSON.stringify(ingredients));
          listEl.textContent = ingredients.join(', ');

          // Recalculate and update allergen display
          console.log('Sending to API:', ingredients.length, 'ingredients');
          console.log('Full list:', ingredients);
          updateAllergenDisplay(rowIdx, ingredients);
        } catch (e) {
          console.error('Error toggling ingredient:', e);
        }
      };

      // Handle barcode lookup
      const handleBarcodeResult = async (barcode) => {
        // Don't stop scanning - allow continuous scanning
        // Deduplicate network calls per barcode while allowing multiple rows to consume results
        let inFlight = activeLookups.get(barcode);
        if (!inFlight) {
          const startTime = Date.now();
          inFlight = (async () => {
            let searchLogs = [];
            const res = await fetchProductByBarcode(barcode, (logMsg) => {
              searchLogs.push(logMsg);
              // Inline update logic to avoid scope issues
              // Inline update logic to avoid scope issues
              // Find the row element first
              const aiAssistTable = document.getElementById('aiAssistTable');
              const trElement = aiAssistTable ? aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`) : null;

              if (trElement) {
                const logsDiv = trElement.querySelector('.aiRowSearchLogs');
                const statusEl = trElement.querySelector('.barcodeLoadingStatus');

                if (logsDiv) {
                  logsDiv.style.display = 'block';
                  logsDiv.innerHTML = searchLogs.map(log => `<div>${log}</div>`).join('');
                  logsDiv.scrollTop = logsDiv.scrollHeight;
                }

                if (statusEl) {
                  statusEl.textContent = logMsg;
                }
              }
            }, (sourceData) => {
              // Source tracker update handler
              const aiAssistTable = document.getElementById('aiAssistTable');
              const trElement = aiAssistTable ? aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`) : null;
              if (trElement) {
                const trackerPanel = trElement.querySelector('.sourceTrackerPanel');
                if (trackerPanel) {
                  const sourceList = trackerPanel.querySelector('.sourceList');
                  const verifiedCountEl = trackerPanel.querySelector('.verifiedCount');
                  const neededMsg = trackerPanel.querySelector('.neededMessage');

                  // Update verified count
                  if (verifiedCountEl && sourceData.verified !== undefined) {
                    verifiedCountEl.textContent = sourceData.verified;
                  }

                  // Update needed message
                  if (neededMsg && sourceData.needed !== undefined) {
                    if (sourceData.needed <= 0) {
                      neededMsg.textContent = ' Minimum sources met!';
                      neededMsg.style.color = '#34d399';
                    } else {
                      neededMsg.textContent = `Need ${sourceData.needed} more source${sourceData.needed === 1 ? '' : 's'}`;
                    }
                  }

                  // Update source list
                  if (sourceList && sourceData.sources) {
                    const entries = Object.entries(sourceData.sources);
                    if (entries.length > 0) {
                      sourceList.innerHTML = entries.map(([url, info]) => {
                        let domain;
                        try {
                          domain = new URL(url).hostname.replace('www.', '');
                        } catch (e) {
                          domain = url.substring(0, 30);
                        }
                        const statusIcon = info.status === 'accepted' ? '' : info.status === 'rejected' ? '' : '';
                        const statusColor = info.status === 'accepted' ? '#34d399' : info.status === 'rejected' ? '#f87171' : '#fbbf24';
                        const cycleLabel = info.cycle ? `<span style="background:rgba(76,90,212,0.4);color:#a8b2d6;padding:0 3px;border-radius:2px;font-size:0.55rem;margin-left:4px">C${info.cycle}</span>` : '';
                        return `<div style="display:flex;align-items:flex-start;gap:3px;padding:2px 0;border-bottom:1px solid rgba(255,255,255,0.05);font-size:0.65rem">
                          <span style="color:${statusColor};flex-shrink:0">${statusIcon}</span>
                          <div style="flex:1;min-width:0">
                            <div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:flex;align-items:center">
                              <a href="${url}" target="_blank" rel="noopener" style="color:${statusColor};text-decoration:none" title="${url}">${domain}</a>${cycleLabel}
                            </div>
                            ${info.reason ? `<div style="font-size:0.55rem;color:#6b7280">${info.reason}</div>` : ''}
                          </div>
                        </div>`;
                      }).join('');
                    }
                  }
                }
              }
            });
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
            console.log(`Barcode lookup completed in ${elapsed}s for ${barcode}`);
            return res;
          })();
          // Ensure cleanup after resolution
          inFlight.finally(() => {
            // Only delete if the same promise instance is still stored
            const current = activeLookups.get(barcode);
            if (current === inFlight) {
              activeLookups.delete(barcode);
            }
          });
          activeLookups.set(barcode, inFlight);
        } else {
          console.log(`Joining in-flight lookup for barcode ${barcode}`);
        }

        // Close scanner modal immediately when lookup starts
        closeModal();

        // Show loading bar in the ingredient row (not in modal)
        showBarcodeLoadingInRow(rowIdx, ingredientName, barcode);

        try {
          const result = await inFlight;

          // Handle needsPhoto case - show photo upload modal
          if (result && result.needsPhoto) {
            hideBarcodeLoadingInRow(rowIdx);
            showIngredientPhotoUploadModal(rowIdx, ingredientName, result.barcode);
            aiAssistSetStatus('Product not found. Please take a photo of the ingredient list.', 'warn');
            return;
          }

          // Handle success case - show button in row instead of immediate popup
          if (result && result.success && result.ingredientList) {
            // Extract product info from result
            const productName = result.productName || result.product?.product_name || 'Unknown Product';
            const ingredientList = result.ingredientList;

            // Use brand from API response (extracted from barcode database, not product name)
            const brand = result.brand || '';

            // Get product image from Open Food Facts (prefer productImage from API, then check product object)
            const productImage = result.productImage || result.product?.image_url || result.product?.image ||
              (result.sources && result.sources.length > 0 && result.sources[0].productImage) || '';

            // Analyze ingredient list for allergens and dietary preferences first
            // Then create suggestion object with analyzed data
            let aiAllergens = [];
            let aiDiets = [];

            try {
              const { data: analysisData, error } = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
                body: { ingredientText: ingredientList }
              });
              if (!error && analysisData) {
                aiAllergens = Array.isArray(analysisData.allergens) ? analysisData.allergens : [];
                aiDiets = Array.isArray(analysisData.diets) ? analysisData.diets : [];
                // Capture detailed dietary compliance
                if (analysisData.dietary_compliance) {
                  aiDiets.compliance = analysisData.dietary_compliance;
                }
              }
            } catch (err) {
              console.error('Failed to analyze allergens/diets from barcode scan:', err);
            }

            // Create suggestion object with analyzed allergens/diets - use product image from Open Food Facts as brandImage (thumbnail)
            const suggestion = {
              name: productName,
              brand: brand,
              barcode: barcode,
              brandImage: productImage,
              ingredientsImage: '',
              ingredientsList: [ingredientList],
              allergens: aiAllergens,
              diets: aiDiets,
              dietaryCompliance: aiDiets.compliance // Store explicitly
            };

            // Show results button in the ingredient row instead of immediate popup
            showBarcodeResultsButtonInRow(rowIdx, suggestion, result);

            // Update the row with AI-detected allergens and diets immediately
            // IMPORTANT: Merge allergens (union) but REPLACE diets to avoid stale incompatible diets
            const data = collectAiTableData();
            if (data[rowIdx]) {
              // Get existing allergens from the row (which may include data from other brands)
              const existingAllergens = new Set((data[rowIdx].allergens || []).map(a => norm(a)));
              const existingAiDetectedAllergens = new Set((data[rowIdx].aiDetectedAllergens || []).map(a => norm(a)));

              // Merge new allergens from this scan (union - allergens should accumulate)
              aiAllergens.forEach(a => {
                existingAllergens.add(norm(a));
                existingAiDetectedAllergens.add(norm(a));
              });

              // For diets: REPLACE with the new scan result, then remove any incompatible ones
              // This fixes the issue where Gluten-free stayed checked after scanning wheat-containing products
              const newDiets = new Set(aiDiets || []);
              const newAiDetectedDiets = new Set(aiDiets || []);

              // Remove diets that conflict with detected allergens
              const allAllergens = Array.from(existingAllergens).map(a => a.toLowerCase());
              if (allAllergens.includes('wheat')) {
                newDiets.delete('Gluten-free');
                newAiDetectedDiets.delete('Gluten-free');
              }
              if (allAllergens.includes('dairy') || allAllergens.includes('egg')) {
                newDiets.delete('Vegan');
                newAiDetectedDiets.delete('Vegan');
              }
              if (allAllergens.includes('fish') || allAllergens.includes('shellfish')) {
                newDiets.delete('Vegan');
                newDiets.delete('Vegetarian');
                newAiDetectedDiets.delete('Vegan');
                newAiDetectedDiets.delete('Vegetarian');
              }

              // Update with results
              data[rowIdx].allergens = Array.from(existingAllergens);
              data[rowIdx].diets = Array.from(newDiets);
              data[rowIdx].aiDetectedAllergens = Array.from(existingAiDetectedAllergens);
              data[rowIdx].aiDetectedDiets = Array.from(newAiDetectedDiets);
              data[rowIdx].confirmed = false;

              // Also update the DOM row's dataset so it persists across re-renders
              const row = aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"]`);
              if (row) {
                row.dataset.aiDetectedAllergens = JSON.stringify(data[rowIdx].aiDetectedAllergens);
                row.dataset.aiDetectedDiets = JSON.stringify(data[rowIdx].aiDetectedDiets);
              }

              renderAiTable(data);
              aiAssistSetStatus(`Barcode lookup completed and allergens/diets updated for "${productName}".`, 'success');
              aiAssistState.savedToDish = false;
            }
            return;
          } else {
            // Product not found - show error in row instead of modal (modal already closed)
            hideBarcodeLoadingInRow(rowIdx);
            showBarcodeErrorInRow(rowIdx, result?.message || 'Product not found. Please try again or check the barcode.');
            aiAssistSetStatus(result?.message || 'Barcode lookup failed. Try again.', 'warn');
            return;
          }
        } catch (error) {
          console.error('Barcode lookup error:', error);
          hideBarcodeLoadingInRow(rowIdx);
          showBarcodeErrorInRow(rowIdx, 'Barcode lookup failed. Please try again.');
          aiAssistSetStatus('Barcode lookup failed. Try again.', 'error');
        }
      };

      cancelBtn.addEventListener('click', closeModal);

      // Upload button triggers file input
      uploadBtn.addEventListener('click', () => {
        fileInput.click();
      });

      // Skip to ingredient photo button - for items without barcodes
      const skipToPhotoBtn = scannerModal.querySelector('.aiSkipToIngredientPhoto');
      if (skipToPhotoBtn) {
        skipToPhotoBtn.addEventListener('click', () => {
          closeModal();
          // Open the ingredient photo modal without a barcode
          showIngredientPhotoUploadModal(rowIdx, ingredientName, null);
        });
      }

      // Test mode: manual barcode entry (for testing/debugging)
      const testInput = scannerModal.querySelector('#barcodeTestInput');
      const testBtn = scannerModal.querySelector('#barcodeTestBtn');

      testBtn.addEventListener('click', async () => {
        const barcode = testInput.value.trim().replace(/\s+/g, '');
        if (!barcode) {
          statusDiv.textContent = 'Please enter a barcode number';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
          setTimeout(() => {
            statusDiv.textContent = 'Point your camera at barcode or upload an image...';
            statusDiv.style.background = 'rgba(76,90,212,0.9)';
          }, 2000);
          return;
        }

        // Validate barcode format (basic check - numeric, 8-14 digits)
        if (!/^\d{8,14}$/.test(barcode)) {
          statusDiv.textContent = 'Invalid barcode format. Please enter 8-14 digits.';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
          setTimeout(() => {
            statusDiv.textContent = 'Point your camera at barcode or upload an image...';
            statusDiv.style.background = 'rgba(76,90,212,0.9)';
          }, 2000);
          return;
        }

        // Don't stop scanning for test mode - allow continuous scanning
        // Just process in background
        handleBarcodeResult(barcode).catch(err => {
          console.error('Test barcode processing error:', err);
        });
      });

      // Allow Enter key to trigger test lookup
      testInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          testBtn.click();
        }
      });

      // Handle file upload
      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        stopScanning(); // Stop camera if running

        statusDiv.textContent = 'Processing image...';
        statusDiv.style.background = 'rgba(76,90,212,0.9)';

        try {
          // Check if ZXing library is loaded
          if (typeof ZXing === 'undefined') {
            statusDiv.textContent = 'Barcode scanner library not loaded. Please refresh the page.';
            statusDiv.style.background = 'rgba(220,82,82,0.9)';
            return;
          }

          // Create an image element to load the file
          const img = new Image();
          const reader = new FileReader();

          reader.onload = async (event) => {
            img.onload = async () => {
              try {
                // Create a canvas to get image data
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // Use ZXing to decode from the image
                const codeReader = new ZXing.BrowserMultiFormatReader();
                const result = await codeReader.decodeFromImageElement(img);

                if (result) {
                  await handleBarcodeResult(result.text);
                } else {
                  statusDiv.textContent = 'No barcode found in image';
                  statusDiv.style.background = 'rgba(220,82,82,0.9)';
                  setTimeout(() => {
                    statusDiv.textContent = 'Point your camera at barcode or upload an image...';
                    statusDiv.style.background = 'rgba(76,90,212,0.9)';
                  }, 2000);
                }
              } catch (err) {
                console.error('Error decoding barcode from image:', err);
                statusDiv.textContent = 'Could not read barcode from image';
                statusDiv.style.background = 'rgba(220,82,82,0.9)';
                setTimeout(() => {
                  statusDiv.textContent = 'Point your camera at barcode or upload an image...';
                  statusDiv.style.background = 'rgba(76,90,212,0.9)';
                }, 2000);
              }
            };
            img.src = event.target.result;
          };

          reader.readAsDataURL(file);
        } catch (err) {
          console.error('Error processing image:', err);
          statusDiv.textContent = 'Error processing image';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
        }
      });

      try {
        // Check if ZXing library is loaded
        if (typeof ZXing === 'undefined') {
          statusDiv.textContent = 'Barcode scanner library not loaded. Please refresh the page.';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
          return;
        }

        codeReader = new ZXing.BrowserMultiFormatReader();
        statusDiv.textContent = 'Starting camera...';

        // Get available video devices
        const videoInputDevices = await codeReader.listVideoInputDevices();
        if (!videoInputDevices || videoInputDevices.length === 0) {
          statusDiv.textContent = 'No camera found. Please check camera permissions.';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
          return;
        }

        // Prefer back camera on mobile
        let selectedDeviceId = videoInputDevices[0].deviceId;
        const backCamera = videoInputDevices.find(device =>
          device.label.toLowerCase().includes('back') ||
          device.label.toLowerCase().includes('rear') ||
          device.label.toLowerCase().includes('environment')
        );
        if (backCamera) {
          selectedDeviceId = backCamera.deviceId;
        }

        statusDiv.textContent = 'Point camera at barcode...';
        statusDiv.style.background = 'rgba(76,90,212,0.9)';
        scanning = true;

        // Start scanning - let ZXing handle the camera stream
        try {
          codeReader.decodeFromVideoDevice(selectedDeviceId, video, async (result, err) => {
            if (!scanning) return;

            if (result) {
              const barcode = result.text;
              // Don't stop scanning - allow continuous scanning for multiple ingredients
              // Just process the barcode in the background
              handleBarcodeResult(barcode).catch(err => {
                console.error('Barcode processing error:', err);
              });
            }

            if (err && !(err instanceof ZXing.NotFoundException)) {
              console.error('Barcode scan error:', err);
            }
          });

          // Update status to show camera is working
          setTimeout(() => {
            if (scanning && video.readyState >= 2) {
              // Video is playing, camera is working
              statusDiv.textContent = 'Point camera at barcode...';
              statusDiv.style.background = 'rgba(76,90,212,0.9)';
            }
          }, 1000);

        } catch (scanError) {
          // Only show error if ZXing actually fails to start
          console.error('Failed to start ZXing scanner:', scanError);
          statusDiv.textContent = 'Camera access denied or not available';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
          aiAssistSetStatus('Failed to access camera. Please check permissions.', 'warn');
        }

      } catch (err) {
        // This catch is for errors before scanning starts (like listVideoInputDevices)
        console.error('Failed to initialize barcode scanner:', err);
        statusDiv.textContent = 'Camera access denied or not available';
        statusDiv.style.background = 'rgba(220,82,82,0.9)';
        aiAssistSetStatus('Failed to access camera. Please check permissions.', 'warn');
      }
    }

    // Main function: Lookup barcode using Supabase Edge Function
    // Simplified version matching the working test page implementation
    // Main function: Lookup barcode using Supabase Edge Function
    // Simplified version matching the working test page implementation
    async function fetchProductByBarcode(barcode, onLog, onSourceUpdate) {
      console.log(`\n=== Looking up barcode: ${barcode} ===`);

      try {
        // Use fetch directly to handle SSE
        const { data: { session } } = await window.supabaseClient.auth.getSession();
        const response = await fetch(`${window.supabaseClient.functionsUrl}/lookup-barcode`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${session?.access_token || window.supabaseAnonKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ barcode })
        });

        if (!response.ok) {
          throw new Error(`Function returned ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let finalResult = null;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            const match = line.match(/^event: (.+)\ndata: (.+)$/s);
            if (match) {
              const event = match[1];
              const data = JSON.parse(match[2]);

              if (event === 'log') {
                let logMsg = data.message;
                logMsg = logMsg.replace(/\[Antigravity\]/g, '[barcode searcher]');
                console.log(`[Stream] ${logMsg}`);
                if (onLog) onLog(logMsg);
              } else if (event === 'source_update') {
                // Update source tracker panel
                if (onSourceUpdate) onSourceUpdate(data);
              } else if (event === 'result') {
                finalResult = data;
              } else if (event === 'error') {
                console.error('[Stream] Error:', data.message);
                if (onLog) onLog(` Error: ${data.message}`);
                return { error: data.message };
              }
            }
          }
        }

        if (!finalResult) {
          return { error: 'Stream ended without result' };
        }

        const data = finalResult;

        // Handle success case with ingredient list
        if (data && data.success && data.ingredientList) {
          console.log(` Product found and verified: ${data.productName}`);
          console.log(`  Sources verified: ${data.sources ? data.sources.length : 0}`);
          console.log(`  Consistency: ${data.consistencyInfo ? `${data.consistencyInfo.matchingSources}/${data.consistencyInfo.totalSources} sources agree` : 'N/A'}`);

          // Use brand from API response (extracted from barcode database, not product name)
          const brand = data.brand || '';

          // Get product image from API response (Open Food Facts)
          // Prefer productImage from API response, then check sources for productImage
          const productImage = data.productImage ||
            (data.sources && data.sources.length > 0 && data.sources[0].productImage) ||
            '';

          // Normalize dietary compliance from lookup-barcode (camelCase) to frontend expected format (snake_case + Capitalized keys)
          const rawDc = data.dietaryCompliance || data.dietary_compliance || {};
          const normalizedDc = {};
          const diets = [];

          // Helper to process diet keys
          const processDiet = (sourceKey, targetKey) => {
            const entry = rawDc[sourceKey] || rawDc[targetKey] || rawDc[targetKey.toLowerCase()];
            if (entry) {
              const isCompliant = entry.isCompliant === true || entry.is_compliant === true || (typeof entry.isCompliant === 'string' && entry.isCompliant === 'true');
              normalizedDc[targetKey] = {
                is_compliant: isCompliant,
                reason: entry.reason || ''
              };
              if (isCompliant) diets.push(targetKey);
            }
          };

          processDiet('vegan', 'Vegan');
          processDiet('vegetarian', 'Vegetarian');
          processDiet('pescatarian', 'Pescatarian');
          processDiet('glutenFree', 'Gluten-free');

          // Return in format expected by existing code
          return {
            success: true,
            needsPhoto: false,
            ingredientList: data.ingredientList,
            productImage: productImage, // Include productImage at top level for easy access
            product: {
              product_name: data.productName,
              name: data.productName,
              ingredients_text: data.ingredientList,
              ingredientsList: [data.ingredientList],
              brands: brand,
              brand: brand,
              image_url: productImage,
              image: productImage,
              barcode: barcode
            },
            source: data.sources && data.sources.length > 0 ? `${data.sources.length} sources (Claude web search)` : 'Open Food Facts',
            sources: data.sources || [],
            consistencyInfo: data.consistencyInfo,
            productName: data.productName,
            diets: diets,
            allergens: data.allergens || [],
            dietary_compliance: normalizedDc
          };
        }

        // Handle case where product not found but photo can help
        if (data && data.needsPhoto) {
          console.log(' Product not found - needs photo');
          return {
            success: false,
            needsPhoto: true,
            message: data.message || 'Product not found. Please take a photo of the ingredient list.',
            barcode: barcode
          };
        }

        console.log(' Product not found in any database');
        return null;
      } catch (err) {
        console.error('Barcode lookup error:', err);
        return null;
      }
    }

    // Show loading bar in ingredient row
    function showBarcodeLoadingInRow(rowIdx, ingredientName, barcode = '') {
      console.log(`showBarcodeLoadingInRow called with rowIdx: ${rowIdx}, ingredientName: ${ingredientName}`);

      // Register this lookup in the global tracking map
      activeBarcodeLookups.set(rowIdx, {
        barcode,
        ingredientName,
        startTime: Date.now()
      });

      const rows = collectAiTableData();
      const row = rows[rowIdx];
      if (!row) {
        console.error(`Row ${rowIdx} not found in table data`);
        return;
      }

      // Find the row element - look for the tr with data-index matching rowIdx
      const aiAssistTable = document.getElementById('aiAssistTable');
      if (!aiAssistTable) {
        console.error('aiAssistTable not found');
        return;
      }

      // Find the tr element with matching data-index
      const trElement = aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!trElement) {
        console.error(`tr[data-index="${rowIdx}"] not found`);
        return;
      }

      // Find the aiIngredientRow inside this tr
      const rowElement = trElement.querySelector('.aiIngredientRow');
      if (!rowElement) {
        console.error(`aiIngredientRow not found inside tr[data-index="${rowIdx}"]`);
        return;
      }

      console.log('Found rowElement:', rowElement);

      // Find or create the loading area - append to aiIngredientRow (at bottom)
      let loadingArea = rowElement.querySelector('.barcodeLoadingArea');
      if (!loadingArea) {
        loadingArea = document.createElement('div');
        loadingArea.className = 'barcodeLoadingArea';
        loadingArea.style.cssText = `
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(76,90,212,0.1);
      border-radius: 8px;
      border: 1px solid rgba(76,90,212,0.3);
    `;

        // Append to the end of aiIngredientRow (after aiIngredientMain)
        rowElement.appendChild(loadingArea);
      }

      loadingArea.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:8px">
      <div style="display:flex;align-items:center;gap:12px">
        <div style="flex:1;background:rgba(76,90,212,0.2);border-radius:4px;height:6px;overflow:hidden">
          <div class="barcodeLoadingBarFill" data-row-idx="${rowIdx}" style="background:#4c5ad4;height:100%;width:0%;transition:width 0.5s ease-out"></div>
        </div>
        <span style="font-size:0.9rem;color:#6b7ce6;white-space:nowrap">Looking up ${esc(ingredientName)}...</span>
      </div>
      <div class="barcodeLoadingStatus" style="font-size:0.8rem;color:#a8b2d6;margin-left:0;min-height:1.2em">Searching product databases...</div>

      <!-- Source Tracker and Logs side by side -->
      <div style="display:flex;gap:8px;margin-top:6px;align-items:flex-start">
        <!-- Source Tracker Panel (Left, wider) -->
        <div class="sourceTrackerPanel" data-row-idx="${rowIdx}" style="
          flex: 1;
          min-width: 280px;
          max-height: 110px;
          padding: 8px;
          background: rgba(30,40,60,0.9);
          border-radius: 6px;
          border: 1px solid rgba(76,90,212,0.4);
          font-size: 0.7rem;
          color: #a8b2d6;
          display: flex;
          flex-direction: column;
          gap: 4px;
          overflow: hidden;
        ">
          <div style="display:flex;justify-content:space-between;align-items:center;padding-bottom:4px;border-bottom:1px solid rgba(76,90,212,0.3);flex-shrink:0">
            <span style="font-weight:600;color:#8b9cd6;font-size:0.75rem">Source Tracker</span>
            <span class="sourceCountBadge" style="background:rgba(76,90,212,0.3);padding:2px 6px;border-radius:10px;font-size:0.65rem">
              <span class="verifiedCount">0</span>/5 verified
            </span>
          </div>
          <div class="sourceList" style="
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-height: 0;
          ">
            <div style="color:#6b7280;font-style:italic;text-align:center;padding:6px;font-size:0.65rem">Waiting for sources...</div>
          </div>
          <div class="neededMessage" style="
            padding-top: 4px;
            border-top: 1px solid rgba(76,90,212,0.3);
            text-align: center;
            font-size: 0.65rem;
            color: #f59e0b;
            flex-shrink: 0;
          ">Need 5 sources to complete</div>
        </div>

        <!-- Logs Panel (Right, narrower with expand button) -->
        <div class="logsContainer" style="
          width: 180px;
          height: 110px;
          position: relative;
          transition: width 0.3s ease;
          flex-shrink: 0;
        ">
          <div class="aiRowSearchLogs" style="
            padding: 6px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            height: 100%;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.55rem;
            color: #a8b2d6;
          "></div>
          <button class="expandLogsBtn" onclick="this.parentElement.style.width = this.parentElement.style.width === '350px' ? '180px' : '350px'; this.textContent = this.parentElement.style.width === '350px' ? '' : ''" style="
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 20px;
            height: 20px;
            background: rgba(76,90,212,0.6);
            border: none;
            border-radius: 3px;
            color: white;
            font-size: 0.6rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: opacity 0.2s;
          " title="Expand/collapse logs"></button>
        </div>
      </div>

      <div style="font-size:0.75rem;color:#6b7280;font-style:italic;margin-left:0"> You can continue scanning other items while this lookup is in progress</div>
    </div>
  `;

      // Animate loading bar gradually - simulate realistic progress
      const fillBar = loadingArea.querySelector('.barcodeLoadingBarFill');
      const statusEl = loadingArea.querySelector('.barcodeLoadingStatus');
      if (fillBar) {
        const startTime = Date.now();
        const estimatedDuration = 60000; // Estimate 60 seconds for lookup (with retries)
        let progressInterval = null;

        // Status messages for different stages
        const statusMessages = [
          { time: 0, msg: 'Searching product databases...' },
          { time: 2000, msg: 'Checking Open Food Facts...' },
          { time: 5000, msg: 'Searching web for ingredient sources...' },
          { time: 15000, msg: 'Found product, gathering sources...' },
          { time: 25000, msg: 'Validating source URLs...' },
          { time: 30000, msg: 'Verifying ingredient lists...' },
          { time: 40000, msg: 'Searching for additional sources...' },
          { time: 50000, msg: 'Cross-referencing ingredients...' },
          { time: 60000, msg: 'Almost done, finalizing results...' },
          { time: 70000, msg: 'Still searching for more sources...' },
          { time: 80000, msg: 'This product has limited online data...' }
        ];

        // Progress function that updates based on elapsed time
        const updateProgress = () => {
          const elapsed = Date.now() - startTime;
          let progress = Math.min(95, (elapsed / estimatedDuration) * 95); // Cap at 95% until actually done

          // Make progress more gradual with some realistic stages
          if (elapsed < 2000) {
            progress = Math.min(progress, 10); // Slow start (0-10% in first 2 seconds)
          } else if (elapsed < 15000) {
            progress = Math.min(progress, 10 + ((elapsed - 2000) / 13000) * 30); // 10-40% in next 13 seconds
          } else if (elapsed < 30000) {
            progress = Math.min(progress, 40 + ((elapsed - 15000) / 15000) * 25); // 40-65% in next 15 seconds
          } else if (elapsed < 50000) {
            progress = Math.min(progress, 65 + ((elapsed - 30000) / 20000) * 20); // 65-85% in next 20 seconds
          } else {
            progress = Math.min(progress, 85 + ((elapsed - 50000) / 30000) * 10); // 85-95% slowly
          }

          fillBar.style.width = `${progress}%`;

          // Update status message based on elapsed time - REMOVED to allow real logs to show
          // if (statusEl) {
          //   let currentStatus = statusMessages[0].msg;
          //   for (const status of statusMessages) {
          //     if (elapsed >= status.time) {
          //       currentStatus = status.msg;
          //     }
          //   }
          //   statusEl.textContent = currentStatus;
          // }

          // Continue updating until lookup completes (will be stopped when done)
          if (progress < 95 && fillBar.parentElement && fillBar.parentElement.parentElement) {
            // Continue with interval instead of requestAnimationFrame for smoother updates
          } else if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
          }
        };

        // Start with a small delay, then update regularly
        setTimeout(() => {
          updateProgress();
          progressInterval = setInterval(() => {
            if (fillBar.parentElement && fillBar.parentElement.parentElement) {
              updateProgress();
            } else {
              if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
              }
            }
          }, 500);

          // Store interval ID on the fill bar for cleanup if needed
          fillBar.dataset.intervalId = progressInterval;
        }, 100);
      }
    }

    // Show loading bar in ingredient row with a specific start time (used when restoring after re-render)
    // This version doesn't register in activeBarcodeLookups since it's already registered
    function showBarcodeLoadingInRowWithTime(rowIdx, ingredientName, existingStartTime) {
      const rows = collectAiTableData();
      const row = rows[rowIdx];
      if (!row) return;

      const aiAssistTable = document.getElementById('aiAssistTable');
      if (!aiAssistTable) return;

      const trElement = aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!trElement) return;

      const rowElement = trElement.querySelector('.aiIngredientRow');
      if (!rowElement) return;

      // Create the loading area
      let loadingArea = rowElement.querySelector('.barcodeLoadingArea');
      if (!loadingArea) {
        loadingArea = document.createElement('div');
        loadingArea.className = 'barcodeLoadingArea';
        loadingArea.style.cssText = `
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(76,90,212,0.1);
      border-radius: 8px;
      border: 1px solid rgba(76,90,212,0.3);
    `;
        rowElement.appendChild(loadingArea);
      }

      loadingArea.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:8px">
      <div style="display:flex;align-items:center;gap:12px">
        <div style="flex:1;background:rgba(76,90,212,0.2);border-radius:4px;height:6px;overflow:hidden">
          <div class="barcodeLoadingBarFill" data-row-idx="${rowIdx}" style="background:#4c5ad4;height:100%;width:0%;transition:width 0.5s ease-out"></div>
        </div>
        <span style="font-size:0.9rem;color:#6b7ce6;white-space:nowrap">Looking up ${esc(ingredientName)}...</span>
      </div>
      <div class="barcodeLoadingStatus" style="font-size:0.8rem;color:#a8b2d6;margin-left:0;min-height:1.2em">Searching product databases...</div>
      <div class="aiRowSearchLogs" style="
        margin-top: 8px;
        padding: 8px;
        background: rgba(0,0,0,0.2);
        border-radius: 4px;
        height: 100px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 0.7rem;
        color: #a8b2d6;
        display: block;
      "></div>
      <div style="font-size:0.75rem;color:#6b7280;font-style:italic;margin-left:0"> You can continue scanning other items while this lookup is in progress</div>
    </div>
  `;

      const fillBar = loadingArea.querySelector('.barcodeLoadingBarFill');
      const statusEl = loadingArea.querySelector('.barcodeLoadingStatus');
      if (fillBar) {
        // Use the existing startTime to continue progress from where it was
        const startTime = existingStartTime || Date.now();
        const estimatedDuration = 60000;
        let progressInterval = null;

        const statusMessages = [
          { time: 0, msg: 'Searching product databases...' },
          { time: 2000, msg: 'Checking Open Food Facts...' },
          { time: 5000, msg: 'Searching web for ingredient sources...' },
          { time: 15000, msg: 'Found product, gathering sources...' },
          { time: 25000, msg: 'Validating source URLs...' },
          { time: 30000, msg: 'Verifying ingredient lists...' },
          { time: 40000, msg: 'Searching for additional sources...' },
          { time: 50000, msg: 'Cross-referencing ingredients...' },
          { time: 60000, msg: 'Almost done, finalizing results...' },
          { time: 70000, msg: 'Still searching for more sources...' },
          { time: 80000, msg: 'This product has limited online data...' }
        ];

        const updateProgress = () => {
          const elapsed = Date.now() - startTime;
          let progress = Math.min(95, (elapsed / estimatedDuration) * 95);

          if (elapsed < 2000) {
            progress = Math.min(progress, 10);
          } else if (elapsed < 15000) {
            progress = Math.min(progress, 10 + ((elapsed - 2000) / 13000) * 30);
          } else if (elapsed < 30000) {
            progress = Math.min(progress, 40 + ((elapsed - 15000) / 15000) * 25);
          } else if (elapsed < 50000) {
            progress = Math.min(progress, 65 + ((elapsed - 30000) / 20000) * 20);
          } else {
            progress = Math.min(progress, 85 + ((elapsed - 50000) / 30000) * 10);
          }

          fillBar.style.width = `${progress}%`;

          // Update status message based on elapsed time - REMOVED to allow real logs to show
          // if (statusEl) {
          //   let currentStatus = statusMessages[0].msg;
          //   for (const status of statusMessages) {
          //     if (elapsed >= status.time) {
          //       currentStatus = status.msg;
          //     }
          //   }
          //   statusEl.textContent = currentStatus;
          // }

          if (progress < 95 && fillBar.parentElement && fillBar.parentElement.parentElement) {
            // Continue
          } else if (progressInterval) {
            clearInterval(progressInterval);
            progressInterval = null;
          }
        };

        // Start immediately and update regularly
        setTimeout(() => {
          updateProgress();
          progressInterval = setInterval(() => {
            if (fillBar.parentElement && fillBar.parentElement.parentElement) {
              updateProgress();
            } else {
              if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
              }
            }
          }, 500);

          fillBar.dataset.intervalId = progressInterval;
        }, 100);
      }
    }

    // Hide loading bar in ingredient row
    function hideBarcodeLoadingInRow(rowIdx) {
      // Unregister this lookup from the global tracking map
      activeBarcodeLookups.delete(rowIdx);

      const aiAssistTable = document.getElementById('aiAssistTable');
      if (!aiAssistTable) return;

      // Find the tr element with matching data-index
      const trElement = aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!trElement) return;

      const rowElement = trElement.querySelector('.aiIngredientRow');
      if (!rowElement) return;

      const loadingArea = rowElement.querySelector('.barcodeLoadingArea');
      if (loadingArea) {
        // Complete progress to 100% before removing
        const fillBar = loadingArea.querySelector('.barcodeLoadingBarFill');
        if (fillBar) {
          // Clear any intervals
          if (fillBar.dataset.intervalId) {
            clearInterval(parseInt(fillBar.dataset.intervalId));
          }
          // Complete to 100%
          fillBar.style.width = '100%';
          // Wait a moment before removing so user sees completion
          setTimeout(() => {
            if (loadingArea.parentElement) {
              loadingArea.remove();
            }
          }, 300);
          return;
        }
        loadingArea.remove();
      }
    }

    // Expose loading functions globally for auto-fill
    window.showBarcodeLoadingInRow = showBarcodeLoadingInRow;
    window.hideBarcodeLoadingInRow = hideBarcodeLoadingInRow;

    // Show error message in ingredient row
    function showBarcodeErrorInRow(rowIdx, errorMessage) {
      const aiAssistTable = document.getElementById('aiAssistTable');
      if (!aiAssistTable) return;

      // Find the tr element with matching data-index
      const trElement = aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!trElement) return;

      const rowElement = trElement.querySelector('.aiIngredientRow');
      if (!rowElement) return;

      let loadingArea = rowElement.querySelector('.barcodeLoadingArea');
      if (!loadingArea) {
        loadingArea = document.createElement('div');
        loadingArea.className = 'barcodeLoadingArea';
        loadingArea.style.cssText = `
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(220,82,82,0.1);
      border-radius: 8px;
      border: 1px solid rgba(220,82,82,0.3);
    `;

        // Append to the end of aiIngredientRow (at bottom)
        rowElement.appendChild(loadingArea);
      }

      loadingArea.innerHTML = `
    <div style="display:flex;align-items:center;gap:8px">
      <span style="color:#dc5252;font-size:0.95rem;font-weight:500"> ${esc(errorMessage)}</span>
    </div>
  `;
    }

    // Show button to view barcode results in ingredient row
    function showBarcodeResultsButtonInRow(rowIdx, suggestion, barcodeResult) {
      // IMPORTANT: Remove from activeBarcodeLookups since lookup is complete
      // This prevents the restoration logic in renderAiTable from overwriting the results button
      activeBarcodeLookups.delete(rowIdx);

      const rows = collectAiTableData();
      const row = rows[rowIdx];
      if (!row) return;

      // Store result in state
      if (!aiAssistState.barcodeResults) {
        aiAssistState.barcodeResults = {};
      }
      aiAssistState.barcodeResults[rowIdx] = { suggestion, barcodeResult };

      // Find the row element - look for the tr with data-index matching rowIdx
      const aiAssistTable = document.getElementById('aiAssistTable');
      if (!aiAssistTable) return;

      // Find the tr element with matching data-index
      const trElement = aiAssistTable.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!trElement) return;

      // Find the aiIngredientRow inside this tr
      const rowElement = trElement.querySelector('.aiIngredientRow');
      if (!rowElement) return;

      // Find or create the results area - append to aiIngredientRow (at bottom)
      let loadingArea = rowElement.querySelector('.barcodeLoadingArea');
      if (!loadingArea) {
        loadingArea = document.createElement('div');
        loadingArea.className = 'barcodeLoadingArea';
        loadingArea.style.cssText = `
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(76,90,212,0.1);
      border-radius: 8px;
      border: 1px solid rgba(76,90,212,0.3);
    `;

        // Append to the end of aiIngredientRow (after aiIngredientMain)
        rowElement.appendChild(loadingArea);
      }

      const productName = barcodeResult.productName || suggestion.name || 'Product';
      const sourceCount = barcodeResult.sources?.length || 0;

      loadingArea.innerHTML = `
    <div style="display:flex;align-items:center;gap:12px;justify-content:space-between">
      <div style="flex:1">
        <div style="font-size:0.95rem;color:#4caf50;font-weight:600;margin-bottom:4px"> ${esc(productName)}</div>
        <div style="font-size:0.85rem;color:#a8b2d6">Found ${sourceCount} source${sourceCount !== 1 ? 's' : ''}</div>
      </div>
      <button type="button" class="viewBarcodeResultsBtn" data-row-idx="${rowIdx}" style="
        padding: 10px 20px;
        background: #4c5ad4;
        border: none;
        border-radius: 6px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
      " onmouseover="this.style.background='#5d6ae5'" onmouseout="this.style.background='#4c5ad4'">View Results</button>
    </div>
  `;

      // Add click handler
      const viewBtn = loadingArea.querySelector('.viewBarcodeResultsBtn');
      if (viewBtn) {
        viewBtn.addEventListener('click', () => {
          const stored = aiAssistState.barcodeResults?.[rowIdx];
          if (stored) {
            showBarcodeSourcesModal(rowIdx, stored.suggestion, stored.barcodeResult);
            // Remove the banner after viewing results once
            if (loadingArea && loadingArea.parentNode) {
              loadingArea.remove();
            }
          }
        });
      }
    }

    // Show barcode lookup sources modal
    function showBarcodeSourcesModal(rowIdx, suggestion, barcodeResult) {
      const sources = barcodeResult.sources || [];
      const productName = barcodeResult.productName || suggestion.name;
      let ingredientList = barcodeResult.ingredientList || '';
      const consistencyInfo = barcodeResult.consistencyInfo || {};

      // Antigravity analysis data
      const unifiedIngredientList = barcodeResult.unifiedIngredientList || [];
      const top9Allergens = barcodeResult.allergens || barcodeResult.top9Allergens || suggestion.allergens || [];
      const dietaryCompliance = barcodeResult.dietaryCompliance || barcodeResult.dietary_compliance || suggestion.dietaryCompliance || suggestion.dietary_compliance || null;
      const sourceDifferences = barcodeResult.sourceDifferences || [];

      // If there's a conflict where all are different except one, use the consensus list
      const hasConflict = consistencyInfo.differentSources &&
        consistencyInfo.differentSources > 1 &&
        consistencyInfo.matchingSources >= 1 &&
        consistencyInfo.matchingSources < consistencyInfo.totalSources;

      if (hasConflict && consistencyInfo.differences) {
        const consensusDiff = consistencyInfo.differences.find(d => d.groupSize === consistencyInfo.matchingSources);
        if (consensusDiff) {
          ingredientList = consensusDiff.ingredientsText;
          suggestion.ingredientsList = [consensusDiff.ingredientsText];
        }
      }

      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10002;
    padding: 20px;
  `;

      const closeModal = () => {
        if (modal && modal.parentNode) {
          document.body.removeChild(modal);
        }
      };

      // Extract barcode for reporting
      const barcode = barcodeResult.barcode || (suggestion && suggestion.barcode) || '';

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #4c5ad4;
    border-radius: 16px;
    max-width: 900px;
    max-height: 85vh;
    overflow-y: auto;
    padding: 24px;
    color: #fff;
    width: 100%;
  `;

      // Get product image
      const productImage = barcodeResult.productImage || suggestion.brandImage || '';

      // Simple render functions that use new edge function data format
      const renderDietaryComplianceSimple = (dietData) => {
        const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];

        return `
          <div id="dietary-compliance-section" style="margin-bottom: 24px;">
            <h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1.1rem; font-weight: 600;">Dietary Compliance</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
              ${allDiets.map(diet => {
          const data = dietData[diet] || { flagged: false, triggers: [] };
          const flagged = data.flagged;
          const triggers = data.triggers || [];

          // For diets, flagged = NOT compliant
          const bgColor = !flagged ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)';
          const borderColor = !flagged ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
          const titleColor = !flagged ? '#fff' : '#fca5a5';
          const icon = !flagged ? '' : '';
          const iconBg = !flagged ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
          const iconColor = !flagged ? '#4ade80' : '#f87171';

          return `
                  <div style="
                    background: ${bgColor};
                    border: 1px solid ${borderColor};
                    border-radius: 12px;
                    padding: 16px;
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                  ">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                      <span style="font-weight: 600; color: ${titleColor}; font-size: 1rem;">${diet}</span>
                      <span style="
                        background: ${iconBg};
                        color: ${iconColor};
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 0.9rem;
                        font-weight: bold;
                      ">${icon}</span>
                    </div>
                    ${flagged && triggers.length > 0 ? `
                      <div style="font-size: 0.85rem; color: #fca5a5; line-height: 1.4;">
                        ${triggers.map(t => ` ${esc(t)}`).join('<br>')}
                      </div>
                    ` : ''}
                    ${!flagged ? `
                      <div style="font-size: 0.85rem; color: #86efac;">
                        Complies with diet
                      </div>
                    ` : ''}
                  </div>
                `;
        }).join('')}
            </div>
          </div>
        `;
      };

      const renderAllergensSimple = (allergenData) => {
        const allTop9 = ['Dairy', 'Egg', 'Peanut', 'Tree Nut', 'Soy', 'Wheat', 'Fish', 'Shellfish', 'Sesame'];

        return `
          <div id="allergen-check-section" style="margin-bottom: 24px;">
            <h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1.1rem; font-weight: 600;">Allergen Check</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
              ${allTop9.map(allergen => {
          const data = allergenData[allergen] || { flagged: false, triggers: [] };
          const flagged = data.flagged;
          const triggers = data.triggers || [];

          const bgColor = flagged ? 'rgba(239,68,68,0.1)' : 'rgba(34,197,94,0.1)';
          const borderColor = flagged ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)';
          const titleColor = flagged ? '#fca5a5' : '#fff';
          const icon = flagged ? '' : '';
          const iconBg = flagged ? 'rgba(239,68,68,0.2)' : 'rgba(34,197,94,0.2)';
          const iconColor = flagged ? '#f87171' : '#4ade80';

          return `
                  <div style="
                    background: ${bgColor};
                    border: 1px solid ${borderColor};
                    border-radius: 12px;
                    padding: 16px;
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                  ">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                      <span style="font-weight: 600; color: ${titleColor}; font-size: 1rem;">${allergen}</span>
                      <span style="
                        background: ${iconBg};
                        color: ${iconColor};
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 0.9rem;
                        font-weight: bold;
                      ">${icon}</span>
                    </div>
                    ${flagged && triggers.length > 0 ? `
                      <div style="font-size: 0.85rem; color: #fca5a5; opacity: 0.9; line-height: 1.4;">
                        ${triggers.map(t => ` ${esc(t)}`).join('<br>')}
                      </div>
                    ` : ''}
                    ${!flagged ? `
                      <div style="font-size: 0.85rem; color: #86efac;">
                        Safe for this allergen
                      </div>
                    ` : ''}
                  </div>
                `;
        }).join('')}
            </div>
          </div>
        `;
      };

      // Helper to render unified ingredient list
      const renderIngredientList = (list, rowIdx) => {
        let ingredients = Array.isArray(list) ? list : [list];

        // Robustness: if single item contains commas, split it
        if (ingredients.length === 1 && typeof ingredients[0] === 'string' && ingredients[0].includes(',')) {
          ingredients = ingredients[0].split(',').map(s => s.trim()).filter(s => s.length > 0);
        }

        const text = ingredients.join(', ');

        return `
          <div style="margin-bottom: 24px;">
            <h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1.1rem; font-weight: 600;">Unified Ingredient List</h3>
            <div style="
              background: rgba(30, 41, 59, 0.5);
              border: 1px solid rgba(148, 163, 184, 0.2);
              border-radius: 12px;
              padding: 16px;
            ">
              <p id="unified-ingredient-list-${rowIdx}" 
                 data-ingredients="${encodeURIComponent(JSON.stringify(ingredients))}"
                 style="
                margin: 0;
                color: #e2e8f0;
                font-size: 0.95rem;
                line-height: 1.6;
              ">${esc(text)}</p>
            </div>
          </div>
        `;
      };

      // Helper to render source consistency
      const renderSourceConsistency = (consistency, rowIdx) => {
        if (!consistency) return '';
        const { totalSources, matchingSources, differentSources, differences } = consistency;

        // Calculate score/color
        const percent = totalSources > 0 ? (matchingSources / totalSources) * 100 : 0;
        let color = '#4ade80'; // green
        let label = 'High Consistency';

        if (percent === 100 || matchingSources === totalSources) {
          label = 'No discrepancies';
        } else if (percent < 50) {
          color = '#f87171'; // red
          label = 'Low Consistency';
        } else if (percent < 80) {
          color = '#facc15'; // yellow
          label = 'Moderate Consistency';
        }

        return `
          <div style="margin-bottom: 24px;">
            ${(!differences || differences.length === 0) ? `
              <h3 style="margin: 0 0 12px 0; color: #4ade80; font-size: 1.1rem; font-weight: 600;">No ingredient discrepancies</h3>
            ` : `
              <h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1.1rem; font-weight: 600;">Source Consistency</h3>
            `}
            
            ${differences && differences.length > 0 ? `
              <div style="
                background: rgba(255, 166, 0, 0.05); 
                border: 1px solid rgba(255, 166, 0, 0.1); 
                border-radius: 8px; 
                padding: 12px; 
                margin-bottom: 16px; 
                color: #fbbf24; 
                font-size: 0.9rem;
              ">
                Found ${differences.length} discrepancies between sources.
              </div>
            ` : ''}

            <div style="display: flex; flex-direction: column; gap: 16px;">
              ${(differences || []).map(diff => `
                <div style="
                  background: rgba(30, 41, 59, 0.5);
                  border: 1px solid rgba(148, 163, 184, 0.2);
                  border-radius: 8px;
                  padding: 16px;
                ">
                  <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                    <h4 style="margin: 0; color: #fff; font-size: 1rem; font-weight: 600;">${esc(diff.ingredient)}</h4>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <span style="color: #94a3b8; font-size: 0.8rem;">Include</span>
                      <input type="checkbox" checked 
                        onchange="toggleDiscrepancyIngredient(this, ${esc(JSON.stringify(diff.ingredient))}, ${rowIdx})"
                        style="
                          width: 16px; 
                          height: 16px; 
                          accent-color: #10b981; 
                          cursor: pointer;
                        "
                      >
                    </label>
                  </div>
                  
                  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <div>
                      <div style="color: #4ade80; font-size: 0.75rem; font-weight: 700; margin-bottom: 8px; text-transform: uppercase;">Present In</div>
                      <ul style="margin: 0; padding: 0; list-style: none;">
                        ${diff.presentIn.map(source => `
                          <li style="
                            color: #94a3b8; 
                            font-size: 0.85rem; 
                            margin-bottom: 4px; 
                            display: flex; 
                            align-items: center; 
                            gap: 6px;
                          ">
                            <span style="width: 4px; height: 4px; border-radius: 50%; background: #4ade80;"></span>
                            ${esc(new URL(source).hostname.replace('www.', ''))}
                          </li>
                        `).join('')}
                      </ul>
                    </div>
                    
                    <div>
                      <div style="color: #f87171; font-size: 0.75rem; font-weight: 700; margin-bottom: 8px; text-transform: uppercase;">Missing In</div>
                      <ul style="margin: 0; padding: 0; list-style: none;">
                        ${diff.missingIn.map(source => `
                          <li style="
                            color: #94a3b8; 
                            font-size: 0.85rem; 
                            margin-bottom: 4px; 
                            display: flex; 
                            align-items: center; 
                            gap: 6px;
                          ">
                            <span style="width: 4px; height: 4px; border-radius: 50%; background: #f87171;"></span>
                            ${esc(new URL(source).hostname.replace('www.', ''))}
                          </li>
                        `).join('')}
                      </ul>
                    </div>
                  </div>
                  
                  ${diff.note ? `
                    <div style="
                      margin-top: 12px; 
                      padding-top: 12px; 
                      border-top: 1px solid rgba(148, 163, 184, 0.1); 
                      color: #64748b; 
                      font-size: 0.85rem; 
                      font-style: italic;
                    ">
                      Note: ${esc(diff.note)}
                    </div>
                  ` : ''}
                </div>
              `).join('')}
            </div>
          </div>
        `;
      };

      // Helper to render source details
      const renderSourceDetails = (sources) => {
        if (!sources || sources.length === 0) return '';

        return `
          <div style="margin-bottom: 24px;">
            <h3 style="margin: 0 0 12px 0; color: #fff; font-size: 1.1rem; font-weight: 600;">Analyzed Sources</h3>
            <div style="display: flex; flex-direction: column; gap: 8px;">
              ${sources.map(s => {
          const domain = s.url ? new URL(s.url).hostname.replace('www.', '') : 'Unknown Source';
          return `
                  <a href="${esc(s.url)}" target="_blank" rel="noopener noreferrer" style="
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    background: rgba(30, 41, 59, 0.5);
                    border: 1px solid rgba(148, 163, 184, 0.2);
                    border-radius: 8px;
                    padding: 12px;
                    text-decoration: none;
                    transition: background 0.2s;
                  " onmouseover="this.style.background='rgba(30, 41, 59, 0.8)'" onmouseout="this.style.background='rgba(30, 41, 59, 0.5)'">
                    <div style="display: flex; align-items: center; gap: 10px; overflow: hidden;">
                      <div style="
                        width: 24px; height: 24px; border-radius: 4px;
                        background: rgba(148, 163, 184, 0.1);
                        display: flex; align-items: center; justify-content: center;
                        font-size: 0.8rem; color: #94a3b8;
                      "></div>
                      <div style="display: flex; flex-direction: column; overflow: hidden;">
                        <span style="color: #e2e8f0; font-size: 0.9rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                          ${esc(domain)}
                        </span>
                        <span style="color: #94a3b8; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                          ${s.ingredients ? `${s.ingredients.length} ingredients` : (s.ingredientsText ? `${s.ingredientsText.split(',').length} ingredients` : 'No ingredients found')}
                        </span>
                      </div>
                    </div>
                    <span style="color: #64748b; font-size: 1.2rem;"></span>
                  </a>
                  ${s.ingredientsText ? `
                    <div style="
                      margin-top: -4px;
                      margin-bottom: 8px;
                      margin-left: 12px;
                      margin-right: 12px;
                      padding: 10px;
                      background: rgba(15, 23, 42, 0.6);
                      border: 1px solid rgba(148, 163, 184, 0.1);
                      border-top: none;
                      border-bottom-left-radius: 8px;
                      border-bottom-right-radius: 8px;
                      font-size: 0.8rem;
                      color: #94a3b8;
                      line-height: 1.4;
                    ">
                      <div style="font-weight: 600; margin-bottom: 4px; color: #64748b; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em;">Source Ingredients:</div>
                      ${esc(s.ingredientsText)}
                    </div>
                  ` : ''}
                `;
        }).join('')}
            </div>
          </div>
        `;
      };

      modalContent.innerHTML = `
        <div style="margin-bottom: 24px;">
          <div style="display: flex; align-items: flex-start; gap: 16px;">
            ${productImage ? `
              <div style="flex-shrink: 0;">
                <img src="${esc(productImage)}" alt="${esc(productName)}"
                     style="width: 80px; height: 80px; object-fit: contain; border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.2); background: #fff;"
                     onerror="console.log('Image load error:', this.src); this.style.display='none';">
              </div>
            ` : `
              <div style="
                flex-shrink: 0; width: 80px; height: 80px; border-radius: 12px;
                background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
                display: flex; align-items: center; justify-content: center;
                font-size: 2rem;
              "></div>
            `}
            <div style="flex: 1;">
              <h2 style="margin: 0 0 4px 0; font-size: 1.4rem; color: #fff; font-weight: 700; line-height: 1.2;">
                ${esc(productName)}
              </h2>
              ${suggestion.brand ? `
                <div style="color: #94a3b8; font-size: 0.95rem; font-weight: 500;">${esc(suggestion.brand)}</div>
              ` : ''}
              <div style="margin-top: 8px; display: inline-flex; align-items: center; gap: 6px; background: rgba(34,197,94,0.1); border: 1px solid rgba(34,197,94,0.2); padding: 4px 10px; border-radius: 20px;">
                <span style="width: 8px; height: 8px; background: #4ade80; border-radius: 50%;"></span>
                <span style="color: #4ade80; font-size: 0.85rem; font-weight: 600;">${sources.length} Verified Sources</span>
              </div>
            </div>
          </div>
        </div>

        <div id="dietary-allergen-loading" style="margin-bottom: 24px; padding: 24px; text-align: center; color: #94a3b8;">
          <div style="animation: pulse 1.5s ease-in-out infinite;">Analyzing ingredients...</div>
        </div>
        <div id="dietary-compliance-container"></div>
        <div id="allergen-check-container"></div>
        ${renderIngredientList(unifiedIngredientList.length > 0 ? unifiedIngredientList : ingredientList, rowIdx)}
        ${renderSourceConsistency(consistencyInfo, rowIdx)}
        ${renderSourceDetails(sources)}

      <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
        <button type="button" class="reportIssueBtn" style="
          padding: 12px 20px;
          background: transparent;
          border: 1px solid rgba(248, 113, 113, 0.3);
          border-radius: 8px;
          color: #f87171;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
          margin-right: auto;
        ">Something doesn't look right</button>

        <button type="button" class="cancelBtn" style="
          padding: 12px 20px;
          background: #4c5ad4;
          border: 1px solid #4c5ad4;
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Cancel</button>

        <button type="button" class="confirmApplyBtn" style="
          padding: 12px 24px;
          background: #10b981;
          border: 1px solid #10b981;
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
          box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        ">Confirm & Apply</button>
      </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Call edge function to get fresh dietary/allergen analysis
      const ingredientsToAnalyze = unifiedIngredientList.length > 0 ? unifiedIngredientList :
        (typeof ingredientList === 'string' ? ingredientList.split(',').map(s => s.trim()) : [ingredientList]);

      checkDietaryAllergens(ingredientsToAnalyze).then(result => {
        // Hide loading indicator
        const loadingEl = modalContent.querySelector('#dietary-allergen-loading');
        if (loadingEl) loadingEl.style.display = 'none';

        // Populate dietary compliance section
        const dietContainer = modalContent.querySelector('#dietary-compliance-container');
        if (dietContainer) {
          dietContainer.innerHTML = renderDietaryComplianceSimple(result.diets || {});
        }

        // Populate allergen check section
        const allergenContainer = modalContent.querySelector('#allergen-check-container');
        if (allergenContainer) {
          allergenContainer.innerHTML = renderAllergensSimple(result.allergens || {});
        }

        console.log('Dietary/allergen analysis loaded:', result);
      }).catch(err => {
        console.error('Failed to get dietary/allergen analysis:', err);
        const loadingEl = modalContent.querySelector('#dietary-allergen-loading');
        if (loadingEl) {
          loadingEl.innerHTML = '<div style="color: #f87171;">Failed to analyze ingredients. Please try again.</div>';
        }
      });

      // Event handlers
      const cancelBtn = modalContent.querySelector('.cancelBtn');
      const confirmApplyBtn = modalContent.querySelector('.confirmApplyBtn');
      const reportIssueBtn = modalContent.querySelector('.reportIssueBtn');
      const discrepancyCheckboxes = modalContent.querySelectorAll('input[type="checkbox"][onchange^="toggleDiscrepancyIngredient"]');

      // Handle Report Issue
      if (reportIssueBtn) {
        reportIssueBtn.addEventListener('click', () => {
          const reportModal = document.createElement('div');
          reportModal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); z-index: 10002;
            display: flex; align-items: center; justify-content: center;
          `;

          reportModal.innerHTML = `
            <div style="background: #1e293b; padding: 24px; border-radius: 12px; width: 90%; max-width: 500px; border: 1px solid rgba(148, 163, 184, 0.2);">
              <h3 style="color: #fff; margin: 0 0 16px 0;">Report Issue</h3>
              <p style="color: #94a3b8; margin-bottom: 16px; font-size: 0.9rem;">Please describe what's wrong with the analysis.</p>
              <textarea style="width: 100%; height: 100px; background: rgba(0,0,0,0.2); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #fff; padding: 12px; margin-bottom: 16px; resize: vertical;" placeholder="e.g. The ingredient list is missing..."></textarea>
              <div style="display: flex; justify-content: flex-end; gap: 12px;">
                <button class="cancelReportBtn" style="padding: 8px 16px; background: transparent; border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 6px; cursor: pointer;">Cancel</button>
                <button class="sendReportBtn" style="padding: 8px 16px; background: #f87171; border: none; color: #fff; border-radius: 6px; cursor: pointer; font-weight: 600;">Send Report</button>
              </div>
            </div>
          `;

          document.body.appendChild(reportModal);

          reportModal.querySelector('.cancelReportBtn').onclick = () => document.body.removeChild(reportModal);

          reportModal.querySelector('.sendReportBtn').onclick = async function () {
            const msg = reportModal.querySelector('textarea').value;
            if (!msg) return;

            this.textContent = 'Sending...';
            this.disabled = true;

            try {
              await fetch('https://fgoiyycctnwnghrvsilt.supabase.co/functions/v1/report-issue', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  message: msg,
                  productName: productName,
                  barcode: barcode,
                  analysisDetails: barcodeResult
                })
              });

              // Mark this ingredient as having a reported issue
              const data = collectAiTableData();
              if (data[rowIdx]) {
                data[rowIdx].issueReported = true;
              }
              renderAiTable(data);

              document.body.removeChild(reportModal);
              // Also close the parent modal
              if (modal && modal.parentNode) {
                document.body.removeChild(modal);
              }
              aiAssistSetStatus('Issue reported. Thank you!', 'success');
            } catch (e) {
              console.error('Failed to report issue:', e);
              this.textContent = 'Error';
              setTimeout(() => {
                document.body.removeChild(reportModal);
                aiAssistSetStatus('Failed to send report.', 'error');
              }, 1000);
            }
          };
        });
      }

      // Handle Confirm & Apply button
      if (confirmApplyBtn) {
        let confirmed = false;

        confirmApplyBtn.addEventListener('mouseenter', () => {
          if (!confirmed) confirmApplyBtn.style.background = '#5d6ae5';
        });

        confirmApplyBtn.addEventListener('mouseleave', () => {
          if (!confirmed) confirmApplyBtn.style.background = '#4c5ad4';
        });

        confirmApplyBtn.addEventListener('click', async () => {
          confirmed = true;
          confirmApplyBtn.style.background = '#4caf50';
          confirmApplyBtn.innerHTML = ' Applied!';
          confirmApplyBtn.style.cursor = 'default';
          confirmApplyBtn.disabled = true;

          // Get selected discrepancy ingredients
          const selectedDiffs = [];
          discrepancyCheckboxes.forEach(cb => {
            if (cb.checked) {
              selectedDiffs.push(cb.dataset.ingredient);
            }
          });

          // Build final ingredient list including selected discrepancies
          // The unified list displayed in the UI is the source of truth
          const listEl = document.getElementById(`unified-ingredient-list-${rowIdx}`);
          let finalIngredients = [];
          if (listEl) {
            try {
              finalIngredients = JSON.parse(decodeURIComponent(listEl.dataset.ingredients || '[]'));
              // Robustness check
              if (finalIngredients.length === 1 && typeof finalIngredients[0] === 'string' && finalIngredients[0].includes(',')) {
                finalIngredients = finalIngredients[0].split(',').map(s => s.trim()).filter(s => s.length > 0);
              }
            } catch (e) {
              console.error('Error parsing final ingredients:', e);
              finalIngredients = [...unifiedIngredientList];
            }
          } else {
            finalIngredients = [...unifiedIngredientList];
          }

          const finalIngredientList = finalIngredients.join(', ');

          // Update suggestion with the final list
          suggestion.ingredientsList = [finalIngredientList];

          // Use already-analyzed allergens and diets from antigravity
          // Use already-analyzed allergens and diets from antigravity
          const allergens = top9Allergens.map(a => {
            // Handle object format {name: "...", triggers: [...]}
            if (typeof a === 'object' && a.name) {
              return a.name;
            }
            // Handle string format "Allergen (trigger)"
            if (typeof a === 'string') {
              const match = a.match(/^([^(]+)(?:\s*\(([^)]+)\))?$/);
              if (match) {
                return match[1].trim();
              }
              return a;
            }
            return String(a);
          });

          // Convert dietary compliance to diets array
          // Handle different naming conventions: camelCase vs snake_case, lowercase vs Capitalized keys
          let diets = [];
          if (dietaryCompliance) {
            const getCompliant = (key1, key2) => {
              const entry = dietaryCompliance[key1] || dietaryCompliance[key2];
              return entry?.isCompliant === true || entry?.is_compliant === true;
            };
            if (getCompliant('vegan', 'Vegan')) diets.push('Vegan');
            if (getCompliant('vegetarian', 'Vegetarian')) diets.push('Vegetarian');
            if (getCompliant('pescatarian', 'Pescatarian')) diets.push('Pescatarian');
            if (getCompliant('glutenFree', 'Gluten-free')) diets.push('Gluten-free');
          }

          // Fallback to diets array from barcodeResult or suggestion if dietaryCompliance yielded nothing
          if (diets.length === 0) {
            const fallbackDiets = barcodeResult.diets || suggestion.diets || [];
            if (Array.isArray(fallbackDiets) && fallbackDiets.length > 0) {
              diets = fallbackDiets.map(d => {
                // Normalize to proper casing
                const lower = (d || '').toLowerCase().trim();
                const proper = DIETS.find(pd => pd.toLowerCase() === lower);
                return proper || d;
              });
            }
          }

          // Update suggestion with allergens and diets
          suggestion.allergens = allergens;
          suggestion.diets = diets;

          // Close modal and apply
          document.body.removeChild(modal);
          closeModal();

          const sourceCount = sources.length;
          aiAssistSetStatus(`Product confirmed from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}.`, 'success');

          setTimeout(() => {
            applyBrandSuggestionConfirmed(rowIdx, suggestion);
          }, 0);
        });
      }

      // Legacy handlers for old button types (keeping for backwards compatibility)
      const confirmBtn = modalContent.querySelector('.confirmBtn');
      const confirmConsensusBtn = modalContent.querySelector('.confirmConsensusBtn');
      const confirmIngredientListBtn = modalContent.querySelector('.confirmIngredientListBtn');
      const confirmVariationBtns = modalContent.querySelectorAll('.confirmVariationBtn');
      const confirmGroupBtns = modalContent.querySelectorAll('.confirmGroupIngredientListBtn');

      // Handle grouped ingredient list confirmation buttons
      confirmGroupBtns.forEach(btn => {
        let groupConfirmed = false;

        btn.addEventListener('mouseenter', () => {
          if (!groupConfirmed) {
            btn.style.background = btn.dataset.groupIdx === '0' ? '#5d6ae5' : '#f59e0b';
          }
        });

        btn.addEventListener('mouseleave', () => {
          if (!groupConfirmed) {
            btn.style.background = btn.dataset.groupIdx === '0' ? '#4c5ad4' : '#ff9800';
          }
        });

        btn.addEventListener('click', async () => {
          groupConfirmed = true;
          btn.style.background = '#4caf50';
          btn.innerHTML = ' Confirmed';
          btn.style.cursor = 'default';

          // Get ingredient text from the parent group div
          const groupDiv = btn.closest('[data-ingredients-text]');
          const groupIngredientList = groupDiv ? groupDiv.dataset.ingredientsText : (ingredientList || '');

          // Show loading message next to button
          const loadingMsg = document.createElement('span');
          loadingMsg.textContent = ' Loading...';
          loadingMsg.style.cssText = 'color: #9ca3af; font-size: 0.85rem; font-style: italic;';
          btn.parentElement.appendChild(loadingMsg);

          // Update suggestion with selected ingredient list
          suggestion.ingredientsList = [groupIngredientList];

          try {
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: {
                ingredientText: groupIngredientList,
                productName: productName,
                labels: [],
                categories: []
              }
            });

            if (!analysisResult.error && analysisResult.data) {
              const { allergens, diets } = analysisResult.data;

              if (loadingMsg.parentElement) {
                loadingMsg.remove();
              }

              showAllergenDietPreview(rowIdx, suggestion, {
                allergens: allergens || [],
                diets: diets || [],
                ingredientList: groupIngredientList,
                productName: productName
              });

              document.body.removeChild(modal);
              closeModal();
              return;
            }
          } catch (err) {
            console.error('Failed to analyze allergens/diets:', err);
            if (loadingMsg.parentElement) {
              loadingMsg.remove();
            }
          }

          // If analysis fails, proceed normally
          if (loadingMsg.parentElement) {
            loadingMsg.remove();
          }
          document.body.removeChild(modal);
          closeModal();

          const sourceCount = sources.length;
          aiAssistSetStatus(`Product found! Verified from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}.`, 'success');

          setTimeout(() => {
            applyBrandSuggestionConfirmed(rowIdx, suggestion);
          }, 0);
        });
      });

      // Handle ingredient list confirmation button (for non-conflict cases)
      if (confirmIngredientListBtn) {
        let ingredientListConfirmed = false;

        confirmIngredientListBtn.addEventListener('mouseenter', () => {
          if (!ingredientListConfirmed) {
            confirmIngredientListBtn.style.background = '#5d6ae5';
          }
        });

        confirmIngredientListBtn.addEventListener('mouseleave', () => {
          if (!ingredientListConfirmed) {
            confirmIngredientListBtn.style.background = '#4c5ad4';
          }
        });

        confirmIngredientListBtn.addEventListener('click', async () => {
          ingredientListConfirmed = true;
          confirmIngredientListBtn.style.background = '#4caf50';
          confirmIngredientListBtn.innerHTML = ' Confirmed';
          confirmIngredientListBtn.style.cursor = 'default';

          // Show loading message next to button
          const loadingMsg = document.createElement('span');
          loadingMsg.textContent = 'Loading detected allergens and dietary preferences...';
          loadingMsg.style.cssText = 'margin-left: 12px; color: #9ca3af; font-size: 0.85rem; font-style: italic;';
          confirmIngredientListBtn.parentElement.appendChild(loadingMsg);

          // User confirmed the ingredient list - proceed with allergen/diet preview
          const finalIngredientList = ingredientList || suggestion.ingredientsList?.[0] || '';

          try {
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: {
                ingredientText: finalIngredientList,
                productName: productName,
                labels: [],
                categories: []
              }
            });

            if (!analysisResult.error && analysisResult.data) {
              const { allergens, diets } = analysisResult.data;

              // Remove loading message
              if (loadingMsg.parentElement) {
                loadingMsg.remove();
              }

              showAllergenDietPreview(rowIdx, suggestion, {
                allergens: allergens || [],
                diets: diets || [],
                ingredientList: finalIngredientList,
                productName: productName
              });

              document.body.removeChild(modal);
              closeModal();
              return;
            }
          } catch (err) {
            console.error('Failed to analyze allergens/diets:', err);
            // Remove loading message on error
            if (loadingMsg.parentElement) {
              loadingMsg.remove();
            }
          }

          // If analysis fails, proceed normally
          if (loadingMsg.parentElement) {
            loadingMsg.remove();
          }
          document.body.removeChild(modal);
          closeModal();

          const sourceCount = sources.length;
          aiAssistSetStatus(`Product found! Verified from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}.`, 'success');

          setTimeout(() => {
            applyBrandSuggestionConfirmed(rowIdx, suggestion);
          }, 0);
        });
      }

      // Handle variation confirmation buttons
      confirmVariationBtns.forEach(btn => {
        let variationConfirmed = false;

        btn.addEventListener('mouseenter', () => {
          if (!variationConfirmed) {
            btn.style.background = '#5d6ae5';
          }
        });

        btn.addEventListener('mouseleave', () => {
          if (!variationConfirmed) {
            btn.style.background = '#4c5ad4';
          }
        });

        btn.addEventListener('click', async () => {
          variationConfirmed = true;
          btn.style.background = '#4caf50';
          btn.innerHTML = ' Confirmed';
          btn.style.cursor = 'default';

          // Get the ingredient list from the button's data attribute
          const variationIngredientList = btn.dataset.ingredients || '';

          // Show loading message next to button
          const loadingMsg = document.createElement('span');
          loadingMsg.textContent = 'Loading detected allergens and dietary preferences...';
          loadingMsg.style.cssText = 'margin-left: 12px; color: #9ca3af; font-size: 0.85rem; font-style: italic;';
          btn.parentElement.appendChild(loadingMsg);

          try {
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: {
                ingredientText: variationIngredientList,
                productName: productName,
                labels: [],
                categories: []
              }
            });

            if (!analysisResult.error && analysisResult.data) {
              const { allergens, diets } = analysisResult.data;

              // Remove loading message
              if (loadingMsg.parentElement) {
                loadingMsg.remove();
              }

              showAllergenDietPreview(rowIdx, suggestion, {
                allergens: allergens || [],
                diets: diets || [],
                ingredientList: variationIngredientList,
                productName: productName
              });

              document.body.removeChild(modal);
              closeModal();
              return;
            }
          } catch (err) {
            console.error('Failed to analyze allergens/diets:', err);
            // Remove loading message on error
            if (loadingMsg.parentElement) {
              loadingMsg.remove();
            }
          }

          // If analysis fails, proceed normally
          if (loadingMsg.parentElement) {
            loadingMsg.remove();
          }
          document.body.removeChild(modal);
          closeModal();

          const sourceCount = sources.length;
          aiAssistSetStatus(`Product found! Verified from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}.`, 'success');

          // Update suggestion with the variation's ingredient list
          suggestion.ingredientsList = [variationIngredientList];

          setTimeout(() => {
            applyBrandSuggestionConfirmed(rowIdx, suggestion);
          }, 0);
        });
      });

      // Handle consensus confirmation button
      if (confirmConsensusBtn) {
        let consensusConfirmed = false;

        confirmConsensusBtn.addEventListener('mouseenter', () => {
          if (!consensusConfirmed) {
            confirmConsensusBtn.style.background = '#5d6ae5';
          }
        });

        confirmConsensusBtn.addEventListener('mouseleave', () => {
          if (!consensusConfirmed) {
            confirmConsensusBtn.style.background = '#4c5ad4';
          }
        });

        confirmConsensusBtn.addEventListener('click', async () => {
          consensusConfirmed = true;
          confirmConsensusBtn.style.background = '#4caf50';
          confirmConsensusBtn.innerHTML = ' Confirmed';
          confirmConsensusBtn.style.cursor = 'default';

          // Show loading message next to button
          const loadingMsg = document.createElement('span');
          loadingMsg.textContent = 'Loading detected allergens and dietary preferences...';
          loadingMsg.style.cssText = 'margin-left: 12px; color: #9ca3af; font-size: 0.85rem; font-style: italic;';
          confirmConsensusBtn.parentElement.appendChild(loadingMsg);

          // User confirmed the consensus list - proceed with allergen/diet preview
          const finalIngredientList = ingredientList || suggestion.ingredientsList?.[0] || '';

          try {
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: {
                ingredientText: finalIngredientList,
                productName: productName,
                labels: [],
                categories: []
              }
            });

            if (!analysisResult.error && analysisResult.data) {
              const { allergens, diets } = analysisResult.data;

              // Remove loading message
              if (loadingMsg.parentElement) {
                loadingMsg.remove();
              }

              showAllergenDietPreview(rowIdx, suggestion, {
                allergens: allergens || [],
                diets: diets || [],
                ingredientList: finalIngredientList,
                productName: productName
              });

              document.body.removeChild(modal);
              closeModal();
              return;
            }
          } catch (err) {
            console.error('Failed to analyze allergens/diets:', err);
            // Remove loading message on error
            if (loadingMsg.parentElement) {
              loadingMsg.remove();
            }
          }

          // If analysis fails, proceed normally
          if (loadingMsg.parentElement) {
            loadingMsg.remove();
          }
          document.body.removeChild(modal);
          closeModal();

          const sourceCount = sources.length;
          aiAssistSetStatus(`Product found! Verified from ${sourceCount} source${sourceCount !== 1 ? 's' : ''}.`, 'success');

          setTimeout(() => {
            applyBrandSuggestionConfirmed(rowIdx, suggestion);
          }, 0);
        });
      }

      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        closeModal(); // Close barcode scanner modal too
      });

      // Close on outside click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          closeModal();
        }
      });
    }

    // Show allergen and dietary preference preview before applying
    function showAllergenDietPreview(rowIdx, suggestion, analysisData) {
      const { allergens, diets, ingredientList, productName } = analysisData;

      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10003;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #4c5ad4;
    border-radius: 16px;
    max-width: 700px;
    max-height: 85vh;
    overflow-y: auto;
    padding: 24px;
    color: #fff;
    width: 100%;
  `;

      const allergensList = allergens.length > 0 ? allergens.map(a => `
    <div style="
      display: inline-block;
      padding: 6px 12px;
      margin: 4px;
      background: rgba(220,82,82,0.2);
      border: 1px solid rgba(220,82,82,0.4);
      border-radius: 6px;
      font-size: 0.9rem;
      color: #ff6b6b;
      font-weight: 500;
    ">${esc(a)}</div>
  `).join('') : '<div style="color: #9ca3af; font-weight: 600;"> No allergens detected</div>';

      const dietsList = diets.length > 0 ? diets.map(d => `
    <div style="
      display: inline-block;
      padding: 6px 12px;
      margin: 4px;
      background: rgba(76,212,90,0.2);
      border: 1px solid rgba(76,212,90,0.4);
      border-radius: 6px;
      font-size: 0.9rem;
      color: #4caf50;
      font-weight: 500;
    ">${esc(d)}</div>
  `).join('') : '<div style="color: #999;">No dietary preferences detected</div>';

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: #4c5ad4; font-size: 1.4rem;"> Allergen & Diet Preview</h3>
      <p style="margin: 0; font-size: 1rem; color: #fff; font-weight: 600;">${esc(productName)}</p>
    </div>

    <div style="margin-bottom: 20px;">
      <div style="font-weight: 600; color: #4c5ad4; font-size: 1.05rem; margin-bottom: 12px;">
        Ingredient List:
      </div>
      <div style="
        background: rgba(76,90,212,0.1);
        border: 1px solid rgba(76,90,212,0.3);
        border-radius: 8px;
        padding: 16px;
        font-size: 0.95rem;
        line-height: 1.6;
        color: #e0e0e0;
        white-space: pre-wrap;
        word-wrap: break-word;
      ">
        ${esc(ingredientList)}
      </div>
    </div>

    <div style="margin-bottom: 24px;">
      <div style="font-weight: 600; color: #dc5252; font-size: 1.05rem; margin-bottom: 12px;">
         Detected Allergens:
      </div>
      <div style="margin-bottom: 20px;">
        ${allergensList}
      </div>

      <div style="font-weight: 600; color: #4caf50; font-size: 1.05rem; margin-bottom: 12px;">
         Dietary Preferences:
      </div>
      <div>
        ${dietsList}
      </div>
    </div>

    <div style="display: flex; gap: 12px; justify-content: space-between; align-items: center;">
      <button type="button" class="reportIssueBtn" style="
        padding: 14px 24px;
        background: #dc2626;
        border: none;
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      "> Something isn't right</button>
      <div style="display: flex; gap: 12px;">
        <button type="button" class="cancelPreviewBtn" style="
          padding: 14px 24px;
          background: rgba(255,255,255,0.1);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Cancel</button>
        <button type="button" class="applyPreviewBtn" style="
          padding: 14px 24px;
          background: #4c5ad4;
          border: none;
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Apply with Detected Allergens & Diets</button>
      </div>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      const cancelBtn = modalContent.querySelector('.cancelPreviewBtn');
      const applyBtn = modalContent.querySelector('.applyPreviewBtn');
      const reportBtn = modalContent.querySelector('.reportIssueBtn');

      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
      });

      applyBtn.addEventListener('click', () => {
        document.body.removeChild(modal);

        // Update suggestion with detected allergens and diets
        suggestion.allergens = allergens;
        suggestion.diets = diets;

        const sourceCount = suggestion.ingredientsList ? suggestion.ingredientsList.length : 0;
        aiAssistSetStatus(`Product applied with detected allergens and dietary preferences.`, 'success');

        setTimeout(() => {
          applyBrandSuggestionConfirmed(rowIdx, suggestion);
        }, 0);
      });

      reportBtn.addEventListener('click', () => {
        // Show comment modal
        showAllergenIssueCommentModal(modal, rowIdx, suggestion, analysisData);
      });

      // Close on outside click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    }

    // Show allergen and dietary preference preview for replacement
    function showReplacementAllergenDietPreview(oldItem, replacementData) {
      const { brandName, barcode, ingredientList, brandImage, productName, allergens, diets } = replacementData;

      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10003;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #4c5ad4;
    border-radius: 16px;
    max-width: 700px;
    max-height: 85vh;
    overflow-y: auto;
    padding: 24px;
    color: #fff;
    width: 100%;
  `;

      const allergensList = allergens.length > 0 ? allergens.map(a => `
    <div style="
      display: inline-block;
      padding: 6px 12px;
      margin: 4px;
      background: rgba(220,82,82,0.2);
      border: 1px solid rgba(220,82,82,0.4);
      border-radius: 6px;
      font-size: 0.9rem;
      color: #ff6b6b;
      font-weight: 500;
    ">${esc(a)}</div>
  `).join('') : '<div style="color: #9ca3af; font-weight: 600;"> No allergens detected</div>';

      const dietsList = diets.length > 0 ? diets.map(d => `
    <div style="
      display: inline-block;
      padding: 6px 12px;
      margin: 4px;
      background: rgba(76,212,90,0.2);
      border: 1px solid rgba(76,212,90,0.4);
      border-radius: 6px;
      font-size: 0.9rem;
      color: #4caf50;
      font-weight: 500;
    ">${esc(d)}</div>
  `).join('') : '<div style="color: #999;">No dietary preferences detected</div>';

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: #4c5ad4; font-size: 1.4rem;"> Replacement Preview</h3>
      <p style="margin: 0 0 4px 0; font-size: 1rem; color: #fff; font-weight: 600;">Replacing: <span style="color: #a8b2d6;">${esc(oldItem.brandName)}</span>  <span style="color: #4c5ad4;">${esc(brandName)}</span></p>
      <p style="margin: 0; font-size: 0.9rem; color: #a8b2d6;">${esc(productName)}</p>
    </div>

    <div style="margin-bottom: 20px;">
      <div style="font-weight: 600; color: #4c5ad4; font-size: 1.05rem; margin-bottom: 12px;">
        Ingredient List:
      </div>
      <div style="
        background: rgba(76,90,212,0.1);
        border: 1px solid rgba(76,90,212,0.3);
        border-radius: 8px;
        padding: 16px;
        font-size: 0.95rem;
        line-height: 1.6;
        color: #e0e0e0;
        white-space: pre-wrap;
        word-wrap: break-word;
      ">
        ${esc(ingredientList)}
      </div>
    </div>

    <div style="margin-bottom: 24px;">
      <div style="font-weight: 600; color: #dc5252; font-size: 1.05rem; margin-bottom: 12px;">
         Detected Allergens:
      </div>
      <div style="margin-bottom: 20px;">
        ${allergensList}
      </div>

      <div style="font-weight: 600; color: #4caf50; font-size: 1.05rem; margin-bottom: 12px;">
         Dietary Preferences:
      </div>
      <div>
        ${dietsList}
      </div>
    </div>

    <div style="display: flex; gap: 12px; justify-content: space-between; align-items: center;">
      <button type="button" class="reportReplacementIssueBtn" style="
        padding: 14px 24px;
        background: #dc2626;
        border: none;
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      "> Something isn't right</button>
      <div style="display: flex; gap: 12px;">
        <button type="button" class="cancelReplacementPreviewBtn" style="
          padding: 14px 24px;
          background: rgba(255,255,255,0.1);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Cancel</button>
        <button type="button" class="applyReplacementPreviewBtn" style="
          padding: 14px 24px;
          background: #4c5ad4;
          border: none;
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Apply Replacement</button>
      </div>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      const cancelBtn = modalContent.querySelector('.cancelReplacementPreviewBtn');
      const applyBtn = modalContent.querySelector('.applyReplacementPreviewBtn');
      const reportBtn = modalContent.querySelector('.reportReplacementIssueBtn');

      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        renderBrandItems();
      });

      applyBtn.addEventListener('click', async () => {
        document.body.removeChild(modal);

        // Find the overlay indices for the old item
        const overlayIndices = oldItem.dishes.map(d => d.overlayIdx);

        // Apply the replacement
        await applyReplacement(oldItem, brandName, barcode, ingredientList, brandImage, overlayIndices, allergens, diets);
        renderBrandItems();
      });

      reportBtn.addEventListener('click', () => {
        // Show comment modal for reporting issues
        showReplacementIssueCommentModal(modal, oldItem, replacementData);
      });

      // Close on outside click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          renderBrandItems();
        }
      });
    }

    // Show comment modal for reporting replacement allergen/diet issues
    function showReplacementIssueCommentModal(parentModal, oldItem, replacementData) {
      const { brandName, productName, allergens, diets, ingredientList } = replacementData;
      const restaurantName = state.restaurant?.name || state.restaurant?.restaurantName || 'Unknown Restaurant';
      const restaurantSlug = state.restaurant?.slug || state.restaurant?._id || '';

      // Hide parent modal temporarily
      parentModal.style.display = 'none';

      const commentModal = document.createElement('div');
      commentModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10004;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #dc2626;
    border-radius: 16px;
    max-width: 600px;
    padding: 24px;
    color: #fff;
    width: 100%;
  `;

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: #dc2626; font-size: 1.4rem;"> Report Issue</h3>
      <p style="margin: 0; font-size: 1rem; color: #fff; font-weight: 600;">${esc(productName)}</p>
    </div>

    <div style="margin-bottom: 20px;">
      <label style="display: block; font-weight: 600; color: #fff; margin-bottom: 8px; font-size: 1.05rem;">
        What seems wrong with the allergen/diet detection?
      </label>
      <textarea id="replacementIssueComment" placeholder="Please describe what's incorrect about the detected allergens or dietary preferences..." style="
        width: 100%;
        min-height: 150px;
        padding: 12px;
        background: rgba(76,90,212,0.1);
        border: 1px solid rgba(76,90,212,0.3);
        border-radius: 8px;
        color: #fff;
        font-size: 0.95rem;
        font-family: inherit;
        resize: vertical;
        box-sizing: border-box;
      "></textarea>
      <div id="replacementCommentStatus" style="margin-top: 12px; color: #a8b2d6; font-size: 0.9rem; min-height: 24px;"></div>
    </div>

    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button type="button" class="cancelReplacementCommentBtn" style="
        padding: 14px 24px;
        background: rgba(255,255,255,0.1);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
      <button type="button" class="submitReplacementIssueBtn" style="
        padding: 14px 24px;
        background: #dc2626;
        border: none;
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">Send Report</button>
    </div>
  `;

      commentModal.appendChild(modalContent);
      document.body.appendChild(commentModal);

      const commentTextarea = modalContent.querySelector('#replacementIssueComment');
      const cancelBtn = modalContent.querySelector('.cancelReplacementCommentBtn');
      const submitBtn = modalContent.querySelector('.submitReplacementIssueBtn');
      const statusDiv = modalContent.querySelector('#replacementCommentStatus');

      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(commentModal);
        parentModal.style.display = 'flex';
      });

      submitBtn.addEventListener('click', async () => {
        const comment = commentTextarea.value.trim();

        if (!comment) {
          statusDiv.textContent = 'Please describe the issue before submitting.';
          statusDiv.style.color = '#ef4444';
          return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = 'Sending...';
        statusDiv.textContent = 'Sending report...';
        statusDiv.style.color = '#a8b2d6';

        try {
          // Send email notification
          const result = await window.supabaseClient.functions.invoke('send-notification-email', {
            body: {
              type: 'allergen_issue',
              restaurantName: restaurantName,
              restaurantSlug: restaurantSlug,
              productName: productName,
              brandName: brandName,
              ingredientList: ingredientList,
              detectedAllergens: allergens || [],
              detectedDiets: diets || [],
              comment: comment,
              context: 'brand_replacement'
            }
          });

          if (result.error) {
            throw new Error(result.error.message || 'Failed to send report');
          }

          statusDiv.textContent = 'Report sent successfully. Thank you for your feedback!';
          statusDiv.style.color = '#4caf50';

          setTimeout(() => {
            document.body.removeChild(commentModal);
            document.body.removeChild(parentModal);
            renderBrandItems();
          }, 2000);
        } catch (error) {
          console.error('Error sending replacement issue report:', error);
          statusDiv.textContent = 'Failed to send report. Please try again.';
          statusDiv.style.color = '#ef4444';
          submitBtn.disabled = false;
          submitBtn.textContent = 'Send Report';
        }
      });
    }

    // Show comment modal for reporting allergen/diet issues
    function showAllergenIssueCommentModal(parentModal, rowIdx, suggestion, analysisData) {
      const { allergens, diets, ingredientList, productName } = analysisData;
      const restaurantName = state.restaurant?.name || state.restaurant?.restaurantName || 'Unknown Restaurant';
      const restaurantSlug = state.restaurant?.slug || state.restaurant?._id || '';

      // Hide parent modal temporarily
      parentModal.style.display = 'none';

      const commentModal = document.createElement('div');
      commentModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10004;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #dc2626;
    border-radius: 16px;
    max-width: 600px;
    padding: 24px;
    color: #fff;
    width: 100%;
  `;

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: #dc2626; font-size: 1.4rem;"> Report Issue</h3>
      <p style="margin: 0; font-size: 1rem; color: #fff; font-weight: 600;">${esc(productName)}</p>
    </div>

    <div style="margin-bottom: 20px;">
      <label style="display: block; font-weight: 600; color: #fff; margin-bottom: 8px; font-size: 1.05rem;">
        What seems wrong with the allergen/diet detection?
      </label>
      <textarea id="issueComment" placeholder="Please describe what's incorrect about the detected allergens or dietary preferences..." style="
        width: 100%;
        min-height: 150px;
        padding: 12px;
        background: rgba(76,90,212,0.1);
        border: 1px solid rgba(76,90,212,0.3);
        border-radius: 8px;
        color: #fff;
        font-size: 0.95rem;
        font-family: inherit;
        resize: vertical;
        box-sizing: border-box;
      "></textarea>
      <div id="commentStatus" style="margin-top: 12px; color: #a8b2d6; font-size: 0.9rem; min-height: 24px;"></div>
    </div>

    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button type="button" class="cancelCommentBtn" style="
        padding: 14px 24px;
        background: rgba(255,255,255,0.1);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
      <button type="button" class="submitIssueBtn" style="
        padding: 14px 24px;
        background: #dc2626;
        border: none;
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">Send Report</button>
    </div>
  `;

      commentModal.appendChild(modalContent);
      document.body.appendChild(commentModal);

      const commentTextarea = modalContent.querySelector('#issueComment');
      const cancelBtn = modalContent.querySelector('.cancelCommentBtn');
      const submitBtn = modalContent.querySelector('.submitIssueBtn');
      const statusDiv = modalContent.querySelector('#commentStatus');

      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(commentModal);
        parentModal.style.display = 'flex';
      });

      submitBtn.addEventListener('click', async () => {
        const comment = commentTextarea.value.trim();

        if (!comment) {
          statusDiv.textContent = 'Please describe the issue before submitting.';
          statusDiv.style.color = '#ef4444';
          return;
        }

        submitBtn.disabled = true;
        submitBtn.textContent = 'Sending...';
        statusDiv.textContent = 'Sending report...';
        statusDiv.style.color = '#a8b2d6';

        try {
          // Send email notification
          const result = await window.supabaseClient.functions.invoke('send-notification-email', {
            body: {
              type: 'allergen_issue',
              restaurantName: restaurantName,
              restaurantSlug: restaurantSlug,
              productName: productName,
              ingredientList: ingredientList,
              detectedAllergens: allergens,
              detectedDiets: diets,
              managerComment: comment
            }
          });

          if (result.error) {
            console.error('Email send error:', result.error);
            statusDiv.textContent = 'Failed to send report. Please try again.';
            statusDiv.style.color = '#ef4444';
            submitBtn.disabled = false;
            submitBtn.textContent = 'Send Report';
            return;
          }

          statusDiv.textContent = 'Report sent successfully! We will review the issue.';
          statusDiv.style.color = '#4ade80';

          // Mark this ingredient as having a reported issue
          const data = collectAiTableData();
          if (data[rowIdx]) {
            data[rowIdx].issueReported = true;
          }
          renderAiTable(data);

          // Close modals after a moment
          setTimeout(() => {
            document.body.removeChild(commentModal);
            if (parentModal.parentNode) {
              document.body.removeChild(parentModal);
            }
            aiAssistSetStatus('Issue report sent successfully', 'success');
          }, 1500);

        } catch (error) {
          console.error('Error sending report:', error);
          statusDiv.textContent = 'Error sending report: ' + (error.message || 'Unknown error');
          statusDiv.style.color = '#ef4444';
          submitBtn.disabled = false;
          submitBtn.textContent = 'Send Report';
        }
      });

      // Close on outside click
      commentModal.addEventListener('click', (e) => {
        if (e.target === commentModal) {
          document.body.removeChild(commentModal);
          parentModal.style.display = 'flex';
        }
      });
    }

    function applyBrandSuggestion(rowIdx, suggestionIdx) {
      ensureAiAssistElements();
      const suggestions = aiAssistState.brandSuggestions[rowIdx] || [];
      const suggestion = suggestions[suggestionIdx];
      if (!suggestion) return;

      // Show confirmation modal to verify product and ingredients
      showBrandConfirmationModal(suggestion, () => {
        // User confirmed - proceed with applying the brand
        applyBrandSuggestionConfirmed(rowIdx, suggestion);
      });
    }

    // Show option to choose between quick verification or multi-source verification
    function showMultiSourceVerificationOption(rowIdx, suggestion, barcode) {
      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #4c5ad4;
    border-radius: 16px;
    max-width: 600px;
    padding: 24px;
    color: #fff;
  `;

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: #4c5ad4; font-size: 1.4rem;"> Product Found!</h3>
      <p style="margin: 0; font-size: 1rem; color: #fff; font-weight: 600;">${esc(suggestion.name)}</p>
      ${suggestion.brand ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">${esc(suggestion.brand)}</p>` : ''}
    </div>

    <div style="margin-bottom: 24px;">
      <p style="margin: 0 0 16px 0; color: #a0a0a0; font-size: 0.95rem;">
        Choose how you want to verify this product:
      </p>

      <div style="margin-bottom: 16px; padding: 12px; background: rgba(76,90,212,0.1); border-radius: 8px; border: 1px solid rgba(76,90,212,0.3);">
        <label style="display: block; color: #a0a0a0; font-size: 0.9rem; margin-bottom: 8px;">
          AI Search Provider:
        </label>
        <select class="searchProviderSelect" style="
          width: 100%;
          padding: 8px 12px;
          background: #0b1020;
          border: 1px solid #4c5ad4;
          border-radius: 6px;
          color: #fff;
          font-size: 0.95rem;
          cursor: pointer;
        ">
          <option value="claude"> Claude (Web Search Enabled)</option>
        </select>
        <div style="margin-top: 6px; font-size: 0.8rem; color: #7c8db5; font-style: italic;">
          Claude uses web search to find ingredient information from multiple sources
        </div>
      </div>

      <div style="display: flex; flex-direction: column; gap: 12px;">
        <button type="button" class="quickVerify" style="
          padding: 16px;
          background: rgba(76,90,212,0.2);
          border: 2px solid #4c5ad4;
          border-radius: 12px;
          color: #fff;
          text-align: left;
          cursor: pointer;
          transition: all 0.2s;
        ">
          <div style="font-weight: 600; font-size: 1.05rem; margin-bottom: 6px;"> Quick Verification (Single Source)</div>
          <div style="font-size: 0.85rem; color: #a0a0a0; line-height: 1.4;">
            Verify using Open Food Facts database only. Faster but less comprehensive.
          </div>
        </button>

        <button type="button" class="multiSourceVerify" style="
          padding: 16px;
          background: rgba(76,212,90,0.2);
          border: 2px solid #4caf50;
          border-radius: 12px;
          color: #fff;
          text-align: left;
          cursor: pointer;
          transition: all 0.2s;
        ">
          <div style="font-weight: 600; font-size: 1.05rem; margin-bottom: 6px; color: #4caf50;">
             Multi-Source Verification (Recommended)
          </div>
          <div style="font-size: 0.85rem; color: #a0a0a0; line-height: 1.4;">
            Search brand website + additional retailers for ingredient lists. AI compares all sources for consistency.
            More thorough and reliable.
          </div>
        </button>
      </div>
    </div>

    <div style="display: flex; justify-content: flex-end;">
      <button type="button" class="cancelVerify" style="
        padding: 12px 24px;
        background: #301424;
        border: 1px solid #4c2138;
        border-radius: 8px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      const quickBtn = modalContent.querySelector('.quickVerify');
      const multiBtn = modalContent.querySelector('.multiSourceVerify');
      const cancelBtn = modalContent.querySelector('.cancelVerify');
      const providerSelect = modalContent.querySelector('.searchProviderSelect');

      // Hover effects
      quickBtn.addEventListener('mouseenter', () => {
        quickBtn.style.background = 'rgba(76,90,212,0.3)';
        quickBtn.style.transform = 'translateY(-2px)';
      });
      quickBtn.addEventListener('mouseleave', () => {
        quickBtn.style.background = 'rgba(76,90,212,0.2)';
        quickBtn.style.transform = 'translateY(0)';
      });

      multiBtn.addEventListener('mouseenter', () => {
        multiBtn.style.background = 'rgba(76,212,90,0.3)';
        multiBtn.style.transform = 'translateY(-2px)';
      });
      multiBtn.addEventListener('mouseleave', () => {
        multiBtn.style.background = 'rgba(76,212,90,0.2)';
        multiBtn.style.transform = 'translateY(0)';
      });

      // Quick verification - use existing modal
      quickBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        showBrandConfirmationModal(suggestion, () => {
          applyBrandSuggestionConfirmed(rowIdx, suggestion);
        });
      });

      // Multi-source verification - call new edge function
      multiBtn.addEventListener('click', async () => {
        const selectedProvider = providerSelect.value;
        document.body.removeChild(modal);
        await verifyProductFromMultipleSources(rowIdx, suggestion, barcode, selectedProvider);
      });

      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        aiAssistSetStatus('Product verification cancelled', 'warn');
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          aiAssistSetStatus('Product verification cancelled', 'warn');
        }
      });
    }

    // Show error modal when multi-source verification fails
    function showMultiSourceErrorModal(errorMessage, provider, openFoodFactsSuggestion, rowIdx) {
      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #dc5252;
    border-radius: 16px;
    max-width: 600px;
    width: 100%;
    padding: 24px;
    color: #fff;
  `;

      // Check if it's an API key error
      const isApiKeyError = errorMessage.includes('API_KEY') || errorMessage.includes('not configured');
      const providerName = 'Claude';
      const apiKeyName = 'ANTHROPIC_API_KEY';

      // Defensive check for openFoodFactsSuggestion
      const safeSuggestion = openFoodFactsSuggestion || {};
      const productName = safeSuggestion.name || safeSuggestion.product_name || 'Unknown Product';
      const productBrand = safeSuggestion.brand || '';

      modalContent.innerHTML = `
    <div style="text-align: center; margin-bottom: 20px;">
      <div style="font-size: 3rem; color: #dc5252; margin-bottom: 12px;"></div>
      <h2 style="margin: 0 0 8px 0; color: #dc5252; font-size: 1.5rem;">Multi-Source Verification Failed</h2>
      <p style="margin: 0; color: #a0a0a0; font-size: 0.95rem;">
        ${productBrand ? esc(productBrand) + ' ' : ''}${esc(productName)}
      </p>
    </div>

    <div style="background: rgba(220,82,82,0.1); border: 1px solid rgba(220,82,82,0.3); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
      <div style="font-weight: 600; color: #dc5252; margin-bottom: 8px;">Error Details:</div>
      <div style="font-size: 0.9rem; color: #e0e0e0; line-height: 1.5; font-family: monospace; word-break: break-word;">
        ${esc(errorMessage)}
      </div>
    </div>

    ${isApiKeyError ? `
      <div style="background: rgba(76,90,212,0.1); border: 1px solid rgba(76,90,212,0.3); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <div style="font-weight: 600; color: #4c5ad4; margin-bottom: 12px;"> Setup Required:</div>
        <div style="font-size: 0.9rem; color: #e0e0e0; line-height: 1.6;">
          <p style="margin: 0 0 12px 0;">The <strong>${providerName}</strong> API key is not configured. To use this provider:</p>
          <ol style="margin: 0; padding-left: 20px;">
            <li style="margin-bottom: 8px;">Go to your <a href="https://supabase.com/dashboard/project/fgoiyycctnwnghrvsilt/settings/functions" target="_blank" style="color: #7c9cff; text-decoration: underline;">Supabase Functions Settings</a></li>
            <li style="margin-bottom: 8px;">Add environment variable: <code style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px;">${apiKeyName}</code></li>
            <li style="margin-bottom: 8px;">Get API key from: <a href="https://console.anthropic.com/" target="_blank" style="color: #7c9cff; text-decoration: underline;">Anthropic Console</a></li>
          </ol>
        </div>
      </div>
    ` : ''}

    <div style="margin-bottom: 20px;">
      <p style="margin: 0 0 12px 0; color: #a0a0a0; font-size: 0.95rem;">What would you like to do?</p>
      
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <button type="button" class="useQuick" style="
          padding: 16px;
          background: rgba(76,212,90,0.2);
          border: 2px solid #4caf50;
          border-radius: 12px;
          color: #fff;
          text-align: left;
          cursor: pointer;
          transition: all 0.2s;
        ">
          <div style="font-weight: 600; font-size: 1.05rem; margin-bottom: 6px;"> Use Quick Verification</div>
          <div style="font-size: 0.85rem; color: #a0a0a0; line-height: 1.4;">
            Verify using Open Food Facts only (single source, no API key needed)
          </div>
        </button>
      </div>
    </div>

    <div style="display: flex; justify-content: flex-end;">
      <button type="button" class="closeError" style="
        padding: 12px 24px;
        background: #301424;
        border: 1px solid #4c2138;
        border-radius: 8px;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      const useQuickBtn = modalContent.querySelector('.useQuick');
      const closeBtn = modalContent.querySelector('.closeError');

      // Use quick verification
      useQuickBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        showBrandConfirmationModal(openFoodFactsSuggestion, () => {
          applyBrandSuggestionConfirmed(rowIdx, openFoodFactsSuggestion);
        });
      });

      // Close
      closeBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        aiAssistSetStatus('Verification cancelled', 'warn');
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          aiAssistSetStatus('Verification cancelled', 'warn');
        }
      });
    }

    // Show modal when insufficient sources are found
    function showInsufficientSourcesModal(verificationData, openFoodFactsSuggestion) {
      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    padding: 20px;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid #dc5252;
    border-radius: 16px;
    max-width: 600px;
    width: 100%;
    padding: 24px;
    color: #fff;
  `;

      const sourcesFound = verificationData.sources || [];
      const sourcesWithData = sourcesFound.filter(s => s && s.dataAvailable);

      // Defensive check for openFoodFactsSuggestion
      const safeSuggestion = openFoodFactsSuggestion || {};
      const productName = safeSuggestion.name || safeSuggestion.product_name || 'Unknown Product';
      const productBrand = safeSuggestion.brand || '';

      modalContent.innerHTML = `
    <div style="text-align: center; margin-bottom: 20px;">
      <div style="font-size: 3rem; color: #dc5252; margin-bottom: 12px;"></div>
      <h2 style="margin: 0 0 8px 0; color: #dc5252; font-size: 1.5rem;">Insufficient Sources Found</h2>
      <p style="margin: 0; color: #a0a0a0; font-size: 0.95rem;">
        Cannot verify ingredient list for ${productBrand ? esc(productBrand) + ' ' : ''}${esc(productName)}
      </p>
    </div>

    <div style="background: rgba(220,82,82,0.1); border: 1px solid rgba(220,82,82,0.3); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
      <div style="font-weight: 600; color: #dc5252; margin-bottom: 8px; font-size: 1.05rem;">
        Found ${verificationData.sourcesFound} source${verificationData.sourcesFound !== 1 ? 's' : ''}, but ${verificationData.minimumSourcesRequired} required
      </div>
      <p style="margin: 0; color: #c0c0c0; font-size: 0.9rem; line-height: 1.5;">
        Multi-source verification requires ingredient lists from at least <strong>${verificationData.minimumSourcesRequired} independent websites</strong> to ensure accuracy.
        The AI was only able to find ${verificationData.sourcesFound} source${verificationData.sourcesFound !== 1 ? 's' : ''} with ingredient data for this product.
      </p>
    </div>

    ${sourcesWithData.length > 0 ? `
      <div style="margin-bottom: 20px;">
        <div style="font-weight: 600; margin-bottom: 12px; color: #a0a0a0; font-size: 0.9rem;">Sources Found:</div>
        ${sourcesWithData.map(source => `
          <div style="background: rgba(76,212,90,0.1); border: 1px solid rgba(76,212,90,0.3); border-radius: 6px; padding: 10px; margin-bottom: 8px;">
            <div style="font-weight: 600; color: #4caf50; font-size: 0.95rem;">${esc(source?.name || 'Unknown Source')}</div>
            <div style="font-size: 0.8rem; color: #808080; word-break: break-all; margin-top: 4px;">
              <a href="${esc(source?.url || '#')}" target="_blank" style="color: #6b7ce6; text-decoration: none;">
                ${esc(source?.url || 'No URL')}
              </a>
            </div>
          </div>
        `).join('')}
      </div>
    ` : ''}

    <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
      <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;">What you can do:</div>
      <ul style="margin: 0; padding-left: 20px; color: #c0c0c0; font-size: 0.9rem; line-height: 1.6;">
        <li>Try scanning a different product with more widely available data</li>
        <li>Manually research and add ingredient information</li>
        <li>Contact the brand directly for official ingredient lists</li>
      </ul>
    </div>

    <div style="display: flex; gap: 12px;">
      <button type="button" class="closeBtn" style="
        flex: 1;
        padding: 14px;
        background: #6b7ce6;
        border: none;
        border-radius: 8px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">Close</button>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      const closeBtn = modalContent.querySelector('.closeBtn');

      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.background = '#5a6bd5';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.background = '#6b7ce6';
      });

      closeBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
        aiAssistSetStatus('Verification cancelled. Insufficient sources.', 'warn');
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
          aiAssistSetStatus('Verification cancelled. Insufficient sources.', 'warn');
        }
      });
    }

    // Helper functions for row-specific loading bars
    function showRowLoadingBar(rowIdx, message = 'Processing...') {
      const resultsDiv = document.querySelector(`.aiRowBrandResults[data-row-idx="${rowIdx}"]`);
      if (!resultsDiv) return;

      resultsDiv.innerHTML = `
    <div class="aiRowLoadingContainer" style="
      padding: 16px;
      background: rgba(76,90,212,0.1);
      border: 1px solid rgba(76,90,212,0.3);
      border-radius: 8px;
      margin-top: 12px;
    ">
      <div style="margin-bottom: 8px;">
        <div class="aiRowLoadingBar" style="
          width: 100%;
          height: 8px;
          background: rgba(255,255,255,0.1);
          border-radius: 4px;
          overflow: hidden;
        ">
          <div class="aiRowLoadingBarFill" style="
            height: 100%;
            background: linear-gradient(90deg, #4c5ad4, #667eea);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
            animation: shimmer 1.5s infinite;
          "></div>
        </div>
      </div>
      <div class="aiRowLoadingMessage" style="
        font-size: 0.9rem;
        color: #a8b2d6;
        text-align: center;
      ">${message}</div>
      <div class="aiRowSearchLogs" style="
        margin-top: 12px;
        padding: 10px;
        background: rgba(103, 116, 160, 0.05);
        border: 1px solid rgba(103, 116, 160, 0.2);
        border-radius: 6px;
        max-height: 200px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 0.75rem;
        color: #a8b2d6;
        text-align: left;
        line-height: 1.5;
        display: block;
      "></div>
      <div style="
        margin-top: 12px;
        padding: 12px;
        background: rgba(76,175,80,0.1);
        border: 1px solid rgba(76,175,80,0.3);
        border-radius: 6px;
        font-size: 0.85rem;
        color: #4caf50;
        text-align: center;
      ">
         <strong>Tip:</strong> Continue scanning other ingredients while this one is processing!
      </div>
    </div>
  `;

      resultsDiv.style.display = 'block';
    }

    function updateRowLoadingBar(rowIdx, progress, message) {
      const resultsDiv = document.querySelector(`.aiRowBrandResults[data-row-idx="${rowIdx}"]`);
      if (!resultsDiv) return;

      const fillBar = resultsDiv.querySelector('.aiRowLoadingBarFill');
      const messageDiv = resultsDiv.querySelector('.aiRowLoadingMessage');

      if (fillBar) fillBar.style.width = `${progress}%`;
      if (messageDiv) messageDiv.textContent = message;
    }

    function updateRowSearchLogs(rowIdx, logs) {
      const resultsDiv = document.querySelector(`.aiRowBrandResults[data-row-idx="${rowIdx}"]`);
      if (!resultsDiv) return;

      const logsDiv = resultsDiv.querySelector('.aiRowSearchLogs');
      console.log(`[updateRowSearchLogs] rowIdx=${rowIdx} logsDiv=${!!logsDiv} logs=${logs?.length}`);
      if (!logsDiv) return;

      if (logs && logs.length > 0) {
        logsDiv.style.display = 'block';
        logsDiv.innerHTML = logs.map(log => `<div>${log}</div>`).join('');
        // Auto-scroll to bottom
        logsDiv.scrollTop = logsDiv.scrollHeight;
      }
    }

    function hideRowLoadingBar(rowIdx) {
      const resultsDiv = document.querySelector(`.aiRowBrandResults[data-row-idx="${rowIdx}"]`);
      if (!resultsDiv) return;

      resultsDiv.innerHTML = '';
      resultsDiv.style.display = 'none';
    }

    // Verify product from multiple sources using AI
    async function verifyProductFromMultipleSources(rowIdx, openFoodFactsSuggestion, barcode, provider = 'claude') {
      // Show loading bar at the ingredient row
      showRowLoadingBar(rowIdx, 'Starting multi-source verification...');
      updateRowLoadingBar(rowIdx, 10, 'Starting multi-source verification...');

      aiAssistSetStatus('Searching multiple sources...', 'info');

      // Initialize progress tracking
      let progressTimers = [];
      let currentProgress = 10;
      let lastUpdateTime = Date.now();

      // Real-time progress updater that increments based on time elapsed
      // This gives smooth progress while waiting for actual backend response
      const progressUpdater = setInterval(() => {
        const elapsed = Date.now() - lastUpdateTime;
        // Increment progress slowly (reaches ~80% after ~15 seconds of waiting)
        if (currentProgress < 80) {
          currentProgress = Math.min(80, currentProgress + 1);
          updateRowLoadingBar(rowIdx, currentProgress, 'Searching web sources...');
        }
      }, 800); // Update every 800ms

      // Set initial progress
      updateRowLoadingBar(rowIdx, 10, 'Starting search...');

      // Defensive check for openFoodFactsSuggestion (needed in both try and catch blocks)
      const safeSuggestion = openFoodFactsSuggestion || {};

      try {
        // Verify Supabase client is available
        if (!window.supabaseClient) {
          throw new Error('Supabase client not initialized');
        }

        console.log('Calling verify-brand-sources function with:', {
          productName: safeSuggestion.name || safeSuggestion.product_name || 'Unknown Product',
          brand: safeSuggestion.brand || '',
          barcode: barcode,
          provider: provider
        });

        const requestBody = {
          productName: safeSuggestion.name || safeSuggestion.product_name || 'Unknown Product',
          brand: safeSuggestion.brand || '',
          barcode: barcode,
          provider: provider,
          openFoodFactsData: {
            image_url: safeSuggestion.image || '',
            ingredients_text: safeSuggestion.ingredientsList?.[0] || '',
            product_name: safeSuggestion.name || safeSuggestion.product_name || 'Unknown Product'
          }
        };

        console.log('Request body:', JSON.stringify(requestBody, null, 2));

        // Use fetch with streaming for real-time logs
        const functionUrl = `${SUPABASE_URL}/functions/v1/verify-brand-sources`;
        const response = await fetch(functionUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${SUPABASE_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error(`Function error: ${response.statusText}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let result = { data: null, error: null };
        let allLogs = [];

        // Clear progress updater as we'll use real logs now
        clearInterval(progressUpdater);
        progressTimers.forEach(timer => clearTimeout(timer));

        // Show logs container
        updateRowSearchLogs(rowIdx, ['Starting search stream...']);

        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            console.log('[Stream] Reader done');
            break;
          }

          const chunkStr = decoder.decode(value, { stream: true });
          console.log(`[Stream] Received chunk (${value.length} bytes):`, chunkStr);
          buffer += chunkStr;
          const chunks = buffer.split('\n\n');
          buffer = chunks.pop(); // Keep incomplete chunk

          console.log(`[Stream] Processing ${chunks.length} complete events`);

          for (const chunk of chunks) {
            const lines = chunk.split('\n');
            let event = null;
            let data = null;

            for (const line of lines) {
              if (line.startsWith('event: ')) {
                event = line.substring(7).trim();
              } else if (line.startsWith('data: ')) {
                try {
                  data = JSON.parse(line.substring(6).trim());
                } catch (e) {
                  console.error('[Stream] Error parsing JSON data:', e, line);
                }
              }
            }

            console.log(`[Stream] Parsed event: ${event}`, data);

            if (event && data) {
              if (event === 'log') {
                allLogs.push(data.message);
                updateRowSearchLogs(rowIdx, allLogs); // Pass all logs to render full history
              } else if (event === 'result') {
                result.data = data;
              } else if (event === 'error') {
                result.error = data;
              }
            }
          }
        }

        console.log('Function response received:', result);

        // Parse search logs for real-time progress updates (fallback if stream didn't update UI enough)
        const verificationData = result.data;
        if (verificationData && verificationData.searchLogs && verificationData.searchLogs.length > 0) {
          // Update progress based on log milestones
          const logs = verificationData.searchLogs;
          let progress = currentProgress;

          // Map log events to progress percentages
          const logProgressMap = {
            'PHASE 1': 30,
            'Deduplicating': 40,
            'PHASE 1 ANALYSIS': 50,
            'SUCCESS': 75,
            'PHASE 2': 60,
            'FINAL ANALYSIS': 70,
            'VERIFICATION SUCCESSFUL': 85
          };

          // Check for milestone keywords in logs
          for (const log of logs) {
            for (const [keyword, progressValue] of Object.entries(logProgressMap)) {
              if (log.includes(keyword) && progressValue > progress) {
                progress = progressValue;
                break;
              }
            }
          }

          currentProgress = progress;
        }

        updateRowLoadingBar(rowIdx, 95, 'Processing verification results...');

        if (result.error) {
          console.error('Multi-source verification error:', result.error);
          hideRowLoadingBar(rowIdx);

          // Show detailed error modal
          const errorMessage = result.error.message || result.error.toString();
          showMultiSourceErrorModal(errorMessage, provider, safeSuggestion, rowIdx);
          aiAssistSetStatus('Multi-source verification failed. See error details.', 'warn');
          return;
        }

        console.log('Multi-source verification result:', verificationData);

        // Update search logs if available (already processed above for progress)
        if (verificationData && verificationData.searchLogs && verificationData.searchLogs.length > 0) {
          updateRowSearchLogs(rowIdx, verificationData.searchLogs);
        }

        // Check if we got an insufficient sources error
        if (verificationData && verificationData.error && verificationData.error.includes('Insufficient sources')) {
          // Keep the logs visible when showing the error
          showInsufficientSourcesModal(verificationData, safeSuggestion);
          aiAssistSetStatus(`Only found ${verificationData.sourcesFound || 0} sources. Need ${verificationData.minimumSourcesRequired || 0}.`, 'warn');
          return;
        }

        // Show enhanced confirmation modal with all sources
        updateRowLoadingBar(rowIdx, 100, 'Verification complete!');
        setTimeout(() => hideRowLoadingBar(rowIdx), 500);
        showMultiSourceConfirmationModal(rowIdx, verificationData, safeSuggestion);
        aiAssistSetStatus(`Found ${verificationData?.sources?.length || 0} sources. Review verification.`, 'success');

      } catch (error) {
        console.error('Failed to verify from multiple sources:', error);

        // Clear progress updater and timers
        if (typeof progressUpdater !== 'undefined') clearInterval(progressUpdater);
        if (progressTimers) progressTimers.forEach(timer => clearTimeout(timer));

        hideRowLoadingBar(rowIdx);

        // Show detailed error modal with more context
        let errorMessage = 'Unknown error occurred';
        if (error.message) {
          errorMessage = error.message;
        } else if (error.toString) {
          errorMessage = error.toString();
        } else if (typeof error === 'string') {
          errorMessage = error;
        }

        // Add more context for network errors, but show the actual error first
        if (errorMessage.includes('Failed to send') || errorMessage.includes('fetch') || errorMessage === 'Unknown error occurred') {
          const fullError = JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
          errorMessage = `Network/Request Error:\n\n${errorMessage}\n\nFull error details:\n${fullError}\n\nThis could be due to:\n1. Network connectivity issues\n2. CORS configuration\n3. Function deployment issue\n4. Supabase client configuration`;
        }

        showMultiSourceErrorModal(errorMessage, provider, safeSuggestion, rowIdx);
        aiAssistSetStatus('Multi-source verification failed. See error details.', 'warn');
      }
    }

    // Enhanced modal showing multiple source verification
    function showMultiSourceConfirmationModal(rowIdx, verificationData, openFoodFactsSuggestion) {
      const { product, sources, consistency, consolidatedIngredients, crossContaminationWarnings, allergens, allergensInferred, diets, dietsInferred, visualMatching } = verificationData;

      // Safety check: Ensure product object exists with default values
      const safeProduct = product || {
        name: openFoodFactsSuggestion?.name || openFoodFactsSuggestion?.product_name || 'Unknown Product',
        brand: openFoodFactsSuggestion?.brand || 'Unknown Brand',
        barcode: openFoodFactsSuggestion?.barcode || ''
      };

      // Safety check: Ensure consistency object exists with default values
      // But if there are no sources, we can't have a match - set to error state
      const hasSources = Array.isArray(sources) && sources.length > 0;
      const safeConsistency = consistency || (hasSources ? {
        score: 100,
        allMatch: true,
        differences: []
      } : {
        score: 0,
        allMatch: false,
        differences: []
      });

      // Safety check: Ensure sources is an array
      const safeSources = Array.isArray(sources) ? sources : [];

      // Safety check: Ensure visualMatching object exists with default values
      const safeVisualMatching = visualMatching || {
        imagesAvailable: 0,
        primaryImage: null
      };

      // Safety check: Ensure arrays exist with default values
      const safeAllergens = Array.isArray(allergens) ? allergens : [];
      const safeDiets = Array.isArray(diets) ? diets : [];
      const safeCrossContaminationWarnings = Array.isArray(crossContaminationWarnings) ? crossContaminationWarnings : [];
      const safeConsolidatedIngredients = consolidatedIngredients || '';

      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    padding: 20px;
    overflow: hidden;
  `;

      const consistencyColor = safeConsistency.score >= 85 ? '#4caf50' : safeConsistency.score >= 70 ? '#ff9800' : '#dc5252';
      const consistencyIcon = safeConsistency.score >= 85 ? '' : safeConsistency.score >= 70 ? '' : '';

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid ${consistencyColor};
    border-radius: 16px;
    max-width: 95vw;
    width: 1100px;
    max-height: 85vh;
    overflow-y: auto;
    padding: 24px;
    color: #fff;
  `;

      // Build sources HTML - separate verified vs suggested sources
      const sourcesWithData = safeSources.filter(s => s && s.dataAvailable);
      const suggestedSources = safeSources.filter(s => s && !s.dataAvailable);

      const verifiedSourcesHtml = sourcesWithData.map((source, idx) => {
        // Try multiple image sources
        const imageUrl = source.productImage || source.image_url || (idx === 0 && safeVisualMatching.primaryImage ? safeVisualMatching.primaryImage : '');
        return `
    <div style="
      background: rgba(76,212,90,0.1);
      border: 2px solid rgba(76,212,90,0.4);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
    ">
      <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
        ${imageUrl ? `
          <img src="${esc(imageUrl)}" alt="Product"
               style="width: 60px; height: 60px; object-fit: contain; border-radius: 6px; background: white; padding: 4px; cursor: pointer;"
               onerror="this.onerror=null; this.style.display='none';"
               onload="this.style.display='block';"
               onclick="window.open('${esc(imageUrl)}', '_blank')">
        ` : ''}
        <div style="flex: 1;">
          <div style="font-weight: 600; color: #4caf50; margin-bottom: 4px;">
             ${esc(source.name)}
          </div>
          <div style="font-size: 0.85rem; color: #a0a0a0; word-break: break-all;">
            <a href="${esc(source.url)}" target="_blank" style="color: #6b7ce6; text-decoration: none;">
              ${esc(source.url)}
            </a>
          </div>
        </div>
      </div>
      <div style="font-size: 0.85rem; color: #ccc; line-height: 1.5; margin-top: 8px; word-wrap: break-word; white-space: pre-wrap;">
        <strong>Ingredients:</strong> ${esc(source.ingredientsText)}
      </div>
      ${source.crossContaminationWarnings && source.crossContaminationWarnings.length > 0 && !source.crossContaminationWarnings.toLowerCase().includes('not listed') ? `
        <div style="font-size: 0.85rem; color: #ff9800; margin-top: 6px;">
          <strong> Warning:</strong> ${esc(source.crossContaminationWarnings)}
        </div>
      ` : ''}
    </div>
  `;
      }).join('');

      const suggestedSourcesHtml = suggestedSources.length > 0 ? `
    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(76,90,212,0.3);">
      <p style="margin: 0 0 12px 0; font-weight: 600; color: #ff9800;"> Suggested Sources (Check Manually):</p>
      <p style="margin: 0 0 12px 0; font-size: 0.85rem; color: #a0a0a0;">
        Please verify ingredient information from these additional sources by clicking the links below:
      </p>
      ${suggestedSources.map((source, idx) => `
        <div style="
          background: rgba(255,152,0,0.1);
          border: 1px solid rgba(255,152,0,0.3);
          border-radius: 8px;
          padding: 12px;
          margin-bottom: 8px;
        ">
          <div style="display: flex; align-items: center; justify-content: space-between;">
            <div style="flex: 1;">
              <div style="font-weight: 600; color: #ff9800; margin-bottom: 4px;">
                ${idx === 0 ? '' : ''} ${esc(source.name)}
              </div>
              <div style="font-size: 0.85rem; color: #a0a0a0;">
                Click to check ingredients on this website
              </div>
            </div>
            <a href="${esc(source.url)}" target="_blank" style="
              display: inline-block;
              padding: 8px 16px;
              background: #ff9800;
              color: white;
              text-decoration: none;
              border-radius: 6px;
              font-size: 0.85rem;
              font-weight: 600;
              white-space: nowrap;
            ">
              Visit Site 
            </a>
          </div>
        </div>
      `).join('')}
    </div>
  ` : '';

      const sourcesHtml = verifiedSourcesHtml + suggestedSourcesHtml;

      // Build ingredient mismatches section - always show
      // Don't show "Perfect Match" if there are no sources
      const mismatchesHtml = safeSources.length === 0 ? `
    <div style="
      background: rgba(220,82,82,0.1);
      border: 1px solid rgba(220,82,82,0.3);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 20px;
    ">
      <div style="font-weight: 600; color: #dc5252; margin-bottom: 4px;"> No Sources Available</div>
      <p style="margin: 0; font-size: 0.85rem; color: #a0a0a0;">
        Unable to verify this product. No sources with ingredient data were found.
      </p>
    </div>
  ` : safeConsistency.differences && safeConsistency.differences.length > 0 ? `
    <div style="
      background: rgba(255,152,0,0.1);
      border: 1px solid rgba(255,152,0,0.3);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 20px;
    ">
      <div style="font-weight: 600; color: #ff9800; margin-bottom: 8px;"> Ingredient Wording Differences:</div>
      <p style="margin: 0 0 12px 0; font-size: 0.85rem; color: #a0a0a0;">
        These are minor wording differences between sources. The core ingredients are the same.
      </p>
      <div style="font-size: 0.85rem; line-height: 1.8; color: #ccc;">
        ${safeConsistency.differences.map(diff => {
        // Parse || separated comparisons (format: "Source1: phrase||Source2: phrase")
        if (diff.includes('||')) {
          const comparisons = diff.split('||');
          return `<div style="margin-bottom: 12px; padding: 8px; background: rgba(255,255,255,0.02); border-radius: 4px; border-left: 3px solid rgba(255,152,0,0.4);">
              ${comparisons.map((comp, idx) => {
            const [sources, phrase] = comp.split(':').map(s => s.trim());
            return `<div style="margin-bottom: ${idx === comparisons.length - 1 ? '0' : '4px'};">
                  <span style="font-family: Consolas, Monaco, monospace; color: #ffb74d; font-weight: 500;">${esc(sources)}</span>: <span style="color: #e0e0e0;">${phrase}</span>
                </div>`;
          }).join('')}
            </div>`;
        } else {
          // Fallback for non-comparison differences
          const formatted = diff.replace(/"([^"]+)"/g, '<span style="font-family: Consolas, Monaco, monospace; background: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 3px; color: #ffb74d;">$1</span>');
          return `<div style="margin-bottom: 8px; padding-left: 8px; border-left: 2px solid rgba(255,152,0,0.3);">${formatted}</div>`;
        }
      }).join('')}
      </div>
    </div>
  ` : `
    <div style="
      background: rgba(76,212,90,0.1);
      border: 1px solid rgba(76,212,90,0.3);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 20px;
    ">
      <div style="font-weight: 600; color: #4caf50; margin-bottom: 4px;"> Perfect Match</div>
      <p style="margin: 0; font-size: 0.85rem; color: #a0a0a0;">
        All sources have identical ingredient lists with no wording differences.
      </p>
    </div>
  `;

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: ${consistencyColor}; font-size: 1.4rem;">
        ${consistencyIcon} Multi-Source Verification Results
      </h3>
      <p style="margin: 0; font-size: 1.05rem; font-weight: 600;">${esc(safeProduct.name)}</p>
      ${safeProduct.brand ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">${esc(safeProduct.brand)}</p>` : ''}
    </div>

    <!-- Source Consistency -->
    <div style="
      background: rgba(${safeConsistency.allMatch ? '76,212,90' : '220,82,82'},0.15);
      border: 2px solid ${consistencyColor};
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
      text-align: center;
    ">
      <div style="font-size: 1.5rem; font-weight: 700; color: ${consistencyColor}; margin-bottom: 4px;">
        ${safeSources.length === 0 ? ' No Sources Found' : safeConsistency.allMatch ? ' All Sources Match!' : ' Sources Have Differences'}
      </div>
      <div style="font-size: 0.85rem; color: #a0a0a0;">
        ${safeSources.length === 0 ? 'No sources were found to verify this product' : `${safeSources.length} source${safeSources.length !== 1 ? 's' : ''} analyzed`}
      </div>
    </div>

    <!-- Product Images Carousel -->
    ${safeVisualMatching.imagesAvailable > 0 ? `
      <div style="margin-bottom: 20px;">
        <p style="margin: 0 0 12px 0; font-weight: 600; color: #4c5ad4;"> Product Images (${safeVisualMatching.imagesAvailable} available):</p>
        <div style="
          display: flex;
          gap: 12px;
          overflow-x: auto;
          padding: 12px;
          background: rgba(0,0,0,0.2);
          border-radius: 8px;
        ">
          ${safeSources.filter(s => s && s.productImage).map((source, idx) => `
            <div style="flex-shrink: 0; text-align: center;">
              <img src="${esc(source.productImage)}" alt="${esc(source.name)}"
                   style="
                     width: 120px;
                     height: 120px;
                     object-fit: contain;
                     border-radius: 8px;
                     background: white;
                     padding: 8px;
                     cursor: pointer;
                     border: 2px solid rgba(76,90,212,0.3);
                   "
                   onclick="window.open('${esc(source.productImage)}', '_blank')">
              <div style="font-size: 0.75rem; color: #a0a0a0; margin-top: 6px;">
                ${esc(source.name)}
              </div>
            </div>
          `).join('')}
        </div>
        <p style="margin: 8px 0 0 0; font-size: 0.8rem; color: #a0a0a0; font-style: italic;">
          Click any image to view full size
        </p>
      </div>
    ` : ''}

    <!-- Sources -->
    <div style="margin-bottom: 20px;">
      <p style="margin: 0 0 12px 0; font-weight: 600; color: #4c5ad4;"> Sources Found (${safeSources.length}):</p>
      ${sourcesHtml}
    </div>

    ${mismatchesHtml}

    ${safeConsistency.allMatch && safeSources.length > 0 ? `
    <!-- Consolidated Ingredients - All Sources Agree -->
    <div style="
      background: rgba(76,212,90,0.2);
      border: 2px solid rgba(76,212,90,0.4);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    ">
      <p style="margin: 0 0 8px 0; font-weight: 600; color: #4caf50; font-size: 1.05rem;">
         Consolidated Ingredient List (All ${safeSources.length} source${safeSources.length !== 1 ? 's' : ''} agree):
      </p>
      <p style="margin: 0 0 12px 0; font-size: 0.9rem; line-height: 1.6; word-wrap: break-word; white-space: pre-wrap; font-family: 'Monaco', 'Courier New', monospace; color: #e0e0e0;">
        ${esc(safeConsolidatedIngredients)}
      </p>
      <button type="button" class="confirmConsolidatedIngredientsBtn" style="
        padding: 10px 20px;
        background: #4c5ad4;
        border: none;
        border-radius: 6px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        font-size: 0.95rem;
        transition: all 0.2s;
      ">Confirm and Apply This Ingredient List</button>
    </div>
    ` : safeConsolidatedIngredients ? `
    <!-- Consolidated Ingredients -->
    <div style="
      background: rgba(76,90,212,0.1);
      border: 1px solid rgba(76,90,212,0.3);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    ">
      <p style="margin: 0 0 8px 0; font-weight: 600; color: #4c5ad4;"> Consolidated Ingredient List:</p>
      <p style="margin: 0; font-size: 0.9rem; line-height: 1.6; word-wrap: break-word; white-space: pre-wrap;">
        ${esc(safeConsolidatedIngredients)}
      </p>
    </div>
    ` : ''}

    <!-- Allergens Section - Always Show -->
    <div style="
      background: rgba(76,90,212,0.1);
      border: 1px solid rgba(76,90,212,0.3);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    ">
      <p style="margin: 0 0 8px 0; font-weight: 600; color: ${safeAllergens.length > 0 ? '#dc5252' : '#a0a0a0'};">
        ${safeAllergens.length > 0 ? ' Detected Allergens' : ' Allergens'} ${safeAllergens.length > 0 ? (allergensInferred ? '<span style="font-weight: normal; font-size: 0.85rem;">(inferred from ingredients)</span>' : '<span style="font-weight: normal; font-size: 0.85rem;">(from explicit product labels)</span>') : ''}:
      </p>
      <p style="margin: 0 0 12px 0; font-size: 0.9rem; color: ${safeAllergens.length > 0 ? '#dc5252' : '#a0a0a0'};">
        ${safeAllergens.length > 0 ? safeAllergens.map(a => esc(a)).join(', ') : 'No allergens detected'}
      </p>

      ${safeCrossContaminationWarnings && safeCrossContaminationWarnings.length > 0 ? `
        <p style="margin: 12px 0 0 0; font-weight: 600; color: #ff9800;"> Cross-Contamination Warning:</p>
        <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: #ff9800;">
          ${safeCrossContaminationWarnings.map(w => esc(w)).join(', ')}
        </p>
      ` : ''}

      <!-- Dietary Compatibility Section - Always Show -->
      <p style="margin: 12px 0 0 0; font-weight: 600; color: ${safeDiets.length > 0 ? '#4caf50' : '#a0a0a0'};">
        ${safeDiets.length > 0 ? ' Dietary Compatibility' : ' Dietary Compatibility'} ${safeDiets.length > 0 ? (dietsInferred ? '<span style="font-weight: normal; font-size: 0.85rem;">(inferred from ingredients)</span>' : '<span style="font-weight: normal; font-size: 0.85rem;">(from explicit product labels)</span>') : ''}:
      </p>
      <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: ${safeDiets.length > 0 ? '#4caf50' : '#a0a0a0'};">
        ${safeDiets.length > 0 ? safeDiets.map(d => esc(d)).join(', ') : 'Not compatible with any dietary preferences'}
      </p>
    </div>

    <!-- Confirmation Checkbox -->
    <div style="
      background: rgba(76,90,212,0.1);
      border: 1px solid rgba(76,90,212,0.3);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    ">
      <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer; font-size: 1rem;">
        <input type="checkbox" id="confirmCheckbox" class="verifyCheckbox" style="width: 24px; height: 24px; cursor: pointer; flex-shrink: 0; margin-top: 2px;" required>
        <span style="line-height: 1.5;">
          <strong>I confirm that this is the correct product and that the allergens and dietary information are accurate.</strong>
        </span>
      </label>
    </div>

    <!-- Action Buttons -->
    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button type="button" class="confirmCancel" style="
        padding: 12px 24px;
        background: #301424;
        border: 1px solid #4c2138;
        border-radius: 8px;
        color: #fff;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
      <button type="button" class="confirmApply" style="
        padding: 12px 24px;
        background: ${consistencyColor};
        border: 1px solid ${consistencyColor};
        border-radius: 8px;
        color: #fff;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        opacity: 0.5;
      " disabled>Confirm & Apply</button>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      const confirmBtn = modalContent.querySelector('.confirmApply');
      const cancelBtn = modalContent.querySelector('.confirmCancel');
      const verifyCheckboxes = modalContent.querySelectorAll('.verifyCheckbox');
      const confirmConsolidatedBtn = modalContent.querySelector('.confirmConsolidatedIngredientsBtn');

      // Handle consolidated ingredients confirmation button (when all sources agree)
      if (confirmConsolidatedBtn) {
        confirmConsolidatedBtn.addEventListener('click', async () => {
          confirmConsolidatedBtn.disabled = true;
          confirmConsolidatedBtn.style.background = '#4caf50';
          confirmConsolidatedBtn.innerHTML = ' Confirmed';
          confirmConsolidatedBtn.style.cursor = 'default';

          // Show loading message
          const loadingMsg = document.createElement('span');
          loadingMsg.textContent = 'Loading detected allergens and dietary preferences...';
          loadingMsg.style.cssText = 'margin-left: 12px; color: #9ca3af; font-size: 0.85rem; font-style: italic;';
          confirmConsolidatedBtn.parentElement.appendChild(loadingMsg);

          try {
            const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
              body: {
                ingredientText: safeConsolidatedIngredients,
                productName: safeProduct.name,
                labels: [],
                categories: []
              }
            });

            if (!analysisResult.error && analysisResult.data) {
              const { allergens, diets } = analysisResult.data;

              // Remove loading message
              if (loadingMsg.parentElement) {
                loadingMsg.remove();
              }

              // Build suggestion object with consolidated data
              const enhancedSuggestion = {
                name: safeProduct.name,
                brand: safeProduct.brand,
                barcode: safeProduct.barcode,
                image: safeVisualMatching.primaryImage || openFoodFactsSuggestion?.image,
                ingredientsImage: safeSources[0]?.productImage || openFoodFactsSuggestion?.ingredientsImage,
                ingredientsList: [safeConsolidatedIngredients],
                allergens: allergens || [],
                diets: diets || [],
                multiSourceVerified: true,
                consistencyScore: safeConsistency.score,
                sourcesCount: safeSources.length
              };

              document.body.removeChild(modal);
              applyBrandSuggestionConfirmed(rowIdx, enhancedSuggestion);
              aiAssistSetStatus(`Applied brand with ${safeSources.length}-source verification`, 'success');
              return;
            }
          } catch (err) {
            console.error('Failed to analyze allergens/diets:', err);
            // Remove loading message on error
            if (loadingMsg.parentElement) {
              loadingMsg.remove();
            }
          }

          // If analysis fails, proceed with consolidated ingredients
          const enhancedSuggestion = {
            name: safeProduct.name,
            brand: safeProduct.brand,
            barcode: safeProduct.barcode,
            image: safeVisualMatching.primaryImage || openFoodFactsSuggestion?.image,
            ingredientsImage: safeSources[0]?.productImage || openFoodFactsSuggestion?.ingredientsImage,
            ingredientsList: [safeConsolidatedIngredients],
            allergens: safeAllergens,
            diets: safeDiets,
            multiSourceVerified: true,
            consistencyScore: safeConsistency.score,
            sourcesCount: safeSources.length
          };

          document.body.removeChild(modal);
          applyBrandSuggestionConfirmed(rowIdx, enhancedSuggestion);
          aiAssistSetStatus(`Applied brand with ${safeSources.length}-source verification`, 'success');
        });
      }

      // Enable/disable confirm button based on checkboxes and sources
      const updateConfirmButton = () => {
        const allChecked = Array.from(verifyCheckboxes).every(cb => cb.checked);
        const hasValidSources = safeSources.length > 0;
        const canConfirm = allChecked && hasValidSources;
        confirmBtn.disabled = !canConfirm;
        confirmBtn.style.opacity = canConfirm ? '1' : '0.5';
        confirmBtn.style.cursor = canConfirm ? 'pointer' : 'not-allowed';
        if (!hasValidSources && confirmBtn.textContent.includes('Confirm')) {
          confirmBtn.title = 'Cannot confirm: No sources found for verification';
        } else {
          confirmBtn.title = '';
        }
      };

      // Initial update to set correct state
      updateConfirmButton();

      verifyCheckboxes.forEach(cb => {
        cb.addEventListener('change', updateConfirmButton);
      });

      // Handle confirm
      confirmBtn.addEventListener('click', () => {
        if (confirmBtn.disabled) return;

        // Build suggestion object with multi-source data
        const enhancedSuggestion = {
          name: safeProduct.name,
          brand: safeProduct.brand,
          barcode: safeProduct.barcode,
          image: safeVisualMatching.primaryImage || openFoodFactsSuggestion?.image,
          ingredientsImage: safeSources[0]?.productImage || openFoodFactsSuggestion.ingredientsImage,
          ingredientsList: [safeConsolidatedIngredients],
          allergens: safeAllergens,
          diets: safeDiets,
          multiSourceVerified: true,
          consistencyScore: safeConsistency.score,
          sourcesCount: safeSources.length
        };

        document.body.removeChild(modal);
        applyBrandSuggestionConfirmed(rowIdx, enhancedSuggestion);
        aiAssistSetStatus(`Applied brand with ${safeSources.length}-source verification`, 'success');
      });

      // Handle cancel
      const handleCancel = () => {
        document.body.removeChild(modal);
        aiAssistSetStatus('Multi-source verification cancelled', 'warn');
      };

      cancelBtn.addEventListener('click', handleCancel);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) handleCancel();
      });
    }

    function showBrandConfirmationModal(suggestion, onConfirm) {
      const hasImage = suggestion.ingredientsImage;
      const hasIngredients = suggestion.ingredientsList && suggestion.ingredientsList.length > 0;

      // Create modal overlay with scroll lock
      const modal = document.createElement('div');
      modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    padding: 20px;
    overflow: hidden;
    touch-action: none;
  `;

      const modalContent = document.createElement('div');
      modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid ${hasImage ? '#4c5ad4' : '#dc5252'};
    border-radius: 16px;
    max-width: 95vw;
    width: 1000px;
    max-height: 85vh;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 24px;
    color: #fff;
    touch-action: pan-y;
  `;

      modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: ${hasImage ? '#4c5ad4' : '#dc5252'}; font-size: 1.3rem;">
        ${hasImage ? ' Verify Product & Ingredients' : ' WARNING: No Label Image'}
      </h3>
      <p style="margin: 0; font-size: 0.95rem; color: #a0a0a0;">
        ${hasImage
          ? 'Please confirm this matches the exact product you use in your restaurant.'
          : 'This product has NO label image. You cannot verify if the data is accurate or current.'}
      </p>
    </div>

    ${suggestion.image ? `
      <div style="margin-bottom: 20px; text-align: center;">
        <img src="${esc(suggestion.image)}" alt="${esc(suggestion.name)}"
             style="max-width: 200px; max-height: 200px; border-radius: 8px; border: 1px solid rgba(76,90,212,0.3);">
        <p style="margin: 8px 0 0 0; font-weight: 600; font-size: 1.05rem;">${esc(suggestion.name)}</p>
        ${suggestion.brand ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">${esc(suggestion.brand)}</p>` : ''}
      </div>
    ` : ''}

    ${hasImage ? `
      <div style="margin-bottom: 20px;">
        <div style="background: rgba(76,90,212,0.1); border: 1px solid rgba(76,90,212,0.3); border-radius: 8px; padding: 16px; margin-bottom: 12px;">
          <p style="margin: 0 0 12px 0; font-weight: 600; color: #4c5ad4;"> Ingredient Label Image:</p>
          <img src="${esc(suggestion.ingredientsImage)}" alt="Ingredient label"
               style="width: 100%; border-radius: 6px; cursor: pointer; border: 1px solid rgba(76,90,212,0.3);"
               onclick="window.open('${esc(suggestion.ingredientsImage)}', '_blank')">
          <p style="margin: 8px 0 0 0; font-size: 0.85rem; color: #a0a0a0; font-style: italic;">
            Click image to view full size
          </p>
        </div>
      </div>
    ` : ''}

    ${hasIngredients ? `
      <div style="background: rgba(76,90,212,0.1); border: 1px solid rgba(76,90,212,0.3); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <p style="margin: 0 0 8px 0; font-weight: 600; color: #4c5ad4;"> Ingredients List (from database):</p>
        <p style="margin: 0; font-size: 0.9rem; line-height: 1.5;">
          ${suggestion.ingredientsList.join(', ')}
        </p>
        ${suggestion.allergens && suggestion.allergens.length > 0 ? `
          <p style="margin: 12px 0 0 0; font-weight: 600; color: #dc5252;"> Detected Allergens:</p>
          <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: #dc5252;">
            ${suggestion.allergens.join(', ')}
          </p>
        ` : ''}
        ${suggestion.diets && suggestion.diets.length > 0 ? `
          <p style="margin: 12px 0 0 0; font-weight: 600; color: #4caf50;"> Detected Dietary Preferences:</p>
          <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: #4caf50;">
            ${suggestion.diets.join(', ')}
          </p>
        ` : ''}
      </div>
    ` : ''}

    ${hasImage && hasIngredients ? `
      <div style="background: rgba(220,82,82,0.15); border: 1px solid rgba(220,82,82,0.4); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <p style="margin: 0 0 12px 0; font-weight: 600; color: #dc5252;"> Before confirming, verify:</p>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <label style="display: flex; align-items: center; gap: 12px; cursor: pointer; font-size: 0.95rem; line-height: 1.5;">
            <input type="checkbox" class="verifyCheckbox" style="width: 20px; height: 20px; cursor: pointer; flex-shrink: 0;">
            <span>The ingredient label image is readable and matches this exact product</span>
          </label>
        </div>
      </div>
    ` : !hasImage ? `
      <div style="background: rgba(220,82,82,0.15); border: 1px solid rgba(220,82,82,0.4); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <p style="margin: 0 0 12px 0; font-weight: 600; color: #dc5252;"> Cannot Verify:</p>
        <ul style="margin: 0; padding-left: 20px; line-height: 1.8; font-size: 0.9rem;">
          <li>No ingredient label image available</li>
          <li>Cannot verify if data is current or accurate</li>
          <li>Cannot confirm allergen information</li>
          <li>Data may be outdated or incorrect</li>
        </ul>
        <p style="margin: 12px 0 0 0; font-weight: 600; color: #dc5252;">
          It is NOT RECOMMENDED to use this product without visual verification.
        </p>
      </div>
    ` : ''}

    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button type="button" class="confirmCancel" style="
        padding: 12px 24px;
        background: #301424;
        border: 1px solid #4c2138;
        border-radius: 8px;
        color: #fff;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
      <button type="button" class="confirmApply" style="
        padding: 12px 24px;
        background: ${hasImage ? '#4c5ad4' : '#dc5252'};
        border: 1px solid ${hasImage ? '#6b7ce6' : '#ef6f6f'};
        border-radius: 8px;
        color: #fff;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">${hasImage ? 'Confirm & Apply' : 'Use Anyway (Not Recommended)'}</button>
    </div>
  `;

      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // Add hover effects
      const confirmBtn = modalContent.querySelector('.confirmApply');
      const cancelBtn = modalContent.querySelector('.confirmCancel');
      const verifyCheckboxes = modalContent.querySelectorAll('.verifyCheckbox');

      // Disable confirm button initially if there are verification checkboxes
      if (verifyCheckboxes.length > 0 && hasImage) {
        confirmBtn.disabled = true;
        confirmBtn.style.opacity = '0.5';
        confirmBtn.style.cursor = 'not-allowed';
      }

      // Enable/disable confirm button based on checkboxes
      const updateConfirmButton = () => {
        if (verifyCheckboxes.length === 0 || !hasImage) {
          return; // No checkboxes or no image, always enabled
        }
        const allChecked = Array.from(verifyCheckboxes).every(cb => cb.checked);
        confirmBtn.disabled = !allChecked;
        confirmBtn.style.opacity = allChecked ? '1' : '0.5';
        confirmBtn.style.cursor = allChecked ? 'pointer' : 'not-allowed';
      };

      verifyCheckboxes.forEach(cb => {
        cb.addEventListener('change', updateConfirmButton);
      });

      confirmBtn.addEventListener('mouseenter', () => {
        if (!confirmBtn.disabled) {
          confirmBtn.style.transform = 'translateY(-2px)';
          confirmBtn.style.boxShadow = '0 4px 12px rgba(76,90,212,0.4)';
        }
      });
      confirmBtn.addEventListener('mouseleave', () => {
        confirmBtn.style.transform = 'translateY(0)';
        confirmBtn.style.boxShadow = 'none';
      });

      cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.background = '#3d1a2e';
      });
      cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.background = '#301424';
      });

      // Handle confirm
      confirmBtn.addEventListener('click', () => {
        if (confirmBtn.disabled) return;
        document.body.removeChild(modal);
        onConfirm();
      });

      // Handle cancel
      const handleCancel = () => {
        document.body.removeChild(modal);
        aiAssistSetStatus('Brand not applied. Verification required for safety.', 'warn');
      };

      cancelBtn.addEventListener('click', handleCancel);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) handleCancel();
      });
    }

    function applyBrandSuggestionConfirmed(rowIdx, suggestion) {

      const row = aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"]`);
      if (!row) return;

      // Get existing brands array
      let brands = [];
      if (row.dataset.brands) {
        try {
          brands = JSON.parse(row.dataset.brands);
        } catch (_) { }
      }

      // Add new brand to the array
      const newBrand = {
        name: suggestion.brand || suggestion.name || 'Brand',
        barcode: suggestion.barcode || '', // Include the barcode if available
        brandImage: suggestion.brandImage || suggestion.image || '', // Prefer brandImage (product front photo), fallback to image
        ingredientsImage: suggestion.ingredientsImage || '', // Use ingredient label photo
        ingredientsList: Array.isArray(suggestion.ingredientsList) ? suggestion.ingredientsList : [],
        allergens: Array.isArray(suggestion.allergens) ? suggestion.allergens : [],
        diets: Array.isArray(suggestion.diets) ? suggestion.diets : []
      };

      // If product name or ingredient list explicitly states "gluten free", ensure diet reflects that
      const brandText = `${(newBrand.name || '').toLowerCase()} ${newBrand.ingredientsList.join(' ').toLowerCase()}`;
      const hasGlutenFreeClaim = brandText.includes('gluten free');
      const hasExplicitWheat = /\bwheat\b/.test(brandText);
      if (hasGlutenFreeClaim) {
        if (!newBrand.diets.includes('Gluten-free')) {
          newBrand.diets = [...new Set([...(newBrand.diets || []), 'Gluten-free'])];
        }
        if (Array.isArray(newBrand.allergens) && !hasExplicitWheat) {
          newBrand.allergens = newBrand.allergens.filter(a => norm(a) !== 'wheat');
        }
      }
      console.log('Adding brand:', newBrand);
      brands.push(newBrand);

      // IMPORTANT: Update the DOM row's dataset BEFORE calling collectAiTableData
      // This ensures the brands data is available when we collect and re-render
      row.dataset.brands = JSON.stringify(brands);
      console.log('Updated row.dataset.brands:', row.dataset.brands);

      // Collect all allergens and diets from all brands (union)
      const brandAllergens = new Set();
      const brandDiets = new Set();
      brands.forEach(brand => {
        if (Array.isArray(brand.allergens)) {
          brand.allergens.forEach(a => brandAllergens.add(norm(a)));
        }
        if (Array.isArray(brand.diets)) {
          brand.diets.forEach(d => brandDiets.add(d));
        }
      });
      console.log('Brand allergens:', Array.from(brandAllergens));
      console.log('Brand diets:', Array.from(brandDiets));

      // Now collect data first to get base ingredient allergens/diets
      const allData = collectAiTableData();
      console.log('Collected data before brand apply:', allData[rowIdx]);

      // Merge base ingredient allergens/diets with brand allergens/diets (union)
      if (allData[rowIdx]) {
        const baseAllergens = new Set((allData[rowIdx].allergens || []).map(a => norm(a)));
        const baseDiets = new Set(allData[rowIdx].diets || []);
        const baseAiDetectedAllergens = new Set((allData[rowIdx].aiDetectedAllergens || []).map(a => norm(a)));
        const baseAiDetectedDiets = new Set(allData[rowIdx].aiDetectedDiets || []);

        // OVERWRITE base allergens/diets with brand allergens/diets
        // This clears any previous AI-detected allergens from the text (e.g. "sesame seeds")
        // and ensures only the brand's allergens are present.
        allData[rowIdx].allergens = Array.from(brandAllergens);

        // Normalize diets to match DIETS constant casing
        const normalizedBrandDiets = Array.from(brandDiets).map(d => {
          const lower = d.toLowerCase().trim();
          const proper = DIETS.find(pd => pd.toLowerCase() === lower);
          return proper || d;
        });
        console.log('Applying brand diets (normalized):', normalizedBrandDiets);

        allData[rowIdx].diets = normalizedBrandDiets;
        allData[rowIdx].aiDetectedAllergens = Array.from(brandAllergens);
        allData[rowIdx].aiDetectedDiets = normalizedBrandDiets;
        allData[rowIdx].confirmed = false;

        // Ensure diets/allergens stay consistent (e.g., vegan removes dairy)
        enforceDietAllergenConsistency(allData[rowIdx]);

        // Also update the DOM row's dataset so it persists across re-renders
        row.dataset.aiDetectedAllergens = JSON.stringify(allData[rowIdx].aiDetectedAllergens);
        row.dataset.aiDetectedDiets = JSON.stringify(allData[rowIdx].aiDetectedDiets);
      }

      // Re-render the table with updated data
      // This will automatically update the confirm button state based on scan requirements
      renderAiTable(allData);

      // Close the inline brand results
      const rowBrandResults = aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"] .aiRowBrandResults`);
      if (rowBrandResults) {
        rowBrandResults.classList.remove('show');
        rowBrandResults.innerHTML = '';
      }

      // Also close the old global results if present
      if (aiAssistBrandResults) {
        aiAssistBrandResults.classList.remove('show');
        aiAssistBrandResults.innerHTML = '';
      }
      aiAssistSetStatus('Brand applied. Please review allergens carefully.', 'warn');
    }

    async function requestAiExtraction(payload) {
      const endpoint = state.aiAssistEndpoint || window.__CLE_AI_ENDPOINT__ || null;
      if (endpoint) {
        const res = await fetch(endpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!res.ok) {
          const text = await res.text().catch(() => res.statusText);
          throw new Error(text || 'AI endpoint returned an error');
        }
        return await res.json();
      }

      // Use proxy to avoid CORS issues, with fallback to direct Edge Function call
      try {
        const response = await fetch('/api/ai-proxy', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            functionName: 'ai-ingredient-assistant',
            payload: payload
          })
        });

        // Check if response is HTML (error page) or if status indicates failure
        const contentType = response.headers.get('content-type') || '';
        if (!response.ok || contentType.includes('text/html')) {
          // If it's HTML or not OK, skip to fallback immediately
          const errorText = await response.text().catch(() => '');
          // Check if it's an HTML error page
          if (contentType.includes('text/html') || errorText.includes('<!DOCTYPE') || response.status === 501 || response.status === 405) {
            throw new Error(`PROXY_UNAVAILABLE`);
          }
          throw new Error(errorText || `Proxy returned ${response.status}`);
        }

        const data = await response.json();
        return data;
      } catch (proxyErr) {
        // If proxy is unavailable, skip straight to direct call
        const isProxyUnavailable = proxyErr.message === 'PROXY_UNAVAILABLE' ||
          proxyErr.message.includes('501') ||
          proxyErr.message.includes('405') ||
          proxyErr.message.includes('<!DOCTYPE');

        if (!isProxyUnavailable) {
          console.warn('AI extraction via proxy failed:', proxyErr);
        } else {
          console.log('Proxy unavailable, using direct Edge Function call');
        }

        // Fallback: Use Supabase client to avoid CORS issues
        try {
          if (window.supabaseClient) {
            // Use Supabase client which handles CORS properly
            try {
              const { data, error } = await window.supabaseClient.functions.invoke('ai-ingredient-assistant', {
                body: payload
              });

              if (error) {
                // If Supabase client invoke fails, check if it's a CORS/network error
                if (error.message && (error.message.includes('CORS') || error.message.includes('Failed to send') || error.message.includes('fetch'))) {
                  throw new Error('NETWORK_ERROR');
                }
                throw new Error(error.message || 'Edge Function returned an error');
              }

              console.log(' Successfully called Edge Function via Supabase client (proxy was unavailable)');
              return data;
            } catch (supabaseErr) {
              // If Supabase client fails due to CORS, provide helpful error
              if (supabaseErr.message === 'NETWORK_ERROR' || supabaseErr.message.includes('Failed to send') || supabaseErr.message.includes('CORS')) {
                console.log('Supabase client failed due to CORS/network issue');
                // Don't throw here - let it fall through to show user-friendly message
                throw new Error('CORS_ERROR: The recipe generation service cannot be accessed due to network restrictions. Please try again in a few moments or contact support if the issue persists.');
              }
              throw supabaseErr;
            }
          }

          // Final fallback: Try direct fetch (will likely fail due to CORS, but worth trying)
          const SUPABASE_URL = 'https://fgoiyycctnwnghrvsilt.supabase.co';
          const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZnb2l5eWNjdG53bmdocnZzaWx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MzY1MjYsImV4cCI6MjA3NjAxMjUyNn0.xlSSXr0Gl7j-vsckrj-2anpPmp4BG2SUIdN-_dquSA8';

          try {
            const directResponse = await fetch(`${SUPABASE_URL}/functions/v1/ai-ingredient-assistant`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                'apikey': SUPABASE_ANON_KEY
              },
              body: JSON.stringify(payload)
            });

            if (!directResponse.ok) {
              const text = await directResponse.text().catch(() => directResponse.statusText);
              throw new Error(text || 'Edge Function returned an error');
            }

            const data = await directResponse.json();
            console.log(' Successfully called Edge Function directly (proxy was unavailable)');
            return data;
          } catch (finalErr) {
            // If direct fetch also fails, throw a user-friendly error
            throw new Error('SUPABASE_CLIENT_FAILED');
          }
        } catch (directErr) {
          console.error('All request methods failed:', { proxyErr, directErr });

          // Provide user-friendly error message based on error type
          let errorMsg = 'The recipe generation service is temporarily unavailable.';

          if (directErr.message === 'SUPABASE_CLIENT_FAILED' || directErr.message.includes('CORS')) {
            errorMsg = 'Network connection issue. The recipe generation service cannot be accessed right now. This is likely a temporary CORS configuration issue. Please try again in a few minutes.';
          } else if (proxyErr.message && proxyErr.message.includes('BOOT_ERROR')) {
            errorMsg = 'The recipe generation service is starting up. Please wait a moment and try again.';
          } else if (directErr.message && directErr.message.includes('<!DOCTYPE')) {
            errorMsg = 'Service unavailable. Please try again later.';
          }

          throw new Error(errorMsg);
        }
      }
    }

    async function handleRecipePhotoUpload(file) {
      ensureAiAssistElements();
      try {
        const reader = new FileReader();
        reader.onload = async (e) => {
          const imageData = e.target.result;
          aiAssistSetStatus('Reading recipe from photo using AI...');

          // Get dish name from input field if available
          const nameInput = document.getElementById('aiAssistNameInput');
          const dishNameForAi = nameInput?.value?.trim() || (aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '');

          const payload = {
            imageData: imageData,
            imageFileName: file.name,
            text: 'Please extract all ingredients from this recipe image.',
            dishName: dishNameForAi
          };

          try {
            const result = await requestAiExtraction(payload);

            // Store dietary options if provided by AI
            const dishDietaryOptions = (result?.dietaryOptions && Array.isArray(result.dietaryOptions)) ? result.dietaryOptions : [];
            if (dishDietaryOptions.length > 0) {
              aiAssistState.detectedDietaryOptions = dishDietaryOptions;
            }

            // Map ingredients and add dish-level dietary options to each ingredient
            const rows = Array.isArray(result?.ingredients) ? result.ingredients.map(ing => {
              let needsScan = ing.needsScan === true || ing.needsScan === 'true';
              const ingredientName = ing.name ? ing.name.toLowerCase() : '';
              const aiAllergens = Array.isArray(ing.allergens) ? [...ing.allergens] : [];
              const aiDiets = Array.isArray(ing.diets) && ing.diets.length ? [...ing.diets] : [...dishDietaryOptions];

              // Client-side fallback: Mark processed ingredients that should require scanning
              // even if AI didn't catch them (flours, processed foods, etc.)
              if (!needsScan && ingredientName) {
                if (requiresBarcodeScan(ingredientName)) {
                  needsScan = true;
                }
              }

              const entry = {
                ...ing,
                name: ingredientName,
                allergens: aiAllergens.slice(),
                diets: aiDiets.slice(),
                aiDetectedAllergens: aiAllergens.slice(),
                aiDetectedDiets: aiDiets.slice(),
                // Ensure needsScan is a boolean (default to false if not provided)
                needsScan: needsScan
              };
              enforceDietAllergenConsistency(entry);
              return entry;
            }) : [];

            renderAiTable(rows);

            // Show dietary options in status if detected
            let statusMessage = rows.length ? 'Extracted ingredients from recipe photo. Review before applying.' : 'Could not extract ingredients from recipe photo.';
            if (dishDietaryOptions.length > 0) {
              statusMessage += ` Detected dietary options: ${dishDietaryOptions.join(', ')}.`;
            }

            aiAssistSetStatus(statusMessage, rows.length ? 'info' : 'warn');
          } catch (err) {
            console.error('Recipe photo extraction failed', err);
            aiAssistSetStatus('Failed to read recipe photo: ' + (err.message || err), 'error');
          }
        };
        reader.readAsDataURL(file);
      } catch (err) {
        console.error('Recipe photo upload failed', err);
        aiAssistSetStatus('Failed to upload recipe photo: ' + (err.message || err), 'error');
      }
    }

    function renderPhotoPreviews() {
      const container = document.getElementById('aiAssistPhotosContainer');
      const photosList = document.getElementById('aiAssistPhotosList');
      if (!container || !photosList) return;

      if (!window.aiAssistPhotos || window.aiAssistPhotos.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';
      photosList.innerHTML = '';

      window.aiAssistPhotos.forEach((photoData, idx) => {
        const photoDiv = document.createElement('div');
        photoDiv.style.cssText = 'position:relative;width:100px;height:100px;border:1px solid rgba(76,90,212,0.3);border-radius:4px;overflow:hidden;';
        photoDiv.innerHTML = `
      <img src="${photoData}" style="width:100%;height:100%;object-fit:cover;cursor:pointer;" onclick="openImageModal('${photoData}')" alt="Recipe photo ${idx + 1}">
      <button type="button" onclick="removePhotoAtIndex(${idx})" style="position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.7);color:white;border:none;border-radius:50%;width:24px;height:24px;cursor:pointer;font-size:16px;line-height:1;"></button>
    `;
        photosList.appendChild(photoDiv);
      });
    }

    // Compress image to reduce payload size
    function compressImage(dataUrl, maxWidth = 1200, quality = 0.8) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          // Calculate new dimensions while maintaining aspect ratio
          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }

          canvas.width = width;
          canvas.height = height;

          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          // Convert to JPEG with quality compression
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        img.src = dataUrl;
      });
    }

    async function handleMultipleRecipePhotoUpload(files) {
      ensureAiAssistElements();
      if (!window.aiAssistPhotos) window.aiAssistPhotos = [];

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        try {
          const reader = new FileReader();
          reader.onload = async (e) => {
            // Compress image before storing
            const compressed = await compressImage(e.target.result);
            window.aiAssistPhotos.push(compressed);
            renderPhotoPreviews();
          };
          reader.readAsDataURL(file);
        } catch (err) {
          console.error('Failed to read file', err);
        }
      }
    }

    function removePhotoAtIndex(idx) {
      if (window.aiAssistPhotos && idx >= 0 && idx < window.aiAssistPhotos.length) {
        window.aiAssistPhotos.splice(idx, 1);
        renderPhotoPreviews();
      }
    }

    window.removePhotoAtIndex = removePhotoAtIndex;

    async function handleRecipePhotoCamera() {
      ensureAiAssistElements();
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        aiAssistState.mediaStream = stream;
        if (aiAssistVideo) {
          aiAssistVideo.srcObject = stream;
          aiAssistVideo.play();
        }
        updateAiAssistMediaPreview();
        aiAssistSetStatus('Position recipe in view and click Capture photo');
      } catch (err) {
        console.error('Camera access failed', err);
        aiAssistSetStatus('Could not access camera: ' + (err.message || err), 'error');
      }
    }

    // Helper function to check if ingredient is duplicate
    function isDuplicateIngredient(newIngredient, existingData) {
      const newName = (newIngredient.name || '').toLowerCase().trim();
      if (!newName) return false;

      return existingData.some(existing => {
        const existingName = (existing.name || '').toLowerCase().trim();
        return existingName === newName;
      });
    }

    // Helper function to merge new ingredients with existing ones, avoiding duplicates
    function mergeIngredientsWithoutDuplicates(existingData, newRows) {
      const merged = [...existingData];
      let duplicateCount = 0;

      newRows.forEach(newRow => {
        if (!isDuplicateIngredient(newRow, merged)) {
          merged.push(newRow);
        } else {
          duplicateCount++;
        }
      });

      return { merged, duplicateCount };
    }

    async function handleAiProcess() {
      ensureAiAssistElements();
      if (!aiAssistInput) return;
      const text = aiAssistInput.value.trim();
      const hasPhotos = window.aiAssistPhotos && window.aiAssistPhotos.length > 0;
      if (!text && !hasPhotos) {
        aiAssistSetStatus('Describe the dish or add recipe photos before processing.', 'warn');
        return;
      }

      // Clear existing ingredient data before processing new input
      renderAiTable([]);
      console.log('Cleared existing ingredient data for fresh processing');

      // If we have photos, process them
      if (hasPhotos) {
        aiAssistSetStatus('Processing ' + window.aiAssistPhotos.length + ' recipe photo(s) using AI...');

        // Show progress bar
        const progressBar = document.getElementById('aiProgressBar');
        const progressBarFill = document.getElementById('aiProgressBarFill');
        if (progressBar && progressBarFill) {
          progressBar.classList.add('show');
          progressBarFill.style.width = '20%';
        }

        // Get dish name from input field if available
        const nameInput = document.getElementById('aiAssistNameInput');
        const dishNameForAi = nameInput?.value?.trim() || (aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '');

        for (let i = 0; i < window.aiAssistPhotos.length; i++) {
          const photoData = window.aiAssistPhotos[i];
          const payload = {
            imageData: photoData,
            imageFileName: `recipe_${i + 1}.jpg`,
            text: text || 'Please extract all ingredients from this recipe image.',
            dishName: dishNameForAi
          };

          // Update progress for current photo
          if (progressBarFill) {
            const progress = 20 + ((i / window.aiAssistPhotos.length) * 70);
            progressBarFill.style.width = progress + '%';
          }

          try {
            const result = await requestAiExtraction(payload);

            // Get dietary options from AI
            const dishDietaryOptions = (result?.dietaryOptions && Array.isArray(result.dietaryOptions)) ? result.dietaryOptions : [];

            // Add dietary options to each ingredient and preserve needsScan
            const rows = Array.isArray(result?.ingredients) ? result.ingredients.map(ing => ({
              ...ing,
              diets: dishDietaryOptions,
              // Preserve needsScan from AI (default to false if not provided)
              needsScan: ing.needsScan === true || ing.needsScan === 'true'
            })) : [];

            if (rows.length > 0) {
              // Render new data directly (existing data was cleared at start)
              const existingData = collectAiTableData();
              const allRows = [...existingData, ...rows];
              renderAiTable(allRows);

              let statusMsg = `Photo ${i + 1}/${window.aiAssistPhotos.length} processed.`;
              if (dishDietaryOptions.length > 0) {
                statusMsg += ` Detected: ${dishDietaryOptions.join(', ')}.`;
              }
              statusMsg += ' Review ingredients before applying.';
              aiAssistSetStatus(statusMsg, 'info');
            }
          } catch (err) {
            console.error('Recipe photo extraction failed', err);
            aiAssistSetStatus(`Failed to read recipe photo ${i + 1}: ` + (err.message || err), 'error');
          }
        }

        // Complete progress bar
        if (progressBarFill) progressBarFill.style.width = '100%';
        setTimeout(() => {
          if (progressBar) progressBar.classList.remove('show');
          if (progressBarFill) progressBarFill.style.width = '0%';
        }, 300);

        return;
      }

      // Otherwise process text
      aiAssistSetStatus('Preparing to analyze description');
      // Get dish name from input field if available, otherwise use getCurrentName
      const nameInput = document.getElementById('aiAssistNameInput');
      const dishNameForAi = nameInput?.value?.trim() || (aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '');
      const payload = {
        text,
        dishName: dishNameForAi
      };
      if (window !== window.parent) {
        const requestId = `ai-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        aiAssistState.pendingRequestId = requestId;
        parent.postMessage({
          type: 'aiAssistExtract',
          requestId,
          ...payload
        }, "*");
      } else {
        // Show progress bar
        const progressBar = document.getElementById('aiProgressBar');
        const progressBarFill = document.getElementById('aiProgressBarFill');
        if (progressBar && progressBarFill) {
          progressBar.classList.add('show');
          progressBarFill.style.width = '10%';
        }

        (async () => {
          // Continuous progress animation
          let progressInterval = null;
          let currentProgress = 10;

          const startProgressAnimation = () => {
            if (progressInterval) clearInterval(progressInterval);

            // Animate progress continuously from 10% to 90%
            progressInterval = setInterval(() => {
              if (currentProgress < 90) {
                currentProgress += Math.random() * 1 + 0.3; // Increment by 0.3-1.3% each step (slower)
                if (currentProgress > 90) currentProgress = 90;
                if (progressBarFill) {
                  progressBarFill.style.width = `${currentProgress}%`;
                }
              }
            }, 200); // Update every 200ms for slower animation
          };

          const stopProgressAnimation = () => {
            if (progressInterval) {
              clearInterval(progressInterval);
              progressInterval = null;
            }
          };

          try {
            // Start continuous progress animation
            aiAssistSetStatus('Analyzing input');
            startProgressAnimation();

            const result = await requestAiExtraction(payload);

            // Stop animation and jump to completion
            stopProgressAnimation();
            currentProgress = 95;
            if (progressBarFill) progressBarFill.style.width = '95%';

            const rows = Array.isArray(result?.ingredients) ? result.ingredients : [];

            // Clean up ingredient names and ensure needsScan is set
            rows.forEach(row => {
              if (row.name) {
                // Remove text in parentheses and trim
                row.name = row.name.replace(/\s*\([^)]*\)\s*/g, '').trim();
                // Remove common prefixes/suffixes
                row.name = row.name.replace(/\s*(optional|garnish|topping|for serving|for garnish)\s*$/gi, '').trim();
              }
              // Ensure needsScan is a boolean (default to false if not provided)
              row.needsScan = row.needsScan === true || row.needsScan === 'true';

              // Client-side fallback: Mark processed ingredients that should require scanning
              // even if AI didn't catch them (flours, processed foods, processed meats, etc.)
              if (!row.needsScan && row.name) {
                const ingredientLower = row.name.toLowerCase();
                if (requiresBarcodeScan(ingredientLower)) {
                  row.needsScan = true;
                }
              }
            });

            // NOTE: Brands from memory are now shown as thumbnails with + buttons
            // in the renderAiTable function, rather than auto-populating.
            // This gives users control over whether to use remembered brands.

            // Render new data directly (existing data was cleared at start)
            renderAiTable(rows);

            let statusMsg = rows.length ? 'Dish ingredient suggestions ready. Please review and confirm each ingredient before saving.' : 'AI could not extract ingredients from the description.';
            aiAssistSetStatus(statusMsg, 'info');

            // Complete progress bar
            stopProgressAnimation();
            if (progressBarFill) progressBarFill.style.width = '100%';
            setTimeout(() => {
              if (progressBar) progressBar.classList.remove('show');
              if (progressBarFill) progressBarFill.style.width = '0%';
            }, 300);

          } catch (err) {
            console.error('AI extraction failed', err);

            // Stop animation and hide progress bar on error
            stopProgressAnimation();
            if (progressBar) progressBar.classList.remove('show');
            if (progressBarFill) progressBarFill.style.width = '0%';

            // Check for specific error types
            const errorMsg = err.message || String(err);
            let statusMsg = '';

            if (errorMsg.includes('Anthropic API key') || errorMsg.includes('API key not configured')) {
              statusMsg = 'AI service error: Anthropic API key not configured. Please check Supabase Edge Function settings.';
            } else if (errorMsg.includes('Failed to proxy') || errorMsg.includes('proxy')) {
              statusMsg = 'AI service error: Proxy endpoint unavailable. Check if /api/ai-proxy is deployed.';
            } else if (errorMsg.includes('network') || errorMsg.includes('fetch')) {
              statusMsg = 'AI service error: Network connection failed. Please check your internet connection.';
            } else {
              statusMsg = 'AI service error: ' + (errorMsg.substring(0, 100) || 'Unknown error');
            }

            if (text) {
              const ingredients = heuristicallyExtractIngredients(text);
              // Render new data directly (existing data was cleared at start)
              renderAiTable(ingredients);

              statusMsg += ' Fallback: Generated a draft using local parsing. Review before applying.';
              aiAssistSetStatus(statusMsg, 'warn');
            } else {
              aiAssistSetStatus(statusMsg || ('AI assistant request failed: ' + errorMsg), 'warn');
            }
          }
        })();
      }
    }

    function handleAiAssistantResult(payload) {
      ensureAiAssistElements();
      if (!payload || payload.requestId !== aiAssistState.pendingRequestId) return;
      aiAssistState.pendingRequestId = null;
      const rows = Array.isArray(payload.ingredients) ? payload.ingredients : [];

      // Clean up ingredient names and ensure needsScan is set
      rows.forEach(row => {
        if (row.name) {
          // Remove text in parentheses and trim
          row.name = row.name.replace(/\s*\([^)]*\)\s*/g, '').trim();
          // Remove common prefixes/suffixes
          row.name = row.name.replace(/\s*(optional|garnish|topping|for serving|for garnish)\s*$/gi, '').trim();
        }
        // Ensure needsScan is a boolean (default to false if not provided)
        row.needsScan = row.needsScan === true || row.needsScan === 'true';

        // Client-side fallback: Mark processed ingredients that should require scanning
        // even if AI didn't catch them (flours, processed foods, etc.)
        if (!row.needsScan && row.name) {
          const ingredientLower = row.name.toLowerCase();
          if (requiresBarcodeScan(ingredientLower)) {
            row.needsScan = true;
          }
        }
      });

      // NOTE: Brands from memory are now shown as thumbnails with + buttons
      // in the renderAiTable function, rather than auto-populating.
      // This gives users control over whether to use remembered brands.

      // NOTE: Do NOT call rememberBrand here - brands should only be saved when dish is saved to server
      renderAiTable(rows);
      aiAssistSetStatus(rows.length ? 'Dish ingredient suggestions ready. Please review and confirm each ingredient before saving.' : 'AI could not extract ingredients from the description.', 'info');
    }

    function handleAiAssistantError(payload) {
      ensureAiAssistElements();
      if (!payload || payload.requestId !== aiAssistState.pendingRequestId) return;
      aiAssistState.pendingRequestId = null;
      aiAssistSetStatus(payload.error || 'AI assistant request failed.', 'warn');
    }

    function applyAiIngredientsToOverlay() {
      console.log('applyAiIngredientsToOverlay called');
      ensureAiAssistElements();
      const rows = collectAiTableData();

      // Hide any previous save error
      const saveErrorEl = document.getElementById('aiAssistSaveError');
      const saveErrorDetailsEl = document.getElementById('aiAssistSaveErrorDetails');
      if (saveErrorEl) saveErrorEl.style.display = 'none';

      // Validate dish name is not empty
      const nameInput = document.getElementById('aiAssistNameInput');
      if (nameInput && !nameInput.value.trim()) {
        console.log('Dish name is empty');
        if (saveErrorEl && saveErrorDetailsEl) {
          saveErrorDetailsEl.textContent = 'Please enter a dish name before saving';
          saveErrorEl.style.display = 'block';
          saveErrorEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        // Focus the name input field
        nameInput.focus();
        nameInput.style.border = '2px solid #dc2626';
        setTimeout(() => {
          nameInput.style.border = '1px solid rgba(76,90,212,0.35)';
        }, 2000);
        return;
      }

      if (!rows.length) {
        console.log('No rows to apply');
        aiAssistSetStatus('Add at least one ingredient before applying.', 'warn');
        return;
      }

      // Check if all ingredients are confirmed
      const unconfirmed = rows.filter(item => item.name.trim() && !item.confirmed);
      if (unconfirmed.length > 0) {
        const ingredientNames = unconfirmed.map(item => item.name).join(', ');
        console.log('Unconfirmed ingredients:', ingredientNames);

        // Show error at bottom near Save to Dish button
        if (saveErrorEl && saveErrorDetailsEl) {
          saveErrorDetailsEl.textContent = `Please click "Confirm" for: ${ingredientNames}`;
          saveErrorEl.style.display = 'block';
          saveErrorEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        return;
      }

      // Validate cross-contamination selection
      const noCrossCheckbox = document.getElementById('aiAssistNoCrossContamination');
      const crossAllergenCheckboxes = document.querySelectorAll('.aiCrossAllergenCheckbox');
      const crossErrorEl = document.getElementById('aiAssistCrossContaminationError');

      console.log('Found cross-contamination elements:', {
        noCrossCheckbox,
        crossAllergenCheckboxesCount: crossAllergenCheckboxes.length
      });

      const noCrossChecked = noCrossCheckbox && noCrossCheckbox.checked;
      const anyAllergenChecked = Array.from(crossAllergenCheckboxes || []).some(cb => cb.checked);

      console.log('Cross-contamination checkbox states:');
      crossAllergenCheckboxes.forEach(cb => {
        console.log(`  ${cb.dataset.allergen}: checked=${cb.checked}`);
      });

      console.log('Cross-contamination validation:', { noCrossChecked, anyAllergenChecked });

      if (!noCrossChecked && !anyAllergenChecked) {
        console.log('Cross-contamination validation failed');
        if (crossErrorEl) {
          crossErrorEl.style.display = 'block';
          crossErrorEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        return;
      }

      // NOTE: Brands are NOT saved to memory here - they will only be saved to memory
      // when the overlay is actually saved to the server (not just applied to the dish)

      // Collect cross-contamination data
      const crossContaminationData = {
        noCrossContamination: noCrossCheckbox && noCrossCheckbox.checked,
        allergens: []
      };

      console.log('Collecting cross-contamination data...');
      if (!crossContaminationData.noCrossContamination) {
        Array.from(crossAllergenCheckboxes || []).forEach(cb => {
          console.log(`  Checking ${cb.dataset.allergen}: checked=${cb.checked}`);
          if (cb.checked) {
            console.log(`    -> Adding ${cb.dataset.allergen} to allergens array`);
            crossContaminationData.allergens.push(cb.dataset.allergen);
          }
        });
      } else {
        console.log('  noCrossContamination is checked, skipping allergen collection');
      }

      console.log('Cross-contamination data collected:', crossContaminationData);

      // Mark as saved
      aiAssistState.savedToDish = true;
      // Clear dish name modification flag since dish is now saved
      aiAssistState.dishNameModified = false;

      console.log('aiAssistState.context?.onApply exists?', !!aiAssistState.context?.onApply);
      console.log('SAVE TO DISH: About to save rows - checking for userOverriddenScan:', rows.map(r => ({ name: r.name, userOverriddenScan: r.userOverriddenScan })));

      if (aiAssistState.context?.onApply) {
        // Pass ingredients, dietary options, and cross-contamination data to the overlay
        const dataToApply = {
          ingredients: rows,
          dietaryOptions: aiAssistState.detectedDietaryOptions || [],
          crossContamination: crossContaminationData
        };
        console.log('Calling onApply with:', { rowCount: rows.length, dataToApply });
        aiAssistState.context.onApply(rows, dataToApply);
      } else {
        console.error('No onApply callback found!');
      }
      closeAiAssistant();
      aiAssistSetStatus('');
    }

    // Helper function to get weeks ago text and color
    // showAll: if true, show text even for dates beyond 30 days (for admin/manager)
    const getWeeksAgoInfo = (date, showAll = false) => {
      try {
        const x = new Date(date);
        if (isNaN(x)) return { text: '', color: '#888' };
        const now = new Date();

        // Reset both dates to midnight for accurate comparison
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const compareDate = new Date(x.getFullYear(), x.getMonth(), x.getDate());

        const diffDays = Math.floor((today - compareDate) / (1000 * 60 * 60 * 24));
        const diffWeeks = Math.floor(diffDays / 7);

        // If more than 30 days and not showing all, return null to indicate suspension
        if (diffDays > 30 && !showAll) {
          return null; // Signal to suspend restaurant
        }

        // Determine weeks ago and color
        let text, color;
        if (diffDays < 7) {
          text = 'this week';
          color = '#4caf50'; // Green
        } else if (diffWeeks === 1) {
          text = 'last week';
          color = '#8bc34a'; // Yellow-green
        } else if (diffWeeks === 2) {
          text = 'two weeks ago';
          color = '#ff9800'; // Orange
        } else if (diffWeeks === 3) {
          text = 'three weeks ago';
          color = '#f44336'; // Red
        } else {
          // 4+ weeks - show number of weeks for admin/manager, otherwise "three weeks ago"
          if (showAll) {
            text = `${diffWeeks} weeks ago`;
            color = '#f44336'; // Red for all dates beyond 3 weeks
          } else {
            // 4 weeks but still within 30 days
            text = 'three weeks ago';
            color = '#f44336'; // Red
          }
        }

        return { text, color };
      } catch (_) {
        return { text: '', color: '#888' };
      }
    };

    const daysAgo = d => {
      const info = getWeeksAgoInfo(d);
      if (!info) return '';
      return info.text;
    };
    function div(html, cls) { const d = document.createElement('div'); if (cls) d.className = cls; d.innerHTML = html; return d; }

    // Normalize overlay coordinates to 0-100% with basic heuristics against 0-1000 legacy data
    function normalizeOverlayCoords(overlays) {

      return (overlays || []).map((o) => {
        const it = { ...o };

        const num = (v) => {
          const n = typeof v === 'string' ? parseFloat(v) : v;
          return Number.isFinite(n) ? n : 0;
        };

        const coords = ['x', 'y', 'w', 'h'].map((k) => num(it[k]));
        const maxCoord = Math.max(...coords, 0);
        const looksLikeThousandScale = maxCoord > 150 && maxCoord <= 1200;

        // If values look like 0-1000 grid, scale down to 0-100 once
        if (looksLikeThousandScale) {
          ['x', 'y', 'w', 'h'].forEach((k) => {
            const n = num(it[k]);
            it[k] = n / 10;
          });
        }

        // Clamp to sane bounds in percentage space
        const x = Math.max(0, Math.min(100, num(it.x)));
        const y = Math.max(0, Math.min(100, num(it.y)));
        const w = Math.max(0.5, Math.min(100 - x, num(it.w)));
        const h = Math.max(0.5, Math.min(100 - y, num(it.h)));

        it.x = x;
        it.y = y;
        it.w = w;
        it.h = h;

        // Preserve pageIndex (avoid clamping to prevent pulling other pages onto page 0)
        const pIdx = Number.isFinite(num(it.pageIndex)) ? num(it.pageIndex) : 0;
        it.pageIndex = Math.floor(pIdx);

        return it;
      });
    }

    function normalizeRestaurant(row) {
      if (!row) return null;
      const id = row._id ?? row.id;
      const menuImage = row.menuImage ?? row.menu_image;
      const menuImages = row.menuImages ?? row.menu_images;
      // Support both single image (backward compatible) and multiple images
      const menuImagesArray = menuImages ? (Array.isArray(menuImages) ? menuImages : [menuImages]) :
        (menuImage ? [menuImage] : []);
      const lastConfirmed = row.lastConfirmed ?? row.last_confirmed;
      const overlays = normalizeOverlayCoords(Array.isArray(row.overlays) ? row.overlays : []);
      return {
        _id: id,
        name: row.name,
        slug: row.slug,
        menuImage: menuImagesArray[0] || menuImage || '', // Keep for backward compatibility
        menuImages: menuImagesArray, // New array format
        lastConfirmed,
        overlays,
        website: row.website || null,
        phone: row.phone || null,
        delivery_url: row.delivery_url || null
      };
    }

    function configureModalClose({ visible = true, onClick = null } = {}) {
      const closeBtn = document.getElementById('modalCloseBtn');
      if (closeBtn) {
        closeBtn.style.display = visible ? 'inline-flex' : 'none';
        closeBtn.onclick = onClick || null;
      }
    }

    async function insertChangeLogEntry(base) {
      const client = window.supabaseClient;
      if (!client) throw new Error('Supabase client not ready.');
      const payload = {
        restaurant_id: base.restaurantId,
        type: base.type,
        description: base.description,
        changes: base.changes,
        user_email: base.userEmail || null,
        photos: Array.isArray(base.photos) ? base.photos : (base.photos ? [base.photos] : []),
        // Note: overlays field removed - overlays are saved separately in restaurants table
        // and the changes are tracked in the 'changes' JSON field above
        timestamp: base.timestamp || new Date().toISOString()
      };
      Object.keys(payload).forEach(k => payload[k] == null && delete payload[k]);
      const { error } = await client.from('change_logs').insert([payload]);
      if (error) throw error;
      return true;
    }

    async function fetchChangeLogEntries(restaurantId) {
      const client = window.supabaseClient;
      if (!client) throw new Error('Supabase client not ready.');
      let query = client.from('change_logs').select('*').order('timestamp', { ascending: false }).limit(50);
      if (restaurantId) {
        query = query.eq('restaurant_id', restaurantId);
      }
      const { data, error } = await query;
      if (error) throw error;
      return data || [];
    }
    /* risk + tooltip */
    function computeStatus(item, sel, userDiets) {
      const hasAllergenReqs = sel && sel.length > 0;
      const hasDietReqs = userDiets && userDiets.length > 0;

      if (!hasAllergenReqs && !hasDietReqs) return 'neutral';

      // Check allergen requirements - use normalized comparison
      const allergenHits = (item.allergens || []).filter(a => sel.includes(a));
      const hasAllergenIssues = allergenHits.length > 0;
      const removableAllergenSet = new Set((item.removable || []).map(r => norm(r.allergen || '')));
      const allergenRemovableAll = hasAllergenIssues ? allergenHits.every(a => removableAllergenSet.has(norm(a))) : true;

      // Check dietary requirements
      const itemDiets = new Set(item.diets || []);
      const meetsDietReqs = !hasDietReqs || userDiets.every(diet => itemDiets.has(diet));

      // Check if diet can be made (blocking allergens/ingredients are removable)
      let canBeMadeForDiets = false;
      if (hasDietReqs && !meetsDietReqs) {
        const allergenConflicts = {
          'Vegan': ['dairy', 'egg', 'fish', 'shellfish'],
          'Vegetarian': ['fish', 'shellfish'],
          'Pescatarian': [],
          'Gluten-free': ['wheat']
        };

        const unmetDiets = userDiets.filter(diet => !itemDiets.has(diet));
        if (unmetDiets.length) {
          canBeMadeForDiets = unmetDiets.every(userDiet => {
            const conflicts = allergenConflicts[userDiet] || [];
            const itemAllergens = item.allergens || [];
            const conflictingAllergens = conflicts.filter(allergen => {
              return itemAllergens.some(a => norm(a) === norm(allergen));
            });
            const allConflictingAllergensRemovable = conflictingAllergens.length > 0 &&
              conflictingAllergens.every(allergen => removableAllergenSet.has(norm(allergen)));

            const blockingIngredients = item.ingredientsBlockingDiets?.[userDiet] || [];
            const allBlockingIngredientsRemovable = blockingIngredients.length > 0 &&
              blockingIngredients.every(ing => ing.removable);

            const hasBlocks = conflictingAllergens.length > 0 || blockingIngredients.length > 0;
            if (!hasBlocks) return false;
            if (conflictingAllergens.length > 0 && !allConflictingAllergensRemovable) return false;
            if (blockingIngredients.length > 0 && !allBlockingIngredientsRemovable) return false;
            return true;
          });
        }
      }

      // If doesn't meet dietary requirements and can't be made, it's unsafe
      if (!meetsDietReqs && !canBeMadeForDiets) return 'unsafe';

      // If has allergen issues that can't be removed, it's unsafe
      if (hasAllergenIssues && !allergenRemovableAll) return 'unsafe';

      // If has removable allergen issues OR can be made to meet diets, it's removable
      if (hasAllergenIssues && allergenRemovableAll) return 'removable';
      if (!meetsDietReqs && canBeMadeForDiets) return 'removable';

      // Otherwise it's safe
      return 'safe';
    }

    function hasCrossContamination(item, sel) {
      if (!sel || !sel.length) return false;
      const crossContam = (item.crossContamination || []);
      return crossContam.some(a => sel.includes(a));
    }

    /* scale-aware tooltip */
    function currentScale() {
      try { return (window.visualViewport && window.visualViewport.scale) ? window.visualViewport.scale : 1; }
      catch (_) { return 1; }
    }
    function tooltipBodyHTML(item, sel, userDiets, isClick = false) {
      const status = computeStatus(item, sel, userDiets);
      const details = item.details || {};
      const hasCross = hasCrossContamination(item, sel);

      // Detect if mobile - on mobile always show details, on desktop only when clicked
      const isMobile = prefersMobileInfo();
      const showDetails = isMobile || isClick;

      if (!sel.length && (!userDiets || !userDiets.length)) return `<div class="note">No dietary preferences saved. Sign in to save your preferences.</div>`;

      let html = '';

      // Build allergen section first
      if (sel.length) {
        html += `<div style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(76,90,212,0.2)"><strong style="display:block;margin-bottom:8px;color:var(--ink)">Allergens:</strong>`;
        const hits = (item.allergens || []).filter(a => sel.includes(a));
        const removableSet = new Set((item.removable || []).map(r => norm(r.allergen || '')));

        const unsafeHits = hits.filter(a => !removableSet.has(norm(a)));
        const removableHits = hits.filter(a => removableSet.has(norm(a)));

        if (unsafeHits.length) {
          const list = unsafeHits.map(a => {
            const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '';
            const allergenLower = a.toLowerCase();
            let text = `${emoji} Contains <strong>${esc(allergenLower)}</strong>`;

            // Only show ingredient details when clicked (desktop) or always on mobile
            if (showDetails) {
              const ingredientInfo = details[allergenLower] || details[a];
              if (ingredientInfo) {
                // Extract just the ingredients part (remove "Contains " prefix if present)
                const ingredients = ingredientInfo.replace(/^Contains\s+/i, '');
                // More compact styling for mobile
                const detailStyle = isMobile
                  ? 'font-size:0.8em;opacity:0.8;margin-top:1px;margin-left:18px;line-height:1.2'
                  : 'font-size:0.85em;opacity:0.85;margin-top:2px;margin-left:20px';
                text += `<div style="${detailStyle}">${esc(ingredients)}</div>`;
              }
            }
            return `<div style="margin-bottom:4px">${text}</div>`;
          }).join('');
          html += `<div class="note tooltipDangerText">${list}</div>`;
        }
        if (removableHits.length) {
          const list = removableHits.map(a => {
            const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '';
            const allergenLower = a.toLowerCase();
            let text = `${emoji} Contains <strong>${esc(allergenLower)}</strong> (can be accommodated)`;

            // Only show ingredient details when clicked (desktop) or always on mobile
            if (showDetails) {
              const ingredientInfo = details[allergenLower] || details[a];
              if (ingredientInfo) {
                // Extract just the ingredients part (remove "Contains " prefix if present)
                const ingredients = ingredientInfo.replace(/^Contains\s+/i, '');
                // More compact styling for mobile
                const detailStyle = isMobile
                  ? 'font-size:0.8em;opacity:0.8;margin-top:1px;margin-left:18px;line-height:1.2'
                  : 'font-size:0.85em;opacity:0.85;margin-top:2px;margin-left:20px';
                text += `<div style="${detailStyle}">${esc(ingredients)}</div>`;
              }
            }
            return `<div style="margin-bottom:4px">${text}</div>`;
          }).join('');
          html += `<div class="note tooltipWarnText">${list}</div>`;
        }
        // Show allergens that the dish is free from (even if it contains others)
        const freeFromAllergens = sel.filter(a => !hits.includes(a));
        if (freeFromAllergens.length > 0) {
          const successLines = freeFromAllergens.map(a => {
            const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '';
            return `<div style="margin-bottom:4px;color:#4cc85a;font-size:0.9rem">${emoji} This dish is free of <strong>${esc(a.toLowerCase())}</strong></div>`;
          }).join('');
          html += `<div>${successLines}</div>`;
        }

        // Ingredients list removed per user request - not needed in tooltip
        html += `</div>`;
      }

      // Display dietary preferences section - show status for each user preference
      const hasUserDiets = userDiets && userDiets.length > 0;

      if (hasUserDiets) {
        html += `<div class="note" style="margin-top:12px"><strong style="display:block;margin-bottom:8px;color:var(--ink)">Diets:</strong>`;

        const itemDietSet = new Set(item.diets || []);
        const removableAllergens = new Set((item.removable || []).map(r => norm(r.allergen)));

        // Define which allergens conflict with each diet
        const allergenConflicts = {
          'Vegan': ['dairy', 'egg', 'fish', 'shellfish'],
          'Vegetarian': ['fish', 'shellfish'],
          'Pescatarian': []
        };

        userDiets.forEach(userDiet => {
          const isDietMet = itemDietSet.has(userDiet);
          const emoji = {
            'Vegan': '',
            'Vegetarian': '',
            'Pescatarian': '',
            'Gluten-free': '',
          }[userDiet] || '';
          const dietLower = userDiet.toLowerCase();

          // Check if there are removable allergens or blocking ingredients that would affect this diet
          const conflicts = allergenConflicts[userDiet] || [];
          const itemAllergens = item.allergens || [];
          const conflictingAllergens = conflicts.filter(allergen => itemAllergens.includes(allergen));

          // Check if ALL conflicting allergens are removable
          const allConflictingAllergensRemovable = conflictingAllergens.length > 0 &&
            conflictingAllergens.every(allergen => removableAllergens.has(norm(allergen)));

          // Check if ALL blocking ingredients are removable (if we have this info from AI assistant)
          const blockingIngredients = item.ingredientsBlockingDiets?.[userDiet] || [];
          const allBlockingIngredientsRemovable = blockingIngredients.length > 0 &&
            blockingIngredients.every(ing => ing.removable);

          // If diet is met BUT there are removable blockers for this specific diet, show "can be made" instead
          // Only show "can be made" if there are actual blockers that can be removed, not just any removable ingredient
          const hasRemovableBlockers =
            (conflictingAllergens.length > 0 && allConflictingAllergensRemovable) ||
            (blockingIngredients.length > 0 && allBlockingIngredientsRemovable);

          if (isDietMet && !hasRemovableBlockers) {
            // Diet is met and no removable blockers - show green "is"
            html += `<div style="margin-bottom:6px;color:#4cc85a;font-size:0.9rem">${emoji} This dish is <strong>${esc(dietLower)}</strong></div>`;
          } else if (isDietMet && hasRemovableBlockers) {
            // Diet is met but has removable blockers for this diet - show yellow "can be made"
            html += `<div style="margin-bottom:6px;color:#facc15;font-size:0.9rem">${emoji} This dish can be made <strong>${esc(dietLower)}</strong></div>`;
          } else {
            // Diet is not met - check if it can be made to meet the diet
            // (conflicts, conflictingAllergens, allConflictingAllergensRemovable, blockingIngredients, and allBlockingIngredientsRemovable already defined above)

            // The dish can be made to meet the diet ONLY if:
            // 1. ALL conflicting allergens (if any) are removable, AND
            // 2. ALL blocking ingredients (if any) are removable
            // If we have blocking ingredients info from AI assistant, use it strictly
            // Otherwise, we can only check allergens - if no conflicting allergens but diet still not met,
            // we can't determine if blocking ingredients are removable, so show "is not"
            let canBeMade = false;

            // Check if we have detailed ingredient blocking info (from AI assistant)
            const hasBlockingIngredientsInfo = item.ingredientsBlockingDiets !== undefined;

            if (hasBlockingIngredientsInfo) {
              // We have detailed info - use it strictly
              // Can be made only if:
              // 1. ALL blocking ingredients (if any) are removable, AND
              // 2. ALL conflicting allergens (if any) are removable
              const noBlockingIngredients = blockingIngredients.length === 0;
              const noConflictingAllergens = conflictingAllergens.length === 0;

              canBeMade =
                (noBlockingIngredients || allBlockingIngredientsRemovable) &&
                (noConflictingAllergens || allConflictingAllergensRemovable);
            } else {
              // No blocking ingredients info - can only check allergens
              // If there are conflicting allergens, check if they're all removable
              // If no conflicting allergens but diet still not met, we can't determine if blocking ingredients are removable
              // So only show "can be made" if conflicting allergens exist AND are all removable
              canBeMade = conflictingAllergens.length > 0 && allConflictingAllergensRemovable;
            }

            if (canBeMade) {
              // All blocking ingredients/allergens can be substituted out - show yellow (same as allergen warning color)
              html += `<div style="margin-bottom:6px;color:#facc15;font-size:0.9rem">${emoji} This dish can be made <strong>${esc(dietLower)}</strong></div>`;
            } else {
              // Cannot be made to meet the diet - show red
              let dietText = `${emoji} This dish is not <strong>${esc(dietLower)}</strong>`;

              // Only show ingredient details when clicked (desktop) or always on mobile
              if (showDetails && blockingIngredients.length > 0) {
                const ingredientNames = blockingIngredients
                  .map(ing => ing.name || ing)
                  .filter(name => name)
                  .join(', ');
                if (ingredientNames) {
                  // More compact styling for mobile
                  const detailStyle = isMobile
                    ? 'font-size:0.8em;opacity:0.8;margin-top:1px;margin-left:18px;line-height:1.2'
                    : 'font-size:0.85em;opacity:0.85;margin-top:2px;margin-left:20px';
                  dietText += `<div style="${detailStyle}">${esc(ingredientNames)}</div>`;
                }
              }
              html += `<div style="margin-bottom:6px;color:#e85d5d;font-size:0.9rem">${dietText}</div>`;
            }
          }
        });

        html += `</div>`;
      }

      // Add cross-contamination risk at the bottom with yellow warning icon
      if (hasCross && sel.length) {
        const crossHits = (item.crossContamination || []).filter(a => sel.includes(a));
        if (crossHits.length > 0) {
          const crossList = crossHits.map(a => {
            const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '';
            return `${emoji} <strong>${esc(a.toLowerCase())}</strong>`;
          }).join(', ');
          html += `<div class="note" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(76,90,212,0.2)">`;
          html += `<div style="display:flex;align-items:flex-start;gap:8px;color:#facc15;font-size:0.9rem">`;
          html += `<span style="font-size:1.2rem;flex-shrink:0;"></span>`;
          html += `<div>Cross-contamination risk: ${crossList}</div>`;
          html += `</div></div>`;
        }
      }

      return html;
    }

    async function toggleLoveDishInTooltip(user, restaurantId, dishName, button) {
      if (!window.lovedDishesSet) window.lovedDishesSet = new Set();
      const dishKey = `${String(restaurantId)}:${dishName}`;
      const isLoved = window.lovedDishesSet.has(dishKey);

      button.disabled = true;

      try {
        if (isLoved) {
          const { error } = await window.supabaseClient
            .from('user_loved_dishes')
            .delete()
            .eq('user_id', user.id)
            .eq('restaurant_id', restaurantId)
            .eq('dish_name', dishName);

          if (error) throw error;
          window.lovedDishesSet.delete(dishKey);
          button.classList.remove('loved');
          button.setAttribute('title', 'Add to favorite dishes');
          button.setAttribute('aria-label', 'Add to favorites');
          const img = button.querySelector('img');
          if (img) img.src = 'images/heart-icon.svg';
        } else {
          const { error } = await window.supabaseClient
            .from('user_loved_dishes')
            .upsert({
              user_id: user.id,
              restaurant_id: restaurantId,
              dish_name: dishName
            }, { onConflict: 'user_id,restaurant_id,dish_name' });

          if (error) throw error;
          window.lovedDishesSet.add(dishKey);
          button.classList.add('loved');
          button.setAttribute('title', 'Remove from favorite dishes');
          button.setAttribute('aria-label', 'Remove from favorites');
          const img = button.querySelector('img');
          if (img) img.src = 'images/heart-icon.svg';
        }
      } catch (err) {
        console.error('Failed to update loved dish', err);
      } finally {
        button.disabled = false;
      }
    }

    function renderTopbar() {
      const el = document.getElementById('topbar'); el.innerHTML = '';
      const isQrExperience = !!(state.qr || urlQR);
      document.body.classList.toggle('qrMode', isQrExperience);
      const OWNER_EMAIL = 'matt.29.ds@gmail.com';
      const isOwner = state.user?.email === OWNER_EMAIL;
      const isManager = state.user?.role === 'manager';

      // Check editor mode from localStorage - defined early for brand click
      const currentMode = localStorage.getItem('clarivoreManagerMode') || 'editor';
      const isEditorMode = currentMode === 'editor';

      const brand = div(`<img src="https://static.wixstatic.com/media/945e9d_2b97098295d341d493e4a07d80d6b57c~mv2.png" alt=""><span>Clarivore</span>`, 'brand');
      // Go to dashboard in editor mode, home page in customer mode
      brand.onclick = () => {
        if ((isOwner || isManager) && isEditorMode) {
          window.location.href = 'manager-dashboard.html';
        } else {
          window.location.href = 'home.html';
        }
      };
      brand.style.cursor = 'pointer';
      el.appendChild(brand);
      const managerRestaurants = state.user?.managerRestaurants || [];

      // Show navigation for non-QR users, or show sign-in button for QR users
      const navWrap = div('', 'topNav');
      const tabs = div('', 'tabs');

      if (isQrExperience) {
        // QR mode - show simple sign-in button for non-logged-in users
        if (!state.user?.loggedIn) {
          const signInTab = div('Sign in', 'tab');
          signInTab.onclick = () => {
            window.location.href = 'account.html';
          };
          tabs.appendChild(signInTab);
          navWrap.appendChild(tabs);
          el.appendChild(navWrap);
        }
      } else {
        // Non-QR mode - show full navigation
        const navStructure = [];

        if (isOwner && isEditorMode) {
          // Owner in editor mode - same nav as admin-dashboard
          navStructure.push({ t: 'Admin', to: '/admin-dashboard', external: true });
          navStructure.push({ t: 'Dashboard', to: '/manager-dashboard', external: true });
          // Webpage editor dropdown
          if (managerRestaurants.length === 1) {
            navStructure.push({ t: 'Webpage editor', to: `restaurant.html?slug=${encodeURIComponent(managerRestaurants[0].slug)}&edit=1`, external: true, fullUrl: true });
          } else if (managerRestaurants.length > 1) {
            navStructure.push({
              type: 'group',
              label: 'Webpage editor',
              items: managerRestaurants.map(r => ({
                t: r.name,
                to: `restaurant.html?slug=${encodeURIComponent(r.slug)}&edit=1`,
                external: true,
                fullUrl: true
              }))
            });
          }
          navStructure.push({
            type: 'group',
            label: 'Tablet pages',
            items: [
              { t: 'Server tablet', to: '/server-tablet', external: true },
              { t: 'Kitchen tablet', to: '/kitchen-tablet', external: true }
            ]
          });
          navStructure.push({ t: 'Account settings', to: '/account', external: true });
        } else if (isOwner && !isEditorMode) {
          // Owner in customer mode
          navStructure.push({ t: 'Home', to: '/home', external: true });
          navStructure.push({
            type: 'group',
            label: 'By restaurant',
            items: [
              { t: 'All restaurants', to: '/restaurants', external: true },
              { t: 'Favorite restaurants', to: '/favorites', external: true }
            ]
          });
          navStructure.push({
            type: 'group',
            label: 'By dish',
            items: [
              { t: 'Dish search', to: '/dish-search', external: true },
              { t: 'My dishes', to: '/my-dishes', external: true }
            ]
          });
          navStructure.push({ t: 'Account settings', to: '/account', external: true });
        } else if (isManager && isEditorMode) {
          // Manager in editor mode
          navStructure.push({ t: 'Dashboard', to: '/manager-dashboard', external: true });
          if (managerRestaurants.length === 1) {
            navStructure.push({ t: 'Webpage editor', to: `restaurant.html?slug=${encodeURIComponent(managerRestaurants[0].slug)}&edit=1`, external: true, fullUrl: true });
          } else if (managerRestaurants.length > 1) {
            navStructure.push({
              type: 'group',
              label: 'Webpage editor',
              items: managerRestaurants.map(r => ({
                t: r.name,
                to: `restaurant.html?slug=${encodeURIComponent(r.slug)}&edit=1`,
                external: true,
                fullUrl: true
              }))
            });
          }
          navStructure.push({
            type: 'group',
            label: 'Tablet pages',
            items: [
              { t: 'Server tablet', to: '/server-tablet', external: true },
              { t: 'Kitchen tablet', to: '/kitchen-tablet', external: true }
            ]
          });
          navStructure.push({ t: 'Account settings', to: '/account', external: true });
        } else {
          // Regular user or manager in customer mode
          navStructure.push({ t: 'Home', to: '/home', external: true });
          navStructure.push({
            type: 'group',
            label: 'By restaurant',
            items: [
              { t: 'All restaurants', to: '/restaurants', external: true },
              { t: 'Favorite restaurants', to: '/favorites', external: true }
            ]
          });
          navStructure.push({
            type: 'group',
            label: 'By dish',
            items: [
              { t: 'Dish search', to: '/dish-search', external: true },
              { t: 'My dishes', to: '/my-dishes', external: true }
            ]
          });
          navStructure.push({ t: 'Account settings', to: '/account', external: true });
        }
        navStructure.forEach(item => {
          if (item.type === 'group') {
            const group = div('', 'nav-group');
            const trigger = div(item.label, 'nav-dropdown-trigger');
            const content = div('', 'nav-dropdown-content');

            item.items.forEach(sub => {
              const b = div(sub.t, 'tab');
              b.onclick = () => {
                const targetUrl = sub.fullUrl ? sub.to : (sub.external ? sub.to + '.html' : null);
                if (targetUrl) {
                  if (hasUnsavedChanges()) {
                    showUnsavedChangesModal(() => {
                      window.editorDirty = false;
                      if (aiAssistState) aiAssistState.savedToDish = true;
                      window.location.href = targetUrl;
                    });
                  } else {
                    window.location.href = targetUrl;
                  }
                } else {
                  send({ type: 'navigate', to: sub.to });
                }
              };
              content.appendChild(b);
            });

            group.appendChild(trigger);
            group.appendChild(content);
            tabs.appendChild(group);
          } else {
            const b = div(item.t, 'tab');
            b.onclick = () => {
              if (item.external) {
                const targetUrl = item.to + '.html';
                if (hasUnsavedChanges()) {
                  showUnsavedChangesModal(() => {
                    window.editorDirty = false;
                    if (aiAssistState) aiAssistState.savedToDish = true;
                    window.location.href = targetUrl;
                  });
                } else {
                  window.location.href = targetUrl;
                }
              } else {
                send({ type: 'navigate', to: item.to });
              }
            };
            tabs.appendChild(b);
          }
        });
        navWrap.appendChild(tabs);
        el.appendChild(navWrap);
      }

      // Mode toggle for managers and owner
      const modeToggleContainer = document.getElementById('modeToggleContainer');
      if (modeToggleContainer && state.user?.loggedIn && (isManager || isOwner)) {
        modeToggleContainer.style.display = 'flex';
        modeToggleContainer.innerHTML = `
          <span class="mode-toggle-label">${isEditorMode ? 'Editor' : 'Customer'}</span>
          <div class="mode-toggle ${isEditorMode ? 'active' : ''}" id="modeToggle" title="Toggle between Editor and Customer mode"></div>
        `;
        const toggle = document.getElementById('modeToggle');
        if (toggle) {
          toggle.onclick = () => {
            const targetUrl = isEditorMode ? 'home.html' : 'manager-dashboard.html';
            const modeValue = isEditorMode ? 'customer' : 'editor';

            if (hasUnsavedChanges()) {
              showUnsavedChangesModal(() => {
                // Clear dirty flags before navigating
                window.editorDirty = false;
                if (aiAssistState) aiAssistState.savedToDish = true;
                localStorage.setItem('clarivoreManagerMode', modeValue);
                window.location.href = targetUrl;
              });
            } else {
              localStorage.setItem('clarivoreManagerMode', modeValue);
              window.location.href = targetUrl;
            }
          };
        }
      } else if (modeToggleContainer) {
        modeToggleContainer.style.display = 'none';
      }
    }

    /* tooltips */
    const pageTip = document.getElementById('tip');
    // Track if tip has been clicked/selected to stop pulsing
    let tipInteracted = false;
    // Track if tip is pinned open (clicked, should stay visible when mouse leaves)
    let tipPinned = false;
    // Track which overlay item is currently pinned (by comparing item data)
    let pinnedOverlayItem = null;

    // Set up click handlers for tip pinning
    if (pageTip) {
      // Removed hover pulsing animation handlers

      // Pin tip open when user clicks anywhere in the tip
      pageTip.addEventListener('click', (e) => {
        // Don't pin if clicking the close button (let close handler handle it)
        if (e.target && e.target.classList.contains('tClose')) {
          hideTip(true);
          return;
        }
        tipInteracted = true;
        tipPinned = true;
        // pinnedOverlayItem is already set when showTipIn is called with isClick=true
      });

      // Also handle touch interactions
      pageTip.addEventListener('touchstart', (e) => {
        if (e.target && e.target.classList.contains('tClose')) {
          hideTip(true);
          return;
        }
        tipInteracted = true;
        tipPinned = true;
        // pinnedOverlayItem is already set when showTipIn is called with isClick=true
      });
    }

    function prefersMobileInfo() {
      try {
        const hasCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        const hasFine = window.matchMedia && window.matchMedia('(pointer: fine)').matches;
        if (hasCoarse) return true;
        if (hasFine) return false;
        return window.innerWidth <= 640;
      } catch (_) {
        return window.innerWidth <= 640;
      }
    }

    // Compact mobile-specific display for allergen/diet information
    // Organized by severity: RED (danger)  YELLOW (caution)  GREEN (safe)
    function mobileCompactBodyHTML(item, sel, userDiets) {
      const details = item.details || {};

      if (!sel.length && (!userDiets || !userDiets.length)) {
        return `<div style="padding:12px;text-align:center;color:rgba(255,255,255,0.6);font-size:0.85rem">No dietary preferences saved</div>`;
      }

      // Collect all items and categorize by severity
      const redItems = []; // Danger
      const yellowItems = []; // Caution/Warning
      const greenItems = []; // Safe

      // Process allergens
      if (sel.length) {
        const dishAllergens = item.allergens || [];
        sel.forEach(allergen => {
          const allergenLower = allergen.toLowerCase();
          const isDanger = dishAllergens.some(a => a.toLowerCase() === allergenLower);
          const emoji = ALLERGEN_EMOJI[allergenLower] || '';

          if (isDanger) {
            const ingredientInfo = details[allergenLower] || details[allergen];
            const ingredients = ingredientInfo ? ingredientInfo.replace(/^Contains\s+/i, '') : '';
            redItems.push({
              type: 'allergen',
              emoji,
              text: allergenLower,
              subtext: ingredients
            });
          } else {
            greenItems.push({
              type: 'allergen-safe',
              emoji,
              text: `${allergenLower}-free`
            });
          }
        });
      }

      // Process diets
      if (userDiets && userDiets.length > 0) {
        const itemDietSet = new Set(item.diets || []);
        userDiets.forEach(userDiet => {
          const isDietMet = itemDietSet.has(userDiet);
          const emoji = DIET_EMOJI[userDiet.toLowerCase()] || '';
          const dietLower = userDiet.toLowerCase();
          const blockingIngredients = item.ingredientsBlockingDiets?.[userDiet] ||
            item.ingredientsBlockingDiets?.[dietLower] || [];

          if (isDietMet) {
            greenItems.push({
              type: 'diet-met',
              emoji,
              text: userDiet
            });
          } else {
            const ingredientNames = blockingIngredients.length > 0
              ? blockingIngredients.map(ing => ing.name || ing).filter(name => name).join(', ')
              : '';
            redItems.push({
              type: 'diet',
              emoji,
              text: `Not ${dietLower}`,
              subtext: ingredientNames
            });
          }
        });
      }

      // Build HTML in order: RED  YELLOW  GREEN
      let html = '<div style="padding:8px 0">';

      // RED items (danger)
      if (redItems.length > 0) {
        redItems.forEach(item => {
          html += `<div style="background:rgba(239,68,68,0.15);border:1px solid rgba(239,68,68,0.3);border-radius:8px;padding:6px 10px;margin-bottom:6px">`;
          html += `<div style="color:#fca5a5;font-size:0.85rem;font-weight:500">${item.emoji} ${esc(item.text)}</div>`;
          if (item.subtext) {
            html += `<div style="color:rgba(252,165,165,0.7);font-size:0.75rem;margin-top:2px;line-height:1.3">${esc(item.subtext)}</div>`;
          }
          html += `</div>`;
        });
      }

      // YELLOW items (caution) - currently none, but structured for future use

      // GREEN items (safe) - show as compact chips in a grid
      if (greenItems.length > 0) {
        html += '<div style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:8px">';
        greenItems.forEach(item => {
          html += `<div style="background:rgba(34,197,94,0.12);border:1px solid rgba(34,197,94,0.25);border-radius:6px;padding:4px 8px;font-size:0.75rem;color:#86efac">${item.emoji} ${esc(item.text)}</div>`;
        });
        html += '</div>';
      }

      html += '</div>';
      return html;
    }
    function renderMobileInfo(item) {
      // Make function available globally for MutationObserver
      window.renderMobileInfo = renderMobileInfo;
      window.currentMobileInfoItem = item;
      ensureMobileInfoPanel();
      if (!mobileInfoPanel) return;
      mobileInfoPanel.style.position = 'fixed';
      /* Use full width in full-screen mode, otherwise use margins */
      const isFullScreen = document.body.classList.contains('mobileViewerActive');
      if (isFullScreen) {
        // Force full width in full-screen mode - use !important via setProperty
        mobileInfoPanel.style.setProperty('left', '0', 'important');
        mobileInfoPanel.style.setProperty('right', '0', 'important');
        mobileInfoPanel.style.setProperty('bottom', '0', 'important');
      } else {
        mobileInfoPanel.style.left = '12px';
        mobileInfoPanel.style.right = '12px';
        mobileInfoPanel.style.bottom = '12px';
      }
      mobileInfoPanel.style.zIndex = '3500';
      if (!prefersMobileInfo()) {
        mobileInfoPanel.classList.remove('show');
        mobileInfoPanel.style.display = 'none';
        mobileInfoPanel.innerHTML = '';
        currentMobileInfoItem = null;
        return;
      }
      if (!item) {
        currentMobileInfoItem = null;
        mobileInfoPanel.innerHTML = '';
        mobileInfoPanel.style.display = 'none';
        mobileInfoPanel.classList.remove('show');
        // Remove selected class from all overlays when mobile panel is closed
        document.querySelectorAll('.overlay').forEach(ov => ov.classList.remove('selected'));
        // Clear tracked overlay selection
        window.__lastSelectedOverlay = null;
        return;
      }
      currentMobileInfoItem = item;
      const bodyHTML = mobileCompactBodyHTML(item, state.allergies || [], state.diets || []);

      mobileInfoPanel.innerHTML = `
    <div class="mobileInfoHeaderRow">
      <div class="mobileInfoHeader">${esc(item.id || 'Item')}</div>
      <div style="display:flex;align-items:center;gap:0;">
        ${state.user?.loggedIn ? '<div id="mobileLoveButtonContainer" style="margin-right:8px;"></div>' : ''}
        <button type="button" class="mobileInfoClose" aria-label="Close dish details"></button>
      </div>
    </div>
    <div class="mobileInfoContent">
      ${bodyHTML}
    </div>
  `;

      // Create love button separately if user is logged in
      if (state.user?.loggedIn && window.supabaseClient) {
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        const dishName = item.id || item.name || 'Unnamed dish';
        const dishKey = restaurantId ? `${String(restaurantId)}:${dishName}` : null;
        const isLoved = dishKey && window.lovedDishesSet && window.lovedDishesSet.has(dishKey);

        if (restaurantId && dishName) {
          const loveBtnContainer = mobileInfoPanel.querySelector('#mobileLoveButtonContainer');
          if (loveBtnContainer) {
            const loveBtn = document.createElement('button');
            loveBtn.type = 'button';
            loveBtn.className = `love-button-tooltip ${isLoved ? 'loved' : ''}`;
            loveBtn.style.cssText = 'width:36px;height:36px;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;line-height:1;touch-action:manipulation;-webkit-tap-highlight-color:transparent;pointer-events:auto;position:relative;z-index:9999';
            loveBtn.setAttribute('title', isLoved ? 'Remove from favorite dishes' : 'Add to favorite dishes');
            loveBtn.setAttribute('aria-label', isLoved ? 'Remove from favorites' : 'Add to favorites');

            const heartImg = document.createElement('img');
            heartImg.src = 'images/heart-icon.svg';
            heartImg.alt = isLoved ? 'Loved' : 'Not loved';
            heartImg.style.cssText = 'width:18px;height:18px;display:block;pointer-events:none';
            loveBtn.appendChild(heartImg);

            loveBtnContainer.appendChild(loveBtn);

            // Attach handler immediately
            const handleLoveClick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleLoveDishInTooltip(state.user, restaurantId, dishName, loveBtn);
            };
            loveBtn.addEventListener('click', handleLoveClick, true);
            loveBtn.addEventListener('touchend', handleLoveClick, true);
          }
        }
      }
      mobileInfoPanel.style.background = 'rgba(11,16,32,0.94)';
      mobileInfoPanel.style.backdropFilter = 'blur(14px)';
      mobileInfoPanel.style.webkitBackdropFilter = 'blur(14px)';
      // Ensure positioning is correct, especially after full-screen mode activates
      const isFullScreenCheck = document.body.classList.contains('mobileViewerActive');
      if (isFullScreenCheck) {
        // Force full width in full-screen mode - use setProperty with important
        mobileInfoPanel.style.setProperty('left', '0', 'important');
        mobileInfoPanel.style.setProperty('right', '0', 'important');
        mobileInfoPanel.style.setProperty('bottom', '0', 'important');
      }
      adjustMobileInfoPanelForZoom();
      mobileInfoPanel.style.display = 'block';
      mobileInfoPanel.classList.add('show');
      const closeBtn = mobileInfoPanel.querySelector('.mobileInfoClose');
      if (closeBtn) {
        const closePanel = (ev) => {
          if (ev) { ev.preventDefault(); ev.stopPropagation(); }
          renderMobileInfo(null);
        };
        closeBtn.addEventListener('click', closePanel);
        closeBtn.addEventListener('touchend', closePanel, { passive: false });
        closeBtn.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { closePanel(ev); } });
      }
    }
    function syncMobileInfoPanel() {
      if (!mobileInfoPanel) return;
      adjustMobileInfoPanelForZoom();
      if (prefersMobileInfo()) {
        if (currentMobileInfoItem) {
          renderMobileInfo(currentMobileInfoItem);
        } else {
          mobileInfoPanel.innerHTML = '';
          mobileInfoPanel.style.display = 'none';
          mobileInfoPanel.classList.remove('show');
        }
        hideTip();
      } else {
        mobileInfoPanel.classList.remove('show');
        mobileInfoPanel.style.display = 'none';
        mobileInfoPanel.innerHTML = '';
        currentMobileInfoItem = null;
      }
    }
    addEventListener('resize', () => syncMobileInfoPanel(), { passive: true });
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', () => syncMobileInfoPanel(), { passive: true });
      visualViewport.addEventListener('scroll', () => syncMobileInfoPanel(), { passive: true });
    }
    ensureMobileInfoPanel();
    function showTipIn(el, x, y, title, bodyHTML, anchorRect = null, isClick = false, item = null) {
      const vv = window.visualViewport;
      const zoom = vv && vv.scale ? vv.scale : 1;
      const offsetLeft = vv && typeof vv.offsetLeft === 'number' ? vv.offsetLeft : 0;
      const offsetTop = vv && typeof vv.offsetTop === 'number' ? vv.offsetTop : 0;
      const viewportWidth = vv && vv.width ? vv.width : window.innerWidth;
      const viewportHeight = vv && vv.height ? vv.height : window.innerHeight;
      const scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft || 0;
      const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
      // Only show love button and close button when item is selected (pinned or clicked)
      const showButtons = tipPinned || isClick;

      // Generate love button HTML if user is logged in and item is selected
      const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
      const dishName = title || 'Unnamed dish';
      const dishKey = restaurantId ? `${String(restaurantId)}:${dishName}` : null;
      const isLoved = dishKey && window.lovedDishesSet && window.lovedDishesSet.has(dishKey);
      const loveButtonId = dishKey ? `love-btn-tooltip-${dishKey.replace(/[^a-zA-Z0-9]/g, '-')}` : null;
      const loveButtonHTML = (showButtons && loveButtonId && state.user?.loggedIn && restaurantId)
        ? `<button type="button" class="love-button-tooltip ${isLoved ? 'loved' : ''}" id="${loveButtonId}" data-restaurant-id="${restaurantId}" data-dish-name="${esc(dishName)}" title="${isLoved ? 'Remove from favorite dishes' : 'Add to favorite dishes'}" aria-label="${isLoved ? 'Remove from favorites' : 'Add to favorites'}"><img src="images/heart-icon.svg" alt="${isLoved ? 'Loved' : 'Not loved'}" style="width:14px;height:14px;display:block;" /></button>`
        : '';

      const closeButtonHTML = showButtons ? '<button class="tClose" type="button"></button>' : '';

      // Add pulsing hover message when it's a hover (not a click) and not already pinned
      const hoverMessage = (!isClick && !tipPinned) ? '<div class="tipHoverMessage">Select item for more options</div>' : '';

      // Add "Add to order" button when item is selected (pinned or clicked)
      const isInOrder = (window.orderItems && title && window.orderItems.includes(title)) || false;
      const addToOrderButton = (showButtons && title) ? `<button type="button" class="addToOrderBtn" data-dish-name="${esc(title)}" id="addToOrderBtn_${esc(title).replace(/[^a-zA-Z0-9]/g, '_')}" ${isInOrder ? 'disabled' : ''}>${isInOrder ? 'Added' : 'Add to order'}</button>` : '';

      el.innerHTML = `
    <div class="tipHead">
      <div class="tTitle">${esc(title || 'Item')}</div>
      <div style="display:flex;align-items:center;gap:0;">
        ${loveButtonHTML}
        ${closeButtonHTML}
      </div>
    </div>
    ${bodyHTML}
    ${hoverMessage}
    ${addToOrderButton}
  `;
      el.style.display = 'block';

      // Reduce bottom padding when hover message is present to eliminate extra space
      if (hoverMessage) {
        el.style.paddingBottom = '4px';
      } else {
        el.style.paddingBottom = '';
      }

      // If this is a click, pin the tip
      if (isClick && item) {
        tipPinned = true;
        tipInteracted = true;
        pinnedOverlayItem = item; // Track which item is pinned
      }

      // Only reset interaction state if not already pinned (preserve pinned state)
      // This allows the tip to stay open when clicked
      if (!tipPinned) {
        tipInteracted = false;
        pinnedOverlayItem = null;
      }

      // Removed pulsing animation from tip pop-up

      // Attach love button handler if present
      const loveBtn = el.querySelector('.love-button-tooltip');
      if (loveBtn && window.supabaseClient && state.user?.loggedIn) {
        const restaurantIdAttr = loveBtn.getAttribute('data-restaurant-id');
        const dishNameAttr = loveBtn.getAttribute('data-dish-name');
        if (restaurantIdAttr && dishNameAttr) {
          const handleLoveClick = (e) => {
            if (e) { e.preventDefault(); e.stopPropagation(); }
            toggleLoveDishInTooltip(state.user, restaurantIdAttr, dishNameAttr, loveBtn);
          };
          loveBtn.addEventListener('click', handleLoveClick);
          loveBtn.addEventListener('touchend', handleLoveClick, { passive: false });
        }
      }

      // Attach "Add to order" button handler if present
      const addToOrderBtn = el.querySelector('.addToOrderBtn');
      const addToOrderConfirmEl = ensureAddToOrderConfirmContainer(el);
      hideAddToOrderConfirmation(addToOrderConfirmEl);
      if (addToOrderBtn) {
        const dishNameAttr = addToOrderBtn.getAttribute('data-dish-name');
        if (dishNameAttr) {
          addToOrderBtn.addEventListener('click', (e) => {
            if (e) { e.preventDefault(); e.stopPropagation(); }
            hideAddToOrderConfirmation(addToOrderConfirmEl);

            // Always check getDishCompatibilityDetails first to match what UI displays
            const details = getDishCompatibilityDetails(dishNameAttr);
            const hasIssues = (details.issues?.allergens?.length > 0 || details.issues?.diets?.length > 0);

            if (hasIssues) {
              // There are issues according to getDishCompatibilityDetails (what UI shows)
              // Show confirmation dialog
              const severity = details.issues?.allergens?.length > 0 || details.issues?.diets?.length > 0 ? 'danger' : 'warn';
              details.severity = severity;
              showAddToOrderConfirmation(addToOrderConfirmEl, dishNameAttr, details, addToOrderBtn);
            } else {
              // No issues according to getDishCompatibilityDetails, add directly
              const result = addDishToOrder(dishNameAttr);
              if (result?.success) {
                addToOrderBtn.disabled = true;
                addToOrderBtn.textContent = 'Added';
                hideAddToOrderConfirmation(addToOrderConfirmEl);
              } else if (result?.needsConfirmation) {
                // Fallback: if addDishToOrder says needs confirmation but getDishCompatibilityDetails doesn't,
                // still show confirmation (shouldn't happen if logic is consistent, but safety check)
                const severity = result.issues?.allergens?.length > 0 || result.issues?.diets?.length > 0 ? 'danger' : 'warn';
                details.severity = severity;
                details.issues = result.issues || details.issues;
                showAddToOrderConfirmation(addToOrderConfirmEl, dishNameAttr, details, addToOrderBtn);
              }
            }
          });
        }
      }

      const isMobile = window.innerWidth <= 640;
      el.style.transform = '';
      el.style.transformOrigin = '';

      const layoutWidth = document.documentElement?.clientWidth || window.innerWidth;
      const baseMaxWidth = isMobile
        ? Math.min(280, Math.max(220, layoutWidth - 40))
        : Math.min(320, Math.max(240, layoutWidth - 80));
      el.style.maxWidth = baseMaxWidth + 'px';
      el.style.padding = isMobile ? '8px' : '10px';
      el.style.borderRadius = isMobile ? '8px' : '10px';
      el.style.fontSize = isMobile ? '12px' : '14px';

      const titleEl = el.querySelector('.tTitle');
      if (titleEl) titleEl.style.fontSize = isMobile ? '14px' : '16px';

      const closeEl = el.querySelector('.tClose');
      if (closeEl) {
        closeEl.style.padding = isMobile ? '3px 6px' : '4px 8px';
        closeEl.style.fontSize = isMobile ? '12px' : '14px';
        closeEl.style.borderRadius = isMobile ? '5px' : '6px';
      }

      const loveBtnEl = el.querySelector('.love-button-tooltip');
      if (loveBtnEl) {
        loveBtnEl.style.padding = isMobile ? '3px 6px' : '4px 8px';
        loveBtnEl.style.fontSize = isMobile ? '12px' : '14px';
        loveBtnEl.style.borderRadius = isMobile ? '5px' : '6px';
      }

      const noteEls = el.querySelectorAll('.note');
      noteEls.forEach(n => n.style.fontSize = isMobile ? '11px' : '13px');

      requestAnimationFrame(() => {
        const r = el.getBoundingClientRect();
        const pad = isMobile ? 8 : 12;
        const visibleLeft = scrollX + offsetLeft;
        const visibleTop = scrollY + offsetTop;
        const visibleRight = visibleLeft + viewportWidth;
        const visibleBottom = visibleTop + viewportHeight;

        const useAnchor = !!anchorRect;

        const anchorLeft = anchorRect ? anchorRect.left + scrollX + offsetLeft : null;
        const anchorRight = anchorRect ? anchorRect.right + scrollX + offsetLeft : null;
        const anchorTop = anchorRect ? anchorRect.top + scrollY + offsetTop : null;
        const anchorBottom = anchorRect ? anchorRect.bottom + scrollY + offsetTop : null;
        const anchorCenterX = anchorRect ? (anchorLeft + anchorRight) / 2 : null;

        let left;
        let top;

        if (useAnchor) {
          const offset = isMobile ? 12 : 16;
          left = (anchorCenterX || (visibleLeft + pad)) - (r.width / 2);
          top = (anchorTop !== null ? anchorTop : (visibleTop + pad)) - r.height - offset;

          if (top < visibleTop + pad) {
            top = (anchorBottom !== null ? anchorBottom : (visibleTop + pad)) + offset;
          }
          if (top + r.height + pad > visibleBottom) {
            const anchorMiddle = anchorRect ? anchorTop + (anchorRect.height / 2) : (visibleTop + viewportHeight / 2);
            top = anchorMiddle - (r.height / 2);
            if (top + r.height + pad > visibleBottom) {
              top = visibleBottom - r.height - pad;
            }
          }
        } else {
          const pointerX = (typeof x === 'number' ? x + scrollX + offsetLeft : (visibleLeft + viewportWidth / 2));
          const pointerY = (typeof y === 'number' ? y + scrollY + offsetTop : (visibleTop + viewportHeight / 2));
          left = pointerX + (isMobile ? 8 : 12);
          top = pointerY + (isMobile ? 8 : 12);
        }

        if (left + r.width + pad > visibleRight) {
          left = Math.max(visibleLeft + pad, visibleRight - r.width - pad);
        }
        if (top + r.height + pad > visibleBottom) {
          top = Math.max(visibleTop + pad, visibleBottom - r.height - pad);
        }

        left = Math.max(visibleLeft + pad, left);
        top = Math.max(visibleTop + pad, top);

        el.style.left = left + 'px';
        el.style.top = top + 'px';
      });

      if (el.querySelector('.tClose')) {
        el.querySelector('.tClose').onclick = () => {
          // Use hideTip with force=true to properly clean up all state including selected class
          hideTip(true);
        };
      }
    }

    function hideTip(force = false) {
      // Don't hide if tip is pinned open (user clicked on it), unless forced
      if (tipPinned && !force) {
        return;
      }
      // Don't hide if mouse is currently over the tip itself, unless forced
      if (pageTip && pageTip.matches(':hover') && !force) {
        return;
      }
      pageTip.style.display = 'none';
      // Reset interaction state when tip is hidden
      tipInteracted = false;
      tipPinned = false;
      pinnedOverlayItem = null;
      // Removed pulse class removal
      // Remove selected from all overlays when tip is hidden
      document.querySelectorAll('.overlay').forEach(ov => ov.classList.remove('selected'));
    }

    /* list */
    function renderCardsPage() {
      renderTopbar();
      const r = document.getElementById('root');
      r.innerHTML = `<h1 style="text-align:center">Restaurants</h1><div class="cards" id="grid"></div>`;
      const grid = document.getElementById('grid');

      // Check if user is admin or manager
      const isAdmin = state.user?.email === 'matt.29.ds@gmail.com';
      const isManager = state.user?.role === 'manager';

      // Filter out restaurants that haven't confirmed in 30+ days (unless admin or manager)
      let filteredRestaurants = state.restaurants || [];

      if (!isAdmin && !isManager) {
        // Only filter for regular customers
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        filteredRestaurants = filteredRestaurants.filter(rs => {
          if (!rs.lastConfirmed) return false; // Hide restaurants that have never confirmed
          const lastConfirmed = new Date(rs.lastConfirmed);
          return lastConfirmed >= thirtyDaysAgo;
        });
      }

      filteredRestaurants.forEach(rs => {
        const c = div(`<div class="card">
        <img src="${esc(rs.menuImage || '')}" alt="">
        <div class="pad">
          <div style="font-weight:800;margin-bottom:6px">${esc(rs.name || 'Restaurant')}</div>
          ${(() => {
            if (!rs.lastConfirmed) return '<div class="note">Last confirmed by staff: </div>';
            const isAdmin = state.user?.email === 'matt.29.ds@gmail.com';
            const isManager = state.user?.role === 'manager';
            const showAll = isAdmin || isManager;
            const info = getWeeksAgoInfo(rs.lastConfirmed, showAll);
            if (!info) return ''; // Don't show if suspended (30+ days) and not admin/manager
            return `<div class="note" style="color: ${info.color}">Last confirmed by staff: ${esc(info.text)}</div>`;
          })()}
          <div style="margin-top:10px"><button class="btn btnPrimary">View menu & allergens</button></div>
        </div></div>`);
        c.querySelector('.btn').onclick = () => send({ type: 'openRestaurant', slug: rs.slug });
        grid.appendChild(c);
      });
    }

    /* chips */
    function renderSavedChips(el) {
      el.innerHTML = '';
      const saved = (state.allergies || []).map(norm);
      if (!saved.length) {
        el.appendChild(div('<div class="note">No saved allergens. Use "Edit saved allergens".</div>'));
        updateFullScreenAllergySummary();
        return;
      }
      const row = div('', 'chips');
      saved.forEach(a => {
        const emoji = ALLERGEN_EMOJI[a] || '';
        row.appendChild(div(`${emoji} ${esc(cap(a))}`, 'chip active'));
      });
      el.appendChild(row);
      updateFullScreenAllergySummary();
    }

    function renderSavedDiets(el) {
      el.innerHTML = '';
      const saved = (state.diets || []);
      if (!saved.length) {
        el.appendChild(div('<div class="note">No saved dietary preferences. Use "Edit saved dietary preferences".</div>'));
        return;
      }
      const row = div('', 'chips');
      saved.forEach(d => {
        const emoji = d === 'Vegan' ? '' : d === 'Vegetarian' ? '' : d === 'Pescatarian' ? '' : d === 'Gluten-free' ? '' : '';
        row.appendChild(div(`${emoji} ${esc(d)}`, 'chip active'));
      });
      el.appendChild(row);
    }

    /* selector for QR guests */
    function renderSelector(el) {
      el.innerHTML = '';
      const row = div('', 'chips');
      row.setAttribute('role', 'list');
      const sel = new Set((state.allergies || []).map(norm));
      ALLERGENS.forEach(a => {
        const isActive = sel.has(a);
        const emoji = ALLERGEN_EMOJI[a] || '';
        const c = div(`${emoji} ${esc(cap(a))}`, 'chip clickable' + (isActive ? ' active' : ''));
        c.setAttribute('role', 'button');
        c.setAttribute('tabindex', '0');
        c.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        c.dataset.value = a;
        const toggle = () => {
          if (sel.has(a)) {
            sel.delete(a);
          } else {
            sel.add(a);
          }
          state.allergies = [...sel];
          updateFullScreenAllergySummary();
          try { sessionStorage.setItem('qrAllergies', JSON.stringify(state.allergies)); } catch (_) { }
          renderSelector(el);
          if (window.__rerenderLayer__) window.__rerenderLayer__();
          send({ type: 'qrAllergies', allergies: state.allergies });
          if (prefersMobileInfo()) renderMobileInfo(currentMobileInfoItem);
        };
        c.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          toggle();
        }, { passive: false });
        c.addEventListener('touchend', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          toggle();
        }, { passive: false });
        c.addEventListener('keydown', (evt) => {
          if (evt.key === 'Enter' || evt.key === ' ') {
            evt.preventDefault();
            toggle();
          }
        });
        row.appendChild(c);
      });
      el.appendChild(row);
      updateFullScreenAllergySummary();
    }

    function renderDietSelector(el) {
      el.innerHTML = '';
      const row = div('', 'chips');
      row.setAttribute('role', 'list');
      const sel = new Set(state.diets || []);
      DIETS.forEach(diet => {
        const isActive = sel.has(diet);
        const emoji = diet === 'Vegan' ? '' : diet === 'Vegetarian' ? '' : diet === 'Pescatarian' ? '' : diet === 'Gluten-free' ? '' : '';
        const c = div(`${emoji} ${esc(diet)}`, 'chip clickable' + (isActive ? ' active' : ''));
        c.setAttribute('role', 'button');
        c.setAttribute('tabindex', '0');
        c.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        c.dataset.value = diet;
        const toggle = () => {
          if (sel.has(diet)) {
            sel.delete(diet);
          } else {
            sel.add(diet);
          }
          state.diets = [...sel];
          try { sessionStorage.setItem('qrDiets', JSON.stringify(state.diets)); } catch (_) { }
          renderDietSelector(el);
          if (window.__rerenderLayer__) window.__rerenderLayer__();
          if (prefersMobileInfo()) renderMobileInfo(currentMobileInfoItem);
        };
        c.addEventListener('click', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          toggle();
        }, { passive: false });
        c.addEventListener('touchend', (evt) => {
          evt.preventDefault();
          evt.stopPropagation();
          toggle();
        }, { passive: false });
        c.addEventListener('keydown', (evt) => {
          if (evt.key === 'Enter' || evt.key === ' ') {
            evt.preventDefault();
            toggle();
          }
        });
        row.appendChild(c);
      });
      el.appendChild(row);
    }

    /* draw (simple image that follows page zoom) */
    function drawMenu(container, imageURL, menuImagesArray = null, currentPage = 0) {
      container.innerHTML = '';
      const inner = div('', 'menuInner'); container.appendChild(inner);

      // Support multiple menu images
      const images = menuImagesArray || (imageURL ? [imageURL] : []);
      const displayImage = images[currentPage] || imageURL || '';

      if (!displayImage) { inner.innerHTML = `<div class="note" style="padding:16px">No menu image configured for this restaurant.</div>`; return; }

      const img = new Image(); img.src = displayImage; img.className = 'menuImg'; img.draggable = false; inner.appendChild(img);
      const layer = div('', 'overlayLayer'); inner.appendChild(layer);

      // Prevent any scroll/drag on the menu container
      container.scrollLeft = 0;
      container.scrollTop = 0;
      container.addEventListener('scroll', (e) => {
        container.scrollLeft = 0;
        container.scrollTop = 0;
      }, { passive: true });
      img.addEventListener('dragstart', (e) => e.preventDefault());

      // Add page navigation if multiple pages
      if (images.length > 1) {
        const pageNav = div('', '');
        pageNav.style.cssText = 'display:flex;justify-content:center;align-items:center;gap:12px;margin:16px 0;padding:12px;background:rgba(76,90,212,0.1);border-radius:8px';
        pageNav.innerHTML = `
      <button class="btn" id="menuPrevPageBtn" style="padding:8px 16px" ${currentPage === 0 ? 'disabled' : ''}> Previous</button>
      <span style="color:#e9ecff;font-weight:600">Page ${currentPage + 1} of ${images.length}</span>
      <button class="btn" id="menuNextPageBtn" style="padding:8px 16px" ${currentPage >= images.length - 1 ? 'disabled' : ''}>Next </button>
    `;
        container.appendChild(pageNav);

        // Page navigation handlers
        const prevBtn = pageNav.querySelector('#menuPrevPageBtn');
        const nextBtn = pageNav.querySelector('#menuNextPageBtn');
        let menuCurrentPage = currentPage;

        const updateMenuPage = (newPage) => {
          if (newPage < 0 || newPage >= images.length) return;
          menuCurrentPage = newPage;
          menuState.currentPage = newPage; // Update tracked page
          img.src = images[newPage];
          if (prevBtn) prevBtn.disabled = newPage === 0;
          if (nextBtn) nextBtn.disabled = newPage >= images.length - 1;
          const pageSpan = pageNav.querySelector('span');
          if (pageSpan) pageSpan.textContent = `Page ${newPage + 1} of ${images.length}`;
          // Re-render overlays for new page using renderLayer
          renderLayer();
        };

        if (prevBtn) prevBtn.onclick = () => updateMenuPage(menuCurrentPage - 1);
        if (nextBtn) nextBtn.onclick = () => updateMenuPage(menuCurrentPage + 1);
      }

      const menuState = getMenuState();
      menuState.img = img;
      menuState.layer = layer;
      menuState.inner = inner;
      menuState.currentPage = currentPage; // Track current page for overlay filtering

      ensureMobileViewerChrome();
      updateZoomIndicator();

      // Track dish interaction for analytics
      const trackedDishes = new Set(); // Prevent duplicate tracking in same session
      const OWNER_EMAIL = 'matt.29.ds@gmail.com';
      async function trackDishInteraction(item) {
        if (!item || !state.user?.loggedIn) return;

        // Don't track interactions from managers or owner - they're editing, not browsing
        const isOwner = state.user?.email === OWNER_EMAIL;
        const isManager = state.user?.role === 'manager';
        if (isOwner || isManager) return;

        const dishName = item.id || item.name || item.label;
        if (!dishName) return;

        // Only track once per dish per session
        const trackKey = `${state.restaurant?.id}-${dishName}`;
        if (trackedDishes.has(trackKey)) return;
        trackedDishes.add(trackKey);

        try {
          const restaurantId = state.restaurant?.id || state.restaurant?._id;
          if (!restaurantId) return;

          // Get user's allergens and diets
          const userAllergens = state.allergies || [];
          const userDiets = state.diets || [];

          // Calculate dish status based on user's restrictions
          let dishStatus = 'neutral';
          const dishAllergens = (item.allergens || []).map(a => a.toLowerCase());
          const dishDiets = item.diets || []; // Diets the dish IS compatible with
          const removable = (item.removable || []).map(r => (r.allergen || '').toLowerCase());

          const hasAllergenConflict = userAllergens.some(a => dishAllergens.includes(a.toLowerCase()));
          const hasDietConflict = userDiets.some(d => !dishDiets.includes(d));

          if (hasAllergenConflict || hasDietConflict) {
            // Check if all conflicts are removable
            const nonRemovableAllergens = userAllergens.filter(a =>
              dishAllergens.includes(a.toLowerCase()) && !removable.includes(a.toLowerCase())
            );
            if (nonRemovableAllergens.length > 0 || hasDietConflict) {
              dishStatus = 'unsafe';
            } else {
              dishStatus = 'removable';
            }
          } else if (userAllergens.length > 0 || userDiets.length > 0) {
            dishStatus = 'safe';
          }

          const { error } = await window.supabaseClient
            .from('dish_interactions')
            .insert([{
              restaurant_id: restaurantId,
              dish_name: dishName,
              user_id: state.user.id,
              user_allergens: userAllergens,
              user_diets: userDiets,
              dish_status: dishStatus
            }]);

          if (error) {
            console.warn('Failed to track dish interaction:', error);
          }
        } catch (err) {
          console.warn('Error tracking dish interaction:', err);
        }
      }

      const showOverlayDetails = (evt, item, target) => {
        ensureMobileInfoPanel();
        let pointerType = 'mouse';
        if (evt) {
          if (typeof evt.pointerType === 'string') {
            pointerType = evt.pointerType;
          } else if (evt.type && evt.type.toLowerCase().includes('touch')) {
            pointerType = 'touch';
          } else if (evt.type && evt.type.toLowerCase().includes('pointer')) {
            pointerType = 'pen';
          }
        }

        // RELAXED CHECK: If we are on mobile (prefersMobileInfo), ALWAYS use mobile panel/zoom
        // This fixes issues where some mobile browsers report 'mouse' for tap events
        const useMobilePanel = prefersMobileInfo() || (pointerType !== 'mouse');
        if (useMobilePanel) {
          if (evt) {
            if (typeof evt.preventDefault === 'function') evt.preventDefault();
            if (typeof evt.stopPropagation === 'function') evt.stopPropagation();
          }

          // If already zoomed to this item, zoom out
          if (isOverlayZoomed && zoomedOverlayItem === item) {
            zoomOutOverlay();
            return;
          }

          hideTip();

          // Get the overlay box element
          const overlayBox = target?.classList?.contains('overlay') ? target : (target?.closest ? target.closest('.overlay') : null);

          // Check if already zoomed (transitioning between dishes)
          const isTransition = isOverlayZoomed;

          // Use zoom instead of mobile panel - pass isTransition for smooth animation
          // Note: Don't add selected class here - let zoomToOverlay handle it AFTER
          // the zoomed class is added, so the correct CSS animation rule applies
          if (overlayBox) {
            zoomToOverlay(item, overlayBox, isTransition);
          }

          // Track dish interaction for analytics (mobile)
          trackDishInteraction(item);
          return;
        }
        if (mobileInfoPanel && mobileInfoPanel.classList.contains('show')) {
          mobileInfoPanel.classList.remove('show');
          mobileInfoPanel.style.display = 'none';
          mobileInfoPanel.innerHTML = '';
          currentMobileInfoItem = null;
        }
        const client = evt?.changedTouches ? evt.changedTouches[0] : evt;
        const rect = target?.getBoundingClientRect
          ? target.getBoundingClientRect()
          : (evt?.currentTarget?.getBoundingClientRect ? evt.currentTarget.getBoundingClientRect() : null);
        const clientX = client?.clientX ?? 0;
        const clientY = client?.clientY ?? 0;

        // Pass whether this is a click to showTipIn
        const isClick = evt && (evt.type === 'click' || evt.type === 'touchend');

        // If tip is pinned to a different overlay, don't show new tip unless clicking
        if (tipPinned && pinnedOverlayItem && !isClick) {
          const currentItemId = item.id || item.name || '';
          const pinnedItemId = pinnedOverlayItem.id || pinnedOverlayItem.name || '';
          if (currentItemId !== pinnedItemId) {
            // Different overlay, but not clicking - ignore hover completely
            return;
          }
        }

        showTipIn(pageTip, clientX, clientY, item.id || 'Item', tooltipBodyHTML(item, state.allergies || [], state.diets || [], isClick), rect, isClick, item);

        // Track dish interaction for analytics (only on click, not hover)
        if (isClick) {
          trackDishInteraction(item);
        }

        // Find the overlay box element (target might be badge or warning)
        const overlayBox = target?.classList?.contains('overlay') ? target : (target?.closest ? target.closest('.overlay') : null);
        if (overlayBox) {
          // Remove selected from all overlays only if this is a click (not just hover)
          if (isClick) {
            document.querySelectorAll('.overlay').forEach(ov => ov.classList.remove('selected'));
            // Add selected to clicked overlay
            overlayBox.classList.add('selected');
            setOverlayPulseColor(overlayBox);
            // Force reflow to ensure animation starts
            void overlayBox.offsetWidth;
          } else {
            // On hover, only add selected if not pinned to any overlay
            // When pinned, don't change selection at all - keep the pinned overlay selected
            if (!tipPinned) {
              document.querySelectorAll('.overlay').forEach(ov => ov.classList.remove('selected'));
              overlayBox.classList.add('selected');
              setOverlayPulseColor(overlayBox);
            }
          }
        }
      };

      // Make showOverlayDetails globally accessible for auto-opening overlays from dish search
      window.showOverlayDetails = showOverlayDetails;

      // Helper function to set pulse color based on overlay's status class
      function setOverlayPulseColor(overlayElement) {
        if (!overlayElement) return;

        // Define colors matching CSS variables
        // These match the values in renderLayer and CSS
        const colors = {
          safe: '22, 163, 74',      // var(--ok) equivalent (green-600)
          removable: '202, 138, 4', // var(--warn) equivalent (yellow-600)
          unsafe: '220, 38, 38',    // var(--bad) equivalent (red-600)
          neutral: '255, 255, 255'
        };

        let rgb = colors.neutral;

        if (overlayElement.classList.contains('safe')) {
          rgb = colors.safe;
        } else if (overlayElement.classList.contains('removable')) {
          rgb = colors.removable;
        } else if (overlayElement.classList.contains('unsafe')) {
          rgb = colors.unsafe;
        }

        // Set outline color to match the border color (using rgb values directly)
        overlayElement.style.outlineColor = `rgb(${rgb})`;
        overlayElement.style.borderStyle = 'solid';
        overlayElement.style.zIndex = '1010';
      }

      function renderLayer() {
        [...layer.querySelectorAll('.overlay')].forEach(n => n.remove());
        const colors = { safe: 'var(--ok)', removable: 'var(--warn)', unsafe: 'var(--bad)', neutral: '#ffffff1a' };

        if (!img.complete || !img.naturalWidth || !img.clientWidth || !img.clientHeight) {
          console.log('Image not ready yet');
          return;
        }

        layer.style.width = img.clientWidth + 'px';
        layer.style.height = img.clientHeight + 'px';

        // Filter overlays by current pageIndex
        const pageForFilter = menuState.currentPage !== undefined ? menuState.currentPage : 0;
        const pageOverlays = (Array.isArray(state.restaurant?.overlays) ? state.restaurant.overlays : [])
          .filter(o => (o.pageIndex || 0) === pageForFilter);

        pageOverlays.forEach(it => {

          const box = document.createElement('div');
          const st = computeStatus(it, state.allergies || [], state.diets || []);
          // Add status as class for easier styling and selection
          box.className = `overlay ${st}`;
          box.style.borderColor = colors[st] || colors.neutral;
          box.style.left = (+it.x || 0) + '%';
          box.style.top = (+it.y || 0) + '%';
          box.style.width = (+it.w || 0) + '%';
          box.style.height = (+it.h || 0) + '%';

          // Determine status icons
          const isDanger = st === 'unsafe';
          const isCaution = st === 'removable';

          // Add warning icon only for cross-contamination risk (caution), not for danger
          if (isCaution) {
            const warning = document.createElement('div');
            warning.className = 'ovWarning';
            warning.title = 'Cross-contamination risk';
            warning.textContent = '';
            box.appendChild(warning);
          }

          const badge = document.createElement('div');
          badge.className = 'ovBadge';
          badge.title = 'Details';
          badge.textContent = 'i';
          // Click handler bubbles to box
          box.appendChild(badge);

          box.addEventListener('mousemove', (e) => {
            if (prefersMobileInfo()) return;
            // If any overlay is pinned (including this one), don't reposition/re-render the tooltip
            // The pinned tooltip should stay in place until explicitly closed or another overlay is clicked
            if (tipPinned) {
              return;
            }
            const rect = (e.currentTarget && e.currentTarget.getBoundingClientRect)
              ? e.currentTarget.getBoundingClientRect()
              : box.getBoundingClientRect();
            // mousemove is hover, not click
            showTipIn(pageTip, e.clientX, e.clientY, it.id || 'Item', tooltipBodyHTML(it, state.allergies || [], state.diets || [], false), rect, false, it);
          });
          box.addEventListener('mouseleave', () => {
            // hideTip already checks if tipPinned is true before hiding
            hideTip();
          });

          // Consolidated Click/Touch Handler
          box.addEventListener('click', (e) => {
            showOverlayDetails(e, it, box);
          });

          layer.appendChild(box);
        });
      }

      window.__rerenderLayer__ = renderLayer;
      captureMenuBaseDimensions(true);

      if (img.complete && img.naturalWidth) {
        renderLayer();
        captureMenuBaseDimensions(true);
      } else {
        img.onload = () => {
          setTimeout(renderLayer, 50);
          captureMenuBaseDimensions(true);
          if (document.body.classList.contains('mobileViewerActive')) {
            setMobileZoom(mobileZoomLevel, true);
          }
        };
      }

      addEventListener('resize', () => {
        // Skip re-render when zoomed - the transform handles positioning
        // and re-rendering would remove the selected class
        if (isOverlayZoomed) return;
        requestAnimationFrame(renderLayer);
      }, { passive: true });

      if (window.visualViewport) {
        visualViewport.addEventListener('resize', () => {
          if (pageTip.style.display === 'block') {
            const currentLeft = parseFloat(pageTip.style.left || 0);
            const currentTop = parseFloat(pageTip.style.top || 0);

            const zoom = visualViewport.scale || 1;
            const k = 1 / zoom;

            const isMobile = window.innerWidth <= 640;
            const vw = visualViewport.width;
            const vh = visualViewport.height;

            pageTip.style.transform = `scale(${k})`;
            pageTip.style.transformOrigin = 'top left';

            const vw2 = visualViewport.width;
            const vh2 = visualViewport.height;
            const baseMaxWidth = isMobile ? Math.min(220, vw2 - 30) : Math.min(280, vw2 - 40);
            pageTip.style.maxWidth = baseMaxWidth + 'px';

            requestAnimationFrame(() => {
              const pad = isMobile ? 8 : 12;
              const r = pageTip.getBoundingClientRect();

              let left = Math.min(currentLeft, vw2 - r.width - pad);
              let top = Math.min(currentTop, vh2 - r.height - pad);
              left = Math.max(pad, left);
              top = Math.max(pad, top);

              pageTip.style.left = left + 'px';
              pageTip.style.top = top + 'px';
            });
          }
        }, { passive: true });
      }
    }

    /* restaurant page */
    function renderRestaurant() {
      renderTopbar();
      const root = document.getElementById('root');
      const rs = state.restaurant || {};

      // Auto-acknowledge if coming from dish search (has dishName parameter) or if ack parameter is set
      const urlParams = new URLSearchParams(window.location.search);
      const dishName = urlParams.get('dishName');
      const ackParam = urlParams.get('ack');
      const hasSubmittedNotice = tabletSimOrderId && tabletSimState.orders.some(o => o.id === tabletSimOrderId && o.status !== TABLET_ORDER_STATUSES.CODE_ASSIGNED);
      state.ack = !!dishName || ackParam === '1' || hasSubmittedNotice; // Auto-acknowledge if coming from dish search, if ack parameter is set, or if user has submitted a notice

      root.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;flex-wrap:wrap;gap:10px">
      <h1 style="margin:0">${esc(rs.name || 'Restaurant')}</h1>
          </div>
    <div class="pill">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;flex-wrap:wrap;gap:8px">
        <div style="font-weight:600">${(state.qr || !state.user?.loggedIn) ? 'Select Your Allergens' : 'Your saved allergens'}</div>
        ${(!state.qr && state.user?.loggedIn) ? `<button class="btnLink clickable" id="editSavedBtn">Edit saved allergens</button>` : ''}
      </div>
      <div id="savedChips"></div>
    </div>
    <div class="pill">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;flex-wrap:wrap;gap:8px">
        <div style="font-weight:600">${(state.qr || !state.user?.loggedIn) ? 'Dietary Preferences' : 'Your saved diets'}</div>
        ${(!state.qr && state.user?.loggedIn) ? `<button class="btnLink clickable" id="editSavedDietsBtn">Edit saved diets</button>` : ''}
      </div>
      <div id="dietChips"></div>
    </div>
    <div class="banner">
      <span>Reference only. Ingredients & practices can change. Always inform staff about your allergens.</span>
      <button class="ackBtn ${state.ack ? 'on' : 'off'}" id="ackBtn">${state.ack ? 'Acknowledged' : 'I understand'}</button>
    </div>
    <div id="confirmedRow" style="display:none" class="note">
      <div style="margin-bottom:30px;padding:12px;background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:8px;" id="modeSwitchContainer">
        <div style="display:flex;align-items:center;gap:8px;color:#a8b2d6;font-size:0.95rem;margin-bottom:12px;">
          <span style="font-size:1.2rem;"></span>
          <span>Tap on any dish to view details and send your allergy notice to the kitchen</span>
        </div>
        <div id="legendRow" style="display:none;margin:0;" class="legend">
          <span><span class="key ok"></span> Meets all requirements</span>
          <span><span class="key warn"></span> Can be accommodated</span>
          <span><span class="key bad"></span> Cannot be accommodated</span>
          <span><span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;background:#facc15;border:2px solid #facc15;border-radius:50%;font-size:9px;color:#000;font-weight:bold;margin-right:4px;vertical-align:middle;line-height:1;"></span>Cross-contamination risk</span>
        </div>
      </div>
      <div>Last confirmed by staff: ${rs.lastConfirmed ? esc(fmtDate(rs.lastConfirmed)) : ''}</div>
    </div>
    <div class="menuWrap" id="menu"></div>
    <div id="restaurantActions" style="display:none;margin-top:20px;gap:12px;flex-wrap:nowrap;justify-content:center;align-items:center;flex-direction:row">
      <button class="btn btnPrimary" id="restaurantWebsiteBtn" style="flex:1;min-width:120px;max-width:200px">
        <span style="display:inline-flex;align-items:center;gap:6px"> Visit Website</span>
      </button>
      <button class="btn btnPrimary" id="restaurantCallBtn" style="flex:1;min-width:120px;max-width:200px">
        <span style="display:inline-flex;align-items:center;gap:6px"> Call Restaurant</span>
      </button>
      <button class="btn btnPrimary" id="restaurantFeedbackBtn" style="flex:1;min-width:120px;max-width:200px">
        <span style="display:inline-flex;align-items:center;gap:6px"> Give Feedback</span>
      </button>
    </div>
  `;

      const chipsHost = document.getElementById('savedChips');
      const allowInteractiveFilters = state.isHowItWorks || state.qr || !state.user?.loggedIn;
      if (allowInteractiveFilters) renderSelector(chipsHost); else renderSavedChips(chipsHost);

      const dietChipsHost = document.getElementById('dietChips');
      if (allowInteractiveFilters) renderDietSelector(dietChipsHost); else renderSavedDiets(dietChipsHost);

      const menu = document.getElementById('menu');
      ensureMobileInfoPanel();
      mobileInfoPanel.classList.remove('show');
      mobileInfoPanel.style.display = 'none';
      mobileInfoPanel.innerHTML = '';

      // If already acknowledged (from dish search), show menu immediately
      const menuShouldShow = state.ack || state.isHowItWorks;
      if (menuShouldShow) {
        if (state.ack) {
          send({ type: 'ack' });
        }
        menu.classList.add('show');
        document.getElementById('legendRow').style.display = 'flex';
        document.getElementById('confirmedRow').style.display = 'block';
        document.getElementById('restaurantActions').style.display = 'flex';
        drawMenu(menu, rs.menuImage, rs.menuImages, 0);
        const hasMenuImage = !!rs.menuImage;
        if (hasMenuImage) {
          ensureMobileViewerChrome();
          updateZoomIndicator();
          const notice = document.getElementById('mobileMenuNotice');
          if (notice) {
            if (prefersMobileInfo()) {
              notice.style.display = 'flex';
              notice.setAttribute('aria-hidden', 'false');
              notice.dataset.enabled = '1';
              const openBtn = notice.querySelector('.mobileMenuOpenBtn');
              if (openBtn) {
                if (!openBtn.__openHandler) {
                  const handler = (e) => {
                    if (e && typeof e.preventDefault === 'function') e.preventDefault();
                    if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
                    openMobileViewer();
                  };
                  openBtn.__openHandler = handler;
                  openBtn.addEventListener('click', handler);
                }
              }
              // Auto-open mobile viewer if coming from dish search with dishName
              // Delay to allow overlay selection to complete first
              if (dishName) {
                setTimeout(() => {
                  openMobileViewer();
                }, 700);
              }
            } else {
              notice.style.display = 'none';
              notice.setAttribute('aria-hidden', 'true');
              delete notice.dataset.enabled;
            }
          }
        }
      }

      document.getElementById('ackBtn').onclick = () => {
        if (!state.ack) { send({ type: 'ack' }); state.ack = true; }
        const b = document.getElementById('ackBtn'); b.textContent = 'Acknowledged'; b.classList.remove('off'); b.classList.add('on');
        menu.classList.add('show');
        document.getElementById('legendRow').style.display = 'flex';
        document.getElementById('confirmedRow').style.display = 'block';
        document.getElementById('restaurantActions').style.display = 'flex';
        drawMenu(menu, rs.menuImage, rs.menuImages, 0);
        const hasMenuImage = !!rs.menuImage;
        if (hasMenuImage) {
          ensureMobileViewerChrome();
          updateZoomIndicator();
          const notice = document.getElementById('mobileMenuNotice');
          if (notice) {
            if (prefersMobileInfo()) {
              notice.style.display = 'flex';
              notice.setAttribute('aria-hidden', 'false');
              notice.dataset.enabled = '1';
              const openBtn = notice.querySelector('.mobileMenuOpenBtn');
              if (openBtn) {
                if (!openBtn.__openHandler) {
                  const handler = (e) => {
                    if (e && typeof e.preventDefault === 'function') e.preventDefault();
                    if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
                    openMobileViewer();
                  };
                  openBtn.__openHandler = handler;
                  openBtn.addEventListener('click', handler);
                }
              }
            } else {
              notice.style.display = 'none';
              notice.setAttribute('aria-hidden', 'true');
              delete notice.dataset.enabled;
            }
          }
        } else {
          const notice = document.getElementById('mobileMenuNotice');
          if (notice) {
            notice.style.display = 'none';
            notice.setAttribute('aria-hidden', 'true');
            delete notice.dataset.enabled;
            const openBtn = notice.querySelector('.mobileMenuOpenBtn');
            if (openBtn && openBtn.__openHandler) {
              openBtn.removeEventListener('click', openBtn.__openHandler);
              delete openBtn.__openHandler;
            }
          }
        }
        if (mobileInfoPanel) {
          mobileInfoPanel.classList.remove('show');
          mobileInfoPanel.style.display = 'none';
          mobileInfoPanel.innerHTML = '';
          currentMobileInfoItem = null;
        }
        if ((state.qr || urlQR) && !state.user?.loggedIn && shouldShowQrPromo()) {
          queueQrPromoTimer();
        } else {
          cancelQrPromoTimer();
        }
      };

      if ((state.qr || urlQR) && !state.user?.loggedIn) {
        if (!shouldShowQrPromo() && shouldShowQrBanner()) {
          showQrBanner();
        } else if (!shouldShowQrBanner()) {
          hideQrBanner();
        }
      } else {
        hideQrBanner();
      }

      if (!state.qr && state.user?.loggedIn) {
        const editBtn = document.getElementById('editSavedBtn');
        if (editBtn) editBtn.onclick = () => send({ type: 'navigate', to: '/accounts', slug: rs.slug });

        const editDietsBtn = document.getElementById('editSavedDietsBtn');
        if (editDietsBtn) editDietsBtn.onclick = () => send({ type: 'navigate', to: '/accounts', slug: rs.slug });
      }

      // Wire up restaurant action buttons
      const websiteBtn = document.getElementById('restaurantWebsiteBtn');
      if (websiteBtn) websiteBtn.onclick = () => { if (rs.website) window.open(rs.website, '_blank'); };

      const callBtn = document.getElementById('restaurantCallBtn');
      if (callBtn) callBtn.onclick = () => { if (rs.phone) window.location.href = `tel:${rs.phone}`; };

      const feedbackBtn = document.getElementById('restaurantFeedbackBtn');
      if (feedbackBtn) feedbackBtn.onclick = () => openFeedbackModal();

      // Queue QR promo timer for non-logged-in QR users on page load
      if ((state.qr || urlQR) && !state.user?.loggedIn && shouldShowQrPromo()) {
        queueQrPromoTimer();
      }
    }

    // Feedback modal for anonymous customer feedback
    function openFeedbackModal() {
      const mb = document.getElementById('modalBack');
      if (!mb) return;
      const body = document.getElementById('modalBody');
      document.getElementById('modalTitle').textContent = 'Share Your Experience';

      body.innerHTML = `
    <div style="max-width:520px;margin:0 auto">
      <p style="color:#a8b2d6;margin:0 0 20px;line-height:1.6;text-align:center">
        Help us ensure restaurant safety by sharing your experience with how this restaurant handles allergies. Your feedback is completely anonymous and will not be shared with the restaurant.
      </p>
      <form id="feedbackForm" style="display:flex;flex-direction:column;gap:16px">
        <textarea 
          id="feedbackText" 
          placeholder="For example: 'The staff was very knowledgeable about cross-contamination', 'I had a reaction to something not listed', 'They made great accommodations for my allergies'..."
          style="width:100%;min-height:140px;padding:12px;border-radius:10px;border:1px solid #2a3261;background:#0f163a;color:#e9ecff;font-family:inherit;resize:vertical;font-size:15px"
          required
        ></textarea>
        <div id="feedbackStatus" style="font-size:14px;min-height:20px;text-align:center"></div>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
          <button type="button" class="btn" onclick="document.getElementById('modalBack').style.display='none'" style="padding:10px 20px;cursor:pointer">
            Cancel
          </button>
          <button type="submit" class="btn btnSecondary" style="padding:10px 20px;cursor:pointer">
            Send Feedback
          </button>
        </div>
      </form>
    </div>
  `;

      configureModalClose({
        visible: true, onClick: () => {
          mb.style.display = 'none';
          mb.onclick = null;
          const form = document.getElementById('feedbackForm');
          if (form) form.innerHTML = '';
        }
      });

      mb.style.display = 'flex';

      // Handle form submission
      const form = document.getElementById('feedbackForm');
      const statusDiv = document.getElementById('feedbackStatus');
      const feedbackText = document.getElementById('feedbackText');

      if (form) {
        form.onsubmit = async (e) => {
          e.preventDefault();
          const text = (feedbackText?.value || '').trim();
          if (!text) {
            if (statusDiv) statusDiv.textContent = 'Please enter your feedback.';
            if (feedbackText) feedbackText.focus();
            return;
          }

          if (statusDiv) statusDiv.textContent = 'Sending...';
          if (form.querySelector('button[type="submit"]')) {
            form.querySelector('button[type="submit"]').disabled = true;
          }

          try {
            const client = window.supabaseClient;
            if (!client) throw new Error('Database connection not ready');

            const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
            if (!restaurantId) throw new Error('Restaurant information not available');

            console.log('Submitting feedback for restaurant ID:', restaurantId);

            const { data, error } = await client
              .from('anonymous_feedback')
              .insert([{
                restaurant_id: restaurantId,
                feedback_text: text
              }]);

            if (error) {
              console.error('Supabase error details:', error);
              throw error;
            }

            console.log('Feedback submitted successfully:', data);

            // Send email notification
            try {
              const restaurantName = state.restaurant?.name || 'Restaurant';
              const restaurantSlug = state.restaurant?.slug || '';

              await fetch('https://fgoiyycctnwnghrvsilt.supabase.co/functions/v1/send-notification-email', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${SUPABASE_KEY}`,
                  'apikey': SUPABASE_KEY
                },
                body: JSON.stringify({
                  type: 'feedback',
                  restaurantName: restaurantName,
                  feedbackText: text,
                  restaurantSlug: restaurantSlug
                })
              });
              console.log('Notification email sent');
            } catch (emailErr) {
              console.error('Failed to send notification email:', emailErr);
              // Don't fail the whole submission if email fails
            }

            if (statusDiv) {
              statusDiv.textContent = ' Thank you for your feedback!';
              statusDiv.style.color = '#22c55e';
            }
            if (feedbackText) feedbackText.value = '';

            setTimeout(() => {
              mb.style.display = 'none';
              mb.onclick = null;
            }, 1500);
          } catch (err) {
            console.error('Feedback submission error:', err);
            if (statusDiv) {
              let errorMsg = 'Sorry, something went wrong. Please try again.';
              if (err.message === 'relation "anonymous_feedback" does not exist') {
                errorMsg = 'Feature not available yet. Database setup in progress.';
              } else if (err.message) {
                errorMsg = `Error: ${err.message}`;
              }
              statusDiv.textContent = errorMsg;
              statusDiv.style.color = '#ef4444';
            }
            if (form.querySelector('button[type="submit"]')) {
              form.querySelector('button[type="submit"]').disabled = false;
            }
          }
        };
      }

      mb.onclick = (e) => {
        if (e.target === mb) {
          mb.style.display = 'none';
          mb.onclick = null;
        }
      };

      // Auto-focus textarea
      if (feedbackText) {
        setTimeout(() => feedbackText.focus(), 100);
      }
    }

    // Restaurant settings modal for managers to edit website, phone, and delivery links
    function openRestaurantSettings() {
      const mb = document.getElementById('modalBack');
      if (!mb) return;
      const body = document.getElementById('modalBody');
      document.getElementById('modalTitle').textContent = 'Restaurant Settings';

      const rs = state.restaurant || {};
      const currentWebsite = rs.website || '';
      const currentPhone = rs.phone || '';
      const currentDeliveryUrl = rs.delivery_url || '';

      body.innerHTML = `
    <div style="max-width:600px;margin:0 auto">
      <p style="color:#a8b2d6;margin:0 0 24px;line-height:1.6">
        Update the links shown on your restaurant page. These links will appear on buttons at the bottom of the page, and the delivery link will also appear when customers select "Delivery / pickup" when confirming their notice.
      </p>
      <form id="settingsForm" style="display:flex;flex-direction:column;gap:20px">
        <label style="display:flex;flex-direction:column;gap:8px">
          <span style="font-weight:600;color:#e9ecff"> Website URL</span>
          <input 
            type="url"
            id="settingsWebsite" 
            placeholder="https://www.example.com"
            value="${esc(currentWebsite)}"
            style="width:100%;padding:12px;border-radius:10px;border:1px solid #2a3261;background:#0f163a;color:#e9ecff;font-family:inherit;font-size:15px"
          />
          <span style="font-size:13px;color:#a8b2d6">Used for the "Visit Website" button</span>
        </label>
        <label style="display:flex;flex-direction:column;gap:8px">
          <span style="font-weight:600;color:#e9ecff"> Phone Number</span>
          <input 
            type="tel"
            id="settingsPhone" 
            placeholder="+1 (555) 123-4567"
            value="${esc(currentPhone)}"
            style="width:100%;padding:12px;border-radius:10px;border:1px solid #2a3261;background:#0f163a;color:#e9ecff;font-family:inherit;font-size:15px"
          />
          <span style="font-size:13px;color:#a8b2d6">Used for the "Call Restaurant" button</span>
        </label>
        <label style="display:flex;flex-direction:column;gap:8px">
          <span style="font-weight:600;color:#e9ecff"> Delivery / Pickup URL</span>
          <input 
            type="url"
            id="settingsDeliveryUrl" 
            placeholder="https://www.delivery-service.com/your-restaurant"
            value="${esc(currentDeliveryUrl)}"
            style="width:100%;padding:12px;border-radius:10px;border:1px solid #2a3261;background:#0f163a;color:#e9ecff;font-family:inherit;font-size:15px"
          />
          <span style="font-size:13px;color:#a8b2d6">Used for the "Order Delivery / Pickup" button and appears when customers select delivery/pickup mode</span>
        </label>
        <div id="settingsStatus" style="font-size:14px;min-height:20px;text-align:center"></div>
        <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
          <button type="button" class="btn" onclick="document.getElementById('modalBack').style.display='none'" style="padding:10px 20px;cursor:pointer">
            Cancel
          </button>
          <button type="submit" class="btn btnPrimary" style="padding:10px 20px;cursor:pointer">
            Save Changes
          </button>
        </div>
      </form>
    </div>
  `;

      configureModalClose({
        visible: true, onClick: () => {
          mb.style.display = 'none';
          mb.onclick = null;
          const form = document.getElementById('settingsForm');
          if (form) form.innerHTML = '';
        }
      });

      mb.style.display = 'flex';

      // Handle form submission
      const form = document.getElementById('settingsForm');
      const statusDiv = document.getElementById('settingsStatus');
      const websiteInput = document.getElementById('settingsWebsite');
      const phoneInput = document.getElementById('settingsPhone');
      const deliveryUrlInput = document.getElementById('settingsDeliveryUrl');

      if (form) {
        form.onsubmit = async (e) => {
          e.preventDefault();

          const website = (websiteInput?.value || '').trim();
          const phone = (phoneInput?.value || '').trim();
          const deliveryUrl = (deliveryUrlInput?.value || '').trim();

          // Validate URLs if provided
          if (website && !website.match(/^https?:\/\/.+/)) {
            if (statusDiv) statusDiv.textContent = 'Please enter a valid website URL (starting with http:// or https://)';
            if (statusDiv) statusDiv.style.color = '#ef4444';
            if (websiteInput) websiteInput.focus();
            return;
          }

          if (deliveryUrl && !deliveryUrl.match(/^https?:\/\/.+/)) {
            if (statusDiv) statusDiv.textContent = 'Please enter a valid delivery URL (starting with http:// or https://)';
            if (statusDiv) statusDiv.style.color = '#ef4444';
            if (deliveryUrlInput) deliveryUrlInput.focus();
            return;
          }

          if (statusDiv) statusDiv.textContent = 'Saving...';
          if (statusDiv) statusDiv.style.color = '#a8b2d6';
          if (form.querySelector('button[type="submit"]')) {
            form.querySelector('button[type="submit"]').disabled = true;
          }

          try {
            const client = window.supabaseClient;
            if (!client) throw new Error('Database connection not ready');

            const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
            if (!restaurantId) throw new Error('Restaurant information not available');

            const { data, error } = await client
              .from('restaurants')
              .update({
                website: website || null,
                phone: phone || null,
                delivery_url: deliveryUrl || null
              })
              .eq('id', restaurantId)
              .select()
              .single();

            if (error) {
              console.error('Supabase error details:', error);
              throw error;
            }

            // Update local state
            if (state.restaurant) {
              state.restaurant.website = website || null;
              state.restaurant.phone = phone || null;
              state.restaurant.delivery_url = deliveryUrl || null;
            }

            // Update delivery button link if visible
            updateOrderConfirmModeVisibility();

            // Mark editor as dirty so "Save to site" button appears
            // Show the save button if we're in editor mode
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn && state.page === 'editor') {
              saveBtn.style.display = 'inline-flex';
            }

            if (statusDiv) {
              statusDiv.textContent = ' Settings saved successfully!';
              statusDiv.style.color = '#22c55e';
            }

            setTimeout(() => {
              mb.style.display = 'none';
              mb.onclick = null;
              // Just close the modal - don't reload to preserve editor mode
              // The updated values are already in state.restaurant, so buttons will work
            }, 1500);
          } catch (err) {
            console.error('Settings save error:', err);
            if (statusDiv) {
              let errorMsg = 'Sorry, something went wrong. Please try again.';
              if (err.message) {
                errorMsg = `Error: ${err.message}`;
              }
              statusDiv.textContent = errorMsg;
              statusDiv.style.color = '#ef4444';
            }
            if (form.querySelector('button[type="submit"]')) {
              form.querySelector('button[type="submit"]').disabled = false;
            }
          }
        };
      }

      mb.onclick = (e) => {
        if (e.target === mb) {
          mb.style.display = 'none';
          mb.onclick = null;
        }
      };

      // Auto-focus first input
      if (websiteInput) {
        setTimeout(() => websiteInput.focus(), 100);
      }
    }

    /* editor */
    async function detectDishesOnMenu(imageData) {
      try {
        const response = await fetch('https://fgoiyycctnwnghrvsilt.supabase.co/functions/v1/detect-menu-dishes', {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZnb2l5eWNjdG53bmdocnZzaWx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MzY1MjYsImV4cCI6MjA3NjAxMjUyNn0.xlSSXr0Gl7j-vsckrj-2anpPmp4BG2SUIdN-_dquSA8',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ imageData })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('API error:', errorText);
          throw new Error('Failed to detect dishes');
        }

        const result = await response.json();
        return result;
      } catch (err) {
        console.error('Detection error:', err);
        return { success: false, error: err.message, dishes: [] };
      }
    }

    function renderEditor() {
      window.editorDirty = false; // Reset on editor entry
      renderTopbar();
      const rs = state.restaurant || {};
      const root = document.getElementById('root');
      root.innerHTML = `
    <h1>Webpage editor</h1>
    <div class="mgrRow" style="justify-content:flex-end">
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <button class="btn" id="undoBtn" title="Undo (Ctrl+Z)" style="opacity:0.5"> Undo</button>
        <button class="btn" id="redoBtn" title="Redo (Ctrl+Y)" style="opacity:0.5"> Redo</button>
        <button class="btn" id="viewLogBtn"> View log of changes</button>
        <button class="btn" id="uploadMenuBtn"> Upload menu image(s)</button>
        <button class="btn" id="settingsBtn"> Restaurant Settings</button>
        <button class="btn btnDanger" id="confirmBtn">Confirm information is up-to-date</button>
        <button class="btn" id="addBox">Add overlay</button>
        <button class="btn btnPrimary" id="saveBtn" style="display:none">Save to site</button>
      </div>
    </div>

    <!-- Unsaved Changes Warning -->
    <div id="editorUnsavedWarning" style="display:none;background:#2a1a0a;border:2px solid #f59e0b;border-radius:8px;padding:20px;margin:16px 0">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
        <span style="font-size:2rem"></span>
        <div>
          <div style="font-size:1.1rem;font-weight:600;color:#f59e0b;margin-bottom:4px">You have unsaved changes</div>
          <div style="font-size:0.95rem;color:#d1d5db">Would you like to save before exiting?</div>
        </div>
      </div>
      <div style="display:flex;gap:12px">
        <button type="button" class="btn btnPrimary" id="editorSaveAndExitBtn" style="flex:1;padding:12px;font-size:1rem"> Save Changes</button>
        <button type="button" class="btn" id="editorExitWithoutSavingBtn" style="flex:1;padding:12px;font-size:1rem;background:#4a1a1a;border-color:#721c24">Exit Without Saving</button>
      </div>
      <button type="button" class="btn" id="editorCancelExitBtn" style="width:100%;margin-top:12px;padding:8px;font-size:0.9rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div class="note" id="editorNote">Drag to move. Drag any corner to resize. Click  to edit details.</div>
      <div style="display:flex;gap:8px;align-items:center">
        <span class="note" style="font-size:12px">Zoom:</span>
        <button class="btn" id="zoomOutBtn" style="padding:4px 12px;font-size:18px;line-height:1"></button>
        <span id="zoomLevel" style="font-size:13px;min-width:45px;text-align:center;color:#a8b2d6">100%</span>
        <button class="btn" id="zoomInBtn" style="padding:4px 12px;font-size:18px;line-height:1">+</button>
        <button class="btn" id="zoomResetBtn" style="padding:4px 8px;font-size:11px">Reset</button>
      </div>
    </div>

    <div id="detectedDishesPanel" style="display:none;background:#1a2351;border:1px solid #2a3261;border-radius:12px;padding:20px;margin-bottom:16px;text-align:center">
      <div style="font-size:1.3rem;font-weight:600;margin-bottom:8px" id="currentDishName"></div>
      <div class="note" style="margin-bottom:12px">Press and drag on the menu to create an overlay for this item</div>
      <div style="display:flex;gap:12px;justify-content:center;align-items:center;font-size:14px;flex-wrap:wrap">
        <button class="btn" id="prevDishBtn" style="padding:6px 12px;font-size:13px"> Previous</button>
        <span id="dishProgress" style="color:#a8b2d6"></span>
        <button class="btn" id="nextDishBtn" style="padding:6px 12px;font-size:13px">Next </button>
        <button class="btn btnSuccess" id="finishMappingBtn" style="padding:6px 12px;font-size:13px;display:none"> Finish Mapping</button>
      </div>
    </div>

    <div class="menuWrap show" id="menu"></div>
    <!-- Navigation arrows above menu (always created, shown/hidden dynamically) -->
    <div id="menuTopNav" style="display:none;justify-content:center;align-items:center;gap:12px;margin:16px 0;padding:12px;background:rgba(76,90,212,0.1);border-radius:8px">
      <button class="btn" id="prevPageBtn" style="padding:8px 16px"> Previous</button>
      <span id="pageIndicator" style="color:#e9ecff;font-weight:600">Page <span id="currentPageNum">1</span> of 1</span>
      <button class="btn" id="nextPageBtn" style="padding:8px 16px">Next </button>
    </div>
    <!-- Navigation arrows below menu (always created, shown/hidden dynamically) -->
    <!-- Navigation arrows below menu removed to prevent duplication -->
  `;
      const menu = document.getElementById('menu');
      const inner = div('', 'menuInner'); menu.appendChild(inner);

      // Support multiple menu images
      const menuImages = rs.menuImages || (rs.menuImage ? [rs.menuImage] : []);
      let currentPageIndex = 0;

      // Track images being uploaded (initialize with current images)
      let pendingMenuImages = [...menuImages];
      let currentUploadIndex = -1; // -1 means not uploading, >= 0 means uploading page at that index
      let lastUploadedIndex = -1; // Track the most recently uploaded/touched page index

      // Function to update navigation UI visibility and state
      const updateMenuNavigationUI = () => {
        const menuTopNav = document.getElementById('menuTopNav');
        const menuBottomNav = document.getElementById('menuBottomNav');

        if (menuImages.length > 1) {
          if (menuTopNav) menuTopNav.style.display = 'flex';
        } else {
          if (menuTopNav) menuTopNav.style.display = 'none';
        }

        // Update page indicators
        const currentPageNum = document.getElementById('currentPageNum');
        const pageIndicatorBottom = document.getElementById('pageIndicatorBottom');
        if (currentPageNum) {
          currentPageNum.textContent = currentPageIndex + 1;
          const parentSpan = currentPageNum.parentElement;
          if (parentSpan) {
            parentSpan.textContent = `Page ${currentPageIndex + 1} of ${menuImages.length}`;
          }
        }
        if (pageIndicatorBottom) {
          pageIndicatorBottom.textContent = `Page ${currentPageIndex + 1} of ${menuImages.length}`;
        }
      };

      // Initialize navigation UI
      updateMenuNavigationUI();

      // Initialize with first page
      const img = new Image();
      img.src = menuImages[0] || '';
      img.className = 'menuImg';
      img.draggable = false;
      inner.appendChild(img);

      // Create overlay layer
      const overlayLayer = div('', 'overlayLayer');
      inner.appendChild(overlayLayer);

      // Prevent any scroll/drag on the menu container
      menu.scrollLeft = 0;
      menu.scrollTop = 0;
      menu.addEventListener('scroll', (e) => {
        menu.scrollLeft = 0;
        menu.scrollTop = 0;
      }, { passive: true });
      img.addEventListener('dragstart', (e) => e.preventDefault());

      const overlays = JSON.parse(JSON.stringify(rs.overlays || []));

      // Add pageIndex to overlays that don't have it (default to 0 for backward compatibility)
      overlays.forEach(o => {
        if (o.pageIndex === undefined) {
          o.pageIndex = 0;
        }
      });

      // Log aiIngredients preservation when entering editor mode
      console.log('renderEditor: Checking aiIngredients in loaded overlays:', overlays.map(o => ({
        id: o.id,
        hasAiIngredients: !!o.aiIngredients,
        aiIngredientsType: typeof o.aiIngredients,
        aiIngredientsPreview: o.aiIngredients ? (typeof o.aiIngredients === 'string' ? o.aiIngredients.substring(0, 100) + '...' : JSON.stringify(o.aiIngredients).substring(0, 100)) : null
      })));

      let dirty = false; function setDirty(v = true) { dirty = v; window.editorDirty = v; document.getElementById('saveBtn').style.display = dirty ? 'inline-flex' : 'none'; }

      // Track all changes as they happen
      let pendingChanges = [];
      let originalOverlaysRef = JSON.stringify(rs.overlays || []);
      // Store original restaurant settings to detect changes
      let originalRestaurantSettings = {
        website: rs.website || null,
        phone: rs.phone || null,
        delivery_url: rs.delivery_url || null
      };
      // Make update function accessible globally for the save handler
      window.updateOriginalRestaurantSettings = function (newSettings) {
        originalRestaurantSettings = newSettings;
      };

      // History tracking for undo/redo
      let history = [{ overlays: JSON.parse(JSON.stringify(overlays)), pendingChanges: [], timestamp: Date.now() }];
      let historyIndex = 0;

      function pushHistory() {
        // Remove any future history if we've undone and then made a new change
        if (historyIndex < history.length - 1) {
          history = history.slice(0, historyIndex + 1);
        }
        // Add new history entry
        history.push({
          overlays: JSON.parse(JSON.stringify(overlays)),
          pendingChanges: [...pendingChanges],
          timestamp: Date.now()
        });
        historyIndex = history.length - 1;
        // Limit history to 50 entries
        if (history.length > 50) {
          history.shift();
          historyIndex--;
        }
        updateUndoRedoButtons();
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          const snapshot = history[historyIndex];
          overlays.splice(0, overlays.length, ...JSON.parse(JSON.stringify(snapshot.overlays)));
          pendingChanges.splice(0, pendingChanges.length, ...snapshot.pendingChanges);
          drawAll();
          setDirty(true);
          updateUndoRedoButtons();
        }
      }

      function redo() {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          const snapshot = history[historyIndex];
          overlays.splice(0, overlays.length, ...JSON.parse(JSON.stringify(snapshot.overlays)));
          pendingChanges.splice(0, pendingChanges.length, ...snapshot.pendingChanges);
          drawAll();
          setDirty(true);
          updateUndoRedoButtons();
        }
      }

      function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        if (undoBtn) {
          undoBtn.disabled = historyIndex <= 0;
          undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
        }
        if (redoBtn) {
          redoBtn.disabled = historyIndex >= history.length - 1;
          redoBtn.style.opacity = historyIndex >= history.length - 1 ? '0.5' : '1';
        }
      }

      const saveBtn = document.getElementById('saveBtn');
      function setSaveState(s) {
        if (!saveBtn) return;
        if (s === 'saving') { saveBtn.disabled = true; saveBtn.textContent = 'Saving'; saveBtn.classList.remove('btnSuccess', 'btnDanger', 'btnPrimary'); saveBtn.classList.add('btn'); }
        else if (s === 'saved') {
          saveBtn.disabled = true; saveBtn.textContent = 'Saved'; saveBtn.classList.remove('btn', 'btnDanger', 'btnPrimary'); saveBtn.classList.add('btnSuccess');
          // Update originalOverlaysRef after successful save
          originalOverlaysRef = JSON.stringify(overlays);
          setTimeout(() => { saveBtn.disabled = false; saveBtn.textContent = 'Save to site'; saveBtn.classList.remove('btnSuccess', 'btnDanger'); saveBtn.classList.add('btnPrimary'); pendingChanges = []; setDirty(false); }, 900);
        }
        else if (s === 'error') {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Retry save';
          saveBtn.classList.remove('btnSuccess', 'btnPrimary');
          saveBtn.classList.add('btnDanger');
          // Make error state more visible
          saveBtn.title = 'Save failed. Click to retry. Check console (F12) for error details.';
        }
      }
      function formatChangesForLog(changesList) {
        // Try multiple sources for full name
        const firstName = state.user?.user_metadata?.first_name || '';
        const lastName = state.user?.user_metadata?.last_name || '';
        let fullName = `${firstName} ${lastName}`.trim();
        // Check for full_name field
        if (!fullName) fullName = (state.user?.user_metadata?.full_name || '').trim();
        // Check raw_user_meta_data (Supabase sometimes uses this)
        if (!fullName) {
          const rawFirst = state.user?.raw_user_meta_data?.first_name || '';
          const rawLast = state.user?.raw_user_meta_data?.last_name || '';
          fullName = `${rawFirst} ${rawLast}`.trim();
        }
        if (!fullName) fullName = (state.user?.raw_user_meta_data?.full_name || '').trim();
        // Fallback to name field
        if (!fullName) fullName = (state.user?.name || '').trim();
        if (!fullName) fullName = (state.user?.email || '').trim();
        if (!fullName) fullName = 'User';

        console.log('formatChangesForLog: user data =', {
          user_metadata: state.user?.user_metadata,
          raw_user_meta_data: state.user?.raw_user_meta_data,
          name: state.user?.name,
          resolvedFullName: fullName
        });

        const grouped = {};
        const generalChanges = [];

        (changesList || []).forEach(change => {
          if (typeof change !== 'string') return;
          const colonIndex = change.indexOf(':');
          if (colonIndex > 0) {
            const itemName = change.substring(0, colonIndex).trim();
            const itemChange = change.substring(colonIndex + 1).trim();
            if (!grouped[itemName]) grouped[itemName] = [];
            if (itemChange) grouped[itemName].push(itemChange);
          } else if (change.trim()) {
            generalChanges.push(change.trim());
          }
        });

        return {
          author: fullName,
          general: generalChanges,
          items: grouped
        };
      }

      if (saveBtn) {
        saveBtn.onclick = () => {
          setSaveState('saving');
          // Combine pendingChanges (UI-tracked) with describeOverlayChanges (comparison-based)
          // This ensures we capture both manual UI changes AND aiIngredients changes
          const uiChanges = [...pendingChanges];
          const comparisonChanges = describeOverlayChanges(JSON.parse(originalOverlaysRef), overlays);

          // Extract renamed dishes to filter out redundant add/remove changes
          const renamedDishes = new Map(); // oldName -> newName
          uiChanges.forEach(change => {
            const renameMatch = change.match(/^Renamed "(.+)" to "(.+)"$/);
            if (renameMatch) {
              renamedDishes.set(renameMatch[1], renameMatch[2]);
            }
          });

          // Merge and deduplicate changes, filtering out redundant add/remove for renames
          const allChanges = [...uiChanges];
          comparisonChanges.forEach(change => {
            // Only add if not already in uiChanges (avoid duplicates)
            if (uiChanges.includes(change)) return;

            // Skip "Added overlay" for new name if it was renamed
            const addedMatch = change.match(/^(.+): Added overlay$/);
            if (addedMatch) {
              const dishName = addedMatch[1];
              // Check if this dish is the new name of a renamed dish
              for (const [oldName, newName] of renamedDishes) {
                if (newName === dishName) return; // Skip, rename already tracked
              }
            }

            // Skip "Removed overlay" for old name if it was renamed
            const removedMatch = change.match(/^(.+): Removed overlay$/);
            if (removedMatch) {
              const dishName = removedMatch[1];
              // Check if this dish is the old name of a renamed dish
              if (renamedDishes.has(dishName)) return; // Skip, rename already tracked
            }

            allChanges.push(change);
          });

          let changesList = allChanges;
          console.log('SAVE BUTTON CLICKED: changesList.length =', changesList.length);
          console.log('SAVE BUTTON: originalOverlaysRef length =', originalOverlaysRef ? originalOverlaysRef.length : 'null');
          console.log('SAVE BUTTON: current overlays length =', overlays ? overlays.length : 'null');
          // Check if restaurant settings changed
          const currentRestaurantSettings = {
            website: state.restaurant?.website || null,
            phone: state.restaurant?.phone || null,
            delivery_url: state.restaurant?.delivery_url || null
          };
          const restaurantSettingsChanged =
            originalRestaurantSettings.website !== currentRestaurantSettings.website ||
            originalRestaurantSettings.phone !== currentRestaurantSettings.phone ||
            originalRestaurantSettings.delivery_url !== currentRestaurantSettings.delivery_url;

          if (restaurantSettingsChanged) {
            changesList.push('Updated restaurant settings (website, phone, delivery URL)');
            console.log('SAVE BUTTON: Restaurant settings changed');
          }

          if (!changesList.length) {
            console.warn('SAVE BUTTON: No changes detected! Checking if aiIngredients differs...');
            // Check if aiIngredients changed even if describeOverlayChanges didn't catch it
            try {
              const originalOverlays = JSON.parse(originalOverlaysRef || '[]');
              const originalById = new Map(originalOverlays.filter(o => o && o.id).map(o => [o.id, o]));
              const aiIngredientChanges = [];

              overlays.forEach((overlay) => {
                if (!overlay || !overlay.id) return;
                const original = originalById.get(overlay.id);
                if (!original) return;

                const currentAiIngredients = overlay.aiIngredients;
                const originalAiIngredients = original.aiIngredients;
                const changed = JSON.stringify(currentAiIngredients) !== JSON.stringify(originalAiIngredients);

                if (changed) {
                  const dishName = overlay.id || 'Unknown dish';
                  console.log(`SAVE BUTTON: Found aiIngredients change in overlay ${dishName}:`, {
                    original: originalAiIngredients ? (typeof originalAiIngredients === 'string' ? originalAiIngredients.substring(0, 100) : JSON.stringify(originalAiIngredients).substring(0, 100)) : 'null',
                    current: currentAiIngredients ? (typeof currentAiIngredients === 'string' ? currentAiIngredients.substring(0, 100) : JSON.stringify(currentAiIngredients).substring(0, 100)) : 'null'
                  });

                  // Generate specific change description
                  if (!originalAiIngredients && currentAiIngredients) {
                    aiIngredientChanges.push(`${dishName}: Added ingredient data`);
                  } else if (originalAiIngredients && !currentAiIngredients) {
                    aiIngredientChanges.push(`${dishName}: Removed ingredient data`);
                  } else {
                    aiIngredientChanges.push(`${dishName}: Updated ingredient data`);
                  }
                }
              });

              if (aiIngredientChanges.length) {
                console.log('SAVE BUTTON: Found aiIngredients changes:', aiIngredientChanges);
                changesList = aiIngredientChanges;
              }
            } catch (e) {
              console.error('SAVE BUTTON: Error checking aiIngredients changes:', e);
            }
            if (!changesList.length) {
              setSaveState('saved');
              return;
            }
          }
          // Debug: Log what we're saving
          console.log('Saving overlays:', JSON.stringify(overlays, null, 2));
          overlays.forEach((overlay, idx) => {
            console.log(`Overlay ${idx} (${overlay.id}):`, {
              crossContamination: overlay.crossContamination,
              noCrossContamination: overlay.noCrossContamination,
              removable: overlay.removable,
              hasAiIngredients: !!overlay.aiIngredients,
              aiIngredientsSample: overlay.aiIngredients ? (typeof overlay.aiIngredients === 'string' ? overlay.aiIngredients.substring(0, 200) : String(overlay.aiIngredients).substring(0, 200)) : 'none'
            });
            // Log one example with parsed aiIngredients if it exists
            if (overlay.aiIngredients && typeof overlay.aiIngredients === 'string') {
              try {
                const parsed = JSON.parse(overlay.aiIngredients);
                const sampleIngredient = parsed[0];
                if (sampleIngredient) {
                  console.log(`  First ingredient sample:`, {
                    name: sampleIngredient.name,
                    needsScan: sampleIngredient.needsScan,
                    userOverriddenScan: sampleIngredient.userOverriddenScan
                  });
                }
              } catch (e) {
                console.log('  Failed to parse aiIngredients:', e);
              }
            }
          });
          const formattedChanges = formatChangesForLog(changesList);
          // Include restaurant settings if they changed
          const restaurantSettingsToSave = restaurantSettingsChanged ? {
            website: currentRestaurantSettings.website,
            phone: currentRestaurantSettings.phone,
            delivery_url: currentRestaurantSettings.delivery_url
          } : null;
          send({ type: 'saveOverlays', overlays, menuImages: menuImages, menuImage: menuImages[0] || rs.menuImage || '', changes: formattedChanges, restaurantSettings: restaurantSettingsToSave });
        };
      }

      function describeOverlayChanges(oldOverlays, newOverlays) {
        const changes = [];
        const oldList = Array.isArray(oldOverlays) ? oldOverlays : [];
        const newList = Array.isArray(newOverlays) ? newOverlays : [];
        const oldById = new Map(oldList.filter(o => o && o.id).map(o => [o.id, o]));
        const newById = new Map(newList.filter(o => o && o.id).map(o => [o.id, o]));

        // Compare each new item against its original version (by ID, not index)
        newList.forEach((item) => {
          if (!item || !item.id) return;
          const itemName = item.id || 'Item';
          const old = oldById.get(item.id);

          if (old) {
            // Check if aiIngredients changed - if so, we'll use ingredient-level tracking instead of dish-level
            const oldAiIngredients = old.aiIngredients;
            const newAiIngredients = item.aiIngredients;
            const hasAiIngredientsChange = JSON.stringify(oldAiIngredients) !== JSON.stringify(newAiIngredients);

            // Note: Dish-level allergen/diet changes are not logged here.
            // All allergen/diet changes should come from ingredient-level tracking in aiIngredients.

            // Track position changes
            const moved = old.x !== item.x || old.y !== item.y || old.w !== item.w || old.h !== item.h;
            if (moved) {
              changes.push(`${itemName}: Adjusted overlay position`);
            }

            // Note: Cross-contamination changes are tracked in pendingChanges (doneBtn handler),
            // not here, to avoid duplicate logging.

            // Track aiIngredients changes with specific details
            // (oldAiIngredients, newAiIngredients, hasAiIngredientsChange already declared above)
            if (hasAiIngredientsChange) {
              if (!oldAiIngredients && newAiIngredients) {
                changes.push(`${itemName}: Added ingredient data`);
              } else if (oldAiIngredients && !newAiIngredients) {
                changes.push(`${itemName}: Removed ingredient data`);
              } else {
                // Parse and compare to find specific changes
                try {
                  const oldIngList = typeof oldAiIngredients === 'string' ? JSON.parse(oldAiIngredients) : oldAiIngredients;
                  const newIngList = typeof newAiIngredients === 'string' ? JSON.parse(newAiIngredients) : newAiIngredients;

                  if (Array.isArray(oldIngList) && Array.isArray(newIngList)) {
                    const specificChanges = [];

                    // Check each ingredient for changes
                    newIngList.forEach(newIng => {
                      const oldIng = oldIngList.find(o => o.name === newIng.name);
                      if (oldIng) {
                        // Check diet changes
                        const oldDiets = new Set(oldIng.diets || []);
                        const newDiets = new Set(newIng.diets || []);
                        const addedDiets = [...newDiets].filter(d => !oldDiets.has(d));
                        const removedDiets = [...oldDiets].filter(d => !newDiets.has(d));
                        if (addedDiets.length) specificChanges.push(`${newIng.name}: added ${addedDiets.join(', ')}`);
                        if (removedDiets.length) specificChanges.push(`${newIng.name}: removed ${removedDiets.join(', ')}`);

                        // Check allergen changes
                        const oldAllergens = new Set(oldIng.allergens || []);
                        const newAllergens = new Set(newIng.allergens || []);
                        const addedAllergens = [...newAllergens].filter(a => !oldAllergens.has(a));
                        const removedAllergens = [...oldAllergens].filter(a => !newAllergens.has(a));
                        if (addedAllergens.length) specificChanges.push(`${newIng.name}: added allergen ${addedAllergens.join(', ')}`);
                        if (removedAllergens.length) specificChanges.push(`${newIng.name}: removed allergen ${removedAllergens.join(', ')}`);
                        if (removedAllergens.length) specificChanges.push(`${newIng.name}: removed allergen ${removedAllergens.join(', ')}`);

                        // Check for added brands
                        const oldBrands = oldIng.brands || [];
                        const newBrands = newIng.brands || [];
                        const getBrandKey = (b) => `${b.name}|${b.barcode || ''}`;
                        const oldBrandKeys = new Set(oldBrands.map(getBrandKey));
                        const newBrandKeys = new Set(newBrands.map(getBrandKey));

                        newBrands.forEach(b => {
                          if (!oldBrandKeys.has(getBrandKey(b))) {
                            specificChanges.push(`${newIng.name}: ${b.name} added as brand item`);
                          }
                        });

                        oldBrands.forEach(b => {
                          if (!newBrandKeys.has(getBrandKey(b))) {
                            specificChanges.push(`${newIng.name}: ${b.name} removed as brand item`);
                          }
                        });
                      }
                    });

                    // Check for added/removed ingredients
                    const oldNames = new Set(oldIngList.map(i => i.name));
                    const newNames = new Set(newIngList.map(i => i.name));
                    const addedIngs = [...newNames].filter(n => !oldNames.has(n));
                    const removedIngs = [...oldNames].filter(n => !newNames.has(n));
                    if (addedIngs.length) specificChanges.push(`Added ingredient: ${addedIngs.join(', ')}`);
                    if (removedIngs.length) specificChanges.push(`Removed ingredient: ${removedIngs.join(', ')}`);

                    if (specificChanges.length > 0) {
                      // Add each specific change with the dish name prefix
                      specificChanges.forEach(sc => changes.push(`${itemName}: ${sc}`));
                    } else {
                      changes.push(`${itemName}: Updated ingredient data`);
                    }
                  } else {
                    changes.push(`${itemName}: Updated ingredient data`);
                  }
                } catch (e) {
                  changes.push(`${itemName}: Updated ingredient data`);
                }
              }
            }
          } else {
            // New overlay added
            changes.push(`${itemName}: Added overlay`);
          }
        });

        // Find removed overlays
        oldList.forEach(item => {
          if (!item || !item.id) return;
          if (!newById.has(item.id)) {
            const itemName = item.id || 'Item';
            changes.push(`${itemName}: Removed overlay`);
          }
        });

        return changes;
      }

      const confirmBtn = document.getElementById('confirmBtn');
      if (confirmBtn) { confirmBtn.onclick = () => { openBrandVerification(); }; }

      const viewLogBtn = document.getElementById('viewLogBtn');
      if (viewLogBtn) { viewLogBtn.onclick = () => { openChangeLog(); }; }

      const settingsBtn = document.getElementById('settingsBtn');
      if (settingsBtn) { settingsBtn.onclick = () => { openRestaurantSettings(); }; }

      const undoBtn = document.getElementById('undoBtn');
      if (undoBtn) { undoBtn.onclick = () => { undo(); }; }

      const redoBtn = document.getElementById('redoBtn');
      if (redoBtn) { redoBtn.onclick = () => { redo(); }; }

      // Keyboard shortcuts for undo/redo
      document.addEventListener('keydown', function handleEditorKeydown(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
        } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
          e.preventDefault();
          redo();
        }
      });

      function updateLastConfirmedText() {
        const lastConfirmedText = document.getElementById('lastConfirmedText');
        if (lastConfirmedText) {
          const now = new Date();
          const isAdmin = state.user?.email === 'matt.29.ds@gmail.com';
          const isManager = state.user?.role === 'manager';
          const showAll = isAdmin || isManager;
          const info = getWeeksAgoInfo(now, showAll);
          if (info && info.text) {
            lastConfirmedText.textContent = 'Last confirmed by staff: ' + info.text;
            lastConfirmedText.style.color = info.color;
          } else {
            lastConfirmedText.textContent = 'Last confirmed: ' + fmtDateTime(now);
            lastConfirmedText.style.color = '';
          }
        }
      }

      // Collect all brand items from all dishes
      function collectAllBrandItems() {
        const brandItems = new Map(); // key: `${ingredientName}|${brandName}|${barcode}`
        const currentOverlays = JSON.parse(JSON.stringify(overlays || []));

        currentOverlays.forEach((overlay, overlayIdx) => {
          const dishName = overlay.id || overlay.name || 'unnamed';
          let ingredients = [];

          // Parse aiIngredients if it exists
          if (overlay.aiIngredients) {
            try {
              ingredients = JSON.parse(overlay.aiIngredients);
            } catch (e) {
              console.error('Failed to parse aiIngredients:', e);
            }
          }

          // Also check for legacy ingredients array format
          if (!ingredients.length && Array.isArray(overlay.ingredients)) {
            ingredients = overlay.ingredients;
          }

          // Process each ingredient
          ingredients.forEach((ingredient, ingIdx) => {
            if (!ingredient.name || !Array.isArray(ingredient.brands) || ingredient.brands.length === 0) {
              return;
            }

            ingredient.brands.forEach(brand => {
              if (!brand.name) return;

              // Create unique key for this brand item - use barcode as primary identifier
              // If barcode exists, use it alone (barcode should be unique per product)
              // If no barcode, fall back to brand name only (to handle items without barcodes)
              const barcode = brand.barcode || '';
              const key = barcode ? barcode : `${brand.name}`;

              if (!brandItems.has(key)) {
                brandItems.set(key, {
                  ingredientName: ingredient.name, // Keep first ingredient name for display
                  brandName: brand.name,
                  barcode: barcode,
                  brandImage: brand.brandImage || '',
                  ingredientsList: Array.isArray(brand.ingredientsList) ? brand.ingredientsList : [],
                  allergens: Array.isArray(brand.allergens) ? brand.allergens : [],
                  diets: Array.isArray(brand.diets) ? brand.diets : [],
                  dishes: []
                });
              }

              // Add dish info to the brand item
              const brandItem = brandItems.get(key);
              brandItem.dishes.push({
                overlayIdx: overlayIdx,
                dishName: dishName,
                ingredientIdx: ingIdx,
                brandIdx: ingredient.brands.indexOf(brand)
              });

              // If this brand item has multiple ingredient names, update to show all ingredients
              if (brandItem.ingredientName !== ingredient.name) {
                // Check if we already have a list of ingredients
                if (!brandItem.ingredientNames) {
                  brandItem.ingredientNames = [brandItem.ingredientName];
                }
                if (!brandItem.ingredientNames.includes(ingredient.name)) {
                  brandItem.ingredientNames.push(ingredient.name);
                }
              }
            });
          });
        });

        return Array.from(brandItems.values());
      }

      function openBrandVerification() {
        const mb = document.getElementById('modalBack');
        const body = document.getElementById('modalBody');
        document.getElementById('modalTitle').textContent = 'Verify Brand Items';

        const brandItems = collectAllBrandItems();

        if (brandItems.length === 0) {
          body.innerHTML = `
        <div class="note" style="text-align:center;margin:20px 0">
          <p>No brand items found in your dishes.</p>
          <p style="margin-top:12px">Add brand items to your dishes to verify them here.</p>
        </div>
        <div style="text-align:center;margin-top:20px">
          <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
        </div>
      `;
          mb.style.display = 'flex';
          configureModalClose({ visible: true, onClick: () => { mb.style.display = 'none'; } });
          return;
        }

        // Track verification status for each brand item
        const verificationStatus = new Map();
        brandItems.forEach((item, idx) => {
          verificationStatus.set(idx, { verified: false, scannedBarcode: null, verifying: false, verificationError: null });
        });

        let currentScanningIdx = null;
        let showingRemoveOptions = null; // Track which card is showing remove options
        let showingDishSelection = null; // Track which card is showing dish selection

        function renderBrandItems() {
          let html = `
        <div style="margin-bottom:16px">
          <p class="note" style="text-align:center">
            Scan the barcode for each brand item to confirm you're still using it.
            You can also remove items you no longer use.
          </p>
        </div>
        <div style="max-height:60vh;overflow-y:auto;border:1px solid rgba(76,90,212,0.3);border-radius:8px;padding:12px">
      `;

          brandItems.forEach((item, idx) => {
            const status = verificationStatus.get(idx);
            const verified = status.verified;
            const verifying = status.verifying;
            const verificationError = status.verificationError;
            const isScanning = currentScanningIdx === idx;
            const showingOptions = showingRemoveOptions === idx && showingDishSelection !== idx;
            const showingDishSel = showingDishSelection === idx;

            html += `
          <div class="brandItemCard" data-idx="${idx}" style="
            background:${verified ? 'rgba(34,197,94,0.1)' : 'rgba(76,90,212,0.1)'};
            border:1px solid ${verified ? 'rgba(34,197,94,0.4)' : 'rgba(76,90,212,0.4)'};
            border-radius:8px;
            padding:16px;
            margin-bottom:12px;
            position:relative
          ">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
              <div style="flex:1">
                <div style="font-weight:600;font-size:1.1rem;margin-bottom:4px">
                  ${esc(item.brandName)}
                </div>
                <div style="color:#a8b2d6;font-size:0.9rem;margin-bottom:8px">
                  ${item.ingredientNames && item.ingredientNames.length > 1
                ? `Ingredients: ${esc(item.ingredientNames.join(', '))}`
                : `Ingredient: ${esc(item.ingredientName)}`}
                </div>
                ${item.barcode ? `<div style="color:#8891b0;font-size:0.85rem;margin-bottom:8px">Barcode: ${esc(item.barcode)}</div>` : ''}
                <div style="color:#8891b0;font-size:0.85rem;margin-bottom:8px">
                  Used in ${item.dishes.length} dish${item.dishes.length !== 1 ? 'es' : ''}: ${esc(item.dishes.map(d => d.dishName).join(', '))}
                </div>
                ${verified ? `<div style="color:#22c55e;font-size:0.9rem;margin-top:8px"> Verified</div>` : ''}
              </div>
              <div style="display:flex;gap:8px;flex-direction:column;align-items:flex-end">
                ${!verified && !showingOptions ? `
                  <button class="btn btnPrimary scanBrandBtn" data-idx="${idx}" style="white-space:nowrap;padding:8px 12px;font-size:0.9rem" ${isScanning ? 'disabled' : ''}>
                    ${isScanning ? 'Scanning...' : ' Scan Barcode'}
                  </button>
                ` : ''}
                ${!showingOptions ? `
                  <div style="display:flex;gap:8px;flex-direction:row;align-items:center">
                    <button class="btn btnDanger removeBrandBtn" data-idx="${idx}" style="white-space:nowrap;padding:8px 12px;font-size:0.9rem">
                      Remove
                    </button>
                  </div>
                ` : ''}
              </div>
            </div>
            ${showingDishSel ? `
              <div class="dishSelectionDiv" style="margin-top:12px;padding:12px;background:rgba(239,68,68,0.1);border:1px solid rgba(239,68,68,0.3);border-radius:6px">
                <div style="color:#fff;font-size:0.95rem;margin-bottom:12px;font-weight:500">
                  Select which dishes to remove this item from:
                </div>
                <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px" id="dishSelectionList_${idx}">
                  <!-- Dish checkboxes will be inserted here -->
                </div>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                  <button class="btn btnDanger confirmRemoveBtn" data-idx="${idx}" style="flex:1;min-width:120px;padding:8px 12px;font-size:0.9rem">
                    Remove Selected
                  </button>
                  <button class="btn cancelDishSelectionBtn" data-idx="${idx}" style="padding:8px 12px;font-size:0.9rem">
                    Cancel
                  </button>
                </div>
              </div>
            ` : ''}
            ${isScanning ? `
              <div id="scanStatus_${idx}" style="margin-top:12px;padding:12px;background:rgba(76,90,212,0.2);border-radius:6px;text-align:center">
                <div style="color:#a8b2d6">Scanning barcode...</div>
              </div>
            ` : ''}
            ${verifying ? `
              <div id="verifyingStatus_${idx}" style="margin-top:12px;padding:12px;background:rgba(76,90,212,0.2);border-radius:6px">
                <div style="color:#a8b2d6;margin-bottom:8px;font-size:0.9rem">Verifying barcode...</div>
                <div style="background:rgba(0,0,0,0.2);border-radius:4px;height:6px;overflow:hidden">
                  <div style="background:linear-gradient(90deg,#4c5ad4,#8b5cf6);background-size:200% 100%;height:100%;width:100%;animation:shimmer 1.5s infinite"></div>
                </div>
                <div style="color:#8891b0;font-size:0.85rem;margin-top:8px;text-align:center">
                  You can continue scanning other items while this verifies
                </div>
              </div>
            ` : ''}
            ${verificationError ? `
              <div id="verificationError_${idx}" style="margin-top:12px;padding:12px;background:rgba(239,68,68,0.1);border:1px solid rgba(239,68,68,0.3);border-radius:6px">
                <div style="color:#ef4444;font-size:0.9rem">${esc(verificationError)}</div>
                <button class="btn btnPrimary clearVerificationErrorBtn" data-idx="${idx}" style="margin-top:8px;padding:6px 12px;font-size:0.85rem">Try Again</button>
              </div>
            ` : ''}
          </div>
        `;
          });

          html += `</div>`;

          const allVerified = Array.from(verificationStatus.values()).every(s => s.verified);
          html += `
        <div style="margin-top:20px;text-align:center">
          <button class="btn btnSuccess" id="confirmAllBtn" ${!allVerified ? 'disabled style="opacity:0.5"' : ''}>
            ${allVerified ? ' Confirm All Verified' : `Verify ${brandItems.length - Array.from(verificationStatus.values()).filter(s => s.verified).length} remaining items`}
          </button>
          <button class="btn" id="cancelBrandVerificationBtn" style="margin-left:8px">Cancel</button>
        </div>
      `;

          body.innerHTML = html;

          // Attach event handlers
          brandItems.forEach((item, idx) => {
            const scanBtn = body.querySelector(`.scanBrandBtn[data-idx="${idx}"]`);
            if (scanBtn) {
              scanBtn.addEventListener('click', () => scanBrandItem(idx));
            }

            const removeBtn = body.querySelector(`.removeBrandBtn[data-idx="${idx}"]`);
            if (removeBtn) {
              removeBtn.addEventListener('click', () => {
                // Close brand verification modal and route to AI assistant for each dish
                const mb = document.getElementById('modalBack');
                if (mb) mb.style.display = 'none';

                // Route to AI assistant for each dish
                routeToAiAssistantForDishes(idx, item);
              });
            }

            // Setup dish selection if needed
            if (showingDishSelection === idx) {
              setupDishSelectionForCard(idx, item);
            }

            // Setup verification error handler
            const clearErrorBtn = body.querySelector(`.clearVerificationErrorBtn[data-idx="${idx}"]`);
            if (clearErrorBtn) {
              clearErrorBtn.addEventListener('click', () => {
                const status = verificationStatus.get(idx);
                status.verificationError = null;
                renderBrandItems();
              });
            }
          });

          const confirmBtn = body.querySelector('#confirmAllBtn');
          if (confirmBtn) {
            confirmBtn.addEventListener('click', () => {
              if (allVerified) {
                finalizeBrandVerification();
              }
            });
          }

          const cancelBtn = body.querySelector('#cancelBrandVerificationBtn');
          if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
              mb.style.display = 'none';
            });
          }
        }

        async function scanBrandItem(idx) {
          const item = brandItems[idx];
          currentScanningIdx = idx;
          renderBrandItems();

          const statusDiv = document.getElementById(`scanStatus_${idx}`);
          if (statusDiv) {
            statusDiv.innerHTML = '<div style="color:#a8b2d6">Opening barcode scanner...</div>';
          }

          // Open barcode scanner
          const scannerModal = document.createElement('div');
          scannerModal.id = 'brandVerificationScannerModal';
          scannerModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        z-index: 10001;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;

          scannerModal.innerHTML = `
        <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px">
          <div style="text-align:center">
            <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Scan Barcode</h3>
            <div style="margin:0;color:#a8b2d6;font-size:0.95rem">
              Brand: <strong style="color:#fff">${esc(item.brandName)}</strong><br>
              Ingredient: <strong style="color:#fff">${esc(item.ingredientName)}</strong>
            </div>
          </div>
          <video id="brandScannerVideo" style="width:100%;max-width:500px;border-radius:8px;background:#000" autoplay playsinline></video>
          <div id="brandScannerStatus" style="text-align:center;color:#a8b2d6;padding:12px;background:rgba(76,90,212,0.2);border-radius:6px">
            Point your camera at the barcode...
          </div>
          <div style="display:flex;gap:8px;justify-content:center">
            <button class="btn" id="brandScannerCancelBtn">Cancel</button>
          </div>
        </div>
      `;

          document.body.appendChild(scannerModal);
          const video = scannerModal.querySelector('#brandScannerVideo');
          const statusDiv2 = scannerModal.querySelector('#brandScannerStatus');
          let codeReader = null;
          let scanning = false;

          const stopScanning = () => {
            if (codeReader) {
              codeReader.reset();
              codeReader = null;
            }
            scanning = false;
            if (video.srcObject) {
              video.srcObject.getTracks().forEach(track => track.stop());
              video.srcObject = null;
            }
          };

          const closeScanner = () => {
            stopScanning();
            if (scannerModal.parentNode) {
              scannerModal.parentNode.removeChild(scannerModal);
            }
            currentScanningIdx = null;
            renderBrandItems();
          };

          const handleBarcodeScanned = async (scannedBarcode) => {
            // Close camera immediately
            closeScanner();

            // Show loading state in the brand card
            const status = verificationStatus.get(idx);
            status.verifying = true;
            renderBrandItems();

            // Just verify the barcode number matches - no API call needed
            // This should be instant (just string comparison)
            const scannedBarcodeClean = scannedBarcode.trim().replace(/\s+/g, '');
            const storedBarcodeClean = (item.barcode || '').trim().replace(/\s+/g, '');

            // Small delay just for visual feedback (verification is instant)
            await new Promise(resolve => setTimeout(resolve, 100));

            if (!storedBarcodeClean) {
              // No stored barcode to compare - can't verify
              status.verifying = false;
              status.verificationError = `No barcode stored for this item. Please add a barcode to this brand item first before verifying.`;
              renderBrandItems();
            } else if (scannedBarcodeClean === storedBarcodeClean) {
              // Barcode matches - verify instantly
              status.verified = true;
              status.scannedBarcode = scannedBarcode;
              status.verifying = false;
              status.verificationError = null;
              renderBrandItems();
            } else {
              // Barcode doesn't match
              status.verifying = false;
              status.verificationError = 'Incorrect barcode';
              renderBrandItems();
            }
          };

          // Initialize barcode scanner
          if (typeof ZXing !== 'undefined') {
            codeReader = new ZXing.BrowserMultiFormatReader();
            scanning = true;

            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
              .then(stream => {
                video.srcObject = stream;
                codeReader.decodeFromVideoDevice(null, video.id, (result, err) => {
                  if (result) {
                    handleBarcodeScanned(result.text);
                  } else if (err && !(err instanceof ZXing.NotFoundException)) {
                    console.error('Barcode scan error:', err);
                  }
                });
              })
              .catch(err => {
                console.error('Camera access error:', err);
                if (statusDiv2) {
                  statusDiv2.innerHTML = '<div style="color:#ef4444">Camera access denied. Please allow camera access to scan barcodes.</div>';
                }
              });
          } else {
            if (statusDiv2) {
              statusDiv2.innerHTML = '<div style="color:#ef4444">Barcode scanner library not loaded. Please refresh the page.</div>';
            }
          }

          scannerModal.querySelector('#brandScannerCancelBtn').addEventListener('click', closeScanner);
        }

        async function handleReplaceBrand(idx) {
          const item = brandItems[idx];
          // Replace for all dishes using this item
          await replaceBrandItem(idx, item.dishes.map(d => d.overlayIdx));
        }

        // Route to AI assistant for each dish that uses this brand item
        async function routeToAiAssistantForDishes(idx, item) {
          const dishes = item.dishes;
          if (dishes.length === 0) return;

          // Close brand verification modal
          const mb = document.getElementById('modalBack');
          if (mb) mb.style.display = 'none';

          // Process dishes one by one
          for (let i = 0; i < dishes.length; i++) {
            const dish = dishes[i];

            // Open AI assistant for this dish with the ingredient pre-filled
            await openAiAssistantForDishReplacement(dish, item, i + 1, dishes.length);
          }
        }

        // Open AI assistant for a specific dish to replace a brand item
        async function openAiAssistantForDishReplacement(dish, brandItem, dishNumber, totalDishes) {
          return new Promise((resolve) => {
            // Get the overlay for this dish
            const overlay = overlays[dish.overlayIdx];
            if (!overlay) {
              resolve();
              return;
            }

            // Extract ingredient name from the brand item
            const ingredientName = brandItem.ingredientName;

            // Get dish name from overlay (overlay.id or overlay.name)
            const actualDishName = overlay.id || overlay.name || dish.dishName || 'Unnamed Dish';

            // Get existing ingredients from the overlay to populate the assistant
            let existingIngredients = [];
            if (overlay.aiIngredients) {
              try {
                existingIngredients = JSON.parse(overlay.aiIngredients);
              } catch (e) { }
            }
            if (!existingIngredients.length && Array.isArray(overlay.ingredients)) {
              existingIngredients = overlay.ingredients;
            }

            // Remove the brand item from the ingredient before opening AI assistant
            existingIngredients.forEach(ing => {
              if (ing.name === ingredientName && Array.isArray(ing.brands)) {
                // Find and remove the brand that matches
                const brandIdx = ing.brands.findIndex(b =>
                  b.name === brandItem.brandName &&
                  (b.barcode || '') === (brandItem.barcode || '')
                );
                if (brandIdx !== -1) {
                  ing.brands.splice(brandIdx, 1);
                  console.log(`Removed brand "${brandItem.brandName}" from ingredient "${ingredientName}"`);
                }
              }
            });

            // Update the overlay with the modified ingredients
            overlay.aiIngredients = JSON.stringify(existingIngredients);
            rs.overlays = overlays;
            setDirty(true);
            drawAll();

            console.log('Opening AI assistant for replacement:', {
              dishName: actualDishName,
              ingredientName: ingredientName,
              brandToReplace: brandItem.brandName,
              existingIngredientsCount: existingIngredients.length
            });

            // Open AI assistant with context pointing to this dish and ingredient
            const context = {
              type: 'dish',
              overlayIdx: dish.overlayIdx,
              dishName: actualDishName,
              ingredientName: ingredientName,
              brandToReplace: brandItem.brandName,
              replacementFlow: true,
              dishNumber: dishNumber,
              totalDishes: totalDishes,
              existingIngredients: existingIngredients,
              getCurrentName: () => actualDishName
            };

            // Open the AI assistant
            openAiAssistant(context);

            // After the table renders, scroll to the ingredient row
            // Wait a bit longer to ensure table is fully rendered
            const scrollToIngredient = () => {
              if (aiAssistTableBody && aiAssistTableBody.querySelectorAll('tr[data-index]').length > 0) {
                scrollToIngredientRow(ingredientName);
              } else {
                // Table not rendered yet, try again
                setTimeout(scrollToIngredient, 200);
              }
            };
            setTimeout(scrollToIngredient, 500);

            // Wait for user to complete the replacement or close the assistant
            // We'll resolve when the assistant is closed or when a replacement is confirmed
            const checkComplete = () => {
              const aiBackdrop = document.getElementById('aiAssistBackdrop');
              if (!aiBackdrop || !aiBackdrop.classList.contains('show')) {
                // Assistant closed
                resolve();
              } else {
                // Check again in a bit
                setTimeout(checkComplete, 500);
              }
            };

            // Start checking for completion
            setTimeout(checkComplete, 1000);
          });
        }

        // Scroll to the ingredient row in the AI assistant table
        function scrollToIngredientRow(ingredientName) {
          if (!aiAssistTableBody) return;

          // Find the row with matching ingredient name
          const rows = aiAssistTableBody.querySelectorAll('tr[data-index]');
          for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const nameInput = row.querySelector('.aiIngredientName');
            if (nameInput && nameInput.value.toLowerCase().trim() === ingredientName.toLowerCase().trim()) {
              // Found the row - scroll to it
              row.scrollIntoView({ behavior: 'smooth', block: 'center' });

              // Highlight the row briefly
              row.style.transition = 'background-color 0.3s';
              row.style.backgroundColor = 'rgba(76,90,212,0.2)';
              setTimeout(() => {
                row.style.backgroundColor = '';
                setTimeout(() => {
                  row.style.transition = '';
                }, 300);
              }, 2000);

              console.log(`Scrolled to ingredient row: ${ingredientName}`);
              break;
            }
          }
        }

        // Show replacement modal for a single dish
        async function showReplacementModalForDish(brandIdx, brandItem, dish, dishNumber, totalDishes) {
          return new Promise((resolve) => {
            const modal = document.createElement('div');
            modal.id = `dishReplacementModal_${dish.overlayIdx}`;
            modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0,0,0,0.95);
          z-index: 10001;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 20px;
        `;

            modal.innerHTML = `
          <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px">
            <div style="text-align:center">
              <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Replace Brand Item</h3>
              <div style="margin:0;color:#a8b2d6;font-size:0.95rem">
                Dish: <strong style="color:#fff">${esc(dish.dishName)}</strong><br>
                Ingredient: <strong style="color:#fff">${esc(brandItem.ingredientName)}</strong><br>
                Removing: <strong style="color:#fff">${esc(brandItem.brandName)}</strong><br>
                <span style="color:#6b7ce6;font-size:0.9rem">(${dishNumber} of ${totalDishes})</span>
              </div>
            </div>
            <div style="position:relative;background:#000;border-radius:12px;overflow:hidden;margin:16px 0">
              <video id="dishReplacementVideo_${dish.overlayIdx}" style="width:100%;max-width:500px;border-radius:8px;background:#000;display:none" autoplay playsinline></video>
              <img id="dishReplacementPreview_${dish.overlayIdx}" style="width:100%;max-width:500px;border-radius:8px;display:none;object-fit:contain" alt="Preview">
              <div id="dishReplacementPlaceholder_${dish.overlayIdx}" style="width:100%;min-height:300px;display:flex;align-items:center;justify-content:center;background:#1a1a1a;color:#a8b2d6;font-size:1.1rem;border-radius:8px">
                Scan barcode of replacement item
              </div>
            </div>
            <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
              <button class="btn btnPrimary" id="dishReplacementCameraBtn_${dish.overlayIdx}" style="padding:12px 24px;font-size:0.95rem"> Scan Barcode</button>
              <button class="btn btnPrimary" id="dishReplacementUploadBtn_${dish.overlayIdx}" style="padding:12px 24px;font-size:0.95rem"> Upload Image</button>
              ${totalDishes > 1 && dishNumber < totalDishes ? `
                <button class="btn" id="dishReplacementSkipBtn_${dish.overlayIdx}" style="padding:12px 24px;font-size:0.95rem">Skip this dish</button>
              ` : ''}
              <button class="btn" id="dishReplacementCancelBtn_${dish.overlayIdx}" style="padding:12px 24px;font-size:0.95rem">Cancel</button>
            </div>
            <input type="file" id="dishReplacementFileInput_${dish.overlayIdx}" accept="image/*" style="display:none">
          </div>
        `;

            document.body.appendChild(modal);

            const video = modal.querySelector(`#dishReplacementVideo_${dish.overlayIdx}`);
            const preview = modal.querySelector(`#dishReplacementPreview_${dish.overlayIdx}`);
            const placeholder = modal.querySelector(`#dishReplacementPlaceholder_${dish.overlayIdx}`);
            const cameraBtn = modal.querySelector(`#dishReplacementCameraBtn_${dish.overlayIdx}`);
            const uploadBtn = modal.querySelector(`#dishReplacementUploadBtn_${dish.overlayIdx}`);
            const skipBtn = modal.querySelector(`#dishReplacementSkipBtn_${dish.overlayIdx}`);
            const cancelBtn = modal.querySelector(`#dishReplacementCancelBtn_${dish.overlayIdx}`);
            const fileInput = modal.querySelector(`#dishReplacementFileInput_${dish.overlayIdx}`);

            let codeReader = null;
            let scanning = false;

            const stopScanning = () => {
              if (codeReader) {
                codeReader.reset();
                codeReader = null;
              }
              scanning = false;
              if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
              }
            };

            const closeModal = () => {
              stopScanning();
              if (modal.parentNode) {
                modal.parentNode.removeChild(modal);
              }
            };

            // Handle barcode scan result
            const handleBarcodeScanned = async (scannedBarcode) => {
              stopScanning();
              closeModal();

              try {
                const result = await fetchProductByBarcode(scannedBarcode);

                if (result && result.success && result.ingredientList) {
                  // Use brand from API response (extracted from barcode database, not product name)
                  const brand = result.brand || '';
                  const productName = result.productName || result.product?.name || result.product?.product_name || 'Unknown Product';

                  const productImage = result.productImage || result.product?.image_url || result.product?.image ||
                    (result.sources && result.sources.length > 0 && result.sources[0].productImage) || '';

                  const suggestion = {
                    name: productName,
                    brand: brand,
                    barcode: scannedBarcode,
                    brandImage: productImage,
                    ingredientsImage: '',
                    ingredientsList: [result.ingredientList]
                  };

                  // Show sources modal, then apply replacement
                  await showReplacementSourcesForDish(brandIdx, brandItem, dish, suggestion, result);

                  resolve(true);
                } else if (result && result.needsPhoto) {
                  alert(`Barcode not found. Please scan again or use a photo.`);
                  resolve(false); // Let user retry
                } else {
                  alert(`Product not found for barcode: ${scannedBarcode}. Please try again.`);
                  resolve(false); // Let user retry
                }
              } catch (error) {
                console.error('Replacement scan error:', error);
                alert(`Error scanning barcode: ${error.message || 'Unknown error'}. Please try again.`);
                resolve(false); // Let user retry
              }
            };

            // Camera button - start barcode scanner
            cameraBtn.addEventListener('click', async () => {
              if (scanning) return;

              try {
                const stream = await navigator.mediaDevices.getUserMedia({
                  video: { facingMode: 'environment' }
                });

                video.srcObject = stream;
                video.style.display = 'block';
                placeholder.style.display = 'none';

                if (!window.ZXing) {
                  alert('Barcode scanner library not loaded. Please refresh the page.');
                  return;
                }

                codeReader = new window.ZXing.BrowserMultiFormatReader();
                scanning = true;

                codeReader.decodeFromVideoDevice(null, video, (result, err) => {
                  if (result) {
                    handleBarcodeScanned(result.getText());
                  } else if (err && !(err instanceof window.ZXing.NotFoundException)) {
                    console.error('Scan error:', err);
                  }
                });
              } catch (error) {
                console.error('Camera error:', error);
                alert('Could not access camera. Please check permissions.');
              }
            });

            // Upload button triggers file input
            if (uploadBtn) {
              uploadBtn.addEventListener('click', () => {
                fileInput.click();
              });
            }

            // File upload
            fileInput.addEventListener('change', async (e) => {
              const file = e.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = async (event) => {
                const imageData = event.target.result;

                try {
                  if (!window.ZXing) {
                    alert('Barcode scanner library not loaded.');
                    return;
                  }

                  const codeReader = new window.ZXing.BrowserMultiFormatReader();
                  const result = await codeReader.decodeFromImageDataUrl(imageData);

                  if (result) {
                    await handleBarcodeScanned(result.getText());
                  } else {
                    alert('Could not read barcode from image. Please try again.');
                  }
                } catch (err) {
                  console.error('Barcode decode error:', err);
                  alert(`Barcode decode error: ${err.message}. Please try again.`);
                }
              };
              reader.readAsDataURL(file);
            });

            // Skip button
            if (skipBtn) {
              skipBtn.addEventListener('click', () => {
                closeModal();
                resolve(true); // Skip this dish, continue to next
              });
            }

            // Cancel button
            cancelBtn.addEventListener('click', () => {
              closeModal();
              resolve(false); // Cancel entire flow
            });
          });
        }

        // Show sources modal for dish replacement, then apply
        async function showReplacementSourcesForDish(brandIdx, oldItem, dish, suggestion, barcodeResult) {
          return new Promise((resolve) => {
            // Use the existing showReplacementBarcodeSourcesModal but with a custom handler
            const sources = barcodeResult.sources || [];
            const productName = barcodeResult.productName || suggestion.name;
            let ingredientList = barcodeResult.ingredientList || '';
            const consistencyInfo = barcodeResult.consistencyInfo || {};

            if (consistencyInfo.differentSources && consistencyInfo.differentSources > 1 &&
              consistencyInfo.matchingSources >= 1 && consistencyInfo.matchingSources < consistencyInfo.totalSources) {
              const consensusDiff = consistencyInfo.differences?.find(d => d.groupSize === consistencyInfo.matchingSources);
              if (consensusDiff) {
                ingredientList = consensusDiff.ingredientsText;
              }
            }

            const modal = document.createElement('div');
            modal.id = `dishReplacementSourcesModal_${dish.overlayIdx}`;
            modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.9);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10010;
          padding: 20px;
        `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
          background: #0c102a;
          border: 2px solid #4c5ad4;
          border-radius: 16px;
          max-width: 900px;
          max-height: 85vh;
          overflow-y: auto;
          padding: 24px;
          color: #fff;
          width: 100%;
        `;

            // Build sources HTML using grouped display
            const sourcesHtml = renderGroupedSourcesHtml(sources, {
              ingredientNames: barcodeResult.ingredientNames || null
            });

            modalContent.innerHTML = `
          <div style="margin-bottom: 20px;">
            <h3 style="margin: 0 0 8px 0; color: #4c5ad4; font-size: 1.4rem;"> Product Found!</h3>
            <p style="margin: 0; font-size: 1.1rem; color: #fff; font-weight: 600;">${esc(productName)}</p>
            ${suggestion.brand ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Brand: ${esc(suggestion.brand)}</p>` : ''}
            <p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Dish: ${esc(dish.dishName)}</p>
            <p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Replacing: ${esc(oldItem.brandName)}  ${esc(suggestion.brand || 'New Brand')}</p>
          </div>
          ${consistencyInfo.totalSources ? `
            <div style="background: rgba(76,212,90,0.15); border: 1px solid rgba(76,212,90,0.4); border-radius: 8px; padding: 12px; margin-bottom: 20px;">
              <div style="font-weight: 600; color: #4caf50; margin-bottom: 4px;">
                Verification: ${consistencyInfo.matchingSources || 0} out of ${consistencyInfo.totalSources || 0} sources agree
              </div>
            </div>
          ` : ''}
          <div style="margin-bottom: 20px;">
            <div style="font-weight: 600; color: #4c5ad4; font-size: 1.05rem; margin-bottom: 12px;">Consolidated Ingredient List:</div>
            <div style="background: rgba(76,90,212,0.1); border: 1px solid rgba(76,90,212,0.3); border-radius: 8px; padding: 16px; font-size: 0.95rem; line-height: 1.6; color: #e0e0e0; white-space: pre-wrap; word-wrap: break-word;">
              ${esc(ingredientList)}
              <button type="button" class="confirmDishReplacementBtn" style="padding: 8px 16px; margin-top: 12px; background: #4c5ad4; border: none; border-radius: 6px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">
                Confirm and apply this ingredient list
              </button>
            </div>
          </div>
          <div style="margin-bottom: 24px;">
            <div style="font-weight: 600; color: #4c5ad4; font-size: 1.05rem; margin-bottom: 12px;">Sources Verified (${sources.length} total):</div>
            <p style="font-size: 0.85rem; color: #999; margin-bottom: 12px; font-style: italic;">
               Note: URLs are provided for reference. Some links may be outdated or inaccessible due to website changes.
            </p>
            ${sourcesHtml}
          </div>
          <div style="display: flex; gap: 12px; justify-content: flex-end;">
            <button type="button" class="cancelDishReplacementBtn" style="padding: 14px 24px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: #fff; font-weight: 600; cursor: pointer;">
              Cancel
            </button>
          </div>
        `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            const confirmBtn = modalContent.querySelector('.confirmDishReplacementBtn');
            const cancelBtn = modalContent.querySelector('.cancelDishReplacementBtn');

            confirmBtn.addEventListener('click', async () => {
              document.body.removeChild(modal);

              // Analyze allergens/diets
              try {
                const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
                  body: {
                    ingredientText: ingredientList,
                    productName: productName,
                    labels: [],
                    categories: []
                  }
                });

                const allergens = analysisResult.data?.allergens || [];
                const diets = analysisResult.data?.diets || [];

                // Apply replacement to this dish
                applyReplacementToDish(brandIdx, oldItem, dish, suggestion, ingredientList, allergens, diets);

                resolve(true);
              } catch (error) {
                console.error('Error analyzing allergens:', error);
                // Still apply replacement even if analysis fails
                applyReplacementToDish(brandIdx, oldItem, dish, suggestion, ingredientList, [], []);
                resolve(true);
              }
            });

            cancelBtn.addEventListener('click', () => {
              document.body.removeChild(modal);
              resolve(false);
            });
          });
        }

        // Apply replacement to a specific dish
        function applyReplacementToDish(brandIdx, oldItem, dish, suggestion, ingredientList, allergens, diets) {
          const overlay = overlays[dish.overlayIdx];
          if (!overlay) return;

          let ingredients = [];
          if (overlay.aiIngredients) {
            try {
              ingredients = JSON.parse(overlay.aiIngredients);
            } catch (e) { }
          }
          if (!ingredients.length && Array.isArray(overlay.ingredients)) {
            ingredients = overlay.ingredients;
          }

          // Find the ingredient and replace the brand
          ingredients.forEach(ing => {
            if (ing.name === oldItem.ingredientName && Array.isArray(ing.brands)) {
              // Remove old brand
              const brandIdx = ing.brands.findIndex(b => b.name === oldItem.brandName && (b.barcode || '') === (oldItem.barcode || ''));
              if (brandIdx !== -1) {
                ing.brands.splice(brandIdx, 1);
              }

              // Add new brand
              const newBrand = {
                name: suggestion.brand || suggestion.name,
                barcode: suggestion.barcode || '',
                image: suggestion.brandImage || '',
                allergens: allergens,
                diets: diets,
                ingredientList: ingredientList
              };

              if (!ing.brands) {
                ing.brands = [];
              }
              ing.brands.push(newBrand);
            }
          });

          overlay.aiIngredients = JSON.stringify(ingredients);
          rs.overlays = overlays;
          setDirty(true);
          drawAll();
        }

        function showDishSelectionForRemoval(idx, item) {
          // Update states to show dish selection
          showingRemoveOptions = null;
          showingDishSelection = idx;
          renderBrandItems();
        }

        function setupDishSelectionForCard(idx, item) {
          // Track which dishes are selected for removal
          const selectedDishes = new Set(item.dishes.map((d, i) => i)); // Start with all selected

          const card = body.querySelector(`.brandItemCard[data-idx="${idx}"]`);
          if (!card) return;

          const selectionList = card.querySelector(`#dishSelectionList_${idx}`);
          if (!selectionList) return;

          // Populate dish checkboxes
          selectionList.innerHTML = item.dishes.map((dish, dishIdx) => `
        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;padding:8px;background:rgba(0,0,0,0.2);border-radius:4px">
          <input type="checkbox" class="dishSelectCheckbox" data-dish-idx="${dishIdx}" data-brand-idx="${idx}" ${selectedDishes.has(dishIdx) ? 'checked' : ''} style="cursor:pointer">
          <span style="color:#a8b2d6;font-size:0.9rem">${esc(dish.dishName)}</span>
        </label>
      `).join('');

          // Attach checkbox handlers
          card.querySelectorAll('.dishSelectCheckbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
              const dishIdx = parseInt(e.target.dataset.dishIdx);
              if (e.target.checked) {
                selectedDishes.add(dishIdx);
              } else {
                selectedDishes.delete(dishIdx);
              }
            });
          });

          // Attach confirm button
          const confirmBtn = card.querySelector('.confirmRemoveBtn');
          if (confirmBtn) {
            confirmBtn.addEventListener('click', () => {
              if (selectedDishes.size === 0) {
                alert('Please select at least one dish to remove the item from.');
                return;
              }
              const dishesToUpdate = Array.from(selectedDishes).map(i => item.dishes[i].overlayIdx);
              showingRemoveOptions = null;
              showingDishSelection = null;
              removeBrandItemFromDishes(idx, dishesToUpdate);
            });
          }

          // Attach cancel button
          const cancelBtn = card.querySelector('.cancelDishSelectionBtn');
          if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
              showingRemoveOptions = null;
              showingDishSelection = null;
              renderBrandItems();
            });
          }
        }

        async function replaceBrandItem(idx, overlayIndices) {
          // Open scanner/upload modal for replacement
          const item = brandItems[idx];
          currentScanningIdx = idx;

          const scannerModal = document.createElement('div');
          scannerModal.id = 'brandReplacementScannerModal';
          scannerModal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        z-index: 10001;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;

          scannerModal.innerHTML = `
        <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px">
          <div style="text-align:center">
            <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Replace Brand Item</h3>
            <div style="margin:0;color:#a8b2d6;font-size:0.95rem">
              Replacing: <strong style="color:#fff">${esc(item.brandName)}</strong><br>
              Ingredient: <strong style="color:#fff">${esc(item.ingredientName)}</strong>
            </div>
          </div>
          <div style="position:relative;background:#000;border-radius:12px;overflow:hidden;margin:16px 0">
            <video id="brandReplacementVideo" style="width:100%;max-width:500px;border-radius:8px;background:#000;display:none" autoplay playsinline></video>
            <img id="brandReplacementPreview" style="width:100%;max-width:500px;border-radius:8px;display:none;object-fit:contain" alt="Preview">
            <div id="brandReplacementPlaceholder" style="width:100%;min-height:300px;display:flex;align-items:center;justify-content:center;background:#1a1a1a;color:#a8b2d6;font-size:1.1rem;border-radius:8px">
              Choose an option below
            </div>
          </div>
          <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
            <button class="btn btnPrimary" id="brandReplacementCameraBtn" style="padding:12px 24px;font-size:0.95rem"> Scan Barcode</button>
            <button class="btn btnPrimary" id="brandReplacementUploadBtn" style="padding:12px 24px;font-size:0.95rem"> Upload Photo</button>
            <button class="btn" id="brandReplacementCancelBtn" style="padding:12px 24px;font-size:0.95rem">Cancel</button>
          </div>
          <input type="file" id="brandReplacementFileInput" accept="image/*" style="display:none">
        </div>
      `;

          document.body.appendChild(scannerModal);
          const video = scannerModal.querySelector('#brandReplacementVideo');
          const preview = scannerModal.querySelector('#brandReplacementPreview');
          const placeholder = scannerModal.querySelector('#brandReplacementPlaceholder');
          const cameraBtn = scannerModal.querySelector('#brandReplacementCameraBtn');
          const uploadBtn = scannerModal.querySelector('#brandReplacementUploadBtn');
          const cancelBtn = scannerModal.querySelector('#brandReplacementCancelBtn');
          const fileInput = scannerModal.querySelector('#brandReplacementFileInput');
          let codeReader = null;
          let mediaStream = null;
          let uploadedImage = null;

          const stopScanning = () => {
            if (codeReader) {
              codeReader.reset();
              codeReader = null;
            }
            if (mediaStream) {
              mediaStream.getTracks().forEach(track => track.stop());
              mediaStream = null;
            }
            if (video.srcObject) {
              video.srcObject.getTracks().forEach(track => track.stop());
              video.srcObject = null;
            }
          };

          const closeScanner = () => {
            stopScanning();
            if (scannerModal.parentNode) {
              scannerModal.parentNode.removeChild(scannerModal);
            }
            currentScanningIdx = null;
            renderBrandItems();
          };

          const showPreview = (src, isVideo = false) => {
            placeholder.style.display = 'none';
            if (isVideo) {
              video.style.display = 'block';
              preview.style.display = 'none';
            } else {
              video.style.display = 'none';
              preview.style.display = 'block';
              preview.src = src;
            }
          };

          const handleReplacementFromBarcode = async (scannedBarcode) => {
            // Close the replacement modal and return to verify brand items page
            closeScanner();

            // Show loading state in the brand item card
            showReplacementLoadingInCard(idx);

            try {
              const result = await fetchProductByBarcode(scannedBarcode);

              if (result && result.success && result.ingredientList) {
                // Use brand from API response (extracted from barcode database, not product name)
                const brand = result.brand || '';
                const productName = result.productName || result.product?.name || result.product?.product_name || 'Unknown Product';

                // Get product image
                const productImage = result.productImage || result.product?.image_url || result.product?.image ||
                  (result.sources && result.sources.length > 0 && result.sources[0].productImage) || '';

                // Create suggestion object (same format as AI assistant)
                const suggestion = {
                  name: productName,
                  brand: brand,
                  barcode: scannedBarcode,
                  brandImage: productImage,
                  ingredientsImage: '',
                  ingredientsList: [result.ingredientList]
                };

                // Hide loading and show sources modal using the existing flow
                hideReplacementLoadingInCard(idx);
                showReplacementBarcodeSourcesModal(idx, item, suggestion, result);
              } else if (result && result.needsPhoto) {
                // Product not found - needs photo instead
                hideReplacementLoadingInCard(idx);
                alert(`Barcode not found in our database. Please use the "Upload Photo" button to take a photo of the barcode or ingredient list instead.`);
                renderBrandItems();
              } else {
                // Product not found for other reasons
                hideReplacementLoadingInCard(idx);
                alert(`Product not found for barcode: ${scannedBarcode}. Please try scanning again or use the "Upload Photo" option.`);
                renderBrandItems();
              }
            } catch (error) {
              console.error('Replacement scan error:', error);
              hideReplacementLoadingInCard(idx);
              alert(`Error scanning barcode: ${error.message || 'Unknown error'}. Please try again or use the "Upload Photo" option.`);
              renderBrandItems();
            }
          };

          const handleReplacementFromPhoto = async (imageData) => {
            // Close the replacement modal and return to verify brand items page
            closeScanner();

            // Show loading state in the brand item card
            showReplacementLoadingInCard(idx);

            try {
              if (!window.supabaseClient) {
                throw new Error('Supabase client not available');
              }

              const result = await window.supabaseClient.functions.invoke('extract-ingredients-from-photo', {
                body: {
                  imageData: imageData,
                  barcode: ''
                }
              });

              if (result.error) {
                throw new Error(result.error.message || 'Failed to extract ingredients');
              }

              const data = result.data || result;

              if (data.success && data.ingredientList) {
                // For photo extraction, use the full product name as the brand display
                // (We don't have barcode API data to get the real brand)
                const productName = data.productName || 'Unknown Product';
                const brand = productName;

                // Hide loading - for photo extraction, go directly to allergen preview (no sources to show)
                hideReplacementLoadingInCard(idx);
                await showReplacementPreview(item, brand, '', data.ingredientList, '', productName);
              } else {
                const message = data.message || 'Could not extract ingredients from photo';
                hideReplacementLoadingInCard(idx);
                alert(message);
                renderBrandItems();
              }
            } catch (error) {
              console.error('Photo extraction error:', error);
              hideReplacementLoadingInCard(idx);
              alert(`Error processing photo: ${error.message || 'Unknown error'}. Please try again.`);
              renderBrandItems();
            }
          };

          const showReplacementPreview = async (oldItem, newBrandName, newBarcode, newIngredientList, newBrandImage, productName) => {
            // We're already back on the verify brand items page, no need to close anything

            // Analyze allergens and diets
            try {
              const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
                body: {
                  ingredientText: newIngredientList,
                  productName: productName,
                  labels: [],
                  categories: []
                }
              });

              const allergens = analysisResult.data?.allergens || [];
              const diets = analysisResult.data?.diets || [];

              // Show preview modal
              showReplacementAllergenDietPreview(oldItem, {
                brandName: newBrandName,
                barcode: newBarcode,
                ingredientList: newIngredientList,
                brandImage: newBrandImage,
                productName: productName,
                allergens: allergens,
                diets: diets
              });
            } catch (err) {
              console.error('Failed to analyze allergens/diets:', err);
              // If analysis fails, show preview with empty allergens/diets
              showReplacementAllergenDietPreview(oldItem, {
                brandName: newBrandName,
                barcode: newBarcode,
                ingredientList: newIngredientList,
                brandImage: newBrandImage,
                productName: productName,
                allergens: [],
                diets: []
              });
            }
          };

          const applyReplacement = async (oldItem, newBrandName, newBarcode, newIngredientList, newBrandImage, overlayIndices, allergens = [], diets = []) => {
            // Replace the brand in all specified dishes
            const newBrand = {
              name: newBrandName,
              barcode: newBarcode,
              brandImage: newBrandImage,
              ingredientsList: [newIngredientList],
              allergens: allergens || [],
              diets: diets || []
            };

            // Update overlays
            const indicesToUpdate = overlayIndices || oldItem.dishes.map(d => d.overlayIdx);
            indicesToUpdate.forEach(overlayIdx => {
              const overlay = overlays[overlayIdx];
              if (!overlay) return;

              let ingredients = [];
              if (overlay.aiIngredients) {
                try {
                  ingredients = JSON.parse(overlay.aiIngredients);
                } catch (e) { }
              }
              if (!ingredients.length && Array.isArray(overlay.ingredients)) {
                ingredients = overlay.ingredients;
              }

              // Find and replace the brand
              ingredients.forEach(ing => {
                if (ing.name === oldItem.ingredientName && Array.isArray(ing.brands)) {
                  const brandIdx = ing.brands.findIndex(b => b.name === oldItem.brandName);
                  if (brandIdx !== -1) {
                    ing.brands[brandIdx] = newBrand;
                  }
                }
              });

              overlay.aiIngredients = JSON.stringify(ingredients);
            });

            // Update the restaurant overlays
            rs.overlays = overlays;
            setDirty(true);
            drawAll();

            // Remove from brand items list and mark as verified
            brandItems.splice(idx, 1);
            verificationStatus.delete(idx);
            // Re-index remaining items (all items after idx shift down by 1)
            const newStatus = new Map();
            brandItems.forEach((item, newIdx) => {
              const oldIdx = newIdx < idx ? newIdx : newIdx + 1;
              newStatus.set(newIdx, verificationStatus.get(oldIdx) || { verified: false });
            });
            verificationStatus.clear();
            newStatus.forEach((v, k) => verificationStatus.set(k, v));

            renderBrandItems();
          };

          // Camera button handler
          cameraBtn.addEventListener('click', async () => {
            try {
              if (typeof ZXing === 'undefined') {
                console.error('Barcode scanner not available. Please upload a photo instead.');
                return;
              }

              const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
              mediaStream = stream;
              video.srcObject = stream;
              showPreview(null, true);

              codeReader = new ZXing.BrowserMultiFormatReader();
              codeReader.decodeFromVideoDevice(null, video.id, (result, err) => {
                if (result) {
                  stopScanning();
                  handleReplacementFromBarcode(result.text);
                } else if (err && !(err instanceof ZXing.NotFoundException)) {
                  console.error('Barcode scan error:', err);
                }
              });
            } catch (err) {
              console.error('Camera access error:', err);
            }
          });

          // Upload button handler
          uploadBtn.addEventListener('click', () => {
            fileInput.click();
          });

          fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                uploadedImage = event.target.result;
                showPreview(uploadedImage, false);
                handleReplacementFromPhoto(uploadedImage);
              };
              reader.readAsDataURL(file);
            }
          });

          cancelBtn.addEventListener('click', closeScanner);
        }

        function removeBrandItemFromDishes(idx, overlayIndices) {
          const item = brandItems[idx];

          // Remove the brand from specified dishes
          overlayIndices.forEach(overlayIdx => {
            const overlay = overlays[overlayIdx];
            if (!overlay) return;

            let ingredients = [];
            if (overlay.aiIngredients) {
              try {
                ingredients = JSON.parse(overlay.aiIngredients);
              } catch (e) { }
            }
            if (!ingredients.length && Array.isArray(overlay.ingredients)) {
              ingredients = overlay.ingredients;
            }

            // Find and remove the brand
            ingredients.forEach(ing => {
              if (ing.name === item.ingredientName && Array.isArray(ing.brands)) {
                const brandIdx = ing.brands.findIndex(b => b.name === item.brandName && (b.barcode || '') === (item.barcode || ''));
                if (brandIdx !== -1) {
                  ing.brands.splice(brandIdx, 1);
                }
              }
            });

            overlay.aiIngredients = JSON.stringify(ingredients);
          });

          // Update the restaurant overlays
          rs.overlays = overlays;
          setDirty(true);
          drawAll();

          // Remove from brand items list
          brandItems.splice(idx, 1);
          verificationStatus.delete(idx);
          // Re-index remaining items (all items after idx shift down by 1)
          const newStatus = new Map();
          brandItems.forEach((item, newIdx) => {
            const oldIdx = newIdx < idx ? newIdx : newIdx + 1;
            newStatus.set(newIdx, verificationStatus.get(oldIdx) || { verified: false });
          });
          verificationStatus.clear();
          newStatus.forEach((v, k) => verificationStatus.set(k, v));

          renderBrandItems();
        }

        function finalizeBrandVerification() {
          // Final confirmation - show photo capture
          mb.style.display = 'none';
          openPhotoCapture();
        }

        renderBrandItems();
        mb.style.display = 'flex';
        configureModalClose({ visible: true, onClick: () => { mb.style.display = 'none'; } });
      }

      // Show loading state in brand item card during replacement lookup
      function showReplacementLoadingInCard(idx) {
        const card = document.querySelector(`.brandItemCard[data-idx="${idx}"]`);
        if (!card) return;

        // Remove any existing loading area
        const existingLoading = card.querySelector('.replacementLoadingArea');
        if (existingLoading) existingLoading.remove();

        const loadingArea = document.createElement('div');
        loadingArea.className = 'replacementLoadingArea';
        loadingArea.style.cssText = `
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(76,90,212,0.1);
      border-radius: 8px;
      border: 1px solid rgba(76,90,212,0.3);
    `;

        loadingArea.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:8px">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="flex:1;background:rgba(76,90,212,0.2);border-radius:4px;height:6px;overflow:hidden">
            <div class="replacementLoadingBarFill" data-idx="${idx}" style="background:#4c5ad4;height:100%;width:0%;transition:width 0.5s ease-out"></div>
          </div>
          <span style="font-size:0.9rem;color:#6b7ce6;white-space:nowrap">Looking up replacement...</span>
        </div>
      </div>
    `;

        card.appendChild(loadingArea);

        // Animate loading bar
        const fillBar = loadingArea.querySelector('.replacementLoadingBarFill');
        if (fillBar) {
          const startTime = Date.now();
          const estimatedDuration = 45000;

          const updateProgress = () => {
            const elapsed = Date.now() - startTime;
            let progress = Math.min(95, (elapsed / estimatedDuration) * 95);

            if (elapsed < 2000) {
              progress = Math.min(progress, 10);
            } else if (elapsed < 10000) {
              progress = Math.min(progress, 10 + ((elapsed - 2000) / 8000) * 30);
            } else if (elapsed < 25000) {
              progress = Math.min(progress, 40 + ((elapsed - 10000) / 15000) * 30);
            } else if (elapsed < 40000) {
              progress = Math.min(progress, 70 + ((elapsed - 25000) / 15000) * 20);
            } else {
              progress = Math.min(progress, 90 + ((elapsed - 40000) / 5000) * 5);
            }

            fillBar.style.width = `${progress}%`;

            if (progress < 95 && fillBar.parentElement) {
              setTimeout(updateProgress, 500);
            } else {
              fillBar.style.width = '95%';
            }
          };

          setTimeout(updateProgress, 100);
        }
      }

      // Hide loading state in brand item card
      function hideReplacementLoadingInCard(idx) {
        const card = document.querySelector(`.brandItemCard[data-idx="${idx}"]`);
        if (!card) return;

        const loadingArea = card.querySelector('.replacementLoadingArea');
        if (loadingArea) {
          const fillBar = loadingArea.querySelector('.replacementLoadingBarFill');
          if (fillBar) fillBar.style.width = '100%';
          setTimeout(() => {
            if (loadingArea.parentNode) {
              loadingArea.remove();
            }
          }, 300);
        }
      }

      // Show barcode sources modal for replacement (based on showBarcodeSourcesModal)
      function showReplacementBarcodeSourcesModal(idx, oldItem, suggestion, barcodeResult) {
        const sources = barcodeResult.sources || [];
        const productName = barcodeResult.productName || suggestion.name;
        let ingredientList = barcodeResult.ingredientList || '';
        const consistencyInfo = barcodeResult.consistencyInfo || {};

        // If there's a conflict where all are different except one, use the consensus list
        const hasConflict = consistencyInfo.differentSources &&
          consistencyInfo.differentSources > 1 &&
          consistencyInfo.matchingSources >= 1 &&
          consistencyInfo.matchingSources < consistencyInfo.totalSources;

        if (hasConflict && consistencyInfo.differences) {
          const consensusDiff = consistencyInfo.differences.find(d => d.groupSize === consistencyInfo.matchingSources);
          if (consensusDiff) {
            ingredientList = consensusDiff.ingredientsText;
            suggestion.ingredientsList = [consensusDiff.ingredientsText];
          }
        }

        const modal = document.createElement('div');
        modal.id = 'replacementBarcodeSourcesModal';
        modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10010;
      padding: 20px;
    `;

        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
      background: #0c102a;
      border: 2px solid #4c5ad4;
      border-radius: 16px;
      max-width: 900px;
      max-height: 85vh;
      overflow-y: auto;
      padding: 24px;
      color: #fff;
      width: 100%;
    `;

        // Build sources HTML using grouped display
        const sourcesHtml = renderGroupedSourcesHtml(sources, {
          ingredientNames: barcodeResult.ingredientNames || null
        });

        modalContent.innerHTML = `
      <div style="margin-bottom: 20px;">
        <h3 style="margin: 0 0 8px 0; color: #4c5ad4; font-size: 1.4rem;"> Product Found!</h3>
        <p style="margin: 0; font-size: 1.1rem; color: #fff; font-weight: 600;">${esc(productName)}</p>
        ${suggestion.brand ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Brand: ${esc(suggestion.brand)}</p>` : ''}
        <p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Replacing: ${esc(oldItem.brandName)}  ${esc(suggestion.brand || 'New Brand')}</p>
      </div>

      <div style="margin-bottom: 24px;">
        <p style="font-size: 0.85rem; color: #999; margin-bottom: 12px; font-style: italic;">
           Note: URLs are provided for reference. Some links may be outdated or inaccessible due to website changes.
        </p>
        ${sourcesHtml}
      </div>

      <div style="display: flex; gap: 12px; justify-content: flex-end;">
        <button type="button" class="cancelReplacementSourcesBtn" style="
          padding: 14px 24px;
          background: rgba(255,255,255,0.1);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Cancel</button>
      </div>
    `;

        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        const cancelBtn = modalContent.querySelector('.cancelReplacementSourcesBtn');
        const confirmBtn = modalContent.querySelector('.confirmReplacementIngredientListBtn');
        const confirmConsensusBtn = modalContent.querySelector('.confirmReplacementConsensusBtn');
        const confirmVariationBtns = modalContent.querySelectorAll('.confirmReplacementVariationBtn');
        const confirmGroupBtns = modalContent.querySelectorAll('.confirmGroupIngredientListBtn');

        cancelBtn.addEventListener('click', () => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
          }
          renderBrandItems();
        });

        const handleConfirm = async (finalIngredientList) => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
          }

          // Proceed with allergen/diet preview for replacement
          await showReplacementPreview(oldItem, suggestion.brand || '', suggestion.barcode || '', finalIngredientList, suggestion.brandImage || '', productName);
        };

        // Handle grouped ingredient list confirmation buttons
        confirmGroupBtns.forEach(btn => {
          btn.addEventListener('click', async () => {
            btn.style.background = '#4caf50';
            btn.innerHTML = ' Confirmed';
            btn.style.cursor = 'default';

            const groupDiv = btn.closest('[data-ingredients-text]');
            const groupIngredientList = groupDiv ? groupDiv.dataset.ingredientsText : (ingredientList || '');
            await handleConfirm(groupIngredientList);
          });
        });

        // Handle consensus confirmation
        if (confirmConsensusBtn) {
          confirmConsensusBtn.addEventListener('click', async () => {
            const consensusDiff = consistencyInfo.differences?.find(d => d.groupSize === consistencyInfo.matchingSources);
            if (consensusDiff) {
              await handleConfirm(consensusDiff.ingredientsText);
            }
          });
        }

        // Handle variation confirmation buttons
        confirmVariationBtns.forEach(btn => {
          btn.addEventListener('click', async () => {
            const variationIngredientList = btn.dataset.ingredients || '';
            await handleConfirm(variationIngredientList);
          });
        });

        // Handle consolidated list confirmation (if it exists - removed the section but keeping handler for safety)
        if (confirmBtn) {
          confirmBtn.addEventListener('click', async () => {
            await handleConfirm(ingredientList);
          });
        }
      }

      // Show sources modal for replacement (exact copy of showBarcodeSourcesModal but for replacement) - DEPRECATED, use showReplacementBarcodeSourcesModal
      function showReplacementSourcesModal(idx, oldItem, replacementData) {
        const { brandName, barcode, brandImage, result } = replacementData;
        const sources = result.sources || [];
        const productName = result.productName || result.product?.name || result.product?.product_name || 'Unknown Product';
        let ingredientList = result.ingredientList || '';
        const consistencyInfo = result.consistencyInfo || {};

        console.log('showReplacementSourcesModal called with:', {
          idx,
          oldItem,
          replacementData,
          sourcesCount: sources.length,
          productName,
          ingredientList: ingredientList.substring(0, 50) + '...',
          consistencyInfo
        });

        // If there's a conflict where all are different except one, use the consensus list
        const hasConflict = consistencyInfo.differentSources &&
          consistencyInfo.differentSources > 1 &&
          consistencyInfo.matchingSources >= 1 &&
          consistencyInfo.matchingSources < consistencyInfo.totalSources;

        if (hasConflict && consistencyInfo.differences) {
          const consensusDiff = consistencyInfo.differences.find(d => d.groupSize === consistencyInfo.matchingSources);
          if (consensusDiff) {
            ingredientList = consensusDiff.ingredientsText;
          }
        }

        const modal = document.createElement('div');
        modal.id = 'replacementSourcesModal';
        modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10010;
      padding: 20px;
    `;

        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
      background: #0c102a;
      border: 2px solid #4c5ad4;
      border-radius: 16px;
      max-width: 900px;
      max-height: 85vh;
      overflow-y: auto;
      padding: 24px;
      color: #fff;
      width: 100%;
    `;

        // Build sources HTML using grouped display
        const sourcesHtml = renderGroupedSourcesHtml(sources, {
          ingredientNames: result.ingredientNames || null
        });

        modalContent.innerHTML = `
      <div style="margin-bottom: 20px;">
        <h3 style="margin: 0 0 8px 0; color: #4c5ad4; font-size: 1.4rem;"> Product Found!</h3>
        <p style="margin: 0; font-size: 1.1rem; color: #fff; font-weight: 600;">${esc(productName)}</p>
        ${brandName ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Brand: ${esc(brandName)}</p>` : ''}
        <p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">Replacing: ${esc(oldItem.brandName)}  ${esc(brandName || 'New Brand')}</p>
      </div>

      <div style="margin-bottom: 24px;">
        <p style="font-size: 0.85rem; color: #999; margin-bottom: 12px; font-style: italic;">
           Note: URLs are provided for reference. Some links may be outdated or inaccessible due to website changes.
        </p>
        ${sourcesHtml}
      </div>

      <div style="display: flex; gap: 12px; justify-content: flex-end;">
        <button type="button" class="cancelReplacementSourcesBtn" style="
          padding: 14px 24px;
          background: rgba(255,255,255,0.1);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 8px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s;
        ">Cancel</button>
      </div>
    `;

        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        console.log('Replacement sources modal appended to DOM. Sources count:', sources.length);
        console.log('Modal element:', modal);
        console.log('Modal visible:', window.getComputedStyle(modal).display !== 'none');

        const cancelBtn = modalContent.querySelector('.cancelReplacementSourcesBtn');
        const confirmBtn = modalContent.querySelector('.confirmReplacementIngredientListBtn');
        const confirmConsensusBtn = modalContent.querySelector('.confirmReplacementConsensusBtn');
        const confirmGroupBtns = modalContent.querySelectorAll('.confirmGroupIngredientListBtn');

        if (!cancelBtn) {
          console.error('Cancel button not found in replacement sources modal!');
        }

        cancelBtn.addEventListener('click', () => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
          }
          renderBrandItems();
        });

        const handleConfirm = async (finalIngredientList) => {
          document.body.removeChild(modal);

          // Proceed with allergen/diet preview
          await showReplacementPreview(oldItem, brandName, barcode, finalIngredientList, brandImage, productName);
        };

        // Handle grouped ingredient list confirmation buttons
        confirmGroupBtns.forEach(btn => {
          btn.addEventListener('click', async () => {
            btn.style.background = '#4caf50';
            btn.innerHTML = ' Confirmed';
            btn.style.cursor = 'default';

            const groupDiv = btn.closest('[data-ingredients-text]');
            const groupIngredientList = groupDiv ? groupDiv.dataset.ingredientsText : (ingredientList || '');
            await handleConfirm(groupIngredientList);
          });
        });

        // Handle consensus confirmation
        if (confirmConsensusBtn) {
          confirmConsensusBtn.addEventListener('click', async () => {
            const consensusDiff = consistencyInfo.differences?.find(d => d.groupSize === consistencyInfo.matchingSources);
            if (consensusDiff) {
              await handleConfirm(consensusDiff.ingredientsText);
            }
          });
        }

        // Handle consolidated list confirmation
        if (confirmBtn) {
          confirmBtn.addEventListener('click', async () => {
            await handleConfirm(ingredientList);
          });
        }
      }

      function openPhotoCapture() {
        const mb = document.getElementById('modalBack');
        const body = document.getElementById('modalBody');
        document.getElementById('modalTitle').textContent = 'Confirm Allergen Information';

        body.innerHTML = `
      <div class="photoCapture">
        <div class="note" style="text-align:center;margin-bottom:8px">Take photos of your current menu to confirm that it aligns with the menu on Clarivore</div>
        <video id="videoStream" class="videoPreview" autoplay playsinline style="display:none"></video>
        <canvas id="photoCanvas" style="display:none"></canvas>
        <div id="photosContainer" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-bottom:12px"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
          <button class="btn btnPrimary" id="startCameraBtn"> Take Photo</button>
          <button class="btn btnPrimary" id="takePictureBtn" style="display:none"> Capture</button>
          <input type="file" id="fileInput" accept="image/*" capture="environment" style="display:none" multiple>
          <button class="btn" id="uploadBtn"> Upload Photos</button>
          <button class="btn btnSuccess" id="doneAddingBtn" style="display:none">Done adding photos</button>
        </div>
        <div id="confirmSection" style="display:none;width:100%;text-align:center">
          <div class="note" style="margin:12px 0 8px">Are all dishes clearly visible in these photos?</div>
          <div style="display:flex;gap:8px;justify-content:center;margin-bottom:12px">
            <button class="btn btnSuccess" id="yesVisibleBtn"> Yes</button>
            <button class="btn btnDanger" id="noVisibleBtn"> No</button>
          </div>
        </div>
        <div id="menuConfirmSection" style="display:none;width:100%;text-align:center">
          <div class="note" style="margin:12px 0 8px">Are these photos of your most current menu?</div>
          <div style="display:flex;gap:8px;justify-content:center">
            <button class="btn btnSuccess" id="confirmPhotoBtn"> Yes, confirm</button>
            <button class="btn btnDanger" id="cancelPhotoBtn"> Cancel</button>
          </div>
        </div>
      </div>
    `;

        mb.style.display = 'flex';
        configureModalClose({
          visible: true, onClick: () => {
            mb.style.display = 'none';
            if (stream) {
              stream.getTracks().forEach(track => track.stop());
              stream = null;
            }
          }
        });

        let stream = null;
        let photoDataArray = [];

        function renderPhotos() {
          const container = document.getElementById('photosContainer');
          container.innerHTML = '';
          photoDataArray.forEach((photoData, idx) => {
            const wrapper = document.createElement('div');
            wrapper.style.cssText = 'position:relative;display:inline-block';
            const img = document.createElement('img');
            img.src = photoData;
            img.style.cssText = 'max-width:120px;max-height:80px;object-fit:cover;border-radius:6px;border:1px solid #2a3466;cursor:pointer';
            img.onclick = () => window.showPhotoPreview(photoData);
            const removeBtn = document.createElement('button');
            removeBtn.textContent = '';
            removeBtn.className = 'btn btnDanger';
            removeBtn.style.cssText = 'position:absolute;top:-8px;right:-8px;width:24px;height:24px;padding:0;min-width:24px;border-radius:50%;font-size:16px;line-height:1';
            removeBtn.onclick = (e) => { e.stopPropagation(); photoDataArray.splice(idx, 1); renderPhotos(); updateButtonStates(); };
            wrapper.appendChild(img);
            wrapper.appendChild(removeBtn);
            container.appendChild(wrapper);
          });
        }

        function updateButtonStates() {
          const doneBtn = document.getElementById('doneAddingBtn');
          const confirmSection = document.getElementById('confirmSection');
          if (photoDataArray.length > 0) {
            doneBtn.style.display = 'inline-flex';
          } else {
            doneBtn.style.display = 'none';
            confirmSection.style.display = 'none';
            document.getElementById('menuConfirmSection').style.display = 'none';
          }
        }

        document.getElementById('startCameraBtn').onclick = async () => {
          try {
            if (!stream) {
              stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
              const video = document.getElementById('videoStream');
              video.srcObject = stream;
            }
            document.getElementById('videoStream').style.display = 'block';
            document.getElementById('startCameraBtn').textContent = ' Take another';
            document.getElementById('takePictureBtn').style.display = 'inline-flex';
          } catch (err) {
            alert('Camera access denied or not available. Please use the upload option.');
          }
        };

        document.getElementById('takePictureBtn').onclick = () => {
          const video = document.getElementById('videoStream');
          const canvas = document.getElementById('photoCanvas');
          const ctx = canvas.getContext('2d');

          const maxWidth = 600;
          const scale = Math.min(1, maxWidth / video.videoWidth);
          canvas.width = video.videoWidth * scale;
          canvas.height = video.videoHeight * scale;

          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          const photoData = canvas.toDataURL('image/jpeg', 0.6);

          console.log('Photo captured, size:', photoData.length, 'bytes');

          photoDataArray.push(photoData);
          renderPhotos();
          updateButtonStates();

          video.style.display = 'none';
          document.getElementById('takePictureBtn').style.display = 'none';
          document.getElementById('startCameraBtn').style.display = 'inline-flex';
        };

        document.getElementById('doneAddingBtn').onclick = () => {
          if (photoDataArray.length === 0) {
            alert('Please add at least one photo.');
            return;
          }
          if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
          }
          document.getElementById('videoStream').style.display = 'none';
          document.getElementById('startCameraBtn').style.display = 'inline-flex';
          document.getElementById('takePictureBtn').style.display = 'none';
          document.getElementById('confirmSection').style.display = 'block';
        };

        document.getElementById('uploadBtn').onclick = () => {
          document.getElementById('fileInput').click();
        };

        document.getElementById('fileInput').onchange = (e) => {
          const files = Array.from(e.target.files);
          let processed = 0;

          files.forEach(file => {
            const reader = new FileReader();
            reader.onload = (ev) => {
              const img = new Image();
              img.onload = () => {
                const canvas = document.getElementById('photoCanvas');
                const ctx = canvas.getContext('2d');

                const maxWidth = 600;
                const scale = Math.min(1, maxWidth / img.width);
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;

                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                const photoData = canvas.toDataURL('image/jpeg', 0.6);

                console.log('Photo uploaded, size:', photoData.length, 'bytes');

                photoDataArray.push(photoData);
                processed++;

                if (processed === files.length) {
                  renderPhotos();
                  updateButtonStates();
                }
              };
              img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
          });

          e.target.value = '';
        };

        document.getElementById('yesVisibleBtn').onclick = () => {
          document.getElementById('confirmSection').style.display = 'none';
          document.getElementById('menuConfirmSection').style.display = 'block';
        };

        document.getElementById('noVisibleBtn').onclick = () => {
          photoDataArray = [];
          renderPhotos();
          updateButtonStates();
          document.getElementById('confirmSection').style.display = 'none';
          document.getElementById('menuConfirmSection').style.display = 'none';
          document.getElementById('startCameraBtn').textContent = ' Take Photo';
        };

        document.getElementById('confirmPhotoBtn').onclick = () => {
          if (photoDataArray.length > 0) {
            send({ type: 'confirmAllergens', photos: photoDataArray, timestamp: new Date().toISOString() });
            const confirmBtn = document.querySelectorAll('.btn.btnDanger')[0];
            if (confirmBtn) {
              confirmBtn.textContent = 'Allergy information confirmed';
              confirmBtn.classList.remove('btnDanger');
              confirmBtn.classList.add('btnSuccess');
            }
            updateLastConfirmedText();
            mb.style.display = 'none';
            if (stream) {
              stream.getTracks().forEach(track => track.stop());
            }
          }
        };

        document.getElementById('cancelPhotoBtn').onclick = () => {
          mb.style.display = 'none';
          if (stream) {
            stream.getTracks().forEach(track => track.stop());
          }
        };
      }

      function openChangeLog() {
        const mb = document.getElementById('modalBack');
        const body = document.getElementById('modalBody');
        document.getElementById('modalTitle').textContent = 'Change Log - ' + esc(rs.name || 'Restaurant');
        configureModalClose({ visible: true, onClick: () => { mb.style.display = 'none'; mb.onclick = null; } });

        send({ type: 'getChangeLog', restaurantId: rs._id || rs.id || null });

        body.innerHTML = `
      <div class="note" style="margin-bottom:12px">Loading change log...</div>
    `;

        mb.style.display = 'flex';

        // Add click handler to close modal when clicking outside
        mb.onclick = (e) => {
          if (e.target === mb) {
            mb.style.display = 'none';
            mb.onclick = null;
          }
        };
      }

      window.displayChangeLog = (logs, errorMsg) => {
        const body = document.getElementById('modalBody');
        if (errorMsg) {
          body.innerHTML = `
        <div class="note" style="color:var(--bad);">${esc(errorMsg)}</div>
        <div style="margin-top:12px;text-align:center">
          <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
        </div>`;
          return;
        }
        const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
        if (Array.isArray(logs) && restaurantId) {
          logs = logs.filter(log => log.restaurantId === restaurantId || log.restaurant_id === restaurantId);
        }
        if (!logs || !logs.length) {
          body.innerHTML = `
        <div class="note">No changes recorded yet.</div>
        <div style="margin-top:12px;text-align:center">
          <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
        </div>`;
          return;
        }

        let html = '';
        logs.forEach(log => {
          html += `<div class="logEntry">
        <div class="logHeader">
          <span class="logTimestamp">${esc(fmtDateTime(log.timestamp))}</span>
        </div>`;
          const parsedChanges = (() => {
            if (!log.changes) return null;
            if (typeof log.changes === 'object') return log.changes;
            if (typeof log.changes === 'string') {
              try { return JSON.parse(log.changes); } catch (_) { return null; }
            }
            return null;
          })();

          if (parsedChanges && (Object.keys(parsedChanges.items || {}).length || (parsedChanges.general || []).length)) {
            let authorName = parsedChanges.author || log.description || '';
            if (authorName.includes(':')) authorName = authorName.split(':')[0];
            if (authorName) {
              html += `<div class="logAuthor">${esc(authorName)}</div>`;
            }
            if (Array.isArray(parsedChanges.general) && parsedChanges.general.length) {
              html += `<ul class="logList">${parsedChanges.general.map(item => `<li>${esc(item)}</li>`).join('')}</ul>`;
            }
            Object.entries(parsedChanges.items || {}).forEach(([itemName, entries]) => {
              html += `<div class="logItem">${esc(itemName)}</div>`;
              if (Array.isArray(entries) && entries.length) {
                html += `<ul class="logList">${entries.map(entry => `<li>${esc(entry)}</li>`).join('')}</ul>`;
              }
            });
          } else {
            let authorLine = log.description || (parsedChanges && parsedChanges.author);
            if (authorLine && authorLine.includes(':')) authorLine = authorLine.split(':')[0];
            if (authorLine) {
              html += `<div class="logAuthor">${esc(authorLine)}</div>`;
            }
            if (log.changes) {
              let changesHtml = esc(typeof log.changes === 'string' ? log.changes : JSON.stringify(log.changes));
              changesHtml = changesHtml.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
              changesHtml = changesHtml.replace(/\n/g, '<br>');
              html += `<div class="note" style="margin-top:8px;font-size:13px;line-height:1.6">${changesHtml}</div>`;
            }
          }
          // Display photos if present (stored as array in database)
          const photos = log.photos || [];
          if (Array.isArray(photos) && photos.length > 0) {
            photos.forEach(photoUrl => {
              const photoEsc = esc(photoUrl).replace(/'/g, '&#39;');
              html += `<img src="${esc(photoUrl)}" class="logThumbnail" onclick="window.showPhotoPreview('${photoEsc}')" alt="Confirmation photo">`;
            });
          }
          // Add restore button if this log entry has overlays data and is an update
          if (log.type === 'update' && log.overlays) {
            const logDataEsc = esc(JSON.stringify({ overlays: log.overlays, menuImage: log.menu_image || log.menuImage })).replace(/'/g, '&#39;');
            html += `<div style="margin-top:12px;text-align:right">
          <button class="btn btnPrimary" onclick="window.restoreFromLog('${logDataEsc}')" style="font-size:0.9rem;padding:6px 12px"> Restore this version</button>
        </div>`;
          }
          html += `</div>`;
        });

        html += `<div style="margin-top:12px;text-align:center">
      <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
    </div>`;

        body.innerHTML = html;
      };

      window.showPhotoPreview = (photoUrl) => {
        const modal = document.getElementById('photoModal');
        const img = document.getElementById('photoModalImage');
        img.src = photoUrl;
        modal.style.display = 'flex';
      };

      window.restoreFromLog = (logDataStr) => {
        try {
          const logData = JSON.parse(logDataStr);
          if (!logData.overlays) {
            alert('This log entry does not contain overlay data.');
            return;
          }

          if (!confirm('Restore overlays from this version? This will replace your current overlays and cannot be undone (but you can use Undo after restoring).')) {
            return;
          }

          // Clear current overlays and load from log
          overlays.splice(0, overlays.length, ...JSON.parse(JSON.stringify(logData.overlays)));

          // Update menu image if it's different
          if (logData.menuImage && logData.menuImage !== rs.menuImage) {
            rs.menuImage = logData.menuImage;
            const img = document.querySelector('.menuImg');
            if (img) img.src = logData.menuImage;
          }

          // Add to pending changes
          pendingChanges.push(`Restored overlays from previous version`);

          // Redraw and mark dirty
          drawAll();
          setDirty(true);
          pushHistory();

          // Close the change log modal
          document.getElementById('modalBack').style.display = 'none';

          alert('Overlays restored successfully! You can use Undo if needed.');
        } catch (err) {
          console.error('Failed to restore from log:', err);
          alert('Failed to restore from this version. The log data may be corrupted.');
        }
      };

      document.getElementById('photoModalClose').onclick = () => {
        document.getElementById('photoModal').style.display = 'none';
      };

      document.getElementById('photoModal').onclick = (e) => {
        if (e.target.id === 'photoModal') {
          document.getElementById('photoModal').style.display = 'none';
        }
      };

      const mb = document.getElementById('modalBack');

      function drawAll() {
        [...inner.querySelectorAll('.editBox')].forEach(n => n.remove());
        const iw = img.clientWidth, ih = img.clientHeight;

        // Filter overlays for current page
        const pageOverlays = overlays.filter((o, idx) => {
          const overlayPageIndex = o.pageIndex !== undefined ? o.pageIndex : 0;
          return overlayPageIndex === currentPageIndex;
        });

        pageOverlays.forEach((it, idx) => {
          // Find original index in full overlays array for proper editing
          const originalIdx = overlays.findIndex(o => o === it);
          const box = document.createElement('div'); box.className = 'editBox';
          Object.assign(box.style, { left: (+it.x) + '%', top: (+it.y) + '%', width: (+it.w) + '%', height: (+it.h) + '%' });

          ['nw', 'ne', 'sw', 'se'].forEach(c => { const h = document.createElement('div'); h.className = 'handle ' + c; box.appendChild(h); h.addEventListener('pointerdown', (e) => startResize(e, c)); });

          const eb = document.createElement('div'); eb.className = 'editBadge'; eb.title = 'Edit this item'; eb.innerHTML = '';
          eb.addEventListener('click', (e) => { e.stopPropagation(); openItemEditor(it, originalIdx >= 0 ? originalIdx : idx); }); box.appendChild(eb);

          let dragging = false, start = {};
          box.addEventListener('pointerdown', (e) => {
            if (e.target.classList.contains('handle') || e.target === eb) return;
            // Set this box as active, remove active from others
            inner.querySelectorAll('.editBox').forEach(b => b.classList.remove('active'));
            box.classList.add('active');
            dragging = true; box.setPointerCapture(e.pointerId);
            start = { x: e.clientX, y: e.clientY, l: box.offsetLeft, t: box.offsetTop, w: box.offsetWidth, h: box.offsetHeight };
          });
          box.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            const nx = Math.max(0, Math.min(iw - start.w, start.l + (e.clientX - start.x)));
            const ny = Math.max(0, Math.min(ih - start.h, start.t + (e.clientY - start.y)));
            const xPct = nx / iw * 100, yPct = ny / ih * 100; it.x = xPct; it.y = yPct; box.style.left = xPct + '%'; box.style.top = yPct + '%';
          });
          box.addEventListener('pointerup', () => { if (dragging) { dragging = false; setDirty(true); pushHistory(); } });

          function startResize(e, corner) {
            e.stopPropagation(); e.preventDefault(); box.setPointerCapture(e.pointerId);
            // Set this box as active when resizing
            inner.querySelectorAll('.editBox').forEach(b => b.classList.remove('active'));
            box.classList.add('active');
            const rect = inner.getBoundingClientRect();
            // Ensure all values are valid numbers, defaulting to current box position if needed
            const safeNum = (v, fallback) => { const n = +v; return isFinite(n) ? n : fallback; };
            const st = {
              x: e.clientX,
              y: e.clientY,
              left: safeNum(it.x, 0),
              top: safeNum(it.y, 0),
              w: safeNum(it.w, 10),
              h: safeNum(it.h, 5)
            };
            const snapThreshold = 0.3;

            function getSnapTargets() {
              const targets = { xEdges: [], yEdges: [] };
              // Only snap to overlays on the same page
              pageOverlays.forEach((other, otherIdx) => {
                if (otherIdx === idx) return;
                targets.xEdges.push(+other.x);
                targets.xEdges.push(+other.x + +other.w);
                targets.yEdges.push(+other.y);
                targets.yEdges.push(+other.y + +other.h);
              });
              return targets;
            }

            function snapValue(val, edges, threshold) {
              for (const edge of edges) {
                if (Math.abs(val - edge) < threshold) return edge;
              }
              return val;
            }

            function onMove(ev) {
              const dx = (ev.clientX - st.x) / rect.width * 100, dy = (ev.clientY - st.y) / rect.height * 100;
              let x = st.left, y = st.top, w = st.w, h = st.h;

              if (corner === 'se') { w = st.w + dx; h = st.h + dy; }
              if (corner === 'ne') { w = st.w + dx; h = st.h - dy; y = st.top + dy; }
              if (corner === 'sw') { w = st.w - dx; h = st.h + dy; x = st.left + dx; }
              if (corner === 'nw') { w = st.w - dx; h = st.h - dy; x = st.left + dx; y = st.top + dy; }

              w = Math.max(1, Math.min(100, w));
              h = Math.max(0.5, Math.min(100, h));
              x = Math.max(0, Math.min(100 - w, x));
              y = Math.max(0, Math.min(100 - h, y));

              const snapTargets = getSnapTargets();
              const right = x + w;
              const bottom = y + h;

              if (corner === 'se') {
                const snappedRight = snapValue(right, snapTargets.xEdges, snapThreshold);
                const snappedBottom = snapValue(bottom, snapTargets.yEdges, snapThreshold);
                if (snappedRight !== right) w = Math.max(1, snappedRight - x);
                if (snappedBottom !== bottom) h = Math.max(0.5, snappedBottom - y);
              }
              else if (corner === 'ne') {
                const snappedRight = snapValue(right, snapTargets.xEdges, snapThreshold);
                const snappedTop = snapValue(y, snapTargets.yEdges, snapThreshold);
                if (snappedRight !== right) w = Math.max(1, snappedRight - x);
                if (snappedTop !== y) {
                  const oldBottom = y + h;
                  y = snappedTop;
                  h = Math.max(0.5, oldBottom - y);
                }
              }
              else if (corner === 'sw') {
                const snappedLeft = snapValue(x, snapTargets.xEdges, snapThreshold);
                const snappedBottom = snapValue(bottom, snapTargets.yEdges, snapThreshold);
                if (snappedLeft !== x) {
                  const oldRight = x + w;
                  x = snappedLeft;
                  w = Math.max(1, oldRight - x);
                }
                if (snappedBottom !== bottom) h = Math.max(0.5, snappedBottom - y);
              }
              else if (corner === 'nw') {
                const snappedLeft = snapValue(x, snapTargets.xEdges, snapThreshold);
                const snappedTop = snapValue(y, snapTargets.yEdges, snapThreshold);
                if (snappedLeft !== x) {
                  const oldRight = x + w;
                  x = snappedLeft;
                  w = Math.max(1, oldRight - x);
                }
                if (snappedTop !== y) {
                  const oldBottom = y + h;
                  y = snappedTop;
                  h = Math.max(0.5, oldBottom - y);
                }
              }

              w = Math.max(1, Math.min(100, w));
              h = Math.max(0.5, Math.min(100, h));
              x = Math.max(0, Math.min(100 - w, x));
              y = Math.max(0, Math.min(100 - h, y));

              it.x = x; it.y = y; it.w = w; it.h = h;
              box.style.left = x + '%'; box.style.top = y + '%'; box.style.width = w + '%'; box.style.height = h + '%';
            }
            function onUp(ev) { box.releasePointerCapture(ev.pointerId); document.removeEventListener('pointermove', onMove); document.removeEventListener('pointerup', onUp); setDirty(true); pushHistory(); }
            document.addEventListener('pointermove', onMove); document.addEventListener('pointerup', onUp);
          }

          box.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
          inner.appendChild(box);
        });
      }

      img.onload = drawAll; if (img.complete) drawAll();
      document.getElementById('addBox').onclick = () => {
        const newOverlay = { id: '', x: 10, y: 10, w: 20, h: 8, allergens: [], removable: [], crossContamination: [], diets: [], details: {}, pageIndex: currentPageIndex };
        overlays.push(newOverlay);
        pendingChanges.push(`${newOverlay.id}: Added overlay`);
        drawAll();
        setDirty(true);
        pushHistory();
      };

      // Detect & Map Dishes - AI-assisted overlay creation
      const detectDishesBtn = document.getElementById('detectDishesBtn');
      if (detectDishesBtn) {
        detectDishesBtn.onclick = async () => {
          const btn = document.getElementById('detectDishesBtn');
          const originalText = btn.textContent;
          btn.disabled = true;
          btn.textContent = ' Detecting dishes...';

          try {
            // Detect all dishes on the menu
            const result = await detectDishesOnMenu(rs.menuImage);

            if (!result.success || !result.dishes || result.dishes.length === 0) {
              alert('Could not detect any dishes on the menu. Please try adding overlays manually.');
              btn.disabled = false;
              btn.textContent = originalText;
              return;
            }

            // Show the detected dishes panel
            const panel = document.getElementById('detectedDishesPanel');
            const currentDishNameEl = document.getElementById('currentDishName');
            const dishProgressEl = document.getElementById('dishProgress');
            const prevBtn = document.getElementById('prevDishBtn');
            const nextBtn = document.getElementById('nextDishBtn');
            const finishBtn = document.getElementById('finishMappingBtn');

            let detectedDishes = result.dishes;
            let currentDishIndex = 0;
            let dragMode = true;
            let dragStart = null;
            let dragPreview = null;

            // Show current dish and update UI
            function showCurrentDish() {
              const mapped = detectedDishes.filter(d => d.mapped).length;
              const total = detectedDishes.length;

              // Check if all done
              if (mapped >= total) {
                currentDishNameEl.textContent = 'All items mapped!';
                dishProgressEl.textContent = `${mapped} of ${total} items mapped`;
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
                finishBtn.style.display = 'inline-flex';
                menu.style.cursor = '';
                dragMode = false;
                return;
              }

              const dish = detectedDishes[currentDishIndex];
              currentDishNameEl.textContent = dish.name;
              dishProgressEl.textContent = `Item ${currentDishIndex + 1} of ${total} (${mapped} mapped)`;

              // Update button states
              prevBtn.disabled = currentDishIndex <= 0;
              nextBtn.disabled = currentDishIndex >= total - 1;
              finishBtn.style.display = mapped > 0 ? 'inline-flex' : 'none';

              menu.style.cursor = 'crosshair';
              panel.style.display = 'block';
              dragMode = true;
            }

            // Previous dish
            prevBtn.onclick = () => {
              if (currentDishIndex > 0) {
                currentDishIndex--;
                showCurrentDish();
              }
            };

            // Next dish
            nextBtn.onclick = () => {
              if (currentDishIndex < detectedDishes.length - 1) {
                currentDishIndex++;
                showCurrentDish();
              }
            };

            // Finish mapping
            finishBtn.onclick = () => {
              panel.style.display = 'none';
              menu.style.cursor = '';
              dragMode = false;
              drawAll();
            };

            showCurrentDish();

            // Handle drag-to-create overlay
            function handleDragStart(e) {
              if (!dragMode) return;

              const rect = img.getBoundingClientRect();
              const x = ((e.clientX - rect.left) / rect.width) * 100;
              const y = ((e.clientY - rect.top) / rect.height) * 100;

              dragStart = { x, y };

              // Create preview element
              dragPreview = document.createElement('div');
              dragPreview.style.cssText = 'position:absolute;border:2px dashed #4CAF50;background:rgba(76,175,80,0.2);pointer-events:none;z-index:1000';
              inner.appendChild(dragPreview);

              e.preventDefault();
            }

            function handleDragMove(e) {
              if (!dragStart || !dragPreview) return;

              const rect = img.getBoundingClientRect();
              const x = ((e.clientX - rect.left) / rect.width) * 100;
              const y = ((e.clientY - rect.top) / rect.height) * 100;

              const minX = Math.min(dragStart.x, x);
              const minY = Math.min(dragStart.y, y);
              const maxX = Math.max(dragStart.x, x);
              const maxY = Math.max(dragStart.y, y);

              dragPreview.style.left = minX + '%';
              dragPreview.style.top = minY + '%';
              dragPreview.style.width = (maxX - minX) + '%';
              dragPreview.style.height = (maxY - minY) + '%';

              e.preventDefault();
            }

            function handleDragEnd(e) {
              if (!dragStart || !dragPreview) return;

              const rect = img.getBoundingClientRect();
              const x = ((e.clientX - rect.left) / rect.width) * 100;
              const y = ((e.clientY - rect.top) / rect.height) * 100;

              const minX = Math.min(dragStart.x, x);
              const minY = Math.min(dragStart.y, y);
              const maxX = Math.max(dragStart.x, x);
              const maxY = Math.max(dragStart.y, y);

              const w = maxX - minX;
              const h = maxY - minY;

              // Only create overlay if drag was meaningful (at least 1% width/height)
              if (w > 1 && h > 1) {
                const dish = detectedDishes[currentDishIndex];

                // Create new overlay
                const newOverlay = {
                  id: dish.name,
                  x: minX,
                  y: minY,
                  w: w,
                  h: h,
                  allergens: [],
                  removable: [],
                  crossContamination: [],
                  diets: [],
                  details: {},
                  pageIndex: currentPageIndex
                };

                overlays.push(newOverlay);
                pendingChanges.push(`${newOverlay.id}: Added overlay manually`);

                // Mark dish as mapped
                dish.mapped = true;

                drawAll();
                setDirty(true);
                pushHistory();
                showCurrentDish();
              }

              // Clean up
              if (dragPreview && dragPreview.parentNode) {
                dragPreview.parentNode.removeChild(dragPreview);
              }
              dragPreview = null;
              dragStart = null;

              e.preventDefault();
            }

            // Add drag handlers to menu image
            img.addEventListener('mousedown', handleDragStart);
            img.addEventListener('mousemove', handleDragMove);
            img.addEventListener('mouseup', handleDragEnd);
            img.addEventListener('mouseleave', handleDragEnd);

            btn.textContent = ' Dishes Detected';

          } catch (err) {
            console.error('Detect dishes error:', err);
            alert('Failed to detect dishes: ' + err.message);
            btn.disabled = false;
            btn.textContent = originalText;
          }
        };
      }

      // Zoom controls
      let zoomScale = 1.0;
      const zoomStep = 0.25;
      const minZoom = 0.5;
      const maxZoom = 3.0;

      function updateZoom() {
        const inner = menu.querySelector('.menuInner');
        const zoomLevelEl = document.getElementById('zoomLevel');

        inner.style.transform = `scale(${zoomScale})`;
        inner.style.transformOrigin = 'top left';

        // Don't set explicit width/height on menu container
        // Let it size naturally based on image and transform
        if (zoomScale !== 1.0) {
          const displayWidth = img.clientWidth;
          const displayHeight = img.clientHeight;
          menu.style.width = `${displayWidth * zoomScale}px`;
          menu.style.height = `${displayHeight * zoomScale}px`;
        } else {
          menu.style.width = '';
          menu.style.height = '';
        }
        menu.style.overflow = 'auto';

        zoomLevelEl.textContent = `${Math.round(zoomScale * 100)}%`;

        // Update button states
        document.getElementById('zoomOutBtn').disabled = zoomScale <= minZoom;
        document.getElementById('zoomInBtn').disabled = zoomScale >= maxZoom;
      }

      function initializeZoom() {
        // Just set zoom to 1.0 and update
        zoomScale = 1.0;
        updateZoom();
      }

      document.getElementById('zoomInBtn').onclick = () => {
        if (zoomScale < maxZoom) {
          zoomScale = Math.min(maxZoom, zoomScale + zoomStep);
          updateZoom();
        }
      };

      document.getElementById('zoomOutBtn').onclick = () => {
        if (zoomScale > minZoom) {
          zoomScale = Math.max(minZoom, zoomScale - zoomStep);
          updateZoom();
        }
      };

      document.getElementById('zoomResetBtn').onclick = () => {
        zoomScale = 1.0;
        updateZoom();
      };

      // Initialize zoom on image load
      img.onload = () => {
        initializeZoom();
        drawAll();
      };

      // If image already loaded, initialize now
      if (img.complete) {
        initializeZoom();
      }

      // Function to switch to a different menu page
      function switchMenuPage(pageIndex) {
        if (pageIndex < 0 || pageIndex >= menuImages.length) return;

        currentPageIndex = pageIndex;
        const menuImg = document.querySelector('.menuImg');
        if (menuImg) {
          menuImg.src = menuImages[pageIndex] || '';
        }

        // Update navigation UI
        updateMenuNavigationUI();

        // Update top navigation buttons
        const prevBtn = document.getElementById('prevPageBtn');
        const nextBtn = document.getElementById('nextPageBtn');
        if (prevBtn) {
          prevBtn.disabled = pageIndex === 0;
          if (pageIndex === 0) {
            prevBtn.style.opacity = '0.5';
            prevBtn.style.cursor = 'not-allowed';
          } else {
            prevBtn.style.opacity = '1';
            prevBtn.style.cursor = 'pointer';
          }
        }
        if (nextBtn) {
          nextBtn.disabled = pageIndex >= menuImages.length - 1;
          if (pageIndex >= menuImages.length - 1) {
            nextBtn.style.opacity = '0.5';
            nextBtn.style.cursor = 'not-allowed';
          } else {
            nextBtn.style.opacity = '1';
            nextBtn.style.cursor = 'pointer';
          }
        }

        // Update bottom navigation buttons - REMOVED

        // Re-render overlays for current page (only overlays with matching pageIndex)
        drawAll();
      }

      // Page navigation handlers (top buttons)
      const prevPageBtn = document.getElementById('prevPageBtn');
      const nextPageBtn = document.getElementById('nextPageBtn');
      if (prevPageBtn) {
        prevPageBtn.onclick = () => {
          if (currentPageIndex > 0) {
            switchMenuPage(currentPageIndex - 1);
          }
        };
      }
      if (nextPageBtn) {
        nextPageBtn.onclick = () => {
          if (currentPageIndex < menuImages.length - 1) {
            switchMenuPage(currentPageIndex + 1);
          }
        };
      }

      // Bottom listeners removed


      // Keyboard navigation support (arrow keys)
      const handleEditorKeyDown = (e) => {
        // Only handle if not typing in an input/textarea
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
          return;
        }

        if (e.key === 'ArrowLeft' && currentPageIndex > 0) {
          e.preventDefault();
          switchMenuPage(currentPageIndex - 1);
        } else if (e.key === 'ArrowRight' && currentPageIndex < menuImages.length - 1) {
          e.preventDefault();
          switchMenuPage(currentPageIndex + 1);
        }
      };

      document.addEventListener('keydown', handleEditorKeyDown);

      // --- Document Scanner Logic ---

      async function detectCorners(imageData, width, height) {
        try {
          const result = await window.supabaseClient.functions.invoke('detect-corners', {
            body: { image: imageData, width, height }
          });
          if (result.error) throw result.error;

          let c = result.data;
          // CLAMP coordinates to 0-1000 to prevent off-screen handles
          const clamp = (v) => Math.max(0, Math.min(1000, v));
          if (c && c.topLeft) {
            c.topLeft.x = clamp(c.topLeft.x); c.topLeft.y = clamp(c.topLeft.y);
            c.topRight.x = clamp(c.topRight.x); c.topRight.y = clamp(c.topRight.y);
            c.bottomRight.x = clamp(c.bottomRight.x); c.bottomRight.y = clamp(c.bottomRight.y);
            c.bottomLeft.x = clamp(c.bottomLeft.x); c.bottomLeft.y = clamp(c.bottomLeft.y);
          }
          return c;
        } catch (e) {
          console.error("Corner detection failed:", e);
          // Fallback: return corners matching the image bounds
          return null;
        }
      }

      function warpImage(img, corners) {
        return new Promise((resolve) => {
          // Ensure OpenCV is loaded
          if (typeof cv === 'undefined') {
            console.error("OpenCV not loaded");
            resolve(null);
            return;
          }

          try {
            const src = cv.imread(img);
            const dst = new cv.Mat();

            // Corners are 0-1000 scale. Map to image dimensions.
            const w = img.width;
            const h = img.height;
            const map = (pt) => ({ x: (pt.x / 1000) * w, y: (pt.y / 1000) * h });

            const tl = map(corners.topLeft);
            const tr = map(corners.topRight);
            const br = map(corners.bottomRight);
            const bl = map(corners.bottomLeft);

            // Calculate destination dimensions (max width/height)
            const widthA = Math.sqrt(((br.x - bl.x) ** 2) + ((br.y - bl.y) ** 2));
            const widthB = Math.sqrt(((tr.x - tl.x) ** 2) + ((tr.y - tl.y) ** 2));
            const maxWidth = Math.max(widthA, widthB);

            const heightA = Math.sqrt(((tr.x - br.x) ** 2) + ((tr.y - br.y) ** 2));
            const heightB = Math.sqrt(((tl.x - bl.x) ** 2) + ((tl.y - bl.y) ** 2));
            const maxHeight = Math.max(heightA, heightB);

            const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y]);
            const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, maxWidth, 0, maxWidth, maxHeight, 0, maxHeight]);

            const M = cv.getPerspectiveTransform(srcTri, dstTri);
            cv.warpPerspective(src, dst, M, new cv.Size(maxWidth, maxHeight));

            // Convert back to canvas/dataURL
            const outCanvas = document.createElement('canvas');
            cv.imshow(outCanvas, dst);
            const outData = outCanvas.toDataURL('image/jpeg', 0.9);

            // Cleanup
            src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();

            resolve(outData);
          } catch (e) {
            console.error("Warp failed:", e);
            resolve(null);
          }
        });
      }

      function showCornerEditor(imageData, initialCorners, options = {}) {
        const debugMeta = options.debugMeta || null;
        const mapForWarp = options.mapForWarp || null;
        const warpImageData = options.warpImageData || imageData;
        return new Promise((resolve) => {
          // Create UI
          const modal = document.createElement('div');
          modal.className = 'modalBack';
          modal.style.cssText = 'display:flex;z-index:10002;background:rgba(0,0,0,0.9);align-items:center;justify-content:center;';

          const container = document.createElement('div');
          container.style.cssText = 'position:relative;max-width:90vw;max-height:80vh;background:#111;padding:20px;border-radius:12px;text-align:center;box-shadow:0 0 20px rgba(0,0,0,0.5);';

          const title = document.createElement('h3');
          title.innerText = 'Adjust Crop';
          title.style.color = '#fff';
          container.appendChild(title);

          const instr = document.createElement('p');
          instr.innerText = 'Drag green corners to match the menu board.';
          instr.style.color = '#ccc';
          container.appendChild(instr);

          // Canvas container
          const canvasBox = document.createElement('div');
          canvasBox.style.cssText = 'position:relative;display:inline-block;margin:10px 0;border:1px solid #333;max-width:100%;';
          container.appendChild(canvasBox);

          const canvas = document.createElement('canvas');
          canvas.style.maxWidth = '100%'; // Ensure it fits in the modal
          canvas.style.height = 'auto';
          canvasBox.appendChild(canvas);
          const ctx = canvas.getContext('2d');

          const img = new Image();
          let corners = initialCorners || {
            topLeft: { x: 100, y: 100 }, topRight: { x: 900, y: 100 },
            bottomRight: { x: 900, y: 900 }, bottomLeft: { x: 100, y: 900 }
          };

          // Load image and setup canvas
          img.onload = () => {
            // Shrink for display if huge
            const maxDisp = 800;
            const scale = Math.min(1, maxDisp / img.width, maxDisp / img.height);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;

            // Draw loop
            const draw = () => {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

              // Draw lines
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.strokeStyle = '#00ff00';
              const pt = (c) => ({ x: (c.x / 1000) * canvas.width, y: (c.y / 1000) * canvas.height });
              const tl = pt(corners.topLeft);
              const tr = pt(corners.topRight);
              const br = pt(corners.bottomRight);
              const bl = pt(corners.bottomLeft);

              ctx.moveTo(tl.x, tl.y); ctx.lineTo(tr.x, tr.y);
              ctx.lineTo(br.x, br.y); ctx.lineTo(bl.x, bl.y);
              ctx.lineTo(tl.x, tl.y);
              ctx.stroke();

              // Draw handles
              [tl, tr, br, bl].forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#00ff00';
                ctx.fill();
                ctx.stroke();
              });
            };
            draw();

            // Interaction
            let dragging = null;

            // Use consistent mouse/touch handling logic
            const getPos = (e) => {
              const rect = canvas.getBoundingClientRect(); // Visual dimensions
              const clientX = e.touches ? e.touches[0].clientX : e.clientX;
              const clientY = e.touches ? e.touches[0].clientY : e.clientY;

              // Map visual pixels to 0-1000 scale
              const x = (clientX - rect.left) / rect.width * 1000;
              const y = (clientY - rect.top) / rect.height * 1000;
              return { x, y };
            }

            const handleStart = (e) => {
              const { x, y } = getPos(e);
              const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);

              // Hit test radius in 0-1000 scale (approx 30 units = ~3%)
              if (dist({ x, y }, corners.topLeft) < 50) dragging = 'topLeft';
              else if (dist({ x, y }, corners.topRight) < 50) dragging = 'topRight';
              else if (dist({ x, y }, corners.bottomRight) < 50) dragging = 'bottomRight';
              else if (dist({ x, y }, corners.bottomLeft) < 50) dragging = 'bottomLeft';
            };

            const handleMove = (e) => {
              if (!dragging) return;
              e.preventDefault(); // Stop scrolling while dragging
              let { x, y } = getPos(e);
              // Clamp
              x = Math.max(0, Math.min(1000, x));
              y = Math.max(0, Math.min(1000, y));

              corners[dragging] = { x, y };
              draw();
            };

            const handleEnd = () => dragging = null;

            canvas.onmousedown = handleStart;
            window.onmousemove = handleMove;
            window.onmouseup = handleEnd;

            canvas.ontouchstart = handleStart;
            window.ontouchmove = handleMove;
            window.ontouchend = handleEnd;
          };
          img.src = imageData;

          // Buttons
          const btnRow = document.createElement('div');
          btnRow.style.marginTop = '15px';

          const confirmBtn = document.createElement('button');
          confirmBtn.innerText = 'Confirm & Crop';
          confirmBtn.className = 'confirm-btn'; // styling from existing css
          confirmBtn.style.cssText = 'background:#22c55e;color:white;padding:10px 20px;border:none;border-radius:6px;cursor:pointer;font-weight:bold;margin-left:10px;';

          const skipBtn = document.createElement('button');
          skipBtn.innerText = 'Skip (Use Original)';
          skipBtn.style.cssText = 'background:#334;color:#ccc;padding:10px 20px;border:none;border-radius:6px;cursor:pointer;';

          skipBtn.onclick = () => {
            document.body.removeChild(modal);
            resolve(null); // Return null to indicate no-warp
          };

          const resetBtn = document.createElement('button');
          resetBtn.innerText = 'Reset to Full';
          resetBtn.style.cssText = 'background:#4c5ad4;color:white;padding:10px 20px;border:none;border-radius:6px;cursor:pointer;margin-left:10px;';
          resetBtn.onclick = () => {
            corners.topLeft = { x: 50, y: 50 };
            corners.topRight = { x: 950, y: 50 };
            corners.bottomRight = { x: 950, y: 950 };
            corners.bottomLeft = { x: 50, y: 950 };
            draw();
          };

          confirmBtn.onclick = () => {
            const cornerImg = document.createElement('img');
            cornerImg.src = warpImageData;
            cornerImg.onload = async () => {
              document.body.removeChild(modal);
              // Optionally map corners before warping (e.g., from letterboxed square to original image)
              const cornersToUse = mapForWarp ? mapForWarp(corners) : corners;
              const warped = await warpImage(cornerImg, cornersToUse);
              resolve(warped);
            };
          };

          btnRow.appendChild(skipBtn);
          btnRow.appendChild(resetBtn); // Add Reset option
          btnRow.appendChild(confirmBtn);
          container.appendChild(btnRow);

          modal.appendChild(container);
          document.body.appendChild(modal);
        });
      }


      // Helper to resize image for Claude API - EXACTLY like getNormalizedImage used for dish detection
      // Creates a 1000x1000 letterboxed image so AI's 0-1000 scale maps directly to pixels
      function resizeImageForAI(dataUrl) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            // CRITICAL: Use exactly 1000x1000 so AI's 0-1000 scale = actual pixels
            canvas.width = 1000;
            canvas.height = 1000;
            const ctx = canvas.getContext('2d');

            // Fill black (same as dish detection)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 1000, 1000);

            // Calculate scale to fit (same as dish detection)
            const scale = Math.min(1000 / img.width, 1000 / img.height);
            const w = img.width * scale;
            const h = img.height * scale;
            const x = (1000 - w) / 2;
            const y = (1000 - h) / 2;

            ctx.drawImage(img, x, y, w, h);

            // Return metrics in pixels on the 1000x1000 canvas (same as dish detection)
            resolve({
              data: canvas.toDataURL('image/jpeg', 0.85),
              width: 1000,
              height: 1000,
              // Metrics for coordinate transformation (pixel values on 1000px canvas)
              scaledW: w,
              scaledH: h,
              offsetX: x,
              offsetY: y
            });
          };
          img.src = dataUrl;
        });
      }

      // Function to process a single image file (Modified for Scanner Flow)
      function processImageFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = async (ev) => {
            const originalData = ev.target.result;

            console.log("Detecting corners...");

            // Resize specifically for the AI detection step
            const aiInfo = await resizeImageForAI(originalData);
            const aiResult = await detectCorners(aiInfo.data, aiInfo.width, aiInfo.height);

            if (aiResult) {
              // Transform AI corners from 1000x1000 letterboxed canvas to original image (0-1000 scale)
              // Same approach as dish detection's mapCoord but returning 0-1000 instead of 0-100
              const mapCoord = (val, padding, dim) => {
                // val: 0-1000 from AI (pixel position on 1000px canvas)
                // padding: pixel offset where image content starts
                // dim: pixel dimension of image content on canvas
                // Returns: 0-1000 position on original image
                const relativePos = (val - padding) / dim; // 0-1 relative position
                return Math.max(0, Math.min(1000, relativePos * 1000));
              };

              const unmapCorner = (p) => ({
                x: mapCoord(p.x, aiInfo.offsetX, aiInfo.scaledW),
                y: mapCoord(p.y, aiInfo.offsetY, aiInfo.scaledH)
              });

              const mappedCorners = {
                topLeft: unmapCorner(aiResult.topLeft || { x: 0, y: 0 }),
                topRight: unmapCorner(aiResult.topRight || { x: 1000, y: 0 }),
                bottomRight: unmapCorner(aiResult.bottomRight || { x: 1000, y: 1000 }),
                bottomLeft: unmapCorner(aiResult.bottomLeft || { x: 0, y: 1000 }),
                description: aiResult.description
              };

              console.log('CornerDetect Debug:', {
                aiInfo,
                rawCorners: aiResult,
                mappedCorners
              });

              // Show corners on the ORIGINAL image using the raw AI corners; keep raw AI dots for debug
              const warpedData = await showCornerEditor(
                originalData,
                mappedCorners,
                {
                  debugMeta: { aiInfo, aiCornersRaw: aiResult }
                }
              );
              if (warpedData) {
                resolve(warpedData);
                return;
              }
            }

            // Fallback
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');

              // Resize image to max 1200px wide while maintaining aspect ratio
              const maxWidth = 1200;
              const scale = Math.min(1, maxWidth / img.width);
              canvas.width = img.width * scale;
              canvas.height = img.height * scale;

              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              const imageData = canvas.toDataURL('image/jpeg', 0.85);
              resolve(imageData);
            };
            img.onerror = reject;
            img.src = originalData;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }


      // Function to show preview modal
      function showMenuPreviewModal(imageData, pageNumber) {
        // Add current image to pending images if not already added
        if (currentUploadIndex >= 0 && currentUploadIndex < pendingMenuImages.length) {
          // Replacing existing page - already in pendingMenuImages
          // (Note: in current implementation, processImageFile returns data, we haven't actually updated the array yet? 
          // Wait, handleMenuImageData calls this. If we are replacing, we need to update the array!)
          // Actually, handleMenuImageData doesn't handle replacement logic, it just passes imageData.
          // Let's assume for now we just track the index.
          pendingMenuImages[currentUploadIndex] = imageData; // Ensure it's updated
          lastUploadedIndex = currentUploadIndex;
        } else {
          // Adding new page - add to pendingMenuImages
          pendingMenuImages.push(imageData);
          lastUploadedIndex = pendingMenuImages.length - 1;
        }

        const modal = document.createElement('div');
        modal.className = 'modalBack';
        modal.style.display = 'flex';
        modal.style.zIndex = '10000';

        const modalContent = document.createElement('div');
        modalContent.className = 'modal';
        modalContent.style.cssText = 'max-width:90vw;max-height:90vh;overflow:auto;background:#0f1534;border:1px solid #2a3466;border-radius:14px;padding:24px';

        // Current image index (the one being previewed)
        let currentImageIndex = currentUploadIndex >= 0 ? currentUploadIndex : pendingMenuImages.length - 1;

        // Create thumbnails for all pending images
        const thumbnailsHTML = pendingMenuImages.map((img, idx) => `
      <div class="preview-thumbnail" data-index="${idx}" style="
        position: relative;
        cursor: pointer;
        border: 3px solid ${idx === currentImageIndex ? '#4c5ad4' : 'rgba(76,90,212,0.3)'};
        border-radius: 8px;
        overflow: hidden;
        background: rgba(76,90,212,0.1);
        transition: all 0.2s;
        ${idx === currentImageIndex ? 'box-shadow: 0 0 0 2px rgba(76,90,212,0.5);' : ''}
      ">
        <button class="preview-remove-thumbnail" data-index="${idx}" style="
          position: absolute;
          top: 4px;
          right: 4px;
          width: 24px;
          height: 24px;
          border-radius: 50%;
          background: rgba(220, 38, 38, 0.9);
          border: 2px solid white;
          color: white;
          font-size: 14px;
          font-weight: bold;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10;
          transition: all 0.2s;
          padding: 0;
        " title="Remove page ${idx + 1}" onclick="event.stopPropagation();"></button>
        <img src="${img}" alt="Page ${idx + 1}" style="
          width: 100px;
          height: 100px;
          object-fit: cover;
          display: block;
        ">
        <div style="
          position: absolute;
          bottom: 0;
          left: 0;
          right: 0;
          background: ${idx === currentImageIndex ? 'rgba(76,90,212,0.9)' : 'rgba(0,0,0,0.7)'};
          color: white;
          text-align: center;
          padding: 4px;
          font-size: 0.75rem;
          font-weight: 600;
        ">Page ${idx + 1}</div>
      </div>
    `).join('');

        modalContent.innerHTML = `
      <div style="text-align:center;margin-bottom:20px">
        <h3 style="margin:0 0 12px 0;color:#e9ecff;font-size:1.3rem">Menu Pages Preview</h3>
        <p style="margin:0;color:#a8b2d6;font-size:0.95rem">Review all pages before saving (${pendingMenuImages.length} ${pendingMenuImages.length === 1 ? 'page' : 'pages'})</p>
      </div>
      
      ${pendingMenuImages.length > 1 ? `
        <div style="margin-bottom:20px;padding:16px;background:rgba(76,90,212,0.1);border-radius:8px">
          <div style="color:#a8b2d6;font-size:0.9rem;margin-bottom:12px;text-align:center">All Menu Pages (click to view)</div>
          <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap" id="previewThumbnails">
            ${thumbnailsHTML}
          </div>
        </div>
      ` : ''}
      
      <div style="text-align:center;margin-bottom:24px;position:relative">

        <img id="previewMainImage" src="${pendingMenuImages[currentImageIndex]}" alt="Menu page preview" style="max-width:100%;max-height:60vh;border-radius:8px;border:2px solid rgba(76,90,212,0.5);box-shadow:0 4px 12px rgba(0,0,0,0.3)">
        ${pendingMenuImages.length > 1 ? `
          <div style="display:flex;justify-content:center;align-items:center;gap:16px;margin-top:16px">
            <button id="previewPrevBtn" style="
              padding: 10px 20px;
              background: ${currentImageIndex === 0 ? 'rgba(76,90,212,0.2)' : '#4c5ad4'};
              border: 2px solid ${currentImageIndex === 0 ? 'rgba(76,90,212,0.4)' : '#4c5ad4'};
              border-radius: 8px;
              color: white;
              font-size: 1rem;
              font-weight: 600;
              cursor: ${currentImageIndex === 0 ? 'not-allowed' : 'pointer'};
              transition: all 0.2s;
              opacity: ${currentImageIndex === 0 ? 0.5 : 1};
            " ${currentImageIndex === 0 ? 'disabled' : ''}> Previous</button>
            <div id="previewPageIndicator" style="color:#a8b2d6;font-size:1rem;font-weight:600;min-width:120px">Page ${currentImageIndex + 1} of ${pendingMenuImages.length}</div>
            <button id="previewNextBtn" style="
              padding: 10px 20px;
              background: ${currentImageIndex >= pendingMenuImages.length - 1 ? 'rgba(76,90,212,0.2)' : '#4c5ad4'};
              border: 2px solid ${currentImageIndex >= pendingMenuImages.length - 1 ? 'rgba(76,90,212,0.4)' : '#4c5ad4'};
              border-radius: 8px;
              color: white;
              font-size: 1rem;
              font-weight: 600;
              cursor: ${currentImageIndex >= pendingMenuImages.length - 1 ? 'not-allowed' : 'pointer'};
              transition: all 0.2s;
              opacity: ${currentImageIndex >= pendingMenuImages.length - 1 ? 0.5 : 1};
            " ${currentImageIndex >= pendingMenuImages.length - 1 ? 'disabled' : ''}>Next </button>
          </div>
        ` : `
          <div id="previewPageIndicator" style="margin-top:12px;color:#a8b2d6;font-size:0.95rem">Page ${currentImageIndex + 1} of ${pendingMenuImages.length}</div>
        `}
      </div>
      <div style="display:flex;gap:12px;justify-content:center">
        <button class="btn" id="previewAddAnotherBtn" style="padding:12px 24px;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)"> Add Another Page</button>
        <button class="btn btnPrimary" id="previewSaveBtn" style="padding:12px 24px"> Save All ${pendingMenuImages.length} ${pendingMenuImages.length === 1 ? 'Page' : 'Pages'}</button>
      </div>
      `;

        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        // Function to remove a page and refresh the modal
        const removePage = (pageIndex) => {
          if (pendingMenuImages.length <= 1) {
            alert('Cannot remove the last page. Please add another page first or cancel the upload.');
            return;
          }

          // Remove the page from pending images
          pendingMenuImages.splice(pageIndex, 1);

          // Calculate new current index after removal
          let newCurrentIndex = currentImageIndex;
          if (currentImageIndex >= pendingMenuImages.length) {
            newCurrentIndex = pendingMenuImages.length - 1;
          } else if (currentImageIndex > pageIndex) {
            newCurrentIndex = currentImageIndex - 1;
          } else if (currentImageIndex === pageIndex) {
            // If we removed the current page, show the previous one (or first if it was the first)
            newCurrentIndex = Math.max(0, pageIndex - 1);
          }

          // Update currentUploadIndex
          if (currentUploadIndex === pageIndex) {
            currentUploadIndex = -1;
          } else if (currentUploadIndex > pageIndex) {
            currentUploadIndex--;
          }

          // Re-render the modal with updated data
          cleanupKeyboardHandler();
          document.body.removeChild(modal);
          // Set currentUploadIndex to the new index so the modal shows the correct page
          const savedCurrentUploadIndex = currentUploadIndex;
          currentUploadIndex = newCurrentIndex;
          showMenuPreviewModal(pendingMenuImages[newCurrentIndex] || pendingMenuImages[0], newCurrentIndex + 1);
          currentUploadIndex = savedCurrentUploadIndex; // Restore original value
        };

        // Function to switch to a different page
        const switchPage = (newIndex) => {
          if (newIndex < 0 || newIndex >= pendingMenuImages.length) return;

          currentImageIndex = newIndex;
          currentUploadIndex = newIndex;

          // Update main image
          const mainImage = modalContent.querySelector('#previewMainImage');
          if (mainImage) {
            mainImage.src = pendingMenuImages[newIndex];
          }

          // Update page indicator
          const pageIndicator = modalContent.querySelector('#previewPageIndicator');
          if (pageIndicator) {
            pageIndicator.textContent = `Page ${newIndex + 1} of ${pendingMenuImages.length} `;
          }

          // Update thumbnail borders
          const thumbnails = modalContent.querySelectorAll('.preview-thumbnail');
          thumbnails.forEach((thumb, idx) => {
            if (idx === newIndex) {
              thumb.style.border = '3px solid #4c5ad4';
              thumb.style.boxShadow = '0 0 0 2px rgba(76,90,212,0.5)';
            } else {
              thumb.style.border = '3px solid rgba(76,90,212,0.3)';
              thumb.style.boxShadow = 'none';
            }
          });

          // Update navigation buttons
          const prevBtn = modalContent.querySelector('#previewPrevBtn');
          const nextBtn = modalContent.querySelector('#previewNextBtn');

          if (prevBtn) {
            const isFirst = newIndex === 0;
            prevBtn.disabled = isFirst;
            prevBtn.style.background = isFirst ? 'rgba(76,90,212,0.2)' : '#4c5ad4';
            prevBtn.style.borderColor = isFirst ? 'rgba(76,90,212,0.4)' : '#4c5ad4';
            prevBtn.style.cursor = isFirst ? 'not-allowed' : 'pointer';
            prevBtn.style.opacity = isFirst ? '0.5' : '1';
          }

          if (nextBtn) {
            const isLast = newIndex >= pendingMenuImages.length - 1;
            nextBtn.disabled = isLast;
            nextBtn.style.background = isLast ? 'rgba(76,90,212,0.2)' : '#4c5ad4';
            nextBtn.style.borderColor = isLast ? 'rgba(76,90,212,0.4)' : '#4c5ad4';
            nextBtn.style.cursor = isLast ? 'not-allowed' : 'pointer';
            nextBtn.style.opacity = isLast ? '0.5' : '1';
          }
        };

        // Handle thumbnail clicks to switch preview image
        const thumbnails = modalContent.querySelectorAll('.preview-thumbnail');
        thumbnails.forEach((thumb, idx) => {
          thumb.onclick = (e) => {
            // Don't switch if clicking the remove button
            if (e.target.classList.contains('preview-remove-thumbnail')) {
              return;
            }

            switchPage(idx);
          };
        });

        // Handle Previous button
        const prevBtn = modalContent.querySelector('#previewPrevBtn');
        if (prevBtn) {
          prevBtn.onclick = () => {
            if (currentImageIndex > 0) {
              switchPage(currentImageIndex - 1);
            }
          };
        }

        // Handle Next button
        const nextBtn = modalContent.querySelector('#previewNextBtn');
        if (nextBtn) {
          nextBtn.onclick = () => {
            if (currentImageIndex < pendingMenuImages.length - 1) {
              switchPage(currentImageIndex + 1);
            }
          };
        }

        // Handle remove buttons on thumbnails
        const removeThumbnailBtns = modalContent.querySelectorAll('.preview-remove-thumbnail');
        removeThumbnailBtns.forEach((btn) => {
          btn.onclick = (e) => {
            e.stopPropagation();
            const pageIndex = parseInt(btn.dataset.index);
            removePage(pageIndex);
          };
        });

        // Handle remove button on main preview
        const removeCurrentBtn = modalContent.querySelector('#previewRemoveCurrentBtn');
        if (removeCurrentBtn) {
          removeCurrentBtn.onclick = () => {
            removePage(currentImageIndex);
          };
        }

        // Handle keyboard navigation (arrow keys)
        const handleKeyDown = (e) => {
          if (e.key === 'ArrowLeft' && currentImageIndex > 0) {
            e.preventDefault();
            switchPage(currentImageIndex - 1);
          } else if (e.key === 'ArrowRight' && currentImageIndex < pendingMenuImages.length - 1) {
            e.preventDefault();
            switchPage(currentImageIndex + 1);
          }
        };

        // Clean up keyboard listener when closing
        const cleanupKeyboardHandler = () => {
          document.removeEventListener('keydown', handleKeyDown);
        };

        document.addEventListener('keydown', handleKeyDown);

        // Handle save button
        const saveBtn = modalContent.querySelector('#previewSaveBtn');
        saveBtn.onclick = async () => {
          // Change button text to indicate loading
          const originalBtnText = saveBtn.textContent;
          saveBtn.textContent = 'Processing...';
          saveBtn.disabled = true;

          try {
            // Capture old images before update to detect changes
            const oldMenuImages = [...menuImages];
            const pagesToProcess = [];

            // Detect changed or new pages
            // We iterate over pendingMenuImages because that's the desired final state
            for (let i = 0; i < pendingMenuImages.length; i++) {
              const oldImg = i < oldMenuImages.length ? oldMenuImages[i] : null;
              const newImg = pendingMenuImages[i];

              if (oldImg !== newImg || i === lastUploadedIndex) {
                // Image changed, is new, OR was explicitly just uploaded (force re-scan)
                const pageOverlays = overlays.filter(o => {
                  const pIdx = o.pageIndex !== undefined ? o.pageIndex : 0;
                  return pIdx === i;
                });

                // Create a 1000x1000 normalized version of the image (Letterboxed) for consistent AI analysis without distortion
                const getNormalizedImage = (src) => new Promise((resolve, reject) => {
                  const img = new Image();
                  // KEY FIX: Allow cross-origin image loading to prevent "Tainted canvases" error
                  img.crossOrigin = "Anonymous";

                  img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 1000;
                    canvas.height = 1000;
                    const ctx = canvas.getContext('2d');

                    // Fill black
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, 1000, 1000);

                    // Calculate scale to fit
                    const scale = Math.min(1000 / img.width, 1000 / img.height);
                    const w = img.width * scale;
                    const h = img.height * scale;
                    const x = (1000 - w) / 2;
                    const y = (1000 - h) / 2;

                    try {
                      ctx.drawImage(img, x, y, w, h);

                      // Metrics in 1000-scale (native canvas)
                      const metrics = {
                        x: x,
                        y: y,
                        w: w,
                        h: h,
                        scale: scale
                      };

                      resolve({
                        dataUrl: canvas.toDataURL('image/jpeg', 0.85),
                        metrics: metrics
                      });
                    } catch (e) {
                      console.error("Canvas export failed (likely CORS):", e);
                      // Fallback: resolve with null or original src if we can't norm
                      // But better to fail gracefully or try to proceed without norm?
                      // If we fail here, the Promise.all downstream will fail.
                      // Let's resolve with a fallback that indicates failure to normalize
                      reject(e);
                    }
                  };
                  img.onerror = (e) => reject(new Error("Failed to load image for normalization"));
                  img.src = src;
                });

                // Get original dimensions (for reference, though metrics covers what we need)
                const getImageDims = (src) => new Promise((resolve) => {
                  const img = new Image();
                  img.onload = () => resolve({ w: img.width, h: img.height });
                  img.onerror = () => resolve({ w: 1000, h: 1000 }); // Fallback
                  img.src = src;
                });

                // Prepare promises
                const promises = [
                  getNormalizedImage(newImg),
                  getImageDims(newImg)
                ];

                // If there's an old image, we must normalize it too to ensure "Dual Letterboxing" consistency
                // We wrap this in a catch so we don't crash if the old image has CORS issues
                let oldImagePromise = Promise.resolve(null);
                if (oldImg) {
                  oldImagePromise = getNormalizedImage(oldImg).catch(err => {
                    console.warn("Failed to normalize old image (CORS?), falling back to Discovery Mode:", err);
                    return null;
                  });
                }
                promises.push(oldImagePromise);

                const results = await Promise.all(promises);
                const normResultNew = results[0];
                const dims = results[1];
                const normResultOld = results[2]; // Can be null if failed or didn't exist

                // Transform existing overlays to the 1000x1000 letterboxed space of the OLD image
                // If normResultOld is null (load failed), we send EMPTY overlays to force clean discovery
                let transformedOverlays = [];
                if (normResultOld && pageOverlays && pageOverlays.length > 0) {
                  const m = normResultOld.metrics;
                  // Helper: (valPct / 100) * dim + padding
                  const toCanvas = (pct, padding, dim) => (pct / 100) * dim + padding;

                  transformedOverlays = pageOverlays.map(o => ({
                    ...o,
                    x: Math.round(toCanvas(o.x, m.x, m.w)),
                    y: Math.round(toCanvas(o.y, m.y, m.h)),
                    w: Math.round((o.w / 100) * m.w),
                    h: Math.round((o.h / 100) * m.h)
                  }));
                } else if (oldImg && !normResultOld) {
                  console.log("Skipping overlay transformation due to old image load failure. Starting fresh.");
                }

                // Always process if image changed (send normalization version to AI)
                // If normResultOld is null, we send 'oldImage: null' to backend, effectively acting as "New Image Only" mode
                pagesToProcess.push({
                  pageIndex: i,
                  oldImage: normResultOld ? normResultOld.dataUrl : null,
                  newImage: normResultNew.dataUrl, // Send letterboxed new image
                  originalNewImage: newImg,
                  overlays: transformedOverlays, // Transformed OR Empty (if fallback)
                  imageWidth: 1000,
                  imageHeight: 1000,
                  transformMetrics: normResultNew.metrics // Pass metrics for result re-mapping (New Image)
                });
              }
            }

            // Show loading state
            if (pagesToProcess.length > 0) {
              const originalBtnText = saveBtn.textContent;
              saveBtn.textContent = 'AI Processing...';

              // Process each page
              for (const p of pagesToProcess) {
                try {
                  console.log(`Processing page ${p.pageIndex + 1}...`);

                  const result = await window.supabaseClient.functions.invoke('reposition-overlays', {
                    body: {
                      oldImageUrl: p.oldImage,
                      newImageUrl: p.newImage, // 1000x1000 letterboxed
                      overlays: p.overlays,
                      imageWidth: 1000,
                      imageHeight: 1000
                    }
                  });

                  // Handle successful result
                  if (result.data) {
                    const { updatedOverlays, newOverlays } = result.data;
                    let updateCount = 0;
                    let newCount = 0;

                    // Helper to map AI coordinates (0-1000 on square canvas) back to original image (0-100 on content area)
                    const mapCoord = (val1000, padding, dim) => {
                      // val1000: 0-1000 from AI (representing pixels on canvas)
                      // padding: pixel offset on canvas
                      // dim: pixel dimension of drawn image on canvas

                      // Relative to image content: (val1000 - padding) / dim
                      return ((val1000 - padding) / dim) * 100;
                    };

                    // Safety padding disabled per user request.
                    const INFLATION_PCT = 0;

                    const tm = p.transformMetrics;

                    if (updatedOverlays && updatedOverlays.length) {
                      console.log(`AI: Received ${updatedOverlays.length} updated overlays.`);
                      updatedOverlays.forEach(updated => {
                        const existing = overlays.find(o => o.id === updated.id);
                        if (existing) {
                          // Map coordinates back
                          const rawX = mapCoord(updated.x, tm.x, tm.w);
                          const rawY = mapCoord(updated.y, tm.y, tm.h);
                          const rawW = (updated.w) / tm.w * 100;
                          const rawH = (updated.h) / tm.h * 100;

                          // Apply safety inflation
                          existing.x = Math.max(0, rawX - INFLATION_PCT);
                          existing.y = Math.max(0, rawY - INFLATION_PCT);
                          existing.w = Math.min(100 - existing.x, rawW + (INFLATION_PCT * 2));
                          existing.h = Math.min(100 - existing.y, rawH + (INFLATION_PCT * 2));

                          updateCount++;
                        }
                      });
                    } else if (newOverlays && newOverlays.length > 5) {
                      // FALLBACK DETECTION:
                      // If we have 0 updates but many new overlays, it means we likely fell back to "Discovery Mode"
                      // or the AI couldn't match IDs. In this case, the "Old" overlays are likely invalid/duplicates.
                      // We should remove them to prevent duplicates.
                      console.log("AI: No updates found but many new items. Assuming Discovery Mode fallback. Clearing old overlays.");

                      // Remove all overlays for this page that weren't updated (which is all of them)
                      // Note: we're iterating `overlays` (the filtered pageOverlays reference). 
                      // To be safe, we need to modify the main array or splice this one.
                      // Since `overlays` is a reference to objects in `pageOverlays`? No `overlays` IS `pageOverlays`.
                      // But `pageOverlays` is a filter filter result? No, let's check `const overlays = ...`

                      // Wait, `const overlays = pageOverlays; ` where `pageOverlays` comes from `pendingChanges[i].overlays`?
                      // Actually `pendingChanges` is accumulating.

                      // Let's look at how `overlays` is defined in the loop:
                      // `const overlays = pageOverlays; ` (from lines 23670-ish? I need to respect the context)

                      // If we want to clear them, we can just empty the array.
                      // However `overlays` might be a reference to a persistent object.
                      // Let's assume aggressive clearing for the current page only.
                      overlays.length = 0; // Clear the array in-place
                    }

                    if (newOverlays && newOverlays.length) {
                      console.log(`AI: Discovered ${newOverlays.length} new dishes.`);
                      newOverlays.forEach(newItem => {
                        // Map coordinates back from letterbox
                        // newItem.x/y/w/h are 0-1000 from Backend
                        // tm.x/y are padding offsets, tm.w/h are dimensions of the image on the canvas

                        // Safety check: ensure tm dimensions are valid
                        if (!tm.w || !tm.h || tm.w <= 0 || tm.h <= 0) {
                          console.warn('Invalid transform metrics, skipping overlay:', newItem.id, tm);
                          return;
                        }

                        const rawX = mapCoord(newItem.x, tm.x, tm.w);
                        const rawY = mapCoord(newItem.y, tm.y, tm.h);
                        const rawW = (newItem.w) / tm.w * 100;
                        const rawH = (newItem.h) / tm.h * 100;

                        // Apply safety inflation
                        let finalX = Math.max(0, rawX - INFLATION_PCT);
                        let finalY = Math.max(0, rawY - INFLATION_PCT);
                        let finalW = Math.min(100 - finalX, rawW + (INFLATION_PCT * 2));
                        let finalH = Math.min(100 - finalY, rawH + (INFLATION_PCT * 2));

                        // Validate all values are finite numbers
                        if (!isFinite(finalX) || !isFinite(finalY) || !isFinite(finalW) || !isFinite(finalH)) {
                          console.warn('Invalid overlay coordinates, using defaults:', newItem.id, { rawX, rawY, rawW, rawH });
                          finalX = 0; finalY = 0; finalW = 10; finalH = 5;
                        }

                        overlays.push({
                          id: newItem.id,
                          text: newItem.id,
                          x: finalX,
                          y: finalY,
                          w: finalW,
                          h: finalH,
                          pageIndex: p.pageIndex,
                          allergens: [],
                          diets: [],
                          details: {}
                        });
                        newCount++;
                      });
                    }

                    if (updateCount > 0 || newCount > 0) {
                      pendingChanges.push(`AI repositioned ${updateCount} items and added ${newCount} new items on page ${p.pageIndex + 1} `);
                      // Optional: Alert the user about the new items
                      if (newCount > 0) {
                        setTimeout(() => alert(`AI Discovered ${newCount} new dishes on Page ${p.pageIndex + 1} !`), 500);
                      }
                    }
                  } else {
                    console.warn('AI: No updated overlays returned', result);
                  }
                } catch (err) {
                  console.error('AI repositioning failed for page ' + p.pageIndex, err);
                  alert(`AI Error: ${err.message} `); // Show visible error
                  pendingChanges.push(`AI skipped for page ${p.pageIndex + 1}(error)`);
                }
              }
            }
          } catch (e) {
            console.error('Error in save handler:', e);
          }

          // All images are already in pendingMenuImages (added when modal opens)
          // Update menu images (sync with pendingMenuImages)
          menuImages.length = 0;
          menuImages.push(...pendingMenuImages);
          rs.menuImages = menuImages;
          rs.menuImage = menuImages[0] || '';
          state.restaurant.menuImages = menuImages;
          state.restaurant.menuImage = menuImages[0] || '';

          // Update pendingMenuImages to match (so next upload has correct page number)
          pendingMenuImages = [...menuImages];

          // Reset to first page if this was the first image, otherwise switch to newly added page
          if (menuImages.length === 1) {
            currentPageIndex = 0;
            switchMenuPage(0);
          } else {
            // Switch to the newly added page
            currentPageIndex = menuImages.length - 1;
            switchMenuPage(currentPageIndex);
          }

          // Update page navigation UI (top)
          const pageNav = document.querySelector('#prevPageBtn')?.parentElement;
          if (pageNav) {
            if (menuImages.length > 1) {
              pageNav.style.display = 'flex';
            } else {
              pageNav.style.display = 'none';
            }
          }

          // Update page navigation UI (bottom) - REMOVED

          // Update bottom navigation button states
          switchMenuPage(currentPageIndex);

          // Mark as dirty
          pendingChanges.push(`Uploaded menu page ${menuImages.length} `);
          setDirty(true);

          // Close modal
          cleanupKeyboardHandler();
          document.body.removeChild(modal);
          currentUploadIndex = -1;
          lastUploadedIndex = -1;

          // Show confirmation
          setTimeout(() => {
            alert(` ${menuImages.length} menu ${menuImages.length === 1 ? 'page' : 'pages'} saved successfully.\n\nYou can add more pages or save your changes.`);
          }, 100);
        };

        // Handle add another button
        const addAnotherBtn = modalContent.querySelector('#previewAddAnotherBtn');
        addAnotherBtn.onclick = () => {
          // All images are already in pendingMenuImages (added when modal opens)
          // Reset current upload index for new upload
          currentUploadIndex = -1;

          // Close modal
          cleanupKeyboardHandler();
          document.body.removeChild(modal);

          // Update menu images temporarily so UI reflects the new page
          menuImages.length = 0;
          menuImages.push(...pendingMenuImages);
          rs.menuImages = menuImages;
          rs.menuImage = menuImages[0] || '';
          state.restaurant.menuImages = menuImages;
          state.restaurant.menuImage = menuImages[0] || '';

          // Update navigation UI
          updateMenuNavigationUI();

          // Update bottom navigation button states
          switchMenuPage(currentPageIndex);

          // Mark as dirty
          pendingChanges.push(`Added menu page ${pendingMenuImages.length} (pending save)`);
          setDirty(true);

          // Open upload modal again
          setTimeout(() => {
            openMenuUploadModal();
          }, 100);
        };

        // Close on backdrop click
        const backdropHandler = (e) => {
          if (e.target === modal) {
            cleanupKeyboardHandler();
            document.body.removeChild(modal);
            currentUploadIndex = -1;
          }
        };
        modal.onclick = backdropHandler;
      }

      // Menu upload modal elements
      let menuUploadModal = null;
      let menuUploadVideo = null;
      let menuUploadMediaStream = null;
      let menuUploadFileInput = null;
      let menuUploadCameraBtn = null;
      let menuUploadUploadBtn = null;
      let menuUploadCaptureBtn = null;
      let menuUploadCancelBtn = null;
      let menuUploadCloseBtn = null;

      // Function to create menu upload modal
      function createMenuUploadModal() {
        if (menuUploadModal) return menuUploadModal;

        const modal = document.createElement('div');
        modal.className = 'aiAssistBackdrop';
        modal.id = 'menuUploadModal';
        modal.setAttribute('aria-hidden', 'true');
        modal.style.display = 'none';

        modal.innerHTML = `
        <div class="aiAssistPanel" style="max-width:500px" role="dialog" aria-modal="true" aria-labelledby="menuUploadTitle">
        <div class="aiAssistHead">
          <h2 id="menuUploadTitle">Upload menu page</h2>
          <button type="button" class="aiAssistClose" id="menuUploadClose" aria-label="Close"></button>
        </div>
        
        <div class="aiAssistMedia" id="menuUploadMedia" style="display:flex;gap:12px;margin:20px 0">
          <button type="button" class="btn" id="menuUploadUploadBtn" style="flex:1;padding:14px;font-size:1rem"> Upload photo</button>
          <button type="button" class="btn" id="menuUploadCameraBtn" style="flex:1;padding:14px;font-size:1rem"> Take photo</button>
          <input type="file" id="menuUploadFileInput" class="aiAssistHidden" accept="image/*">
        </div>
        
        <div class="aiAssistMediaPreview" id="menuUploadMediaPreview" style="display:none">
          <video id="menuUploadVideo" class="aiAssistHidden" playsinline muted style="width:100%;max-height:400px;border-radius:8px"></video>
          <div class="aiAssistPhotoControls" style="display:flex;gap:12px;margin-top:12px">
            <button type="button" class="btn" id="menuUploadCaptureBtn" style="flex:1;padding:12px">Capture photo</button>
            <button type="button" class="btn" id="menuUploadCancelBtn" style="flex:1;padding:12px;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel camera</button>
          </div>
        </div>
      </div >
        `;

        document.body.appendChild(modal);
        menuUploadModal = modal;
        menuUploadVideo = modal.querySelector('#menuUploadVideo');
        menuUploadFileInput = modal.querySelector('#menuUploadFileInput');
        menuUploadCameraBtn = modal.querySelector('#menuUploadCameraBtn');
        menuUploadUploadBtn = modal.querySelector('#menuUploadUploadBtn');
        menuUploadCaptureBtn = modal.querySelector('#menuUploadCaptureBtn');
        menuUploadCancelBtn = modal.querySelector('#menuUploadCancelBtn');
        menuUploadCloseBtn = modal.querySelector('#menuUploadClose');

        // Bind event handlers
        menuUploadUploadBtn.onclick = () => {
          menuUploadFileInput.value = '';
          menuUploadFileInput.click();
        };

        menuUploadFileInput.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          await handleMenuImageFile(file);
        };

        menuUploadCameraBtn.onclick = () => startMenuCamera();
        menuUploadCaptureBtn.onclick = () => captureMenuPhoto();
        menuUploadCancelBtn.onclick = () => stopMenuCamera();
        menuUploadCloseBtn.onclick = () => closeMenuUploadModal();

        modal.onclick = (e) => {
          if (e.target === modal) {
            closeMenuUploadModal();
          }
        };

        return modal;
      }

      // Function to open menu upload modal
      function openMenuUploadModal() {
        const modal = createMenuUploadModal();
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        stopMenuCamera(); // Ensure camera is stopped when opening
        updateMenuUploadPreview();
      }

      // Function to close menu upload modal
      function closeMenuUploadModal() {
        if (menuUploadModal) {
          stopMenuCamera();
          menuUploadModal.style.display = 'none';
          menuUploadModal.setAttribute('aria-hidden', 'true');
        }
      }

      // Function to update menu upload preview
      function updateMenuUploadPreview() {
        if (!menuUploadModal) return;
        const mediaPreview = menuUploadModal.querySelector('#menuUploadMediaPreview');
        const media = menuUploadModal.querySelector('#menuUploadMedia');

        if (menuUploadMediaStream && menuUploadVideo) {
          // Camera is active
          media.style.display = 'none';
          mediaPreview.style.display = 'block';
          menuUploadVideo.style.display = 'block';
          menuUploadVideo.srcObject = menuUploadMediaStream;
          menuUploadVideo.play();
        } else {
          // No camera
          media.style.display = 'flex';
          mediaPreview.style.display = 'none';
          if (menuUploadVideo) {
            menuUploadVideo.srcObject = null;
            menuUploadVideo.style.display = 'none';
          }
        }
      }

      // Function to start menu camera
      async function startMenuCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          alert('Camera capture is not supported in this browser.');
          return;
        }
        try {
          if (menuUploadMediaStream) {
            stopMenuCamera();
          }
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
          menuUploadMediaStream = stream;
          updateMenuUploadPreview();
        } catch (err) {
          console.error('Camera error', err);
          alert('Could not access the camera: ' + (err.message || err));
        }
      }

      // Function to stop menu camera
      function stopMenuCamera() {
        if (menuUploadMediaStream) {
          try {
            menuUploadMediaStream.getTracks().forEach(track => track.stop());
          } catch (_) { }
        }
        menuUploadMediaStream = null;
        if (menuUploadVideo) {
          try {
            menuUploadVideo.pause();
          } catch (_) { }
          menuUploadVideo.srcObject = null;
        }
        updateMenuUploadPreview();
      }

      // Function to capture menu photo
      async function captureMenuPhoto() {
        if (!menuUploadVideo || !menuUploadMediaStream) {
          alert('Start the camera before capturing a photo.');
          return;
        }
        try {
          const canvas = document.createElement('canvas');
          canvas.width = menuUploadVideo.videoWidth;
          canvas.height = menuUploadVideo.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(menuUploadVideo, 0, 0);

          // Resize image to max 1200px wide while maintaining aspect ratio
          const maxWidth = 1200;
          const scale = Math.min(1, maxWidth / canvas.width);
          const resizedCanvas = document.createElement('canvas');
          resizedCanvas.width = canvas.width * scale;
          resizedCanvas.height = canvas.height * scale;
          const resizedCtx = resizedCanvas.getContext('2d');
          resizedCtx.drawImage(canvas, 0, 0, resizedCanvas.width, resizedCanvas.height);

          const imageData = resizedCanvas.toDataURL('image/jpeg', 0.85);
          stopMenuCamera();
          closeMenuUploadModal();
          await handleMenuImageData(imageData);
        } catch (err) {
          console.error('Capture error', err);
          alert('Could not capture photo: ' + (err.message || err));
        }
      }

      // Function to handle menu image file
      async function handleMenuImageFile(file) {
        try {
          const imageData = await processImageFile(file);
          closeMenuUploadModal();
          await handleMenuImageData(imageData);
        } catch (err) {
          console.error('Error processing image:', err);
          alert('Error processing image. Please try again.');
        }
      }

      // Function to handle menu image data (show preview modal)
      async function handleMenuImageData(imageData) {
        const pageNumber = pendingMenuImages.length + 1;
        showMenuPreviewModal(imageData, pageNumber);
      }

      // Upload new menu image (one at a time)
      document.getElementById('uploadMenuBtn').onclick = () => {
        openMenuUploadModal();
      };


      const backBtn = document.getElementById('backBtn');
      if (backBtn) backBtn.onclick = () => {
        if (dirty) {
          // Show inline warning instead of confirm dialog
          const warningEl = document.getElementById('editorUnsavedWarning');
          if (warningEl) {
            warningEl.style.display = 'block';

            // Scroll warning into view
            warningEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Set up button handlers
            const saveAndExitBtn = document.getElementById('editorSaveAndExitBtn');
            const exitWithoutSavingBtn = document.getElementById('editorExitWithoutSavingBtn');
            const cancelExitBtn = document.getElementById('editorCancelExitBtn');

            const handleSaveAndExit = () => {
              warningEl.style.display = 'none';
              setSaveState('saving');
              // Combine pendingChanges (UI-tracked) with describeOverlayChanges (comparison-based)
              const uiChanges = [...pendingChanges];
              const comparisonChanges = describeOverlayChanges(JSON.parse(originalOverlaysRef), overlays);

              // Merge and deduplicate changes
              const allChanges = [...uiChanges];
              comparisonChanges.forEach(change => {
                if (!uiChanges.includes(change)) {
                  allChanges.push(change);
                }
              });

              let changesList = allChanges;
              if (changesList.length) {
                const formattedChanges = formatChangesForLog(changesList);
                send({ type: 'saveOverlays', overlays, menuImages: menuImages, menuImage: menuImages[0] || rs.menuImage || '', changes: formattedChanges });
                // Stay in editor after saving - dirty flag will be reset by setSaveState('saved')
              } else {
                // No changes to save, just hide the warning
                setSaveState('saved');
              }
            };

            const handleExitWithoutSaving = () => {
              warningEl.style.display = 'none';
              state.page = 'restaurant';
              renderRestaurant();
            };

            const handleCancelExit = () => {
              warningEl.style.display = 'none';
            };

            // Remove old listeners and add new ones
            if (saveAndExitBtn) {
              const newBtn = saveAndExitBtn.cloneNode(true);
              saveAndExitBtn.parentNode.replaceChild(newBtn, saveAndExitBtn);
              newBtn.onclick = handleSaveAndExit;
            }
            if (exitWithoutSavingBtn) {
              const newBtn = exitWithoutSavingBtn.cloneNode(true);
              exitWithoutSavingBtn.parentNode.replaceChild(newBtn, exitWithoutSavingBtn);
              newBtn.onclick = handleExitWithoutSaving;
            }
            if (cancelExitBtn) {
              const newBtn = cancelExitBtn.cloneNode(true);
              cancelExitBtn.parentNode.replaceChild(newBtn, cancelExitBtn);
              newBtn.onclick = handleCancelExit;
            }
          }
        } else {
          state.page = 'restaurant'; renderRestaurant();
        }
      };

      // Check if there's a pending dish to auto-open (from WordPress deep link)
      if (window.__pendingDishToOpen) {
        const pendingDish = window.__pendingDishToOpen;
        window.__pendingDishToOpen = null; // Clear it

        setTimeout(function () {
          console.log('Looking for dish:', pendingDish.dishName);
          console.log('Available dishes:', overlays.map(o => o.id));

          const matchIndex = overlays.findIndex(item => {
            const itemId = (item.id || '').toLowerCase().trim();
            const searchName = (pendingDish.dishName || '').toLowerCase().trim();

            // Exact match
            if (searchName && itemId === searchName) {
              return true;
            }
            // WordPress ID match
            if (pendingDish.dishId && item.wpPostId && item.wpPostId.toString() === pendingDish.dishId.toString()) {
              return true;
            }
            // Contains match (either direction)
            if (searchName && (itemId.includes(searchName) || searchName.includes(itemId))) {
              return true;
            }
            // Fuzzy match - remove spaces and special chars
            const normalizedItem = itemId.replace(/[^a-z0-9]/g, '');
            const normalizedSearch = searchName.replace(/[^a-z0-9]/g, '');
            if (normalizedItem && normalizedSearch && normalizedItem === normalizedSearch) {
              return true;
            }
            return false;
          });

          if (matchIndex !== -1) {
            console.log('Auto-opening dish editor for:', overlays[matchIndex].id);
            openItemEditor(overlays[matchIndex], matchIndex);

            // After opening, click AI button if requested
            if (pendingDish.openAI) {
              setTimeout(function () {
                const aiBtn = document.getElementById('aiAssistBtn');
                if (aiBtn) {
                  console.log('Auto-clicking AI Ingredient Helper button');
                  aiBtn.click();
                }
              }, 500);
            }
          } else {
            console.log('Could not find dish to auto-open:', pendingDish);
            console.log('Tried to match:', pendingDish.dishName);
          }
        }, 500);
      }

      function openItemEditor(it, idx) {
        configureModalClose({ visible: false });
        if (mb) mb.onclick = null;
        const body = document.getElementById('modalBody'); document.getElementById('modalTitle').textContent = 'Edit item';

        // Check if this is a new item or has existing data
        const hasExistingData = (it.allergens && it.allergens.length > 0) || (it.details && Object.keys(it.details).length > 0);

        // Hide the modal initially - AI assistant will open on top
        if (mb) mb.style.display = 'none';

        body.innerHTML = `<div class="algRow" style="grid-template-columns:1fr">
        <input id="itemName" class="algInput" style="font-weight:700" placeholder="Item name" value="${esc(it.id || '')}">
      </div>

      <!--Delete Overlay Warning-->
      <div id="editorDeleteWarning" style="display:none;background:#1a0a0a;border:2px solid #dc2626;border-radius:8px;padding:20px;margin:16px 0">
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
          <span style="font-size:2rem"></span>
          <div>
            <div style="font-size:1.1rem;font-weight:600;color:#dc2626;margin-bottom:4px">Delete this dish?</div>
            <div style="font-size:0.95rem;color:#d1d5db">This action cannot be undone.</div>
          </div>
        </div>
        <div style="display:flex;gap:12px">
          <button type="button" class="btn btnDanger" id="editorConfirmDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:#dc2626;border-color:#b91c1c"> Delete</button>
          <button type="button" class="btn" id="editorCancelDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
        </div>
      </div>

      <div id="manualEntrySection" style="display:none;">
        <div id="algList"></div>
        <div class="note" style="margin:8px 0 4px">Live preview</div>
        <div id="previewBox" style="border:1px solid #2a3466;border-radius:10px;padding:10px"></div>
      </div>
      <div class="editorActionRow" style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
        <button class="btn btnPrimary" id="doneBtn">Done</button>
        <button class="btn btnDanger" id="delBtn">Delete overlay</button>
      </div>`;
        const list = document.getElementById('algList');
        if (!list) {
          console.error('algList element not found in DOM');
          return;
        }
        // Preserve existing AI ingredients data if available
        const existingIngredients = it.aiIngredients || '';
        const existingSummary = it.aiIngredientSummary || '';
        list.dataset.aiIngredients = existingIngredients;
        list.dataset.aiIngredientSummary = existingSummary;

        const sel = new Set(it.allergens || []);
        const details = it.details || {};
        const rem = new Map((it.removable || []).map(r => [r.allergen, r.component]));
        const cross = new Set(it.crossContamination || []);

        // Add allergen section heading
        const allergenTitle = document.createElement('h3');
        allergenTitle.textContent = 'Allergen Information';
        allergenTitle.style.cssText = 'margin: 0 0 12px 0; color: var(--ink);';
        list.appendChild(allergenTitle);

        ALLERGENS.forEach(a => {
          const row = document.createElement('div'); row.className = 'algRow';
          const b = document.createElement('div'); b.className = 'algBtn'; b.textContent = cap(a); b.dataset.a = a; if (sel.has(a)) b.classList.add('active');
          const inp = document.createElement('input'); inp.className = 'algInput'; inp.placeholder = 'Which part of the dish contains the allergen?'; inp.value = details[a] || '';
          const lab = document.createElement('label'); lab.className = 'algChk'; const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = rem.has(a); lab.appendChild(cb); lab.appendChild(document.createTextNode('can be accommodated'));
          const labCross = document.createElement('label'); labCross.className = 'algChk'; const cbCross = document.createElement('input'); cbCross.type = 'checkbox'; cbCross.checked = cross.has(a); labCross.appendChild(cbCross); labCross.appendChild(document.createTextNode('cross-contamination risk'));

          function reflect() {
            const on = b.classList.contains('active');
            inp.style.display = on ? 'block' : 'none';
            lab.style.display = on ? 'flex' : 'none';
            labCross.style.display = 'flex';
            updatePreview();
          }
          b.onclick = () => { b.classList.toggle('active'); reflect(); };
          cb.onchange = updatePreview;
          cbCross.onchange = updatePreview;
          inp.oninput = updatePreview;
          row.appendChild(b); row.appendChild(inp); row.appendChild(lab); row.appendChild(labCross); list.appendChild(row); reflect();
        });

        // Add dietary preference section
        const dietTitle = document.createElement('h3');
        dietTitle.textContent = 'Dietary Preferences';
        dietTitle.style.cssText = 'margin: 24px 0 12px 0; padding-top: 16px; border-top: 1px solid rgba(76,90,212,0.3); color: var(--ink);';
        list.appendChild(dietTitle);

        const dietSel = new Set(it.diets || []);
        DIETS.forEach(diet => {
          const row = document.createElement('div'); row.className = 'algRow';
          const b = document.createElement('div'); b.className = 'algBtn dietBtn'; b.textContent = diet; b.dataset.diet = diet; if (dietSel.has(diet)) b.classList.add('active');

          b.onclick = () => { b.classList.toggle('active'); updatePreview(); };
          row.appendChild(b); list.appendChild(row);
        });

        function updatePreview() {
          const tmp = { id: (document.getElementById('itemName').value || it.id || 'Item'), allergens: [], removable: [], crossContamination: [], diets: [], details: {} };
          list.querySelectorAll('.algRow').forEach(row => {
            const btn = row.querySelector('.algBtn');
            const a = btn.dataset.a;
            const diet = btn.dataset.diet;
            const on = btn.classList.contains('active');

            if (diet) {
              // This is a diet button
              if (on) tmp.diets.push(diet);
            } else if (a) {
              // This is an allergen button
              const txt = row.querySelector('.algInput')?.value.trim() || '';
              const checkboxes = row.querySelectorAll('input[type="checkbox"]');
              const isRem = checkboxes[0]?.checked;
              const isCross = checkboxes[1]?.checked;
              if (on) { tmp.allergens.push(a); if (txt) tmp.details[a] = txt; if (isRem) tmp.removable.push({ allergen: a, component: txt || a }); }
              if (isCross) { tmp.crossContamination.push(a); }
            }
          });

          // Validate dietary preferences against allergens
          const allergenConflicts = {
            'Vegan': ['dairy', 'egg', 'fish', 'shellfish'], // Vegan excludes all animal products
            'Vegetarian': ['fish', 'shellfish'], // Vegetarian allows dairy and eggs but not meat/fish
            'Pescatarian': [], // Pescatarian allows fish, dairy, eggs, but not other meats
            'Gluten-free': ['wheat'] // Gluten-free excludes wheat/gluten ingredients
          };

          tmp.diets = tmp.diets.filter(diet => {
            const conflicts = allergenConflicts[diet] || [];
            const hasConflict = conflicts.some(allergen => tmp.allergens.includes(allergen));
            return !hasConflict;
          });

          document.getElementById('previewBox').innerHTML = tooltipBodyHTML(tmp, ALLERGENS.slice(), DIETS.slice(), true);
        }
        updatePreview();

        function applyIngredientsFromAi(rows, extraData) {
          if (!Array.isArray(rows) || !rows.length) {
            aiAssistSetStatus('No ingredients to apply.', 'warn');
            return;
          }
          // Save AI ingredients data to the overlay object immediately
          console.log('applyIngredientsFromAi saving rows:', rows.map(r => ({
            name: r.name,
            needsScan: r.needsScan,
            userOverriddenScan: r.userOverriddenScan,
            confirmed: r.confirmed
          })));
          // Verify appeal state is included
          const appealRows = rows.filter(r => r.userOverriddenScan === true);
          if (appealRows.length > 0) {
            console.log('APPLY: Found appeal rows being saved:', appealRows.map(r => ({
              name: r.name,
              needsScan: r.needsScan,
              userOverriddenScan: r.userOverriddenScan
            })));
          }
          if (list) {
            list.dataset.aiIngredients = JSON.stringify(rows);
          }
          it.aiIngredients = JSON.stringify(rows);
          console.log('Saved it.aiIngredients (full):', it.aiIngredients);

          // Save the recipe description text from the textarea
          const recipeTextArea = document.getElementById('aiAssistInput');
          if (recipeTextArea && recipeTextArea.value.trim()) {
            it.recipeDescription = recipeTextArea.value.trim();
            console.log('Saved recipe description:', it.recipeDescription.substring(0, 100) + '...');
          }
          // Also verify the parsed data includes appeal state
          try {
            const parsed = JSON.parse(it.aiIngredients);
            const appealInSaved = parsed.filter(r => r.userOverriddenScan === true);
            console.log('APPLY: Verified appeal state in saved data:', appealInSaved.length, 'rows with userOverriddenScan=true');
          } catch (e) {
            console.error('APPLY: Failed to parse saved aiIngredients:', e);
          }
          const allergenDetailsMap = {};
          const activeAllergens = new Set();
          const removableIngredients = new Set(); // Track removable ingredients
          const aggregatedIngredientNames = [];

          // For dietary preferences, start with all possible diets, then remove any that aren't supported by ALL ingredients
          // A dish is only vegan if ALL ingredients are vegan, etc.
          let activeDiets = new Set(['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free']);

          const dietBlockingInfo = {
            'Vegan': [],
            'Vegetarian': [],
            'Pescatarian': [],
            'Gluten-free': []
          };

          rows.forEach(row => {
            const allergens = Array.isArray(row.allergens) ? row.allergens : [];
            const diets = Array.isArray(row.diets) ? row.diets : [];
            const name = (row.name || '').trim();
            const brand = (row.brand || '').trim();
            const isRemovable = row.removable === true;
            console.log(`Processing row: name = "${name}", allergens = `, allergens, `removable = ${row.removable}, isRemovable = ${isRemovable} `);
            if (Array.isArray(row.ingredientsList) && row.ingredientsList.length) {
              aggregatedIngredientNames.push(...row.ingredientsList);
            } else if (name) {
              aggregatedIngredientNames.push(brand ? `${cap(name)} (${brand})` : cap(name));
            }
            const label = name ? cap(name) : '';
            const labelWithBrand = brand ? (label ? `${label} (${brand})` : brand) : label;
            allergens.forEach(al => {
              const key = norm(al);
              if (!key) return;
              activeAllergens.add(key);
              if (labelWithBrand) {
                if (!allergenDetailsMap[key]) allergenDetailsMap[key] = [];
                if (!allergenDetailsMap[key].includes(labelWithBrand)) {
                  allergenDetailsMap[key].push(labelWithBrand);
                }
              }
              // If this ingredient is marked as removable, track the allergen
              if (isRemovable) {
                console.log(`  -> Adding allergen "${key}" to removableIngredients because row is removable`);
                removableIngredients.add(key);
              }
            });

            // Remove any diets that this ingredient doesn't support
            // This way, only diets supported by ALL ingredients remain
            const ingredientDietSet = new Set(diets);
            const hasGlutenAllergen = allergens.some(al => {
              const key = norm(al);
              return key === 'wheat' || key === 'gluten';
            });
            if (!hasGlutenAllergen) {
              ingredientDietSet.add('Gluten-free');
            }
            ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'].forEach(diet => {
              if (!ingredientDietSet.has(diet)) {
                dietBlockingInfo[diet].push({
                  name: labelWithBrand || label || (brand || name || 'Ingredient'),
                  removable: isRemovable === true
                });
              }
            });
            activeDiets.forEach(diet => {
              if (!ingredientDietSet.has(diet)) {
                activeDiets.delete(diet);
              }
            });
          });

          // Ignore the AI's overall dish analysis dietary options - we only trust per-ingredient analysis
          // If the AI said "this dish is vegan" but an ingredient isn't marked vegan, the dish isn't vegan

          // Validate dietary preferences against allergens
          // Remove incompatible dietary preferences based on allergens present
          const allergenConflicts = {
            'Vegan': ['dairy', 'egg', 'fish', 'shellfish'], // Vegan excludes all animal products
            'Vegetarian': ['fish', 'shellfish'], // Vegetarian allows dairy and eggs but not meat/fish
            'Pescatarian': [], // Pescatarian allows fish, dairy, eggs, but not other meats (meat allergens not in our list)
            'Gluten-free': ['wheat']
          };

          activeDiets.forEach(diet => {
            const conflicts = allergenConflicts[diet] || [];
            const hasConflict = conflicts.some(allergen => activeAllergens.has(allergen));
            if (hasConflict) {
              activeDiets.delete(diet);
              console.log(`Removed ${diet} diet due to allergen conflict with ${conflicts.filter(a => activeAllergens.has(a)).join(', ')} `);
            }
          });
          if (list) {
            const uniqueAggregated = [...new Set(aggregatedIngredientNames.map(item => (item || '').trim()).filter(Boolean))];
            list.dataset.aiIngredientSummary = JSON.stringify(uniqueAggregated);
          }
          // Also save ingredient summary to overlay object
          const uniqueAggregated = [...new Set(aggregatedIngredientNames.map(item => (item || '').trim()).filter(Boolean))];
          it.aiIngredientSummary = JSON.stringify(uniqueAggregated);

          list.querySelectorAll('.algRow').forEach(row => {
            const btn = row.querySelector('.algBtn');
            const allergen = btn.dataset.a;
            const key = norm(allergen);
            const input = row.querySelector('.algInput');
            const labels = row.querySelectorAll('.algChk');
            const remLabel = labels[0];
            const crossLabel = labels[1];
            const remChk = remLabel ? remLabel.querySelector('input') : null;
            const crossChk = crossLabel ? crossLabel.querySelector('input') : null;
            const isActive = activeAllergens.has(key);
            btn.classList.toggle('active', isActive);
            if (input) {
              if (isActive) {
                const explanations = allergenDetailsMap[key] || [];
                input.value = explanations.length ? `Contains ${explanations.join(', ')} ` : '';
              } else {
                input.value = '';
              }
              input.style.display = isActive ? 'block' : 'none';
            }
            if (remLabel) {
              remLabel.style.display = isActive ? 'flex' : 'none';
              if (isActive && remChk) {
                // Check the removable checkbox if this allergen is marked as removable
                remChk.checked = removableIngredients.has(key);
              } else if (!isActive && remChk) {
                remChk.checked = false;
              }
            }
            if (crossLabel) {
              crossLabel.style.display = 'flex';
            }
          });
          // Apply dietary preferences
          list.querySelectorAll('.algRow').forEach(row => {
            const btn = row.querySelector('.algBtn.dietBtn');
            if (btn) {
              const diet = btn.dataset.diet;
              const isActive = activeDiets.has(diet);
              btn.classList.toggle('active', isActive);
            }
          });

          // Track old values for change log
          const oldAllergens = new Set(it.allergens || []);
          const oldDiets = new Set(it.diets || []);
          const oldCrossContamination = new Set(it.crossContamination || []);
          const oldNoCrossContamination = it.noCrossContamination || false;
          const dishName = it.id || 'Item';

          // Update the overlay object with the new allergen data
          it.allergens = Array.from(activeAllergens);
          it.diets = Array.from(activeDiets);
          it.details = {};
          Object.keys(allergenDetailsMap).forEach(key => {
            const explanations = allergenDetailsMap[key] || [];
            if (explanations.length) {
              it.details[key] = `Contains ${explanations.join(', ')} `;
            }
          });
          // Add ingredient summary to details
          if (uniqueAggregated && uniqueAggregated.length) {
            it.details.__ingredientsSummary = uniqueAggregated.join(', ');
          }

          // Store cross-contamination data from AI Assistant
          console.log(`=== applyIngredientsFromAi: Processing crossContamination for "${it.id}" === `);
          console.log('  Current it.crossContamination:', it.crossContamination);
          console.log('  extraData.crossContamination:', extraData?.crossContamination);
          if (extraData && extraData.crossContamination) {
            if (extraData.crossContamination.noCrossContamination) {
              it.crossContamination = [];
              it.noCrossContamination = true;
              console.log('  -> Set noCrossContamination=true');
            } else {
              it.crossContamination = extraData.crossContamination.allergens || [];
              it.noCrossContamination = false;
              console.log('  -> Set crossContamination:', it.crossContamination);
            }
          } else {
            console.log('  -> No extraData.crossContamination, keeping existing value:', it.crossContamination);
          }
          console.log('  Final it.crossContamination:', it.crossContamination);

          // Track cross-contamination changes
          const newCrossContamination = new Set(it.crossContamination || []);
          const newNoCrossContamination = it.noCrossContamination || false;

          // Check if noCrossContamination status changed
          if (oldNoCrossContamination !== newNoCrossContamination) {
            if (newNoCrossContamination) {
              pendingChanges.push(`${dishName}: Set to no cross - contamination risk`);
              console.log(`Added pendingChange: ${dishName}: Set to no cross - contamination risk`);
            } else {
              pendingChanges.push(`${dishName}: Removed no cross - contamination status`);
              console.log(`Added pendingChange: ${dishName}: Removed no cross - contamination status`);
            }
          }

          // Check if specific cross-contamination allergens changed
          const addedCross = [...newCrossContamination].filter(a => !oldCrossContamination.has(a));
          const removedCross = [...oldCrossContamination].filter(a => !newCrossContamination.has(a));

          if (addedCross.length) {
            const word = addedCross.length === 1 ? 'cross-contamination risk' : 'cross-contamination risks';
            pendingChanges.push(`${dishName}: Added ${word} for ${addedCross.join(', ')}`);
            console.log(`Added pendingChange: ${dishName}: Added ${word} for ${addedCross.join(', ')}`);
          }
          if (removedCross.length) {
            const word = removedCross.length === 1 ? 'cross-contamination risk' : 'cross-contamination risks';
            pendingChanges.push(`${dishName}: Removed ${word} for ${removedCross.join(', ')}`);
            console.log(`Added pendingChange: ${dishName}: Removed ${word} for ${removedCross.join(', ')}`);
          }

          // Note: Dish-level allergen/diet changes are NOT logged here.
          // All allergen/diet changes are tracked at the ingredient level in aiIngredients.

          // Update the overlay name from the AI Assistant name input only if user explicitly changed it
          const aiNameInput = document.getElementById('aiAssistNameInput');
          const manualNameInput = document.getElementById('itemName');
          const currentName = it.id || 'Item';
          const inputValue = aiNameInput?.value?.trim() || '';

          // Only treat the input as a rename if it differs from the current dish name
          // This prevents stale input values from accidentally renaming dishes
          const newName = (inputValue && inputValue !== currentName) ? inputValue : currentName;

          if (newName !== it.id) {
            const oldName = it.id;
            it.id = newName;
            pendingChanges.push(`Renamed "${oldName}" to "${newName}"`);
            // Also update the manual editor input if it exists
            if (manualNameInput) {
              manualNameInput.value = newName;
            }
          }

          // Update removable ingredients
          console.log('removableIngredients Set before converting:', Array.from(removableIngredients));
          it.removable = [];
          removableIngredients.forEach(allergen => {
            const detail = it.details[allergen] || allergen;
            it.removable.push({ allergen, component: detail });
          });
          console.log('Set removable for', it.id, ':', it.removable);
          const cleanedBlockingInfo = {};
          Object.keys(dietBlockingInfo).forEach(diet => {
            if (dietBlockingInfo[diet].length) {
              cleanedBlockingInfo[diet] = dietBlockingInfo[diet];
            }
          });
          if (Object.keys(cleanedBlockingInfo).length) {
            it.ingredientsBlockingDiets = cleanedBlockingInfo;
          } else {
            delete it.ingredientsBlockingDiets;
          }

          updatePreview();
          setDirty(true);
          pushHistory();
          aiAssistSetStatus('Ingredient details applied and saved to dish!', 'success');
        }

        // Auto-open AI assistant immediately
        // For new items (no allergens): show input screen (photo/upload/describe)
        // For existing items with data: show ingredient editing table

        // Use saved recipe description if available, otherwise fall back to allergen details
        const seedText = it.recipeDescription || Object.values(it.details || {}).join('\n');
        const isNewItem = !it.allergens || it.allergens.length === 0;

        // If there's existing AI ingredients data, parse and pass it to the assistant
        let existingIngredientRows = null;
        console.log('Opening editor for:', it.id, 'isNewItem:', isNewItem, 'allergens:', it.allergens, 'details:', it.details);

        if (it.aiIngredients && typeof it.aiIngredients === 'string') {
          try {
            existingIngredientRows = JSON.parse(it.aiIngredients);
            console.log('Found saved AI ingredients:', existingIngredientRows);
            existingIngredientRows.forEach((row, idx) => {
              const hasAppeal = row.userOverriddenScan === true || row.needsScan === false;
              console.log(`  Row ${idx}: name = "${row.name}", removable = ${row.removable}, needsScan = ${row.needsScan}, userOverriddenScan = ${row.userOverriddenScan}, allergens = `, row.allergens);
              if (hasAppeal) {
                console.log(`   Row ${idx} ("${row.name}") has APPEAL STATE: `, {
                  needsScan: row.needsScan,
                  userOverriddenScan: row.userOverriddenScan,
                  confirmed: row.confirmed
                });
              }
            });
          } catch (e) {
            console.warn('Failed to parse existing AI ingredients:', e);
          }
        } else if (!isNewItem) {
          // Convert existing allergen data into ingredient rows for editing
          // This handles dishes created before the AI ingredient system
          existingIngredientRows = [];
          console.log('Converting legacy allergen data to ingredients, allergens:', it.allergens, 'details:', it.details);

          // If we have details with allergen descriptions, use those
          if (it.details && Object.keys(it.details).length > 0) {
            Object.keys(it.details).forEach(allergen => {
              if (allergen.startsWith('__')) return; // Skip special fields like __ingredientsSummary
              const detail = it.details[allergen];
              if (detail) {
                // Create an ingredient row from the allergen detail
                existingIngredientRows.push({
                  name: detail,
                  brand: '',
                  allergens: [allergen],
                  diets: it.diets || [],
                  removable: (it.removable || []).some(r => r.allergen === allergen),
                  confirmed: false
                });
              }
            });
          } else if (it.allergens && it.allergens.length > 0) {
            // No details, but we have allergens - create generic ingredient rows
            it.allergens.forEach(allergen => {
              existingIngredientRows.push({
                name: `Ingredient with ${allergen} `,
                brand: '',
                allergens: [allergen],
                diets: it.diets || [],
                removable: (it.removable || []).some(r => r.allergen === allergen),
                confirmed: false
              });
            });
          }

          console.log('Converted to ingredient rows:', existingIngredientRows);
        }

        console.log('Final existingIngredientRows:', existingIngredientRows);

        // Open AI assistant immediately - store dish name in closure to avoid stale references
        const currentDishId = it.id || '';
        console.log('openItemEditor: About to open AI Assistant for dish:', currentDishId);

        openAiAssistant({
          seedText,
          getCurrentName: () => {
            // IMPORTANT: Return the dish ID that was captured in the closure when this editor was opened
            // This prevents stale data from other dishes
            console.log('getCurrentName called, returning:', currentDishId);
            return currentDishId;
          },
          onApply: (rows, extraData) => applyIngredientsFromAi(rows, extraData),
          existingIngredients: existingIngredientRows,
          crossContamination: it.crossContamination || [],
          noCrossContamination: it.noCrossContamination || false,
          onDelete: () => {
            // Delete the overlay
            pendingChanges.push(`${it.id || 'Item'}: Removed overlay`);
            overlays.splice(idx, 1);
            if (mb) mb.style.display = 'none';
            drawAll();
            setDirty(true);
            pushHistory();
          }
        });

        document.getElementById('doneBtn').onclick = () => {
          const oldName = it.id;
          const oldAllergens = new Set(it.allergens || []);

          const final = { allergens: [], removable: [], crossContamination: [], diets: [], details: {} };
          console.log('=== DONE BUTTON: Starting to collect dish data ===');
          list.querySelectorAll('.algRow').forEach(row => {
            const btn = row.querySelector('.algBtn');
            const a = btn.dataset.a;
            const diet = btn.dataset.diet;
            const on = btn.classList.contains('active');

            if (diet) {
              // This is a diet button
              if (on) final.diets.push(diet);
            } else if (a) {
              // This is an allergen button
              const txt = row.querySelector('.algInput')?.value.trim() || '';
              const checkboxes = row.querySelectorAll('input[type="checkbox"]');
              console.log(`  Allergen ${a}: found ${checkboxes.length} checkboxes`);
              const isRem = checkboxes[0]?.checked;
              const isCross = checkboxes[1]?.checked;
              console.log(`    - isRem(checkbox[0]): ${isRem} `);
              console.log(`    - isCross(checkbox[1]): ${isCross} `);
              if (on) { final.allergens.push(a); if (txt) final.details[a] = txt; if (isRem) final.removable.push({ allergen: a, component: txt || a }); }
              if (isCross) {
                console.log(`    -> Adding ${a} to crossContamination array`);
                final.crossContamination.push(a);
              }
            }
          });
          console.log('=== DONE BUTTON: Final crossContamination array ===', final.crossContamination);
          if (list && list.dataset.aiIngredientSummary) {
            try {
              const rawSummary = JSON.parse(list.dataset.aiIngredientSummary) || [];
              const summary = [...new Set(rawSummary.map(item => (item || '').trim()).filter(Boolean))];
              if (summary.length) {
                final.details.__ingredientsSummary = summary.join(', ');
              } else {
                delete final.details.__ingredientsSummary;
              }
            } catch (_) { delete final.details.__ingredientsSummary; }
          }
          const newName = (document.getElementById('itemName').value || it.id || 'Item');

          // Track rename
          if (oldName !== newName) {
            pendingChanges.push(`Renamed "${oldName}" to "${newName}"`);
          }

          // Track allergen changes
          const newAllergens = new Set(final.allergens);
          const added = [...newAllergens].filter(a => !oldAllergens.has(a));
          const removed = [...oldAllergens].filter(a => !newAllergens.has(a));
          if (added.length) {
            const allergenWord = added.length === 1 ? 'allergen' : 'allergens';
            pendingChanges.push(`${newName}: Added ${allergenWord} ${added.join(', ')} `);
          }
          if (removed.length) {
            const allergenWord = removed.length === 1 ? 'allergen' : 'allergens';
            pendingChanges.push(`${newName}: Removed ${allergenWord} ${removed.join(', ')} `);
          }

          // Validate dietary preferences against allergens before saving
          const allergenConflicts = {
            'Vegan': ['dairy', 'egg', 'fish', 'shellfish'], // Vegan excludes all animal products
            'Vegetarian': ['fish', 'shellfish'], // Vegetarian allows dairy and eggs but not meat/fish
            'Pescatarian': [] // Pescatarian allows fish, dairy, eggs, but not other meats
          };

          final.diets = final.diets.filter(diet => {
            const conflicts = allergenConflicts[diet] || [];
            const hasConflict = conflicts.some(allergen => final.allergens.includes(allergen));
            if (hasConflict) {
              console.log(`Removed ${diet} from final save due to allergen conflict`);
            }
            return !hasConflict;
          });

          it.id = newName;
          it.allergens = final.allergens;
          it.details = final.details;
          it.removable = final.removable;
          it.crossContamination = final.crossContamination;
          it.diets = final.diets;
          console.log(`=== DONE BUTTON: Set it.crossContamination for "${newName}" === `, it.crossContamination);
          // Save AI ingredients data for future editing
          if (list) {
            it.aiIngredients = list.dataset.aiIngredients || '';
            it.aiIngredientSummary = list.dataset.aiIngredientSummary || '';
          }
          mb.style.display = 'none'; drawAll(); setDirty(true); pushHistory();
        };
        const deleteWarning = document.getElementById('editorDeleteWarning');
        const confirmDeleteBtn = document.getElementById('editorConfirmDeleteBtn');
        const cancelDeleteBtn = document.getElementById('editorCancelDeleteBtn');

        document.getElementById('delBtn').onclick = () => {
          // Show inline delete warning instead of browser confirm
          if (deleteWarning) {
            deleteWarning.style.display = 'block';
            deleteWarning.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        };

        // Set up confirm delete handler
        if (confirmDeleteBtn) {
          confirmDeleteBtn.onclick = () => {
            if (deleteWarning) deleteWarning.style.display = 'none';
            pendingChanges.push(`${it.id || 'Item'}: Removed overlay`);
            overlays.splice(idx, 1);
            mb.style.display = 'none';
            drawAll();
            setDirty(true);
            pushHistory();
          };
        }

        // Set up cancel delete handler
        if (cancelDeleteBtn) {
          cancelDeleteBtn.onclick = () => {
            if (deleteWarning) deleteWarning.style.display = 'none';
          };
        }
        // Don't show the modal - AI assistant opens instead
        // mb.style.display='flex';
      }

      // Make openItemEditor globally accessible for auto-fill
      window.openItemEditor = openItemEditor;
    }

    /* report */
    function renderReport() {
      renderTopbar();
      const root = document.getElementById('root');
      root.innerHTML = `< h1 > Report an issue</h1 >
    <div style="max-width:640px">
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin:8px 0">
        <input id="rName" type="text" placeholder="Your name" style="flex:1">
        <input id="rEmail" type="email" placeholder="Email (required)" style="flex:1">
      </div>
      <textarea id="rMsg" rows="6" style="width:100%;border-radius:16px" placeholder="Describe the issue"></textarea>
      <div class="mgrRow" style="justify-content:flex-start"><button class="btn btnPrimary" id="rSend">Send</button></div>
      <div class="note">We require an email so we can follow up if needed.</div>
    </div>`;
      document.getElementById('rSend').onclick = () => {
        const name = (document.getElementById('rName').value || '').trim();
        const email = (document.getElementById('rEmail').value || '').trim();
        const message = (document.getElementById('rMsg').value || '').trim();
        if (!email) { alert('Please enter your email.'); return; }
        send({ type: 'sendReport', name, email, message });
      };
    }

    function getHowItWorksTourController() {
      if (!window.__howTour) {
        window.__howTour = {
          index: 0,
          container: null,
          replayBtn: null,
          spotlight: null,
          currentSelector: null,
          dismissed: false,
          titleEl: null,
          bodyEl: null,
          progressEl: null,
          prevBtn: null,
          nextBtn: null
        };
      }
      return window.__howTour;
    }

    function ensureHowItWorksTourElements() {
      const ctrl = getHowItWorksTourController();
      if (!ctrl.container) {
        const container = document.createElement('div');
        container.className = 'how-tour-coach hidden';
        container.innerHTML = `
      <div class=\"how-tour-header\">
        <span class=\"how-tour-chip\">How it works</span>
        <button type=\"button\" class=\"how-tour-close\" aria-label=\"Hide training guide\"></button>
      </div >
        <h3 class=\"how-tour-title\">Training guide</h3>
          < p class=\"how-tour-body\">Follow the steps to see every control in action.</p>
            < div class=\"how-tour-progress\">Step 1</div>
              < div class=\"how-tour-controls\">
                < button type =\"button\" class=\"how-tour-prev\">Previous</button>
                  < button type =\"button\" class=\"how-tour-next\">Next</button>
      </div >
        `;
        document.body.appendChild(container);
        ctrl.container = container;
        ctrl.titleEl = container.querySelector('.how-tour-title');
        ctrl.bodyEl = container.querySelector('.how-tour-body');
        ctrl.progressEl = container.querySelector('.how-tour-progress');
        ctrl.prevBtn = container.querySelector('.how-tour-prev');
        ctrl.nextBtn = container.querySelector('.how-tour-next');
        ctrl.closeBtn = container.querySelector('.how-tour-close');
      }

      if (!ctrl.replayBtn) {
        const replayBtn = document.createElement('button');
        replayBtn.type = 'button';
        replayBtn.className = 'how-tour-replay';
        replayBtn.textContent = 'Show guide';
        document.body.appendChild(replayBtn);
        ctrl.replayBtn = replayBtn;
        replayBtn.addEventListener('click', () => {
          ctrl.index = 0;
          ctrl.dismissed = false;
          replayBtn.classList.remove('show');
          ctrl.container.classList.remove('hidden');
          renderHowItWorksTourStep();
        });
      }

      if (!ctrl.spotlight) {
        const spotlight = document.createElement('div');
        spotlight.className = 'how-tour-spotlight';
        document.body.appendChild(spotlight);
        ctrl.spotlight = spotlight;
        window.addEventListener('scroll', updateHowItWorksSpotlight, { passive: true });
        window.addEventListener('resize', updateHowItWorksSpotlight, { passive: true });
      }

      if (!ctrl.prevBtn.__tourBound) {
        ctrl.prevBtn.__tourBound = true;
        ctrl.prevBtn.addEventListener('click', () => {
          if (ctrl.index > 0) {
            ctrl.index -= 1;
            renderHowItWorksTourStep();
          }
        });
      }

      if (!ctrl.nextBtn.__tourBound) {
        ctrl.nextBtn.__tourBound = true;
        ctrl.nextBtn.addEventListener('click', () => {
          if (ctrl.index < HOW_IT_WORKS_TOUR_STEPS.length - 1) {
            ctrl.index += 1;
            renderHowItWorksTourStep();
          } else {
            hideHowItWorksTour({ permanent: true });
          }
        });
      }

      if (!ctrl.closeBtn.__tourBound) {
        ctrl.closeBtn.__tourBound = true;
        ctrl.closeBtn.addEventListener('click', () => hideHowItWorksTour({ permanent: true }));
      }

      return ctrl;
    }

    function updateHowItWorksSpotlight() {
      const ctrl = getHowItWorksTourController();
      const spotlight = ctrl.spotlight;
      if (!spotlight || !ctrl.currentSelector) {
        if (spotlight) spotlight.classList.remove('show');
        return;
      }
      const target = document.querySelector(ctrl.currentSelector);
      if (!target) {
        spotlight.classList.remove('show');
        return;
      }
      const rect = target.getBoundingClientRect();
      const pad = 12;
      spotlight.style.left = `${window.scrollX + rect.left - pad} px`;
      spotlight.style.top = `${window.scrollY + rect.top - pad} px`;
      spotlight.style.width = `${rect.width + pad * 2} px`;
      spotlight.style.height = `${rect.height + pad * 2} px`;
      spotlight.classList.add('show');
    }

    function setHowItWorksTourHighlight(selector, attempt = 0) {
      const ctrl = ensureHowItWorksTourElements();
      ctrl.currentSelector = selector || null;
      if (!selector) {
        updateHowItWorksSpotlight();
        return;
      }
      const target = document.querySelector(selector);
      if (target) {
        try { target.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (_) { }
        updateHowItWorksSpotlight();
      } else if (attempt < 15) {
        setTimeout(() => setHowItWorksTourHighlight(selector, attempt + 1), 350);
      }
    }

    function setTrainingFilters({ allergies, diets } = {}) {
      if (!state.isHowItWorks) return;
      let changed = false;
      if (Array.isArray(allergies)) {
        state.allergies = allergies;
        try { sessionStorage.setItem('qrAllergies', JSON.stringify(allergies)); } catch (_) { }
        const chipsHost = document.getElementById('savedChips');
        if (chipsHost) renderSelector(chipsHost);
        changed = true;
      }
      if (Array.isArray(diets)) {
        state.diets = diets;
        try { sessionStorage.setItem('qrDiets', JSON.stringify(diets)); } catch (_) { }
        const dietHost = document.getElementById('dietChips');
        if (dietHost) renderDietSelector(dietHost);
        changed = true;
      }
      if (changed) {
        if (window.__rerenderLayer__) window.__rerenderLayer__();
        updateOrderSidebar();
      }
    }

    function focusTrainingOverlay(name) {
      const overlays = Array.isArray(state.restaurant?.overlays) ? state.restaurant.overlays : [];
      const item = overlays.find(o => (o.id || o.name) === name);
      const escaped = name.replace(/\"/g, '\\\"');
      const overlayEl = document.querySelector(`[data - item - id=\"${escaped}\"]`);
      if (overlayEl) {
        overlayEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        if (typeof window.showOverlayDetails === 'function' && item) {
          window.showOverlayDetails({ type: 'click', pointerType: 'mouse' }, item, overlayEl);
        }
      }
    }

    function runHowItWorksTourAction(step) {
      if (!state.isHowItWorks || !step || !step.action) return;
      switch (step.action) {
        case 'reset':
          setTrainingFilters({ allergies: [], diets: [] });
          break;
        case 'demoAllergens':
          setTrainingFilters({ allergies: ['peanut'], diets: [] });
          break;
        case 'demoDiets':
          setTrainingFilters({ allergies: ['peanut'], diets: ['Vegan'] });
          break;
        case 'highlightTofu':
          setTrainingFilters({ allergies: ['peanut'], diets: ['Vegan'] });
          focusTrainingOverlay('Grilled Tofu');
          break;
        case 'openNotice':
          openOrderSidebar();
          break;
        default:
          break;
      }
    }

    function renderHowItWorksTourStep() {
      const ctrl = ensureHowItWorksTourElements();
      const step = HOW_IT_WORKS_TOUR_STEPS[ctrl.index] || HOW_IT_WORKS_TOUR_STEPS[0];
      if (!step) return;

      ctrl.titleEl.textContent = step.title;
      ctrl.bodyEl.textContent = step.body;
      ctrl.progressEl.textContent = `Step ${ctrl.index + 1} of ${HOW_IT_WORKS_TOUR_STEPS.length}`;
      ctrl.prevBtn.disabled = ctrl.index === 0;
      ctrl.nextBtn.textContent = ctrl.index === HOW_IT_WORKS_TOUR_STEPS.length - 1 ? 'Finish' : 'Next';

      setHowItWorksTourHighlight(step.selector);
      runHowItWorksTourAction(step);
    }

    function hideHowItWorksTour({ permanent = false, hideReplay = false } = {}) {
      const ctrl = getHowItWorksTourController();
      if (ctrl.container) {
        ctrl.container.classList.add('hidden');
      }
      ctrl.currentSelector = null;
      updateHowItWorksSpotlight();
      if (ctrl.replayBtn) {
        if (permanent && !hideReplay) {
          ctrl.replayBtn.classList.add('show');
        } else if (hideReplay) {
          ctrl.replayBtn.classList.remove('show');
        }
      }
      if (permanent) {
        ctrl.dismissed = true;
      }
    }

    function maybeInitHowItWorksTour() {
      const ctrl = getHowItWorksTourController();
      if (!state.isHowItWorks) {
        hideHowItWorksTour({ permanent: false, hideReplay: true });
        ctrl.dismissed = false;
        return;
      }

      ensureHowItWorksTourElements();
      if (ctrl.dismissed) {
        hideHowItWorksTour({ permanent: true });
        return;
      }
      ctrl.container.classList.remove('hidden');
      if (ctrl.replayBtn) {
        ctrl.replayBtn.classList.remove('show');
      }
      if (ctrl.index >= HOW_IT_WORKS_TOUR_STEPS.length) {
        ctrl.index = 0;
      }
      renderHowItWorksTourStep();
    }

    /* router */
    function render() {
      switch (state.page) {
        case 'restaurants': return renderCardsPage();
        case 'editor': return renderEditor();
        case 'report': return renderReport();
        case 'restaurant': return renderRestaurant();
        default: return;
      }
    }

    /* Check if there are unsaved changes */
    function hasUnsavedChanges() {
      // Check if editor has unsaved changes
      if (window.editorDirty) {
        return true;
      }

      // Check if AI Assistant modal is open and has unsaved changes
      const modalIsOpen = aiAssistBackdrop && aiAssistBackdrop.classList.contains('show');

      if (modalIsOpen && aiAssistState) {
        // Check if dish name has been modified (saved locally but not applied to dish)
        const dishNameModified = aiAssistState.dishNameModified === true;

        // Check if dish name has unsaved local changes in the input field
        const nameInput = document.getElementById('aiAssistNameInput');
        let dishNameHasUnsavedChanges = false;
        if (nameInput && aiAssistState.originalDishName !== null) {
          const currentDishName = nameInput.value?.trim() || '';
          dishNameHasUnsavedChanges = currentDishName !== aiAssistState.originalDishName && currentDishName.length > 0;
        }

        // Check if there are unsaved ingredient changes
        const dataChanged = aiAssistState.savedToDish === false && collectAiTableData().length > 0;

        // Warn if dish name modified, has unsaved changes, or ingredients changed
        if (dishNameModified || dishNameHasUnsavedChanges || dataChanged) {
          return true;
        }
      }

      return false;
    }

    /* Show custom unsaved changes confirmation modal */
    function showUnsavedChangesModal(onLeave, onCancel) {
      // Remove any existing modal
      const existingModal = document.getElementById('unsavedChangesModal');
      if (existingModal) existingModal.remove();

      const modal = document.createElement('div');
      modal.id = 'unsavedChangesModal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100000;
        animation: fadeIn 0.15s ease-out;
      `;

      modal.innerHTML = `
        <div style="
          background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
          border-radius: 16px;
          padding: 32px;
          max-width: 420px;
          width: 90%;
          box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
          border: 1px solid rgba(148, 163, 184, 0.1);
          text-align: center;
        ">
          <div style="
            width: 64px;
            height: 64px;
            background: rgba(251, 191, 36, 0.15);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
          ">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#fbbf24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
              <line x1="12" y1="9" x2="12" y2="13"></line>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
          </div>
          <h3 style="margin: 0 0 12px; color: #fff; font-size: 1.25rem; font-weight: 600;">Unsaved Changes</h3>
          <p style="margin: 0 0 24px; color: #94a3b8; font-size: 0.95rem; line-height: 1.5;">
            You have unsaved changes that will be lost if you leave this page.
          </p>
          <div style="display: flex; gap: 12px; justify-content: center;">
            <button type="button" id="unsavedChangesCancel" style="
              padding: 12px 24px;
              background: transparent;
              border: 1px solid rgba(148, 163, 184, 0.3);
              border-radius: 8px;
              color: #94a3b8;
              font-weight: 600;
              font-size: 0.95rem;
              cursor: pointer;
              transition: all 0.2s;
            ">Stay on Page</button>
            <button type="button" id="unsavedChangesLeave" style="
              padding: 12px 24px;
              background: #dc2626;
              border: 1px solid #dc2626;
              border-radius: 8px;
              color: #fff;
              font-weight: 600;
              font-size: 0.95rem;
              cursor: pointer;
              transition: all 0.2s;
            ">Leave Anyway</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Add hover effects
      const cancelBtn = modal.querySelector('#unsavedChangesCancel');
      const leaveBtn = modal.querySelector('#unsavedChangesLeave');

      cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.background = 'rgba(148, 163, 184, 0.1)';
        cancelBtn.style.borderColor = 'rgba(148, 163, 184, 0.5)';
      });
      cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.background = 'transparent';
        cancelBtn.style.borderColor = 'rgba(148, 163, 184, 0.3)';
      });

      leaveBtn.addEventListener('mouseenter', () => {
        leaveBtn.style.background = '#b91c1c';
      });
      leaveBtn.addEventListener('mouseleave', () => {
        leaveBtn.style.background = '#dc2626';
      });

      // Handle button clicks
      cancelBtn.addEventListener('click', () => {
        modal.remove();
        if (onCancel) onCancel();
      });

      leaveBtn.addEventListener('click', () => {
        modal.remove();
        if (onLeave) onLeave();
      });

      // Close on backdrop click
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
          if (onCancel) onCancel();
        }
      });

      // Close on Escape key
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', handleEscape);
          if (onCancel) onCancel();
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    /* Navigate with unsaved changes check */
    function navigateWithCheck(url) {
      if (hasUnsavedChanges()) {
        showUnsavedChangesModal(() => {
          // Clear dirty flags before navigating
          window.editorDirty = false;
          if (aiAssistState) aiAssistState.savedToDish = true;
          window.location.href = url;
        });
      } else {
        window.location.href = url;
      }
    }

    /* Warn on page unload if there are unsaved changes (browser back/forward, tab close) */
    window.addEventListener('beforeunload', (event) => {
      if (hasUnsavedChanges()) {
        event.preventDefault();
        event.returnValue = '';
        return '';
      }
    });

    /* Intercept navigation links to show custom modal */
    document.addEventListener('click', (event) => {
      const link = event.target.closest('a[href]');
      if (!link) return;

      const href = link.getAttribute('href');
      // Only intercept internal navigation links (not anchors, external links, or javascript:)
      if (!href || href.startsWith('#') || href.startsWith('javascript:') || href.startsWith('mailto:') || href.startsWith('tel:') || href.includes('://')) {
        return;
      }

      // Check for unsaved changes
      if (hasUnsavedChanges()) {
        event.preventDefault();
        showUnsavedChangesModal(() => {
          // Clear dirty flags before navigating
          window.editorDirty = false;
          if (aiAssistState) aiAssistState.savedToDish = true;
          window.location.href = href;
        });
      }
    });

    /* hydrate */
    window.addEventListener('message', (ev) => {
      const m = ev.data || {};
      if (!state._hydrated) { state._hydrated = true; document.body.style.display = ''; }

      if (m.user) {
        state.user = m.user;
        applyDefaultUserName();
      }
      if (Object.prototype.hasOwnProperty.call(m, 'isHowItWorks')) {
        state.isHowItWorks = !!m.isHowItWorks;
      }
      if (state.user?.loggedIn) { closeQrPromo('login'); hideQrBanner(); }
      if (m.allergies) {
        state.allergies = m.allergies;
        rerenderOrderConfirmDetails();
      }
      if (m.diets) {
        state.diets = m.diets;
        rerenderOrderConfirmDetails();
      }
      if (m.restaurant) {
        const newRestaurant = normalizeRestaurant(m.restaurant);
        const newRestaurantId = newRestaurant?._id || newRestaurant?.id || null;
        const oldRestaurantId = state.restaurant?._id || state.restaurant?.id || null;

        // If restaurant changed, filter out orders from the old restaurant
        if (newRestaurantId && oldRestaurantId && newRestaurantId !== oldRestaurantId) {
          tabletSimState.orders = tabletSimState.orders.filter(o => {
            if (!o.restaurantId) return false;
            return o.restaurantId === newRestaurantId;
          });
          // Clear current order if it's from a different restaurant
          if (tabletSimOrderId) {
            const currentOrder = tabletSimState.orders.find(o => o.id === tabletSimOrderId);
            if (!currentOrder || (currentOrder.restaurantId && currentOrder.restaurantId !== newRestaurantId)) {
              tabletSimOrderId = null;
              stopOrderRefresh();
            }
          }
          persistTabletStateSnapshot();
          // Clear sidebar
          renderOrderSidebarStatus(null);
        }

        state.restaurant = newRestaurant;
        if (newRestaurantId) {
          // If restaurant changed, clear old items and restore new ones
          if (oldRestaurantId && newRestaurantId !== oldRestaurantId) {
            window.orderItems = [];
          }
          // Restore order items for this restaurant
          const restored = restoreOrderItems();
          if (!restored) {
            window.orderItems = [];
          }
          persistOrderItems();
          updateOrderSidebar();
          // Open sidebar if there are items
          if (window.orderItems && window.orderItems.length > 0) {
            // Visually restore selected dishes in the menu
            const waitForMenu = () => {
              const menu = document.getElementById('menu');
              if (menu && menu.querySelectorAll('.overlay').length > 0) {
                window.orderItems.forEach(dishName => {
                  const overlays = document.querySelectorAll('.overlay');
                  overlays.forEach(overlay => {
                    const titleEl = overlay.querySelector('.tTitle');
                    if (titleEl) {
                      const title = titleEl.textContent.trim();
                      if (title.toLowerCase() === dishName.toLowerCase() || title === dishName) {
                        overlay.classList.add('selected');
                        const addBtn = overlay.querySelector(`.addToOrderBtn[data-dish-name]`);
                        if (addBtn) {
                          addBtn.disabled = true;
                          addBtn.textContent = 'Added';
                        }
                      }
                    }
                  });
                });
                updateOrderSidebar();
                openOrderSidebar();
              } else {
                setTimeout(waitForMenu, 100);
              }
            };
            setTimeout(waitForMenu, 500);
          }
        }
        rebuildBrandMemoryFromRestaurant();
      }
      if (m.restaurants) {
        // Check if user is admin or manager
        const isAdmin = state.user?.email === 'matt.29.ds@gmail.com';
        const isManager = state.user?.role === 'manager';

        // Filter out restaurants that haven't confirmed in 30+ days (unless admin or manager)
        if (!isAdmin && !isManager) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

          state.restaurants = (m.restaurants || []).filter(rs => {
            if (!rs.lastConfirmed) return false; // Hide restaurants that have never confirmed
            const lastConfirmed = new Date(rs.lastConfirmed);
            return lastConfirmed >= thirtyDaysAgo;
          });
        } else {
          state.restaurants = m.restaurants || [];
        }
      }
      if (typeof m.canEdit === 'boolean') { state.canEdit = m.canEdit; }
      if (typeof m.qr === 'boolean') { state.qr = m.qr; } else if (urlQR) { state.qr = true; }

      // Set page - URL parameter for editor mode takes precedence
      if (m.page) { state.page = m.page; }
      // Auto-activate editor mode if URL parameter is present and user has edit permission
      // This overrides any incoming page message
      if (window.__startInEditor && state.canEdit) {
        console.log('Activating editor mode from URL parameter, canEdit:', state.canEdit);
        state.page = 'editor';
      } else if (window.__startInEditor) {
        console.log('Editor mode requested but canEdit is:', state.canEdit);
      }
      if (m.aiAssistEndpoint) { state.aiAssistEndpoint = m.aiAssistEndpoint; }
      if ((state.qr || urlQR) && (!state.allergies || !state.allergies.length)) {
        try { const s = sessionStorage.getItem('qrAllergies'); if (s) state.allergies = JSON.parse(s) || []; } catch (_) { }
      }
      if ((state.qr || urlQR) && (!state.diets || !state.diets.length)) {
        try { const s = sessionStorage.getItem('qrDiets'); if (s) state.diets = JSON.parse(s) || []; } catch (_) { }
      }
      // Only reset ack if not coming from dish search (which has dishName parameter) or if ack parameter is set
      const urlParamsForAck = new URLSearchParams(window.location.search);
      const dishNameFromUrl = urlParamsForAck.get('dishName');
      const ackParamFromUrl = urlParamsForAck.get('ack');
      if ((m.page === 'restaurant' || m.restaurant) && !dishNameFromUrl && ackParamFromUrl !== '1') { state.ack = false; }
      if (m.type === 'allergiesSaved') {
        state.allergies = m.allergies || [];
        rerenderOrderConfirmDetails();
      }
      if (m.type === 'aiAssistResult') { handleAiAssistantResult(m); return; }
      if (m.type === 'aiAssistError') { handleAiAssistantError(m); return; }

      if (m.type === 'overlaysSaved') {
        try { setSaveState('saved'); } catch (_) { }
        if (m.restaurant) {
          const normalized = normalizeRestaurant(m.restaurant);
          if (normalized) {
            // Log aiIngredients preservation status
            console.log('overlaysSaved: Checking aiIngredients preservation:', normalized.overlays?.map(o => ({
              id: o.id,
              hasAiIngredients: !!o.aiIngredients,
              aiIngredientsType: typeof o.aiIngredients
            })));
            state.restaurant = normalized;
          } else {
            state.restaurant = state.restaurant;
          }
          rebuildBrandMemoryFromRestaurant();
          if (state.restaurant) {
            setTimeout(() => checkForActiveOrders(), 500);
          }
        }
        // Re-render overlays to update colors based on new data
        if (window.__rerenderLayer__) window.__rerenderLayer__();
      }
      if (m.type === 'saveFailed') {
        try {
          setSaveState('error');
          // Log the error details
          console.error('Save failed message received:', m.message, m.error);
          console.error('Full error object:', JSON.stringify(m.error, null, 2));

          // Show user-friendly error with more details
          let errorMsg = m.message || 'Unknown error occurred';
          if (m.error) {
            if (m.error.code) errorMsg += `\nError code: ${m.error.code}`;
            if (m.error.hint) errorMsg += `\nHint: ${m.error.hint}`;
            if (m.error.details) errorMsg += `\nDetails: ${JSON.stringify(m.error.details)}`;
          }
          alert(` Failed to save changes!\n\n${errorMsg}\n\nPlease check the browser console (F12) for full error details.`);
        } catch (_) { }
      }
      if (m.type === 'confirmationSaved') {
        if (m.timestamp && state.restaurant) state.restaurant.lastConfirmed = m.timestamp;
        if (m.restaurant) {
          state.restaurant = normalizeRestaurant(m.restaurant) || state.restaurant;
          rebuildBrandMemoryFromRestaurant();
        }
        try { updateLastConfirmedText(); } catch (_) { }
      }
      if (m.type === 'confirmationFailed') {
        alert('Could not confirm allergen information. ' + (m.message || ''));
      }
      if (m.type === 'changeLog') {
        try { if (window.displayChangeLog) window.displayChangeLog(m.logs || [], m.error); } catch (_) { }
        return;
      }

      renderTopbar(); render(); maybeInitHowItWorksTour();
      updateFullScreenAllergySummary();

      // Auto-open change log modal if requested via URL parameter
      if (window.__openLogOnLoad && state.page === 'editor') {
        setTimeout(() => {
          if (typeof openChangeLog === 'function') {
            openChangeLog();
            window.__openLogOnLoad = false; // Reset to avoid re-opening
          }
        }, 100);
      }
    });

    // Auto-open specific dish editor if coming from WordPress, or overlay if coming from dish search
    (function () {
      const urlParams = new URLSearchParams(window.location.search);
      const openAI = urlParams.get('openAI');
      const dishId = urlParams.get('dishId');
      const dishName = urlParams.get('dishName');

      if (openAI === 'true' && (dishId || dishName)) {
        console.log('WordPress deep link detected, dishName:', dishName, 'dishId:', dishId);

        // Set flag to auto-start in editor mode
        window.__startInEditor = true;

        // Set pending dish to open (will be picked up by renderEditor)
        window.__pendingDishToOpen = {
          dishId: dishId,
          dishName: dishName,
          openAI: openAI === 'true'
        };

        console.log('Set __startInEditor and __pendingDishToOpen flags');
      } else if (dishName && !openAI) {
        // Coming from dish search - open the overlay tooltip
        // Wait for overlays to be loaded and rendered
        let retryCount = 0;
        const MAX_RETRIES = 50; // Max 10 seconds (50 * 200ms)

        const tryOpenOverlay = () => {
          retryCount++;
          if (retryCount > MAX_RETRIES) {
            console.error('Failed to open overlay after maximum retries');
            return;
          }

          // Check if state and restaurant overlays are available
          if (!state || !state.restaurant || !Array.isArray(state.restaurant.overlays) || state.restaurant.overlays.length === 0) {
            // Try again after a short delay
            setTimeout(tryOpenOverlay, 200);
            return;
          }

          // Check if menu is shown (acknowledged) - overlays are only rendered when menu is visible
          const menu = document.getElementById('menu');
          if (!menu || !menu.classList.contains('show')) {
            setTimeout(tryOpenOverlay, 200);
            return;
          }

          // Check if pageTip is available
          const pageTip = document.getElementById('tip');
          if (!pageTip) {
            setTimeout(tryOpenOverlay, 200);
            return;
          }

          // Check if menu image is loaded - overlay boxes are only rendered after image loads
          const menuInner = document.querySelector('.menuInner');
          const menuImg = menuInner ? menuInner.querySelector('.menuImg') : null;
          if (!menuImg || !menuImg.complete || !menuImg.naturalWidth || menuImg.clientWidth === 0 || menuImg.clientHeight === 0) {
            setTimeout(tryOpenOverlay, 200);
            return;
          }

          const overlays = state.restaurant.overlays;
          const searchName = (dishName || '').toLowerCase().trim();

          const matchIndex = overlays.findIndex(item => {
            const itemId = (item.id || item.name || '').toLowerCase().trim();

            // Exact match
            if (searchName && itemId === searchName) {
              return true;
            }
            // Contains match (either direction)
            if (searchName && (itemId.includes(searchName) || searchName.includes(itemId))) {
              return true;
            }
            // Fuzzy match - remove spaces and special chars
            const normalizedItem = itemId.replace(/[^a-z0-9]/g, '');
            const normalizedSearch = searchName.replace(/[^a-z0-9]/g, '');
            if (normalizedItem && normalizedSearch && normalizedItem === normalizedSearch) {
              return true;
            }
            return false;
          });

          if (matchIndex !== -1) {
            const item = overlays[matchIndex];

            // Find the overlay box element - layer has class 'overlayLayer'
            const layer = document.querySelector('.overlayLayer');
            if (layer) {
              const boxes = layer.querySelectorAll('.overlay');
              // Check if showOverlayDetails is available (either locally or globally)
              const showOverlayFn = window.showOverlayDetails;
              if (boxes.length > 0 && boxes[matchIndex] && typeof showOverlayFn === 'function') {
                // Call showOverlayDetails to open the tooltip (it will handle pinning)
                const box = boxes[matchIndex];
                // Create a fake event object to indicate this is a click
                // Use 'touchend' type to trigger mobile panel instead of desktop tooltip
                const fakeEvent = { type: 'touchend', pointerType: 'touch' };
                try {
                  // Scroll the overlay box into view FIRST, then show the tooltip
                  // This ensures the tooltip is positioned correctly relative to where the box ends up
                  box.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  // Wait for scroll to settle before showing the overlay tooltip
                  setTimeout(() => {
                    showOverlayFn(fakeEvent, item, box);
                  }, 500);
                  // Since we're coming from dish search, full-screen will open soon
                  // Set up a MutationObserver to update panel size when full-screen activates
                  const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        if (document.body.classList.contains('mobileViewerActive')) {
                          const panel = document.getElementById('mobileInfoPanel');
                          if (panel) {
                            // Force full width using setProperty with important
                            panel.style.setProperty('left', '0', 'important');
                            panel.style.setProperty('right', '0', 'important');
                            panel.style.setProperty('bottom', '0', 'important');
                            // Re-render to ensure full width
                            if (window.renderMobileInfo && window.currentMobileInfoItem) {
                              window.renderMobileInfo(window.currentMobileInfoItem);
                            }
                          }
                          observer.disconnect();
                        }
                      }
                    });
                  });
                  observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
                  return; // Successfully opened, stop retrying
                } catch (error) {
                  console.error('Error opening overlay:', error);
                  setTimeout(tryOpenOverlay, 200);
                }
              } else {
                // If boxes aren't rendered yet or function not available, wait a bit more
                setTimeout(tryOpenOverlay, 200);
              }
            } else {
              // Layer not ready yet, wait a bit more
              setTimeout(tryOpenOverlay, 200);
            }
          } else {
            console.log('Could not find dish to auto-open:', dishName);
          }
        };

        // Start trying after page load
        if (document.readyState === 'complete') {
          setTimeout(tryOpenOverlay, 500);
        } else {
          window.addEventListener('load', () => {
            setTimeout(tryOpenOverlay, 500);
          });
        }
      }
    })();

    // Initialize order sidebar when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initOrderSidebar);
    } else {
      initOrderSidebar();
    }

    // Check if returning from account page and restore form state
    (async function () {
      const urlParams = new URLSearchParams(window.location.search);
      const formStateKey = getOrderFormStateStorageKey();
      let hasSavedState = localStorage.getItem(formStateKey);
      if (!hasSavedState && formStateKey !== 'orderConfirmFormState') {
        hasSavedState = localStorage.getItem('orderConfirmFormState');
      }
      if (urlParams.has('redirect') || hasSavedState) {
        const isAuthenticated = await checkUserAuth();
        if (isAuthenticated && hasSavedState) {
          // Wait for page and menu to fully load, then restore
          // Allergies/diets will be loaded via message and will trigger re-render
          let hasRestored = false;
          const waitForMenu = () => {
            const menu = document.getElementById('menu');
            if (menu && menu.querySelectorAll('.overlay').length > 0 && !hasRestored) {
              hasRestored = true;
              restoreOrderFormState();
              updateOrderConfirmAuthState();
              // restoreOrderFormState already calls confirmOrder() if there are dishes
              // Re-render multiple times to catch allergies/diets that arrive at different times
              setTimeout(() => {
                rerenderOrderConfirmDetails();
              }, 500);
              setTimeout(() => {
                rerenderOrderConfirmDetails();
              }, 1500);
              setTimeout(() => {
                rerenderOrderConfirmDetails();
              }, 2500);
            } else if (!hasRestored) {
              setTimeout(waitForMenu, 100);
            }
          };
          setTimeout(waitForMenu, 500);
        } else {
          await updateOrderConfirmAuthState();
        }
      }
    })();

    // ==========================================
    // AUTO-FILL DEMO FUNCTIONALITY
    // ==========================================
    (function initAutoFill() {
      const autoFillBtn = document.getElementById('autoFillBtn');
      const autoFillProgress = document.getElementById('autoFillProgress');
      const autoFillProgressOverlay = document.getElementById('autoFillProgressOverlay');
      const autoFillProgressList = document.getElementById('autoFillProgressList');
      const autoFillOverallProgress = document.getElementById('autoFillOverallProgress');
      const autoFillCloseBtn = document.getElementById('autoFillCloseBtn');
      const autoFillCurrentDish = document.getElementById('autoFillCurrentDish');
      const autoFillCurrentAction = document.getElementById('autoFillCurrentAction');
      const autoFillExpandBtn = document.getElementById('autoFillExpandBtn');

      let autoFillRunning = false;

      // Show button when in editor mode with canEdit
      function updateAutoFillButtonVisibility() {
        if (state.canEdit && state.page === 'editor') {
          autoFillBtn.style.display = 'block';
        } else {
          autoFillBtn.style.display = 'none';
        }
      }

      // Observe state changes
      const originalRender = window.render;
      if (originalRender) {
        window.render = function () {
          originalRender.apply(this, arguments);
          updateAutoFillButtonVisibility();
        };
      }
      // Also check on message
      window.addEventListener('message', () => setTimeout(updateAutoFillButtonVisibility, 100));

      // Expand/collapse button
      autoFillExpandBtn.addEventListener('click', () => {
        autoFillProgress.classList.toggle('expanded');
        autoFillExpandBtn.textContent = autoFillProgress.classList.contains('expanded') ? 'Hide list ' : 'Show all dishes ';
      });

      // Close progress panel
      autoFillCloseBtn.addEventListener('click', () => {
        if (!autoFillRunning) {
          autoFillProgress.style.display = 'none';
          autoFillProgressOverlay.style.display = 'none';
        }
      });

      autoFillProgressOverlay.addEventListener('click', () => {
        if (!autoFillRunning) {
          autoFillProgress.style.display = 'none';
          autoFillProgressOverlay.style.display = 'none';
        }
      });

      // Update current status (compact view)
      function updateCurrentStatus(dishName, action) {
        if (autoFillCurrentDish) autoFillCurrentDish.textContent = dishName || 'Processing...';
        if (autoFillCurrentAction) autoFillCurrentAction.textContent = action || '';
      }

      // Update progress item
      function updateProgressItem(idx, status, text) {
        const item = autoFillProgressList.children[idx];
        if (!item) return;
        item.className = 'autoFillProgressItem ' + status;
        const statusEl = item.querySelector('.autoFillProgressStatus');
        const textEl = item.querySelector('.autoFillProgressText');
        if (status === 'pending') statusEl.textContent = '';
        else if (status === 'active') statusEl.textContent = '';
        else if (status === 'completed') statusEl.textContent = '';
        else if (status === 'error') statusEl.textContent = '';
        if (text) textEl.textContent = text;

        // Also update compact status if this is the active item
        if (status === 'active') {
          const parts = text.split(' - ');
          updateCurrentStatus(parts[0], parts[1] || 'Working...');
        }
      }

      // Sleep helper
      const sleep = ms => new Promise(r => setTimeout(r, ms));

      // Wait for element
      async function waitForElement(selector, timeout = 10000) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
          const el = document.querySelector(selector);
          if (el) return el;
          await sleep(100);
        }
        return null;
      }

      // Wait for condition
      async function waitFor(fn, timeout = 30000, interval = 50) {
        const start = Date.now();
        while (Date.now() - start < timeout) {
          if (fn()) return true;
          await sleep(interval);
        }
        return false;
      }

      // Main auto-fill function
      async function runAutoFill() {
        if (autoFillRunning) return;
        autoFillRunning = true;
        autoFillBtn.disabled = true;

        // Show progress panel
        autoFillProgressOverlay.style.display = 'block';
        autoFillProgress.style.display = 'block';

        const overlays = state.restaurant?.overlays || [];
        if (!overlays.length) {
          autoFillOverallProgress.innerHTML = '<span style="color:#fca5a5">No dishes found!</span>';
          autoFillRunning = false;
          autoFillBtn.disabled = false;
          return;
        }

        // Build progress list
        autoFillProgressList.innerHTML = overlays.map((o, i) => `
          <div class="autoFillProgressItem pending">
            <span class="autoFillProgressStatus"></span>
            <span class="autoFillProgressText">${esc(o.id || 'Dish ' + (i + 1))}</span>
          </div>
        `).join('');

        let completed = 0;
        let errors = 0;

        // TODO: Change back to overlays.length for production
        for (let i = 0; i < Math.min(1, overlays.length); i++) {
          const overlay = overlays[i];
          const dishName = overlay.id || 'Dish ' + (i + 1);

          updateProgressItem(i, 'active', `${dishName} - Opening editor...`);
          autoFillOverallProgress.textContent = `Processing ${i + 1} of ${overlays.length}...`;

          try {
            // Open item editor (using window-scoped function)
            if (typeof window.openItemEditor === 'function') {
              window.openItemEditor(overlay, i);
            } else {
              throw new Error('openItemEditor not available');
            }

            await sleep(500);

            // Wait for AI assistant to be ready
            updateProgressItem(i, 'active', `${dishName} - Generating recipe...`);

            // Click generate recipe button
            const generateBtn = await waitForElement('#aiAssistGenerateBtn', 5000);
            console.log('[AutoFill] Generate button found:', generateBtn, 'disabled:', generateBtn?.disabled);
            if (generateBtn && !generateBtn.disabled) {
              generateBtn.click();
              console.log('[AutoFill] Clicked generate button');

              // Wait for generation to complete (button re-enables)
              await waitFor(() => {
                const btn = document.getElementById('aiAssistGenerateBtn');
                return btn && !btn.disabled && !btn.textContent.includes('Generating');
              }, 60000);
              console.log('[AutoFill] Generation complete');
            }

            // Click Process Input button to process the recipe into ingredients
            updateProgressItem(i, 'active', `${dishName} - Processing input...`);
            const processBtn = document.getElementById('aiAssistProcessBtn');
            console.log('[AutoFill] Process button found:', processBtn);

            if (!processBtn) {
              console.log('[AutoFill] ERROR: Process button not found!');
              alert('[AutoFill] Process button not found - skipping to brand lookup');
            } else {
              console.log('[AutoFill] Clicking process button NOW');
              processBtn.click();
              console.log('[AutoFill] Process button clicked, waiting for table...');

              // Wait for processing to complete (table appears with rows)
              const tableAppeared = await waitFor(() => {
                const tableBody = document.getElementById('aiAssistTableBody');
                const rows = tableBody?.querySelectorAll('tr');
                const hasRows = rows && rows.length > 0;
                if (hasRows) console.log('[AutoFill] Table check: found', rows.length, 'rows');
                return hasRows;
              }, 60000);

              if (tableAppeared) {
                console.log('[AutoFill]  Processing complete, table has rows');
              } else {
                console.log('[AutoFill]  Timed out waiting for table rows');
              }

              // Wait a bit more for Add buttons to render
              await sleep(300);
            }

            // Process ingredients - find brands for rows that have "Add" button visible
            console.log('[AutoFill] ========================================');
            console.log('[AutoFill] === STARTING BRAND LOOKUP PHASE ===');
            console.log('[AutoFill] ========================================');
            updateProgressItem(i, 'active', `${dishName} - Scanning for Add buttons...`);

            // Re-query the table body fresh (use ID selector, not class)
            const tableBody = document.getElementById('aiAssistTableBody');
            const tableRows = tableBody ? tableBody.querySelectorAll('tr') : [];
            const allAddBtns = document.querySelectorAll('.aiBrandBarcodeBtn');

            // Log status
            console.log('[AutoFill] STATUS: Table:', !!tableBody, 'Rows:', tableRows.length, 'Add buttons:', allAddBtns.length);

            // Log all rows and their Add button status
            for (let rowIdx = 0; rowIdx < tableRows.length; rowIdx++) {
              const tableRow = tableRows[rowIdx];
              const ingredientName = tableRow.querySelector('.aiIngredientName')?.value || `Row ${rowIdx}`;
              const addBtn = tableRow.querySelector('.aiBrandBarcodeBtn');
              console.log(`[AutoFill] Row ${rowIdx}: "${ingredientName}" - Add button present: ${!!addBtn}`);
            }

            // Collect rows that need brand lookup (parallel)
            // Only rows with needsScan=true require brand identification
            const rowsNeedingBrands = [];
            for (let rowIdx = 0; rowIdx < tableRows.length; rowIdx++) {
              const tableRow = tableRows[rowIdx];
              const ingredientName = tableRow.querySelector('.aiIngredientName')?.value || `Row ${rowIdx}`;
              const needsScan = tableRow.dataset.needsScan === 'true';
              const hasExistingBrands = tableRow.querySelectorAll('.aiBrandItem').length > 0;
              const addBtn = tableRow.querySelector('.aiBrandBarcodeBtn');
              const actualRowIdx = parseInt(tableRow.dataset.index, 10);

              console.log(`[AutoFill] Row ${rowIdx} "${ingredientName}": needsScan=${needsScan}, hasAddBtn=${!!addBtn}, hasExistingBrands=${hasExistingBrands}`);

              // Only process rows that: need scan + have Add button + no existing brands
              if (needsScan && addBtn && !hasExistingBrands) {
                console.log(`[AutoFill] >>> QUEUING Row ${actualRowIdx} "${ingredientName}" for brand lookup`);
                rowsNeedingBrands.push({ rowIdx: actualRowIdx, ingredientName, tableRow });
              } else if (!needsScan) {
                console.log(`[AutoFill] SKIP Row ${rowIdx} "${ingredientName}" - needsScan is false (brand not required)`);
              }
            }

            console.log(`[AutoFill] *** Found ${rowsNeedingBrands.length} rows needing brand lookup ***`);

            // Start all brand lookups in parallel - click through buttons quickly, don't wait for completion
            updateProgressItem(i, 'active', `${dishName} - Starting ${rowsNeedingBrands.length} brand searches...`);

            for (const { rowIdx, ingredientName, tableRow } of rowsNeedingBrands) {
              console.log(`[AutoFill] >>> Starting brand search for Row ${rowIdx}: "${ingredientName}"`);

              try {
                // Scroll the row into view
                tableRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                await sleep(150);

                // Find and click the Add button
                const addBtn = tableRow.querySelector('.aiBrandBarcodeBtn');
                if (!addBtn) {
                  console.log(`[AutoFill] Add button not found for Row ${rowIdx}`);
                  continue;
                }

                console.log(`[AutoFill] Clicking Add button for "${ingredientName}"...`);
                addBtn.click();

                // Wait for choice modal to appear
                const choiceModal = await waitForElement('#brandIdentificationChoiceModal', 2000);
                if (!choiceModal) {
                  console.log(`[AutoFill] Choice modal did not appear for "${ingredientName}"`);
                  continue;
                }

                // Find and click "Find Brand Online (Demo)" button
                const findOnlineBtn = choiceModal.querySelector('.brandChoiceFindOnline');
                if (!findOnlineBtn) {
                  console.log(`[AutoFill] Find Online button not found`);
                  const cancelBtn = choiceModal.querySelector('.brandChoiceCancel');
                  if (cancelBtn) cancelBtn.click();
                  continue;
                }

                console.log(`[AutoFill] Clicking "Find Brand Online" for "${ingredientName}"...`);
                findOnlineBtn.click();
                // Modal closes immediately, search runs in background - move to next row right away
                await sleep(100); // Brief pause for visual feedback

                console.log(`[AutoFill] Brand search initiated for "${ingredientName}"`);

              } catch (err) {
                console.error(`[AutoFill] Error starting brand search for "${ingredientName}":`, err);
                const openModal = document.getElementById('brandIdentificationChoiceModal');
                if (openModal) {
                  const cancelBtn = openModal.querySelector('.brandChoiceCancel');
                  if (cancelBtn) cancelBtn.click();
                }
              }
            }

            // Now wait for all searches to complete (modals closed, loading indicators gone)
            updateProgressItem(i, 'active', `${dishName} - Waiting for brand searches to complete...`);
            console.log(`[AutoFill] Waiting for all brand searches to complete...`);

            await waitFor(() => {
              // Check if any modals are still open
              const choiceModal = document.getElementById('brandIdentificationChoiceModal');
              const scannerModal = document.getElementById('barcodeScannerModal');
              // Check if any loading indicators are still visible
              const loadingIndicators = document.querySelectorAll('.barcodeLoadingArea');
              const done = !choiceModal && !scannerModal && loadingIndicators.length === 0;
              if (!done) {
                console.log(`[AutoFill] Still waiting: choiceModal=${!!choiceModal}, scannerModal=${!!scannerModal}, loadingIndicators=${loadingIndicators.length}`);
              }
              return done;
            }, 120000); // 2 minute timeout for all searches

            console.log(`[AutoFill] === BRAND LOOKUP PHASE COMPLETE ===`);

            // Click confirm for all rows that can be confirmed
            console.log('[AutoFill] === STARTING CONFIRM PHASE ===');
            updateProgressItem(i, 'active', `${dishName} - Confirming ingredients...`);
            const confirmBtns = document.querySelectorAll('.aiConfirmBtn');
            console.log('[AutoFill] Found', confirmBtns.length, 'confirm buttons');

            let confirmedCount = 0;
            for (const btn of confirmBtns) {
              const ingredientName = btn.closest('tr')?.querySelector('.aiIngredientName')?.value || 'unknown';
              // Only click if not already confirmed
              if (btn.dataset.confirmed !== 'true') {
                console.log(`[AutoFill] >>> CLICKING Confirm for: "${ingredientName}"`);
                btn.click();
                confirmedCount++;
                await sleep(50); // Small delay between confirms
              } else {
                console.log(`[AutoFill] SKIP Confirm for "${ingredientName}" - already confirmed`);
              }
            }
            console.log(`[AutoFill] === CONFIRM PHASE COMPLETE: ${confirmedCount} ingredients confirmed ===`);

            // Save to dish
            console.log('[AutoFill] === STARTING SAVE PHASE ===');
            updateProgressItem(i, 'active', `${dishName} - Saving dish...`);
            const saveBtn = document.getElementById('aiAssistApplyBtn');
            console.log('[AutoFill] Save button found:', !!saveBtn);
            if (saveBtn) {
              console.log('[AutoFill] >>> CLICKING Save button');
              saveBtn.click();
              await sleep(500);
              console.log('[AutoFill] Save complete');
            }

            // Close the editor
            console.log('[AutoFill] >>> CLICKING backdrop to close editor');
            const closeBtn = document.querySelector('.aiAssistBackdrop');
            if (closeBtn) closeBtn.click();
            await sleep(300);
            console.log('[AutoFill] === DISH COMPLETE ===');

            updateProgressItem(i, 'completed', `${dishName} - Done!`);
            completed++;

          } catch (err) {
            console.error('Auto-fill error for dish:', dishName, err);
            updateProgressItem(i, 'error', `${dishName} - Error: ${err.message}`);
            errors++;

            // Try to close any open modals
            const backdrop = document.querySelector('.aiAssistBackdrop');
            if (backdrop) backdrop.click();
            await sleep(300);
          }
        }

        // Save all overlays to restaurant
        autoFillOverallProgress.innerHTML = '<span style="color:#6ee7b7">Saving restaurant...</span>';
        await sleep(1000);

        // Trigger save
        try {
          const overlaysToSave = state.restaurant.overlays;
          const menuImages = state.restaurant.menuImages || [state.restaurant.menuImage];
          send({ type: 'saveOverlays', overlays: overlaysToSave, menuImages: menuImages, menuImage: menuImages[0] || '', changes: { summary: 'Auto-fill demo completed' } });
          await sleep(2000);
        } catch (saveErr) {
          console.error('Final save error:', saveErr);
        }

        autoFillOverallProgress.innerHTML = `
          <div style="color:#6ee7b7;font-weight:600;margin-bottom:8px"> Auto-fill complete!</div>
          <div>Completed: ${completed} | Errors: ${errors}</div>
        `;

        autoFillRunning = false;
        autoFillBtn.disabled = false;
      }

      autoFillBtn.addEventListener('click', runAutoFill);
    })();
  </script>
  <script type="module" src="js/report-modal.js"></script>
</body>

</html>