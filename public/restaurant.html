<!doctype html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="favicon.png">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1">

<title>Clarivore</title>
<script src="https://unpkg.com/@zxing/library@latest"></script>
<style>
  :root{
    --bg:#0b1020; --panel:#111630; --ink:#e9ecff; --muted:#a8b2d6;
    --brand:#7c9cff; --ok:#22c55e; --warn:#facc15; --bad:#ef4444;
    --border:#2a3261; --hover:#4c5ad4; --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  html{
    margin:0;padding:0;min-height:100%;width:100%;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    touch-action: pan-x pan-y;
    background:var(--bg);
  }
  body{
    margin:0;padding:0;min-height:100vh;width:100%;background:var(--bg);color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    overflow-x:hidden;
    overflow-y:auto;
    -webkit-overflow-scrolling:touch;
    box-sizing:border-box;
    touch-action: pan-x pan-y;
  }
  *{box-sizing:border-box; touch-action: pan-x pan-y;}
  .menuWrap, .menuInner, .overlayLayer, .overlay, .tip {
    touch-action: pan-x pan-y;
  }
  .wrap{min-height:100%;display:flex;flex-direction:column;width:100%}
  .content{flex:1;max-width:1100px;margin:0 auto;padding:16px;padding-bottom:100px;width:100%;box-sizing:border-box}
  a{color:inherit;text-decoration:none}

  .topbar{position:sticky;top:0;z-index:50;background:linear-gradient(180deg,#0f1530,#0b1020);border-bottom:1px solid #1c2347;box-shadow:var(--shadow);width:100%}
  .topin{max-width:1100px;margin:0 auto;display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px 22px 10px;flex-wrap:wrap;justify-content:center;box-sizing:border-box}
  .brand{display:flex;align-items:center;gap:16px;font-weight:800;flex-shrink:0;cursor:pointer}
  .brand img{width:52px;height:52px;border-radius:6px}
  .brand span{font-size:clamp(1.5rem,1.3rem + 1vw,2.1rem);}

  .topNav{display:flex;align-items:center;gap:12px;flex-wrap:wrap;justify-content:center}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  .tab{padding:8px 12px;border:1px solid var(--border);background:#12183a;border-radius:999px;cursor:pointer;white-space:nowrap}
  .acctBtn{padding:8px 12px;border:1px solid var(--border);background:#12183a;border-radius:999px;cursor:pointer;white-space:nowrap}

  .tab:hover,.btn:hover,.acctBtn:hover,.chip.clickable:hover,.ackBtn:hover,.pill:hover,.algBtn:hover{
    border-color:var(--hover); box-shadow:0 0 0 3px #7c9cff33 inset,0 2px 10px #0b1b60aa;
  }

  h1{font-size:clamp(1.4rem,1.1rem + 1.5vw,2rem);margin:6px 0 12px}
  .note{color:var(--muted)}

  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{padding:8px 10px;border:1px solid var(--border);background:#12183a;border-radius:999px;font-size:14px}
  .chip.active{border-color:#4c5ad4;box-shadow:0 0 0 3px #7c9cff33 inset,0 0 10px #24307a66}
  .chip.clickable{cursor:pointer;touch-action:manipulation;-webkit-tap-highlight-color:transparent}
  .pill{padding:10px 14px;border:1px dashed #33408c;border-radius:12px}

  .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:#1a2351;cursor:pointer;color:#fff}
  .btnPrimary{background:#3651ff;border-color:#4e65ff}
  .btnDanger{background:#8b1d1d;border-color:#a12525}
  .btnSuccess{background:#17663a;border-color:#1a7b46}
  .mgrRow{display:flex;justify-content:flex-end;margin:12px 0;gap:10px;flex-wrap:wrap}

  .cards{display:flex;flex-wrap:wrap;gap:16px;justify-content:center}
  .card{background:var(--panel);border:1px solid #1a2042;border-radius:16px;box-shadow:var(--shadow);width:330px;overflow:hidden}
  .card img{display:block;width:100%;height:160px;object-fit:cover}
  .card .pad{padding:12px}

  .banner{display:flex;align-items:center;justify-content:space-between;gap:10px;background:#351b1b;border:1px solid #5b2c2c;border-radius:12px;padding:10px 12px;margin:10px 0}
  .legend{display:flex;gap:16px;align-items:center;flex-wrap:wrap;color:var(--muted);margin:10px 0 16px}
  .key{display:inline-block;width:14px;height:14px;border-radius:4px;border:2px solid currentColor}
  .key.ok{color:var(--ok)} .key.warn{color:var(--warn)} .key.bad{color:var(--bad)}

  .ackBtn{padding:8px 12px;border-radius:10px;cursor:pointer;border:1px solid}
  @keyframes ackPulse{
    0%{box-shadow:0 0 0 0 rgba(255,180,180,0.45);}
    50%{box-shadow:0 0 0 8px rgba(255,180,180,0);}
    100%{box-shadow:0 0 0 0 rgba(255,180,180,0);}
  }
  .ackBtn.off{background:#8b1d1d;border-color:#a12525;animation:ackPulse 1.8s ease-in-out infinite}
  .ackBtn.on{background:#17663a;border-color:#1a7b46;animation:none}

  /* Viewer: simple image that scales with page zoom */
  .menuWrap{display:none;background:#0d132a;border-radius:14px;position:relative;overflow-x:auto;overflow-y:visible;min-height:140px;transform-origin:top left;-webkit-overflow-scrolling:touch}
  .menuWrap.show{display:block}
  .menuInner{position:relative;display:inline-block;user-select:none;line-height:0;transform-origin:top left;min-width:100%}
  .menuImg{display:block;max-width:100%;height:auto;width:100%}
  .overlayLayer{position:absolute;left:0;top:0;pointer-events:none;line-height:normal;width:100%;height:100%}
  .overlay{position:absolute;border:1.5px solid;border-radius:4px;background:transparent;pointer-events:auto;box-sizing:border-box}
  .overlay:hover{box-shadow:0 0 0 3px #ffffff22,0 6px 16px rgba(0,0,0,.35)}
  .mobileMenuNotice{margin:16px 0;display:flex;flex-direction:column;gap:12px;align-items:stretch}
  .mobileMenuNotice .mobileMenuOpenBtn{width:100%}
  #mobileViewerChrome{position:fixed;inset:0;z-index:3400;display:none;pointer-events:none}
  body.mobileViewerActive #mobileViewerChrome{display:block}
  #mobileViewerChrome .chromeTop{position:fixed;top:calc(env(safe-area-inset-top,0) + 12px);left:0;right:0;display:flex;flex-direction:column;align-items:stretch;gap:10px;padding:0 clamp(12px,3vw,20px);pointer-events:none;z-index:3500}
  #mobileViewerChrome button{pointer-events:auto}
  .mobileViewerSummary{display:none !important}
  .mobileViewerSummaryInner{display:inline-flex;flex-direction:column;align-items:flex-start;gap:6px;padding:10px 16px;border-radius:14px;border:1px solid rgba(76,90,212,0.35);background:rgba(8,12,28,0.94);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);box-shadow:0 10px 28px rgba(0,0,0,0.35);color:var(--muted);max-width:min(800px, calc(100% - 24px))}
  .mobileViewerSummaryInner .label{font-weight:600;color:var(--ink);white-space:nowrap;font-size:0.9rem}
  .mobileViewerSummaryInner .values{color:var(--ink)}
  .mobileInfoHeaderRow{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 16px 8px;border-bottom:1px solid rgba(76,90,212,0.2)}
  .mobileInfoHeader{font-weight:700;font-size:1.1rem;color:var(--ink);flex:1}
  .mobileInfoClose{background:rgba(76,90,212,0.3);border:1px solid rgba(76,90,212,0.5);color:var(--ink);width:36px;height:36px;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:24px;line-height:1;flex-shrink:0}
  .mobileInfoClose:hover{background:rgba(76,90,212,0.5);border-color:var(--hover)}
  .mobileInfoContent{padding:0 16px 16px 16px !important}
  .mobileViewerControlBtn{background:rgba(18,24,58,0.9);border:1px solid rgba(76,90,212,0.5);color:var(--ink);padding:10px 18px;border-radius:999px;font-weight:600;cursor:pointer;box-shadow:0 10px 28px rgba(0,0,0,0.35)}
  .mobileZoomGroup{display:inline-flex;align-items:center;gap:14px;background:rgba(18,24,58,0.9);border:1px solid rgba(76,90,212,0.4);border-radius:999px;padding:10px 18px;box-shadow:0 10px 28px rgba(0,0,0,0.3)}
  .mobileZoomGroup button{background:transparent;border:none;color:var(--ink);font-size:1.3rem;width:48px;height:48px;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center}
  .mobileZoomGroup span{font-weight:600;color:var(--ink);min-width:60px;text-align:center;font-size:0.95rem}
  body.mobileViewerActive{overflow:hidden}
  body.mobileViewerActive .menuWrap{pointer-events:auto;position:fixed;inset:0;margin:0;border-radius:0;padding:calc(env(safe-area-inset-top,0) + 90px) clamp(14px,4vw,36px) calc(env(safe-area-inset-bottom,0) + 80px);background:rgba(4,7,20,0.96);z-index:3100;overflow:auto;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:32px}
  body.mobileViewerActive .menuWrap .menuInner{margin:0 auto}
  body.mobileViewerActive .mobileMenuNotice{display:none !important}
  body.mobileViewerActive .topbar,
  body.mobileViewerActive #root > :not(.menuWrap),
  body.mobileViewerActive .modalBack,
  body.mobileViewerActive .photoModal,
  body.mobileViewerActive .qrPromoBackdrop,
  body.mobileViewerActive .qrBanner{display:none !important}
  .ovBadge{position:absolute;top:3px;right:3px;width:18px;height:18px;background:#3651ff;border:1.5px solid #dbe2ff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;cursor:pointer;z-index:10;pointer-events:auto;line-height:1}
  .ovBadge:hover{background:#4e65ff;box-shadow:0 0 6px #3651ff}
  .ovWarning{position:absolute;top:3px;left:3px;width:18px;height:18px;background:#facc15;border:1.5px solid #fef08a;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;cursor:pointer;z-index:10;pointer-events:auto;line-height:1;color:#000;}
  .ovWarning:hover{background:#fbbf24;box-shadow:0 0 6px #facc15}

  /* Tooltip (with mobile X). We'll shrink it based on visual viewport scale. */
  .tip{position:absolute;z-index:3400;pointer-events:auto;background:rgba(15,21,52,0.98);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:1px solid #2a3466;border-radius:10px;padding:10px;box-shadow:var(--shadow);display:none;max-width:280px;transform-origin:top left}
  .tipHead{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px}
  .tTitle{font-weight:800}
  .tClose{border:1px solid #2a3466;background:#16205a;color:#fff;border-radius:8px;padding:4px 8px;cursor:pointer;line-height:1}
  .tClose:hover{border-color:var(--hover)}
  .tooltipList{margin:4px 0 0 18px;padding:0;list-style:disc}
  .tooltipList li{margin:3px 0}
  .tooltipDangerText{color:var(--bad);font-weight:500}
  .tooltipWarnText{color:var(--warn);font-weight:500}
  .tooltipNeutralText{color:#cbd5f5}

  .aiAssistBackdrop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:20px;background:rgba(7,11,28,0.85);z-index:3600;overflow:hidden;touch-action:none}
  .aiAssistBackdrop.show{display:flex}
  .aiAssistPanel{width:min(95vw,1200px);max-height:85vh;overflow-y:auto;overflow-x:hidden;background:linear-gradient(180deg,#111a3c,#0d132a);border:1px solid #2a3466;border-radius:20px;box-shadow:0 20px 50px rgba(0,0,0,0.5);padding:26px;display:flex;flex-direction:column;gap:18px;touch-action:pan-y}
  .aiAssistHead{display:flex;align-items:center;justify-content:space-between;gap:16px}
  .aiAssistHead h2{margin:0;font-size:clamp(1.1rem,1rem + 1vw,1.6rem)}
  .aiAssistClose{background:rgba(22,32,90,0.9);border:1px solid rgba(76,90,212,0.4);color:var(--ink);width:40px;height:40px;border-radius:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:22px;line-height:1;touch-action:manipulation}
  .aiAssistClose:hover{border-color:var(--hover);box-shadow:0 0 8px #3651ff}
  .aiAssistClose:focus{outline:2px solid var(--hover);outline-offset:2px}
  .aiAssistIntro{margin:0;color:var(--muted);font-size:0.95rem}
  .aiAssistInput{width:100%;min-height:160px;border-radius:16px;border:1px solid rgba(76,90,212,0.35);background:rgba(10,16,36,0.95);color:var(--ink);padding:16px;font-size:1rem;resize:vertical}
  .aiAssistControls{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
  .aiAssistStatus{font-size:0.9rem;color:var(--muted)}
  .aiAssistStatus[data-tone="warn"]{color:var(--warn)}
  .aiAssistStatus[data-tone="error"]{color:var(--bad)}
  .aiAssistStatus[data-tone="success"]{color:var(--ok)}
  .aiProgressBar{display:none;width:100%;height:4px;background:rgba(76,90,212,0.2);border-radius:2px;overflow:hidden;margin:8px 0}
  .aiProgressBar.show{display:block}
  .aiProgressBarFill{height:100%;background:linear-gradient(90deg,#4c5ad4,#8b5cf6);border-radius:2px;transition:width 0.3s ease;animation:shimmer 1.5s infinite}
  @keyframes shimmer{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
  .aiProgressBarFill{background-size:200% 100%}
  .aiAssistMedia{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin-top:6px}
  .aiAssistMedia button{background:#16205a;border:1px solid rgba(76,90,212,0.4);color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
  .aiAssistMedia button:hover{border-color:var(--hover);box-shadow:0 0 8px #3651ff}
  .aiAssistMediaPreview{display:none;flex-direction:column;gap:12px}
  .aiAssistMediaPreview.show{display:flex}
  .aiAssistMediaPreview video,.aiAssistMediaPreview img{max-width:320px;border-radius:12px;border:1px solid rgba(76,90,212,0.35);background:#000}
  .aiAssistPhotoControls{display:flex;gap:10px;flex-wrap:wrap}
  .aiAssistPhotoControls button{background:#16205a;border:1px solid rgba(76,90,212,0.4);color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer}
  .aiAssistPhotoControls button:hover{border-color:var(--hover);box-shadow:0 0 8px #3651ff}
  .aiAssistHidden{display:none !important}
  .aiAssistResults{display:none;flex-direction:column;gap:16px}
  .aiAssistResults.show{display:flex}
  .aiAssistTableWrapper{overflow-x:auto;border:1px solid rgba(76,90,212,0.35);border-radius:16px;background:rgba(9,13,30,0.9)}
  #aiAssistTable{width:100%;border-collapse:collapse;min-width:720px;font-size:0.95rem}
  #aiAssistTable th,#aiAssistTable td{padding:12px;border-bottom:1px solid rgba(76,90,212,0.2);vertical-align:top}
  #aiAssistTable th{text-align:left;background:rgba(17,26,60,0.75)}
  .aiAssistTableWrapper tr:last-child td{border-bottom:none}
  .aiBrandCell{display:flex;flex-direction:column;gap:10px}
  .aiBrandsList{display:flex;flex-direction:column;gap:10px}
  .aiBrandItem{background:#12183a;border:1px solid rgba(76,90,212,0.3);border-radius:12px;padding:10px}
  .aiBrandItemHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .aiBrandItemHeader strong{font-size:0.9rem}
  .aiRemoveBrand{background:#301424;border:1px solid #4c2138;padding:2px 8px;font-size:1.2rem;line-height:1}
  .aiRemoveBrand:hover{border-color:#a12525;box-shadow:0 0 8px rgba(220,82,120,0.55)}
  .aiNoBrands{color:var(--muted);font-size:0.85rem;font-style:italic}
  .aiBrandCell .aiBrandActions{display:flex;gap:8px;flex-wrap:wrap}
  .aiBrandCell .aiBrandActions .btn{padding:8px 12px;font-size:0.9rem}
  .btnSmall{padding:4px 8px !important;font-size:0.85rem !important}
  .aiBrandPreview{display:flex;gap:10px;flex-wrap:wrap}
  .aiBrandPreview img{width:150px;height:150px;object-fit:contain;border-radius:12px;border:1px solid rgba(76,90,212,0.35);background:#0b1020;cursor:pointer;transition:all 0.2s}
  .aiBrandPreview img:hover{border-color:rgba(76,90,212,0.7);box-shadow:0 0 12px rgba(76,90,212,0.4);transform:scale(1.02)}
  .imageModal{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:10000;align-items:center;justify-content:center;padding:20px}
  .imageModal.show{display:flex}
  .imageModal img{max-width:90vw;max-height:90vh;object-fit:contain;border-radius:12px;border:2px solid rgba(76,90,212,0.5);box-shadow:0 10px 50px rgba(0,0,0,0.8)}
  .imageModal .closeModal{position:absolute;top:20px;right:20px;background:rgba(76,90,212,0.8);color:white;border:none;border-radius:50%;width:48px;height:48px;font-size:24px;cursor:pointer;display:flex;align-items:center;justify-content:center}
  .imageModal .closeModal:hover{background:rgba(76,90,212,1)}
  .aiIngredientList{color:var(--muted);font-size:0.85rem}
  .aiIngredientRow{display:flex;flex-direction:column;gap:12px}
  .aiIngredientMain{display:grid;grid-template-columns:1fr 2fr 2fr 1.5fr 1.2fr auto;gap:12px;align-items:start}
  .aiRowBrandResults{display:none;flex-direction:column;gap:12px;padding:16px;border:1px solid rgba(76,90,212,0.35);border-radius:16px;background:rgba(9,13,30,0.9);margin-top:8px}
  .aiRowBrandResults.show{display:flex}
  .aiAllergenChecklist{display:flex;flex-wrap:wrap;gap:8px}
  .aiAllergenChecklist label{display:flex;align-items:center;gap:6px;background:#12183a;border:1px solid rgba(76,90,212,0.3);border-radius:999px;padding:6px 10px;font-size:0.85rem}
  .aiAllergenChecklist label.aiDetected{background:rgba(34,139,34,0.15) !important;border-color:rgba(76,175,80,0.5) !important}
  .aiAllergenChecklist label.aiDetected:hover{background:rgba(34,139,34,0.25) !important;border-color:rgba(76,175,80,0.7) !important}
  .aiAllergenChecklist input{margin:0}
  .aiDietChecklist{display:flex;flex-wrap:wrap;gap:8px}
  .aiDietChecklist label{display:flex;align-items:center;gap:6px;background:#12183a;border:1px solid rgba(76,90,212,0.3);border-radius:999px;padding:6px 10px;font-size:0.85rem}
  .aiDietChecklist label.aiDetected{background:rgba(34,139,34,0.15) !important;border-color:rgba(76,175,80,0.5) !important}
  .aiDietChecklist label.aiDetected:hover{background:rgba(34,139,34,0.25) !important;border-color:rgba(76,175,80,0.7) !important}
  .aiDietChecklist input{margin:0}
  .aiAssistTableActions{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .aiAssistTableActions .aiAssistSpacer{flex:1 1 auto}
  .aiAssistBrandResults{display:none;flex-direction:column;gap:12px;padding:16px;border:1px solid rgba(76,90,212,0.35);border-radius:16px;background:rgba(9,13,30,0.9);max-height:320px;overflow:auto}
  .aiAssistBrandResults.show{display:flex}
  .aiBrandSuggestion{border:1px solid rgba(76,90,212,0.35);border-radius:12px;padding:12px;display:flex;gap:12px;cursor:pointer;align-items:flex-start;background:#12183a}
  .aiBrandSuggestion:hover{border-color:var(--hover);box-shadow:0 0 8px #3651ff}
  .aiBrandSuggestion img{width:72px;height:72px;border-radius:10px;object-fit:cover;border:1px solid rgba(76,90,212,0.35)}
  .aiBrandSuggestion h4{margin:0;font-size:1rem}
  .aiBrandSuggestion p{margin:4px 0 0;font-size:0.85rem;color:var(--muted)}

  /* Modal (editor) */
  .modalBack{position:fixed;inset:0;background:#0008;display:none;align-items:center;justify-content:center;z-index:3000;overflow:auto;padding:20px}
  .modal{background:#0f1534;border:1px solid #2a3466;border-radius:14px;width:min(980px,96vw);max-height:82vh;overflow:auto;box-shadow:var(--shadow);position:relative}
  .modal .head{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid #2a3466}
  .modal .body{padding:14px}
  .modalCloseBtn{position:absolute;top:12px;right:12px;width:32px;height:32px;background:#16205a;border:2px solid #2a3466;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:20px;color:#fff;font-weight:bold;z-index:10}
  .modalCloseBtn:hover{background:#1a2660;border-color:var(--hover)}
  
  .photoCapture{display:flex;flex-direction:column;gap:12px;align-items:center;padding:20px;background:#12183a;border-radius:12px;border:1px solid #2a3466}
  .photoPreview{max-width:100%;max-height:400px;border-radius:8px;border:1px solid #2a3466}
  .videoPreview{max-width:100%;max-height:400px;border-radius:8px;border:1px solid #2a3466;background:#000}
  
  .logEntry{background:#12183a;border:1px solid #2a3466;border-radius:12px;padding:12px;margin:8px 0}
  .logEntry .logHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;flex-wrap:wrap;gap:8px}
  .logEntry .logTimestamp{color:var(--muted);font-size:13px}
  .logEntry .logType{padding:4px 8px;border-radius:6px;font-size:12px;font-weight:600}
  .logType.confirm{background:#17663a;color:#fff}
  .logType.update{background:#3651ff;color:#fff}
  .logEntry .logImage{max-width:100%;border-radius:8px;margin-top:8px;cursor:pointer}
  .logEntry .logImage:hover{opacity:0.8}
  .logEntry .logThumbnail{max-width:120px;max-height:80px;object-fit:cover;border-radius:6px;margin-top:6px;cursor:pointer;border:1px solid #2a3466}
  .logEntry .logThumbnail:hover{opacity:0.85;box-shadow:0 0 8px #3651ff}
  .logAuthor{font-weight:600;margin-bottom:6px}
  .logItem{margin-top:10px;font-weight:600;color:var(--ink)}
  .logList{margin:6px 0 0 18px;padding:0;list-style:disc;color:var(--muted);font-size:13px}
  .logList li{margin:4px 0}
  
  /* Photo preview modal */
  .photoModal{position:fixed;inset:0;background:#000c;display:none;align-items:center;justify-content:center;z-index:4000;padding:20px}
  .photoModal img{max-width:90%;max-height:90%;border-radius:8px;box-shadow:0 10px 40px rgba(0,0,0,.5)}
  .photoModalClose{position:absolute;top:20px;right:20px;width:40px;height:40px;background:#16205a;border:2px solid #2a3466;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:24px;color:#fff;font-weight:bold}
  .photoModalClose:hover{background:#1a2660;border-color:var(--hover)}

  .algRow{display:grid;grid-template-columns:180px minmax(180px,300px) max-content max-content;column-gap:12px;row-gap:6px;align-items:center;margin:6px 0}
  .algBtn{padding:8px 12px;border-radius:999px;border:1px solid #2a3261;background:#12183a;cursor:pointer;text-align:center}
  .algBtn.active{background:#1a2351;box-shadow:0 0 0 3px #7c9cff33 inset;border-color:#4c5ad4}
  .algInput{background:#0c1230;color:var(--ink);border:1px solid #31407f;border-radius:8px;padding:8px 10px;width:100%}
  .algChk{display:flex;align-items:center;gap:8px;white-space:nowrap;justify-self:end}

  .editBox{position:absolute;border:2px solid var(--warn);border-radius:6px;background:transparent;cursor:move;transition:background 0.15s ease, border-color 0.15s ease}
  .editBox:hover{background:rgba(255,193,7,0.08);border-color:#ffc107}
  .editBox.active{background:rgba(76,175,80,0.12);border-color:#4CAF50}
  .editBadge{position:absolute;top:2px;right:2px;width:18px;height:18px;background:#3651ff;border:1.5px solid #dbe2ff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;cursor:pointer;z-index:10;line-height:1}
  .editBadge:hover{background:#4e65ff;box-shadow:0 0 6px #3651ff}
  .handle{position:absolute;width:14px;height:14px;background:#3651ff;border:2px solid #dbe2ff;border-radius:4px}
  .handle.se{right:-7px;bottom:-7px;cursor:nwse-resize}
  .handle.ne{right:-7px;top:-7px;cursor:nesw-resize}
  .handle.nw{left:-7px;top:-7px;cursor:nwse-resize}
  .handle.sw{left:-7px;bottom:-7px;cursor:nesw-resize}

  /* Report inputs */
  input[type="text"], input[type="email"], textarea{
    color:var(--ink) !important; caret-color:var(--ink);
    background:#12183a; border:1px solid #2a3261; border-radius:14px; padding:12px;
  }
  input::placeholder, textarea::placeholder{color:#cfd5ff88}

  /* QR guest promo */
  .qrPromoBackdrop{
    position:fixed; inset:0; display:none;
    align-items:center; justify-content:center;
    padding:20px; background:rgba(8,12,32,.85); z-index:2500;
  }
  .qrPromoBackdrop.show{display:flex;}
  .qrPromo{
    width:min(420px,calc(100% - 40px));
    background:linear-gradient(180deg,#121a3f,#0d132a);
    border:1px solid #2a3466; border-radius:20px;
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    padding:34px 64px 30px 34px; position:relative;
    display:flex; flex-direction:column; gap:14px; text-align:center;
  }
  .qrPromo h2{margin:0 0 6px;font-size:clamp(1.1rem,1rem + 1vw,1.6rem);}
  .qrPromo p{margin:0;color:var(--muted);font-size:0.95rem;line-height:1.5;}
  .qrPromoClose{
    position:absolute; top:12px; right:12px;
    width:44px; height:44px;
    border:1px solid #2a3466; background:#16205a;
    border-radius:8px; cursor:pointer;
    display:flex; align-items:center; justify-content:center;
    font-size:24px; color:#fff; line-height:1;
    touch-action:manipulation;
    z-index:10;
  }
  .qrPromoClose:hover{border-color:var(--hover); box-shadow:0 0 8px #3651ff;}
  .qrPromoClose:active{background:#1e2870;}
  .qrBanner{
    position:fixed; left:0; right:0; top:0; z-index:2200;
    background:linear-gradient(180deg,#0f1534,#0b1020);
    border-bottom:1px solid #2a3466; padding:16px 20px;
    display:none; gap:16px; align-items:center; justify-content:center; flex-wrap:wrap;
    box-shadow:0 4px 20px rgba(0,0,0,.4);
    text-align:center;
  }
  .qrBanner.show{display:flex;}
  body.qrBannerVisible .wrap{padding-top:80px;}
  body.qrBannerVisible .topbar{top:80px;}
  body.qrMode .topbar{border-bottom:none; box-shadow:none;}
  body.qrMode .topin{padding:32px 18px;gap:24px;}
  @media (max-width:640px){
    .topin{gap:12px;padding:16px 14px 12px}
    .brand{gap:12px}
    .brand img{width:40px;height:40px}
    .tabs{gap:6px}
    .tab{padding:6px 10px;font-size:13px}
    .acctBtn{padding:6px 10px;font-size:13px}
    .content{padding:10px;padding-bottom:160px}
    .legend{gap:10px}
    h1{font-size:1.3rem;margin:4px 0 10px}
    .cards{gap:12px}
    .card{width:calc(100% - 20px);max-width:400px}
    .card img{height:140px}
    .card .pad{padding:10px}
    .card .pad > div:first-child{font-size:16px;margin-bottom:4px}
    .note{font-size:12px}
    .btn{padding:8px 12px;font-size:13px}
    .ovBadge,.ovWarning{top:1px;width:6px;height:6px;border:0.5px solid;font-size:5px}
    .ovBadge{right:1px;border-color:#dbe2ff}
    .ovWarning{left:1px;border-color:#fef08a}
    .ovBadge:hover{box-shadow:0 0 4px #3651ff}
    .ovWarning:hover{box-shadow:0 0 4px #facc15}
    .banner{flex-direction:column;align-items:stretch}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar"><div class="topin" id="topbar"></div></div>
  <div class="content" id="root"></div>
</div>

<div class="tip" id="tip"></div>

<div class="modalBack" id="modalBack">
  <div class="modal">
    <button class="modalCloseBtn" id="modalCloseBtn" type="button">×</button>
    <div class="head"><div id="modalTitle">Edit item</div></div>
    <div class="body" id="modalBody"></div>
  </div>
</div>

<div class="photoModal" id="photoModal">
  <div class="photoModalClose" id="photoModalClose">×</div>
  <img id="photoModalImage" src="" alt="Confirmation photo">
</div>

<div class="qrPromoBackdrop" id="qrPromoBackdrop" aria-hidden="true">
  <div class="qrPromo" role="dialog" aria-labelledby="qrPromoTitle" aria-modal="true">
    <button class="qrPromoClose" id="qrPromoClose" type="button" aria-label="Close promotion">×</button>
    <h2 id="qrPromoTitle">See allergy-safe spots all over CLE</h2>
    <p>Save your allergens once and unlock curated menus at restaurants across the city.</p>
    <p>Creating an account takes less than a minute and is completely free.</p>
    <button class="btn btnPrimary" id="qrPromoSignup" type="button">Create free account</button>
  </div>
</div>
<div class="qrBanner" id="qrBanner" aria-hidden="true">
  <div><strong>Keep exploring safely.</strong> Create a free account to save your allergens and see compatible dishes everywhere.</div>
  <button class="btn btnPrimary" id="qrBannerSignup" type="button">Create free account</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script type="module">
// Initialize Supabase
const SUPABASE_URL = 'https://fgoiyycctnwnghrvsilt.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZnb2l5eWNjdG53bmdocnZzaWx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MzY1MjYsImV4cCI6MjA3NjAxMjUyNn0.xlSSXr0Gl7j-vsckrj-2anpPmp4BG2SUIdN-_dquSA8';
const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);
window.supabaseClient = supabaseClient;

// Get slug from URL
const urlParams = new URLSearchParams(window.location.search);
const slug = urlParams.get('slug');
const qrParam = urlParams.get('qr');
const isQrVisit = qrParam ? /^(1|true|yes)$/i.test(qrParam) : false;
window.__qrVisit = isQrVisit;

// Check for editor mode URL parameter
const editParam = urlParams.get('edit') || urlParams.get('mode');
const shouldStartInEditor = editParam === 'true' || editParam === 'editor' || editParam === '1';
window.__startInEditor = shouldStartInEditor;
if(shouldStartInEditor) console.log('Editor mode requested via URL parameter');

if (!slug) {
  document.body.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Error: No restaurant specified</div>';
} else {
  // Fetch restaurant data
  async function loadRestaurant() {
    const { data: restaurant, error } = await supabaseClient
      .from('restaurants')
      .select('*')
      .eq('slug', slug)
      .single();

    if (error) {
      console.error('Error loading restaurant:', error);
      document.body.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Error loading restaurant</div>';
      return;
    }

    if (!restaurant) {
      document.body.innerHTML = '<div style="color: #ef4444; text-align: center; padding: 40px;">Restaurant not found</div>';
      return;
    }

    // Get current user
    const { data: { user } } = await supabaseClient.auth.getUser();

    // Get user allergies and diets if logged in
    let allergies = [];
    let diets = [];
    let canEdit = false;
    if (user) {
      const { data: record } = await supabaseClient
        .from('user_allergies')
        .select('allergens, diets')
        .eq('user_id', user.id)
        .maybeSingle();
      allergies = record?.allergens || [];
      diets = record?.diets || [];

      const { data: managerRecord, error: managerError } = await supabaseClient
        .from('restaurant_managers')
        .select('id')
        .eq('user_id', user.id)
        .eq('restaurant_id', restaurant.id)
        .maybeSingle();
      if(managerError){
        console.error('Manager lookup failed', managerError);
      }
      console.log('Manager row:', managerRecord, 'error:', managerError);
      // TEMPORARY: Make everyone a manager for Falafel Café
      canEdit = !!managerRecord || restaurant.name === 'Falafel Café';
    }

    // Transform restaurant data to match expected format
    const restaurantData = normalizeRestaurant(restaurant);

    // Send data to the embedded page script
    // Check if editor mode should be activated via URL parameter
    const initialPage = (window.__startInEditor && canEdit) ? 'editor' : 'restaurant';
    window.postMessage({
      page: initialPage,
      restaurant: restaurantData,
      user: user ? { loggedIn: true, email: user.email, id: user.id, name: user.user_metadata?.first_name || null } : { loggedIn: false },
      allergies: allergies,
      diets: diets,
      canEdit: canEdit,
      canEditSource: canEdit ? 'manager-row' : 'none',
      qr: isQrVisit
    }, '*');
  }

  loadRestaurant();
}
</script>

<script>
// Ensure zoom is always allowed on mobile Safari
(function () {
  var m = document.querySelector('meta[name="viewport"]');
  if (m && !/maximum-scale/i.test(m.content)) {
    m.content += ', user-scalable=yes, maximum-scale=10';
  }
  ['touchstart','touchmove'].forEach(function (t) {
    document.addEventListener(t, function () {}, {passive:true});
  });
})();
document.body.style.display='none';

const ALLERGENS=["dairy","egg","peanut","tree nut","shellfish","fish","soy","sesame","wheat"];
const DIETS=["Vegan","Vegetarian","Pescatarian"];
const ALLERGEN_ALIASES={
  milk:'dairy',
  lactose:'dairy',
  butter:'dairy',
  eggs:'egg',
  egg:'egg',
  peanuts:'peanut',
  peanut:'peanut',
  treenut:'tree nut',
  "tree nut":"tree nut",
  "tree nuts":"tree nut",
  almond:'tree nut',
  cashew:'tree nut',
  walnut:'tree nut',
  shellfish:'shellfish',
  crustaceans:'shellfish',
  crustacean:'shellfish',
  molluscs:'shellfish',
  fish:'fish',
  salmon:'fish',
  tuna:'fish',
  wheat:'wheat',
  soy:'soy',
  soya:'soy',
  sesame:'sesame'
};
const ALLERGEN_EMOJI={
  'dairy':'🥛',
  'egg':'🥚',
  'peanut':'🥜',
  'tree nut':'🌰',
  'shellfish':'🦐',
  'fish':'🐟',
  'soy':'🫛',
  'sesame':'🫘',
  'wheat':'🌾'
};

function detectAllergensInText(text){
  if(!text) return [];
  const lower=text.toLowerCase();
  const found=new Set();
  Object.entries(ALLERGEN_ALIASES).forEach(([alias,target])=>{
    if(lower.includes(alias)) found.add(target);
  });
  ALLERGENS.forEach(a=>{ if(lower.includes(a)) found.add(a); });
  return [...found];
}
const state={page:null,restaurants:[],restaurant:null,allergies:[],diets:[],ack:false,user:{loggedIn:false},canEdit:false,qr:false,_hydrated:false,aiAssistEndpoint:null};
let mobileInfoPanel=null;
let currentMobileInfoItem=null;
let mobileViewerChrome=null;
let mobileZoomLevel=1;
let mobileViewerKeyHandler=null;

function ensureMobileInfoPanel(){
  if(mobileInfoPanel && mobileInfoPanel.isConnected) return mobileInfoPanel;
  if(!mobileInfoPanel){
    mobileInfoPanel=document.createElement('div');
    mobileInfoPanel.id='mobileInfoPanel';
    mobileInfoPanel.className='mobileInfoPanel';
    mobileInfoPanel.setAttribute('aria-live','polite');
    mobileInfoPanel.style.position='fixed';
    mobileInfoPanel.style.left='12px';
    mobileInfoPanel.style.right='12px';
    mobileInfoPanel.style.bottom='12px';
    mobileInfoPanel.style.width='auto';
    mobileInfoPanel.style.zIndex='3500';
    mobileInfoPanel.style.background='rgba(11,16,32,0.94)';
    mobileInfoPanel.style.backdropFilter='blur(14px)';
    mobileInfoPanel.style.webkitBackdropFilter='blur(14px)';
    mobileInfoPanel.style.paddingBottom='calc(24px + env(safe-area-inset-bottom,0))';
    mobileInfoPanel.style.borderRadius='20px';
    mobileInfoPanel.style.display='none';
  }
  mobileInfoPanel.innerHTML='';
  mobileInfoPanel.classList.remove('show');
  mobileInfoPanel.style.display='none';
  document.body.appendChild(mobileInfoPanel);
  adjustMobileInfoPanelForZoom();
  return mobileInfoPanel;
}

function adjustMobileInfoPanelForZoom(){
  // No longer needed since pinch-to-zoom is disabled
  // Keeping function for compatibility
}

function getMenuState(){
  if(!window.__menuState) window.__menuState={};
  return window.__menuState;
}

function captureMenuBaseDimensions(force=false){
  const state=getMenuState();
  const img=state?.img;
  if(!img) return;
  if(force || !state.baseWidth){
    state.baseWidth = img.clientWidth || img.naturalWidth || img.width || 0;
    state.baseHeight = img.clientHeight || img.naturalHeight || img.height || 0;
  }
}

function ensureMobileViewerChrome(){
  if(mobileViewerChrome && mobileViewerChrome.isConnected) return mobileViewerChrome;
  let chrome=document.getElementById('mobileViewerChrome');
  if(!chrome){
    chrome=document.createElement('div');
    chrome.id='mobileViewerChrome';
    chrome.innerHTML=`
      <div class="chromeTop">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;pointer-events:auto;">
          <button type="button" class="mobileViewerControlBtn" id="mobileViewerCloseBtn">Close</button>
          <div class="mobileZoomGroup">
            <button type="button" id="mobileZoomOutBtn" aria-label="Zoom out">−</button>
            <span id="mobileZoomValue">100%</span>
            <button type="button" id="mobileZoomInBtn" aria-label="Zoom in">+</button>
          </div>
        </div>
        <div class="mobileViewerSummary" id="mobileViewerAllergySummary" aria-live="polite"></div>
      </div>`;
    document.body.appendChild(chrome);
  }
  if(!chrome.style.display) chrome.style.display='none';
  if(!chrome.hasAttribute('aria-hidden')) chrome.setAttribute('aria-hidden','true');
  mobileViewerChrome=chrome;
  const closeBtn=chrome.querySelector('#mobileViewerCloseBtn');
  const zoomOutBtn=chrome.querySelector('#mobileZoomOutBtn');
  const zoomInBtn=chrome.querySelector('#mobileZoomInBtn');
  if(closeBtn) closeBtn.onclick=()=>closeMobileViewer();
  if(zoomOutBtn) zoomOutBtn.onclick=()=>setMobileZoom(mobileZoomLevel-0.25);
  if(zoomInBtn) zoomInBtn.onclick=()=>setMobileZoom(mobileZoomLevel+0.25);
  updateFullScreenAllergySummary();
  return mobileViewerChrome;
}

function updateZoomIndicator(){
  const indicator=document.getElementById('mobileZoomValue');
  if(indicator) indicator.textContent=`${Math.round(mobileZoomLevel*100)}%`;
}

function updateFullScreenAllergySummary(){
  const summary=document.getElementById('mobileViewerAllergySummary');
  if(!summary) return;
  const uniqueKeys=Array.from(new Set((state.allergies||[]).map(norm))).filter(Boolean);
  const selectedDiets=(state.diets||[]);

  let html='';
  if(uniqueKeys.length || selectedDiets.length){
    html='<div class="mobileViewerSummaryInner">';

    // Allergens with emoji badges
    if(uniqueKeys.length){
      const allergenBadges=uniqueKeys.map(a=>{
        const emoji=ALLERGEN_EMOJI[a]||'🔴';
        return `<span style="display:inline-flex;align-items:center;gap:3px;background:rgba(76,90,212,0.25);border:1px solid rgba(76,90,212,0.4);border-radius:999px;padding:3px 8px;font-size:0.8rem;white-space:nowrap;"><span>${emoji}</span><span>${esc(cap(a))}</span></span>`;
      }).join('');
      html+=`<div style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;"><span class="label">Allergens:</span>${allergenBadges}</div>`;
    }

    // Dietary preferences with emoji
    if(selectedDiets.length){
      const dietBadges=selectedDiets.map(d=>{
        const emoji=d==='Vegan'?'🌱':d==='Vegetarian'?'🥬':d==='Pescatarian'?'🐟':'🍽️';
        return `<span style="display:inline-flex;align-items:center;gap:3px;background:rgba(34,197,94,0.15);border:1px solid rgba(34,197,94,0.4);border-radius:999px;padding:3px 8px;font-size:0.8rem;white-space:nowrap;"><span>${emoji}</span><span>${esc(d)}</span></span>`;
      }).join('');
      html+=`<div style="display:flex;align-items:center;gap:5px;flex-wrap:wrap;margin-top:${uniqueKeys.length?'5px':'0'}"><span class="label">Diets:</span>${dietBadges}</div>`;
    }

    html+='</div>';
  } else {
    html=`<div class="mobileViewerSummaryInner"><span class="values">No allergens or dietary preferences selected</span></div>`;
  }
  summary.innerHTML=html;
}

function setMobileZoom(level, resetBase=false){
  const state=getMenuState();
  const img=state?.img;
  if(!img) return;
  if(resetBase){
    state.baseWidth=null;
    state.baseHeight=null;
  }
  captureMenuBaseDimensions(resetBase);
  if(!state.baseWidth){
    updateZoomIndicator();
    return;
  }
  mobileZoomLevel=Math.min(Math.max(level,1),4);
  const width=state.baseWidth*mobileZoomLevel;
  const inner=state.inner;
  const layer=state.layer;
  img.style.width=width+'px';
  if(inner) inner.style.width=width+'px';
  if(layer) layer.style.width=width+'px';
  requestAnimationFrame(()=>{
    if(window.__rerenderLayer__) window.__rerenderLayer__();
    updateZoomIndicator();
  });
}

function resetMobileZoom(){
  const state=getMenuState();
  mobileZoomLevel=1;
  const img=state?.img;
  if(img){
    img.style.width='';
    if(state.inner) state.inner.style.width='';
    if(state.layer) state.layer.style.width='';
  }
  requestAnimationFrame(()=>{
    if(window.__rerenderLayer__) window.__rerenderLayer__();
    captureMenuBaseDimensions(true);
    updateZoomIndicator();
  });
}

function openMobileViewer(){
  const chrome=ensureMobileViewerChrome();
  if(chrome){
    chrome.style.display='block';
    chrome.setAttribute('aria-hidden','false');
  }
  captureMenuBaseDimensions(true);
  document.body.classList.add('mobileViewerActive');
  updateFullScreenAllergySummary();
  setMobileZoom(1,true);
  if(prefersMobileInfo()){
    if(currentMobileInfoItem){
      renderMobileInfo(currentMobileInfoItem);
    } else {
      renderMobileInfo(null);
    }
  }
  const wrap=document.getElementById('menu');
  if(wrap){
    wrap.scrollTop=0;
  }
  const closeBtn=document.getElementById('mobileViewerCloseBtn');
  if(closeBtn){
    setTimeout(()=>closeBtn.focus(),150);
  }
  if(!mobileViewerKeyHandler){
    mobileViewerKeyHandler=(e)=>{
      if(e.key==='Escape'){
        e.preventDefault();
        closeMobileViewer();
      }
    };
    document.addEventListener('keydown',mobileViewerKeyHandler);
  }
}

function closeMobileViewer(){
  document.body.classList.remove('mobileViewerActive');
  if(mobileViewerChrome){
    mobileViewerChrome.style.display='none';
    mobileViewerChrome.setAttribute('aria-hidden','true');
  }
  resetMobileZoom();
  // Close the mobile info panel if it's open
  if(mobileInfoPanel){
    mobileInfoPanel.classList.remove('show');
    mobileInfoPanel.style.display='none';
    mobileInfoPanel.innerHTML='';
    currentMobileInfoItem=null;
  }
  if(prefersMobileInfo()){
    if(currentMobileInfoItem){
      renderMobileInfo(currentMobileInfoItem);
    } else {
      renderMobileInfo(null);
    }
  }
  const openBtn=document.querySelector('#mobileMenuNotice .mobileMenuOpenBtn');
  if(openBtn){
    setTimeout(()=>openBtn.focus(),150);
  }
  const notice=document.getElementById('mobileMenuNotice');
  if(notice && notice.dataset.enabled==='1'){
    notice.style.display='flex';
    notice.setAttribute('aria-hidden','false');
  }
  if(mobileViewerKeyHandler){
    document.removeEventListener('keydown',mobileViewerKeyHandler);
    mobileViewerKeyHandler=null;
  }
}

const urlQR=typeof window.__qrVisit==='boolean'
  ? window.__qrVisit
  : (()=>{const v=new URLSearchParams(location.search).get('qr'); return v && /^(1|true|yes)$/i.test(v);})();

const QR_PROMO_STORAGE_KEY='qrPromoDismissed';
function shouldShowQrPromo(){
  try{return !sessionStorage.getItem(QR_PROMO_STORAGE_KEY);}catch(_){return true;}
}
function dismissQrPromo(){
  try{sessionStorage.setItem(QR_PROMO_STORAGE_KEY,'1');}catch(_){}
}
function shouldShowQrBanner(){
  return !state.user?.loggedIn;
}
function showQrBanner(){
  const banner=document.getElementById('qrBanner');
  if(!banner) return;
  if(!shouldShowQrBanner()) return;
  banner.classList.add('show');
  banner.setAttribute('aria-hidden','false');
  document.body.classList.add('qrBannerVisible');
}
function hideQrBanner(){
  const banner=document.getElementById('qrBanner');
  if(!banner) return;
  banner.classList.remove('show');
  banner.setAttribute('aria-hidden','true');
  document.body.classList.remove('qrBannerVisible');
}
let qrPromoTimerId=null;
function cancelQrPromoTimer(){
  if(qrPromoTimerId){clearTimeout(qrPromoTimerId);qrPromoTimerId=null;}
}
function queueQrPromoTimer(){
  cancelQrPromoTimer();
  qrPromoTimerId=setTimeout(()=>{
    qrPromoTimerId=null;
    if(!state.user?.loggedIn && shouldShowQrPromo()){
      openQrPromo();
    }
  },10000);
}
function openQrPromo(){
  const backdrop=document.getElementById('qrPromoBackdrop');
  if(!backdrop || backdrop.classList.contains('show')) return;
  hideQrBanner();
  backdrop.classList.add('show');
  backdrop.setAttribute('aria-hidden','false');
}
function closeQrPromo(reason='dismiss'){
  const backdrop=document.getElementById('qrPromoBackdrop');
  if(backdrop && backdrop.classList.contains('show')){
    backdrop.classList.remove('show');
    backdrop.setAttribute('aria-hidden','true');
  }
  if(reason!=='login') dismissQrPromo();
  cancelQrPromoTimer();
  if(reason==='dismiss' && shouldShowQrBanner()){
    showQrBanner();
  }
  if(reason==='signup' || reason==='login'){
    hideQrBanner();
  }
}

// Handle navigation in standalone mode
const isStandalone = (window === window.parent);
const send=(p)=>{
  if (isStandalone) {
    // Handle navigation directly in standalone mode
    if (p.type === 'navigate') {
      if (p.to === '/restaurants') window.location.href = 'restaurants.html';
      else if (p.to === '/favorites') window.location.href = 'favorites.html';
      else if (p.to === '/report-issue') window.location.href = 'report-issue.html';
      else if (p.to === '/accounts') {
        const params=new URLSearchParams();
        if(p.slug) params.set('returnSlug',p.slug);
        if(p.redirect) params.set('redirect',p.redirect);
        const url='account.html'+(params.toString()?`?${params.toString()}`:'');
        window.location.href=url;
      }
      else window.location.href = p.to;
    } else if (p.type === 'signIn') {
      const params=new URLSearchParams();
      if(p.slug) params.set('returnSlug',p.slug);
      if(p.redirect) params.set('redirect',p.redirect);
      const url='account.html'+(params.toString()?`?${params.toString()}`:'');
      window.location.href = url;
    } else if (p.type === 'openRestaurant') {
      window.location.href = `restaurant.html?slug=${p.slug}`;
    } else if (p.type === 'saveOverlays') {
      (async ()=>{
        try{
          const client = window.supabaseClient;
          if(!client) throw new Error('Supabase client not ready.');
          const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
          if(!restaurantId) throw new Error('Restaurant not loaded yet.');
          const payload = { overlays: p.overlays || [] };
          if (p.menuImage) payload.menu_image = p.menuImage;
          const { data, error } = await client
            .from('restaurants')
            .update(payload)
            .eq('id', restaurantId)
            .select()
            .single();
          if(error) throw error;
          const updatedRestaurant = normalizeRestaurant(data);
          window.postMessage({type:'overlaysSaved', restaurant: updatedRestaurant}, '*');

          const rawChangePayload=p.changes;
          let changePayload=null;
          if(rawChangePayload && typeof rawChangePayload==='object' && !Array.isArray(rawChangePayload)){
            changePayload=rawChangePayload;
          } else if(typeof rawChangePayload==='string'){
            try{ changePayload=JSON.parse(rawChangePayload); }
            catch(_){ changePayload=null; }
          }

          let authorName='Manager';
          if(state.user?.name){
            authorName=state.user.name;
          } else if(state.user?.user_metadata?.first_name || state.user?.user_metadata?.last_name){
            const first=state.user.user_metadata.first_name || '';
            const last=state.user.user_metadata.last_name || '';
            authorName=`${first} ${last}`.trim();
          } else if(state.user?.email){
            authorName=state.user.email.split('@')[0];
          }

          if(changePayload && changePayload.author){
            authorName=changePayload.author;
          }

          const storedChanges=changePayload
            ? JSON.stringify(changePayload)
            : (typeof rawChangePayload==='string' ? rawChangePayload : 'Menu overlays updated.');

          try{
            await insertChangeLogEntry({
              restaurantId,
              timestamp: new Date().toISOString(),
              type: 'update',
              description: authorName,
              changes: storedChanges,
              overlays: p.overlays || [],
              menuImage: p.menuImage || null,
              userEmail: state.user?.email || null
            });
          }catch(logError){
            console.error('Change log insert failed', logError);
          }
        }catch(err){
          console.error('Saving overlays failed', err);
          window.postMessage({type:'saveFailed', message: err.message}, '*');
        }
      })();
      return;
    } else if (p.type === 'confirmAllergens') {
      (async ()=>{
        try{
          const client = window.supabaseClient;
          if(!client) throw new Error('Supabase client not ready.');
          const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
          if(!restaurantId) throw new Error('Restaurant not loaded yet.');
          const timestamp = p.timestamp || new Date().toISOString();

          const { data: updated, error } = await client
            .from('restaurants')
            .update({ last_confirmed: timestamp })
            .eq('id', restaurantId)
            .select()
            .single();
          if(error) throw error;

      try{
        let userName = 'Manager';
        if(state.user?.name) {
          userName = state.user.name;
        } else if(state.user?.user_metadata?.first_name || state.user?.user_metadata?.last_name) {
          const first = state.user.user_metadata.first_name || '';
          const last = state.user.user_metadata.last_name || '';
          userName = `${first} ${last}`.trim();
        } else if(state.user?.email) {
          userName = state.user.email.split('@')[0];
        }
        const confirmPayload={
          author:userName,
          general:['Allergen information confirmed'],
          items:{}
        };
        await insertChangeLogEntry({
          restaurantId,
          timestamp,
          type: 'confirm',
          description: userName,
          changes: JSON.stringify(confirmPayload),
          userEmail: state.user?.email || null,
          photos: p.photos || (p.photo ? [p.photo] : [])
        });
      }catch(logError){
        console.error('Change log insert failed', logError);
      }

          window.postMessage({type:'confirmationSaved', restaurant: normalizeRestaurant(updated), timestamp}, '*');
        }catch(err){
          console.error('Confirmation failed', err);
          window.postMessage({type:'confirmationFailed', message: err.message}, '*');
        }
      })();
      return;
    } else if (p.type === 'getChangeLog') {
      (async ()=>{
        try{
          const logs = await fetchChangeLogEntries(p.restaurantId || state.restaurant?._id || state.restaurant?.id || null);
          window.postMessage({type:'changeLog', logs:logs || []}, '*');
        }catch(err){
          console.error('Loading change log failed', err);
          window.postMessage({type:'changeLog', logs:[], error: err.message}, '*');
        }
      })();
      return;
    }
    // For other message types, just log them in standalone mode
    console.log('Message sent:', p);
  } else {
    // In iframe mode, use postMessage
    parent.postMessage(p,"*");
  }
};
function requestSignIn(origin){
  const slugParam=(state.restaurant && state.restaurant.slug) || slug || '';
  const payload={type:'signIn'};
  if(slugParam) payload.slug=slugParam;
  if(origin==='restaurants') payload.redirect='restaurants';
  if(origin==='qr') payload.from='qr';
  send(payload);
}
const qrPromoBackdrop=document.getElementById('qrPromoBackdrop');
const qrPromoCloseBtn=document.getElementById('qrPromoClose');
const qrPromoSignupBtn=document.getElementById('qrPromoSignup');
const qrBanner=document.getElementById('qrBanner');
const qrBannerSignupBtn=document.getElementById('qrBannerSignup');

if(qrPromoBackdrop){
  qrPromoBackdrop.addEventListener('click',(e)=>{if(e.target===qrPromoBackdrop) closeQrPromo('dismiss');});
}
if(qrPromoCloseBtn){
  qrPromoCloseBtn.onclick=()=>closeQrPromo('dismiss');
}
if(qrPromoSignupBtn){
  qrPromoSignupBtn.onclick=()=>{closeQrPromo('signup'); requestSignIn('qr');};
}
if(qrBannerSignupBtn){
  qrBannerSignupBtn.onclick=()=>{hideQrBanner(); requestSignIn('qr');};
}
const norm=s=>(s||'').toString().trim().toLowerCase();
const esc=s=>(s??'').toString().replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
const cap=s=>(s||'').split(' ').map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ');
const fmtDate=d=>{try{const x=new Date(d);return isNaN(x)?'':x.toLocaleDateString();}catch(_){return '';}};
const fmtDateTime=d=>{try{const x=new Date(d);return isNaN(x)?'':x.toLocaleDateString()+' at '+x.toLocaleTimeString();}catch(_){return '';}};

let aiAssistBackdrop=null;
let aiAssistPanel=null;
let aiAssistCloseBtn=null;
let aiAssistInput=null;
let aiAssistDictateBtn=null;
let aiAssistProcessBtn=null;
let aiAssistStatusEl=null;
let aiAssistResultsEl=null;
let aiAssistTableBody=null;
let aiAssistAddRowBtn=null;
let aiAssistApplyBtn=null;
let aiAssistBrandResults=null;
let aiAssistUploadBtn=null;
let aiAssistCameraBtn=null;
let aiAssistFileInput=null;
let aiAssistImagePreview=null;
let aiAssistVideo=null;
let aiAssistCaptureBtn=null;
let aiAssistCancelCameraBtn=null;
let aiAssistClearImageBtn=null;
let aiAssistMediaPreview=null;
let aiAssistElementsBound=false;

const aiAssistState={
  context:null,
  recognition:null,
  listening:false,
  pendingRequestId:null,
  brandSuggestions:{},
  imageData:null,
  imageFileName:null,
  mediaStream:null,
  detectedDietaryOptions:[]
};

const AI_BRAND_LIMIT=6;
const AI_BRAND_MEMORY_KEY='cle:aiBrandMemory:v1';

let aiBrandMemoryCache=null;

function loadAiBrandMemory(){
  if(aiBrandMemoryCache) return aiBrandMemoryCache;
  try{
    const raw=localStorage.getItem(AI_BRAND_MEMORY_KEY);
    aiBrandMemoryCache=raw?JSON.parse(raw):{};
  }catch(_){
    aiBrandMemoryCache={};
  }
  return aiBrandMemoryCache;
}

function persistAiBrandMemory(){
  try{
    localStorage.setItem(AI_BRAND_MEMORY_KEY,JSON.stringify(aiBrandMemoryCache||{}));
  }catch(_){ }
}

function normalizeIngredientKey(name){
  return norm(name||'').replace(/[^a-z0-9]+/g,' ').trim();
}

function rememberBrand(name,data={}){
  const key=normalizeIngredientKey(name);
  if(!key) return;
  const store=loadAiBrandMemory();
  const brand=(data.brand||'').trim();
  if(!brand){
    delete store[key];
    persistAiBrandMemory();
    return;
  }
  store[key]={
    brand,
    brandImage:data.brandImage||'',
    ingredientsImage:data.ingredientsImage||'',
    ingredientsList:Array.isArray(data.ingredientsList)?data.ingredientsList.slice():[],
    allergens:Array.isArray(data.allergens)?data.allergens.slice():[],
    diets:Array.isArray(data.diets)?data.diets.slice():[],
  };
  persistAiBrandMemory();
}

function forgetBrand(name){
  const key=normalizeIngredientKey(name);
  if(!key) return;
  const store=loadAiBrandMemory();
  if(store[key]){
    delete store[key];
    persistAiBrandMemory();
  }
}

function getRememberedBrand(name){
  const key=normalizeIngredientKey(name);
  if(!key) return null;
  const store=loadAiBrandMemory();
  const result = store[key]||null;
  console.log(`Looking up brand for "${name}" (key: "${key}"):`, result ? `Found: ${result.brand}` : 'Not found');
  console.log('Available keys in brand memory:', Object.keys(store));
  return result;
}

function rebuildBrandMemoryFromRestaurant(){
  // Clear all existing brand memory
  console.log('=== REBUILDING BRAND MEMORY ===');
  console.log('Old brand memory:', JSON.stringify(aiBrandMemoryCache));
  aiBrandMemoryCache = {};

  // Rebuild from actual dishes in database
  if(!state.restaurant || !Array.isArray(state.restaurant.overlays)){
    console.log('No restaurant or overlays found, clearing memory');
    persistAiBrandMemory();
    return;
  }

  console.log(`Scanning ${state.restaurant.overlays.length} dishes for brands...`);

  // Scan through all overlays/dishes
  state.restaurant.overlays.forEach((overlay, overlayIdx) => {
    const dishName = overlay.id || overlay.name || 'unnamed';

    // Parse aiIngredients if it exists (it's stored as a JSON string)
    let ingredients = [];
    if(overlay.aiIngredients){
      try {
        ingredients = JSON.parse(overlay.aiIngredients);
        console.log(`Dish ${overlayIdx} (${dishName}): Found aiIngredients with ${ingredients.length} ingredients`);
      } catch(e){
        console.log(`Dish ${overlayIdx} (${dishName}): Failed to parse aiIngredients:`, e);
      }
    }

    // Also check for legacy ingredients array format
    if(!ingredients.length && Array.isArray(overlay.ingredients)){
      ingredients = overlay.ingredients;
      console.log(`Dish ${overlayIdx} (${dishName}): Using legacy ingredients array with ${ingredients.length} ingredients`);
    }

    if(!ingredients.length){
      console.log(`Dish ${overlayIdx} (${dishName}): No ingredients found`);
      return;
    }

    console.log(`Dish ${overlayIdx} (${dishName}): Processing ${ingredients.length} ingredients`);

    ingredients.forEach(ingredient => {
      if(!ingredient.name || !Array.isArray(ingredient.brands) || ingredient.brands.length === 0){
        return;
      }

      console.log(`  - Ingredient "${ingredient.name}" has ${ingredient.brands.length} brand(s)`);

      // Save each brand to memory
      ingredient.brands.forEach(brand => {
        if(brand.name){
          console.log(`    -> Saving brand "${brand.name}" for "${ingredient.name}"`);
          rememberBrand(ingredient.name, {
            brand: brand.name,
            brandImage: brand.brandImage || '',
            ingredientsImage: brand.ingredientsImage || '',
            ingredientsList: Array.isArray(brand.ingredientsList) ? brand.ingredientsList : [],
            allergens: Array.isArray(brand.allergens) ? brand.allergens : [],
            diets: Array.isArray(brand.diets) ? brand.diets : []
          });
        }
      });
    });
  });

  console.log('=== BRAND MEMORY REBUILD COMPLETE ===');
  console.log('New brand memory:', JSON.stringify(aiBrandMemoryCache));
}

function fillRowFromMemory(rowElement,force){
  if(!rowElement) return;
  const nameInput=rowElement.querySelector('.aiIngredientName');
  const brandInput=rowElement.querySelector('.aiIngredientBrand');
  const name=(nameInput?.value||'').trim();
  if(!name) return;
  const memory=getRememberedBrand(name);
  if(!memory) return;
  if(brandInput && (force || !(brandInput.value||'').trim()) && memory.brand){
    brandInput.value=memory.brand;
  }
  if(memory.brandImage){
    rowElement.dataset.brandImage=memory.brandImage;
  }
  if(memory.ingredientsImage){
    rowElement.dataset.ingredientsImage=memory.ingredientsImage;
  }
  if(memory.ingredientsList && memory.ingredientsList.length){
    rowElement.dataset.ingredientsList=JSON.stringify(memory.ingredientsList);
  }
  if(memory.allergens && memory.allergens.length){
    const allergenSet=new Set(memory.allergens.map(norm));
    rowElement.querySelectorAll('.aiAllergenChecklist input').forEach(input=>{
      if(allergenSet.has(norm(input.value))) input.checked=true;
    });
  }
  updateAiBrandPreview(rowElement);
}

function aiAssistSetStatus(message='', tone='info'){
  if(!aiAssistStatusEl) return;
  aiAssistStatusEl.textContent=message;
  if(message){
    aiAssistStatusEl.setAttribute('data-tone',tone);
  } else {
    aiAssistStatusEl.removeAttribute('data-tone');
  }
}

function ensureAiAssistElements(){
  if(aiAssistBackdrop && aiAssistBackdrop.isConnected) return;
  if(aiAssistBackdrop && !aiAssistBackdrop.isConnected){
    aiAssistBackdrop=null;
    aiAssistPanel=null;
    aiAssistCloseBtn=null;
    aiAssistInput=null;
    aiAssistDictateBtn=null;
    aiAssistProcessBtn=null;
    aiAssistStatusEl=null;
    aiAssistResultsEl=null;
    aiAssistTableBody=null;
    aiAssistAddRowBtn=null;
    aiAssistApplyBtn=null;
    aiAssistBrandResults=null;
    aiAssistUploadBtn=null;
    aiAssistCameraBtn=null;
    aiAssistFileInput=null;
    aiAssistImagePreview=null;
    aiAssistVideo=null;
    aiAssistCaptureBtn=null;
    aiAssistCancelCameraBtn=null;
    aiAssistClearImageBtn=null;
    aiAssistMediaPreview=null;
    aiAssistElementsBound=false;
  }
  if(!aiAssistBackdrop){
    const backdrop=document.createElement('div');
    backdrop.className='aiAssistBackdrop';
    backdrop.id='aiAssistBackdrop';
    backdrop.setAttribute('aria-hidden','true');
    backdrop.innerHTML=`
      <div class="aiAssistPanel" id="aiAssistPanel" role="dialog" aria-modal="true" aria-labelledby="aiAssistTitle">
        <div class="aiAssistHead">
          <h2 id="aiAssistTitle">AI Ingredient Assistant</h2>
          <div style="display:flex;gap:8px">
            <button type="button" class="btn btnDanger" id="aiAssistDeleteBtn" aria-label="Delete overlay" style="display:none;padding:8px 12px;font-size:0.9rem">🗑 Delete</button>
            <button type="button" class="aiAssistClose" id="aiAssistClose" aria-label="Close AI assistant">×</button>
          </div>
        </div>

        <!-- Unsaved Changes Warning -->
        <div id="aiAssistUnsavedWarning" style="display:none;background:#2a1a0a;border:2px solid #f59e0b;border-radius:8px;padding:20px;margin:16px 0">
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
            <span style="font-size:2rem">⚠️</span>
            <div>
              <div style="font-size:1.1rem;font-weight:600;color:#f59e0b;margin-bottom:4px">You have unsaved work in the AI Assistant</div>
              <div style="font-size:0.95rem;color:#d1d5db">Would you like to save a draft before closing?</div>
            </div>
          </div>
          <div style="display:flex;gap:12px">
            <button type="button" class="btn btnPrimary" id="aiAssistSaveAndExitBtn" style="flex:1;padding:12px;font-size:1rem">💾 Save and Exit</button>
            <button type="button" class="btn" id="aiAssistExitWithoutSavingBtn" style="flex:1;padding:12px;font-size:1rem;background:#4a1a1a;border-color:#721c24">Exit Without Saving</button>
          </div>
          <button type="button" class="btn" id="aiAssistCancelExitBtn" style="width:100%;margin-top:12px;padding:8px;font-size:0.9rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
        </div>

        <!-- Delete Overlay Warning -->
        <div id="aiAssistDeleteWarning" style="display:none;background:#1a0a0a;border:2px solid #dc2626;border-radius:8px;padding:20px;margin:16px 0">
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
            <span style="font-size:2rem">🗑️</span>
            <div>
              <div style="font-size:1.1rem;font-weight:600;color:#dc2626;margin-bottom:4px">Delete this dish?</div>
              <div style="font-size:0.95rem;color:#d1d5db">This action cannot be undone.</div>
            </div>
          </div>
          <div style="display:flex;gap:12px">
            <button type="button" class="btn btnDanger" id="aiAssistConfirmDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:#dc2626;border-color:#b91c1c">🗑 Delete</button>
            <button type="button" class="btn" id="aiAssistCancelDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
          </div>
        </div>

        <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
          <label for="aiAssistNameInput" style="font-size:0.95rem;color:#a8b2d6;white-space:nowrap">Dish name:</label>
          <input type="text" id="aiAssistNameInput" placeholder="Enter dish name" style="flex:1;padding:10px;font-size:1rem;font-weight:600;border-radius:8px;border:1px solid rgba(76,90,212,0.35);background:rgba(10,16,36,0.95);color:var(--ink)">
        </div>
        <p class="aiAssistIntro">Upload recipe photos or describe the dish ingredients below.</p>

        <!-- Photo Upload Section -->
        <div class="aiAssistMedia" id="aiAssistMedia">
          <button type="button" class="btn" id="aiAssistUploadRecipeBtn" style="flex:1">📁 Upload photos</button>
          <button type="button" class="btn" id="aiAssistCameraRecipeBtn" style="flex:1">📷 Take photo</button>
          <input type="file" id="aiAssistRecipeFileInput" class="aiAssistHidden" accept="image/*" multiple>
        </div>

        <!-- Photo Previews Container -->
        <div id="aiAssistPhotosContainer" style="display:none;margin:16px 0;padding:12px;background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:8px;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <strong style="color:var(--ink)">Recipe Photos</strong>
            <button type="button" class="btn" id="aiAssistClearAllPhotosBtn" style="font-size:0.85rem;padding:4px 12px">Clear All</button>
          </div>
          <div id="aiAssistPhotosList" style="display:flex;flex-wrap:wrap;gap:8px;"></div>
        </div>

        <div class="aiAssistMediaPreview" id="aiAssistMediaPreview">
          <video id="aiAssistVideo" class="aiAssistHidden" playsinline muted></video>
          <div class="aiAssistPhotoControls">
            <button type="button" class="btn" id="aiAssistCaptureBtn">Capture photo</button>
            <button type="button" class="btn" id="aiAssistCancelCameraBtn">Cancel camera</button>
          </div>
        </div>

        <!-- OR Divider -->
        <div style="display: flex; align-items: center; gap: 16px; margin: 20px 0;">
          <div style="flex: 1; height: 1px; background: rgba(76,90,212,0.3);"></div>
          <span style="color: #a0a0a0; font-weight: 600; font-size: 1rem;">OR</span>
          <div style="flex: 1; height: 1px; background: rgba(76,90,212,0.3);"></div>
        </div>

        <!-- Text Input Section -->
        <div style="position:relative;">
          <textarea id="aiAssistInput" class="aiAssistInput" placeholder="Example: Grilled chicken marinated in yogurt, lemon juice, garlic, served with toasted pita and tahini sauce."></textarea>
          <button type="button" class="btn" id="aiAssistDictateBtn" style="position:absolute;bottom:12px;left:12px;padding:6px 12px;font-size:0.9rem">🎙 Dictate</button>
        </div>

        <!-- Process Button -->
        <button type="button" class="btn" id="aiAssistProcessBtn" style="width:100%;margin-top:16px;padding:14px;font-size:1.1rem;font-weight:600;background:#2d7d46;border-color:#3a9d5a;color:white">
          ✓ Process Input
        </button>
        <span class="aiAssistStatus" id="aiAssistStatus" style="display:block;margin-top:8px;text-align:center"></span>
        <div class="aiProgressBar" id="aiProgressBar">
          <div class="aiProgressBarFill" id="aiProgressBarFill" style="width:0%"></div>
        </div>
        <div class="aiAssistResults" id="aiAssistResults" aria-live="polite">
          <h3 style="margin:0">Ingredients</h3>
          <div class="aiAssistTableWrapper">
            <table id="aiAssistTable">
              <tbody id="aiAssistTableBody"></tbody>
            </table>
          </div>

          <!-- Validation Error Message (shown when trying to save without confirming all ingredients) -->
          <div id="aiAssistSaveError" style="display:none;background:#2a1a0a;border:2px solid #f59e0b;border-radius:8px;padding:16px;margin:16px 0">
            <div style="display:flex;align-items:center;gap:12px">
              <span style="font-size:1.5rem">⚠️</span>
              <div>
                <div style="font-size:1rem;font-weight:600;color:#f59e0b;margin-bottom:4px">Cannot save - not all ingredients are confirmed</div>
                <div id="aiAssistSaveErrorDetails" style="font-size:0.9rem;color:#d1d5db"></div>
              </div>
            </div>
          </div>

          <div class="aiAssistTableActions">
            <button type="button" class="btn" id="aiAssistAddRowBtn">Add ingredient</button>
          </div>

          <!-- Cross-Contamination Risk Section -->
          <div id="aiAssistCrossContamination" style="margin-top:24px;padding-top:24px;border-top:2px solid rgba(76,90,212,0.3)">
            <h3 style="margin:0 0 12px 0;font-size:1.1rem;color:#a8b2d6">Cross-Contamination Risk</h3>
            <p style="color:#a8b2d6;font-size:0.9rem;margin-bottom:16px;">Select any allergens that may have cross-contamination risk during preparation:</p>

            <div id="aiAssistCrossAllergenCheckboxes" style="display:flex;flex-wrap:wrap;gap:12px;margin-bottom:16px;">
              <!-- Allergen checkboxes will be inserted here -->
            </div>

            <div style="margin-top:16px;">
              <label style="display:flex;align-items:center;gap:12px;padding:16px;background:rgba(76,90,212,0.1);border:2px solid rgba(76,90,212,0.3);border-radius:8px;cursor:pointer;transition:all 0.2s;" id="aiAssistNoCrossContaminationLabel">
                <input type="checkbox" id="aiAssistNoCrossContamination" style="width:20px;height:20px;cursor:pointer;">
                <span style="flex:1;color:#d1d5db;font-size:1rem;font-weight:500;">No cross-contamination risk with any of the above allergens</span>
              </label>
            </div>

            <p id="aiAssistCrossContaminationError" style="display:none;color:#ef4444;font-size:0.9rem;margin-top:12px;padding:12px;background:rgba(239,68,68,0.1);border:1px solid #ef4444;border-radius:6px;">
              ⚠️ Please select "No cross-contamination risk" or check at least one allergen before saving.
            </p>

            <div class="aiAssistTableActions" style="margin-top:20px;">
              <button type="button" class="btn btnPrimary" id="aiAssistApplyBtn">✓ Save to Dish</button>
            </div>
          </div>

          <!-- Dish Overlay Preview -->
          <div id="aiAssistPreview" style="margin-top:24px;padding-top:24px;border-top:2px solid rgba(76,90,212,0.3)">
            <h3 style="margin:0 0 12px 0;font-size:1.1rem;color:#a8b2d6">Preview: What customers will see</h3>
            <div id="aiAssistPreviewBox" style="background:rgba(76,90,212,0.05);border:1px solid rgba(76,90,212,0.3);border-radius:8px;padding:16px;color:#d1d5db;font-size:0.95rem;line-height:1.6">
              <!-- Preview content will be inserted here -->
            </div>
          </div>

          <div class="aiAssistBrandResults" id="aiAssistBrandResults" aria-live="polite"></div>
        </div>
      </div>`;
    document.body.appendChild(backdrop);
    aiAssistBackdrop=backdrop;
    aiAssistPanel=backdrop.querySelector('#aiAssistPanel');

    // Create image modal
    if(!document.getElementById('imageModal')){
      const modal=document.createElement('div');
      modal.id='imageModal';
      modal.className='imageModal';
      modal.innerHTML=`
        <button type="button" class="closeModal" onclick="closeImageModal()" aria-label="Close">×</button>
        <img id="imageModalImg" src="" alt="Full size image">
      `;
      modal.addEventListener('click',(e)=>{
        if(e.target.classList.contains('imageModal')){
          closeImageModal();
        }
      });
      document.body.appendChild(modal);
    }
    aiAssistCloseBtn=backdrop.querySelector('#aiAssistClose');
    aiAssistInput=backdrop.querySelector('#aiAssistInput');
    aiAssistDictateBtn=backdrop.querySelector('#aiAssistDictateBtn');
    aiAssistProcessBtn=backdrop.querySelector('#aiAssistProcessBtn');
    aiAssistStatusEl=backdrop.querySelector('#aiAssistStatus');
    aiAssistResultsEl=backdrop.querySelector('#aiAssistResults');
    aiAssistTableBody=backdrop.querySelector('#aiAssistTableBody');
    aiAssistAddRowBtn=backdrop.querySelector('#aiAssistAddRowBtn');
    aiAssistApplyBtn=backdrop.querySelector('#aiAssistApplyBtn');
    aiAssistBrandResults=backdrop.querySelector('#aiAssistBrandResults');
    aiAssistVideo=backdrop.querySelector('#aiAssistVideo');
    aiAssistCaptureBtn=backdrop.querySelector('#aiAssistCaptureBtn');
    aiAssistCancelCameraBtn=backdrop.querySelector('#aiAssistCancelCameraBtn');
    aiAssistMediaPreview=backdrop.querySelector('#aiAssistMediaPreview');
    window.aiAssistPhotos = []; // Store multiple photos

    // Initialize cross-contamination allergen checkboxes
    const crossAllergenContainer = backdrop.querySelector('#aiAssistCrossAllergenCheckboxes');
    if(crossAllergenContainer && crossAllergenContainer.children.length === 0){
      console.log('Creating cross-contamination checkboxes for the first time');
      ALLERGENS.forEach(allergen => {
        const label = document.createElement('label');
        label.style.cssText = 'display:flex;align-items:center;gap:8px;padding:10px 16px;background:rgba(76,90,212,0.1);border:1px solid rgba(76,90,212,0.3);border-radius:6px;cursor:pointer;transition:all 0.2s;white-space:nowrap;';
        label.className = 'aiCrossAllergenLabel';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'aiCrossAllergenCheckbox';
        checkbox.dataset.allergen = allergen;
        checkbox.style.cssText = 'width:18px;height:18px;cursor:pointer;';

        // Add change listener to log when checkbox is clicked
        checkbox.addEventListener('change', (e) => {
          console.log(`Cross-contamination checkbox ${allergen} changed to:`, e.target.checked, 'element:', e.target);
        });

        const emoji = {
          'dairy': '🥛',
          'egg': '🥚',
          'peanut': '🥜',
          'tree nut': '🌰',
          'shellfish': '🦐',
          'fish': '🐟',
          'soy': '🫛',
          'sesame': '🫘',
          'wheat': '🌾'
        }[allergen] || '';

        const span = document.createElement('span');
        span.style.cssText = 'color:#d1d5db;font-size:0.95rem;';
        span.textContent = `${emoji} ${allergen.charAt(0).toUpperCase() + allergen.slice(1)}`;

        label.appendChild(checkbox);
        label.appendChild(span);
        crossAllergenContainer.appendChild(label);
      });
    }

    // Add mutual exclusivity event listeners for cross-contamination section
    const noCrossCheckbox = backdrop.querySelector('#aiAssistNoCrossContamination');
    const crossAllergenCheckboxes = backdrop.querySelectorAll('.aiCrossAllergenCheckbox');
    const crossErrorEl = backdrop.querySelector('#aiAssistCrossContaminationError');

    if(noCrossCheckbox && crossAllergenCheckboxes.length > 0){
      // When "no risk" is checked, disable and uncheck all allergen checkboxes
      noCrossCheckbox.addEventListener('change', () => {
        if(noCrossCheckbox.checked){
          crossAllergenCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
            cb.parentElement.style.opacity = '0.5';
            cb.parentElement.style.pointerEvents = 'none';
          });
        } else {
          crossAllergenCheckboxes.forEach(cb => {
            cb.disabled = false;
            cb.parentElement.style.opacity = '1';
            cb.parentElement.style.pointerEvents = 'auto';
          });
        }
        // Hide error when selection changes
        if(crossErrorEl) crossErrorEl.style.display = 'none';
        // Update preview to reflect cross-contamination selection
        updateAiPreview();
      });

      // When any allergen checkbox is checked, uncheck "no risk"
      crossAllergenCheckboxes.forEach(cb => {
        cb.addEventListener('change', () => {
          if(cb.checked){
            noCrossCheckbox.checked = false;
          }
          // Hide error when selection changes
          if(crossErrorEl) crossErrorEl.style.display = 'none';
          // Update preview to reflect cross-contamination selection
          updateAiPreview();
        });
      });
    }

    aiAssistElementsBound=false;
  }
  if(!aiAssistElementsBound){
    aiAssistBackdrop.addEventListener('click',(event)=>{
      if(event.target===aiAssistBackdrop) closeAiAssistant();
    });
    aiAssistCloseBtn.addEventListener('click',()=>closeAiAssistant());
    aiAssistDictateBtn.addEventListener('click',()=>toggleAiDictation());
    aiAssistProcessBtn.addEventListener('click',()=>handleAiProcess());

    // Recipe photo upload/camera handlers
    const uploadRecipeBtn = aiAssistBackdrop.querySelector('#aiAssistUploadRecipeBtn');
    const cameraRecipeBtn = aiAssistBackdrop.querySelector('#aiAssistCameraRecipeBtn');
    const recipeFileInput = aiAssistBackdrop.querySelector('#aiAssistRecipeFileInput');

    if(uploadRecipeBtn && recipeFileInput){
      uploadRecipeBtn.addEventListener('click',()=>{
        recipeFileInput.value='';
        recipeFileInput.click();
      });
      recipeFileInput.addEventListener('change',()=>{
        const files=recipeFileInput.files;
        if(files && files.length) handleMultipleRecipePhotoUpload(files);
      });
    }
    if(cameraRecipeBtn){
      cameraRecipeBtn.addEventListener('click',()=>handleRecipePhotoCamera());
    }

    const clearAllPhotosBtn = aiAssistBackdrop.querySelector('#aiAssistClearAllPhotosBtn');
    if(clearAllPhotosBtn){
      clearAllPhotosBtn.addEventListener('click',()=>{
        window.aiAssistPhotos = [];
        renderPhotoPreviews();
      });
    }

    aiAssistAddRowBtn.addEventListener('click',()=>{
      const data=collectAiTableData();
      data.push({name:'',allergens:[],brands:[],confirmed:false});
      renderAiTable(data);
    });

    // New confirmation workflow buttons
    // Save Draft button removed per user request

    console.log('Binding aiAssistApplyBtn:', aiAssistApplyBtn);
    if(aiAssistApplyBtn){
      aiAssistApplyBtn.addEventListener('click',()=>{
        console.log('Save to Dish button clicked!');
        applyAiIngredientsToOverlay();
      });
    } else {
      console.error('aiAssistApplyBtn not found!');
    }
    if(aiAssistUploadBtn && aiAssistFileInput){
      aiAssistUploadBtn.addEventListener('click',()=>{
        aiAssistFileInput.value='';
        aiAssistFileInput.click();
      });
      aiAssistFileInput.addEventListener('change',()=>{
        const file=aiAssistFileInput.files && aiAssistFileInput.files[0];
        if(file) handleAiFileSelection(file);
      });
    }
    if(aiAssistCameraBtn){
      aiAssistCameraBtn.addEventListener('click',()=>startAiCamera());
    }
    if(aiAssistCaptureBtn){
      aiAssistCaptureBtn.addEventListener('click',()=>captureAiPhoto());
    }
    if(aiAssistCancelCameraBtn){
      aiAssistCancelCameraBtn.addEventListener('click',()=>stopAiCamera(true));
    }
    if(aiAssistClearImageBtn){
      aiAssistClearImageBtn.addEventListener('click',()=>clearAiImage());
    }
    aiAssistTableBody.addEventListener('click',(event)=>{
      const row=event.target.closest('tr');
      if(!row) return;
      const idx=Number(row.dataset.index||'0');
      if(event.target.classList.contains('aiDeleteRow') || event.target.closest('.aiDeleteRow')){
        const data=collectAiTableData();
        data.splice(idx,1);
        renderAiTable(data);
        // Mark as unsaved when user deletes a row
        aiAssistState.savedToDish = false;
        return;
      }
      if(event.target.classList.contains('aiBrandSearchBtn') || event.target.closest('.aiBrandSearchBtn')){
        openAiBrandSearch(idx);
        return;
      }
      if(event.target.classList.contains('aiBrandBarcodeBtn') || event.target.closest('.aiBrandBarcodeBtn')){
        openAiBarcodeScanner(idx);
        return;
      }
      if(event.target.classList.contains('aiRemoveBrand') || event.target.closest('.aiRemoveBrand')){
        const brandIdx = Number(event.target.dataset.brandIdx || event.target.closest('.aiRemoveBrand')?.dataset.brandIdx);
        console.log('=== DELETE BRAND CLICKED ===');
        console.log('Row idx:', idx);
        console.log('Brand idx:', brandIdx);
        if(!isNaN(brandIdx)){
          const data = collectAiTableData();
          console.log('Current data before delete:', JSON.stringify(data[idx]));
          if(data[idx] && data[idx].brands){
            console.log(`Removing brand at index ${brandIdx} from ingredient "${data[idx].name}"`);
            console.log('Brands before:', data[idx].brands.map(b => b.name));
            data[idx].brands.splice(brandIdx, 1);
            console.log('Brands after:', data[idx].brands.map(b => b.name));
            // Reset confirmed state since allergens/diets may have changed
            data[idx].confirmed = false;
            console.log('Re-rendering table with updated data');
            renderAiTable(data);
            aiAssistSetStatus('Brand removed from this ingredient.','info');
            // Mark as unsaved when user removes a brand
            aiAssistState.savedToDish = false;
          }
        }
        return;
      }
      if(event.target.classList.contains('aiAddRememberedBrand') || event.target.closest('.aiAddRememberedBrand')){
        console.log('=== ADD REMEMBERED BRAND CLICKED ===');
        const data = collectAiTableData();
        const ingredientName = data[idx]?.name;
        if(ingredientName){
          const memory = getRememberedBrand(ingredientName);
          if(memory && memory.brand){
            console.log(`Adding remembered brand "${memory.brand}" for "${ingredientName}"`);
            // Initialize brands array if needed
            if(!data[idx].brands){
              data[idx].brands = [];
            }
            // Check if this brand is already added
            const brandExists = data[idx].brands.some(b => b.name === memory.brand);
            if(!brandExists){
              data[idx].brands.push({
                name: memory.brand,
                brandImage: memory.brandImage || '',
                ingredientsImage: memory.ingredientsImage || '',
                ingredientsList: memory.ingredientsList || [],
                allergens: memory.allergens || [],
                diets: memory.diets || []
              });
              // Reset confirmed state since we added allergen/diet info
              data[idx].confirmed = false;
              renderAiTable(data);
              aiAssistSetStatus(`Added brand "${memory.brand}" from memory.`, 'success');
              // Mark as unsaved when user adds a brand
              aiAssistState.savedToDish = false;
            } else {
              aiAssistSetStatus(`Brand "${memory.brand}" is already added.`, 'info');
            }
          }
        }
        return;
      }
      if(event.target.classList.contains('aiConfirmBtn')){
        const btn = event.target;
        const isConfirmed = btn.dataset.confirmed === 'true';

        // Toggle state
        if(isConfirmed){
          // Unconfirm
          btn.dataset.confirmed = 'false';
          btn.classList.remove('confirmed');
          btn.classList.add('unconfirmed');
          btn.style.background = '#f59e0b';
          btn.style.borderColor = '#f59e0b';
          btn.textContent = 'Confirm';
        } else {
          // Confirm
          btn.dataset.confirmed = 'true';
          btn.classList.remove('unconfirmed');
          btn.classList.add('confirmed');
          btn.style.background = '#4caf50';
          btn.style.borderColor = '#4caf50';
          btn.textContent = '✓ Confirmed';

          // Hide save error message if shown (since user is now confirming)
          const saveErrorEl = document.getElementById('aiAssistSaveError');
          if(saveErrorEl) saveErrorEl.style.display = 'none';
        }

        // Mark as unsaved when confirmation status changes
        aiAssistState.savedToDish = false;
        return;
      }
    });
    aiAssistTableBody.addEventListener('input',(event)=>{
      const row=event.target.closest('tr');
      if(!row) return;
      if(event.target.classList.contains('aiIngredientName')){
        // NOTE: fillRowFromMemory is obsolete with the new multi-brand system
        // Brand memory loading is now handled in renderAiTable() directly
        // Removed to prevent overwriting brand preview divs
      }
      // Reset confirm button when user makes changes
      resetConfirmButton(row);
      // Mark as unsaved when user makes changes
      aiAssistState.savedToDish = false;
      // Update preview
      updateAiPreview();
    });
    aiAssistTableBody.addEventListener('change',(event)=>{
      const row=event.target.closest('tr');
      if(!row) return;
      // Reset confirm button when checkboxes/radios change
      resetConfirmButton(row);
      // Mark as unsaved when checkboxes/radios change
      aiAssistState.savedToDish = false;
      // Update preview
      updateAiPreview();
    });
    aiAssistBrandResults.addEventListener('click',(event)=>{
      const card=event.target.closest('.aiBrandSuggestion');
      if(!card) return;
      const rowIdx=Number(card.dataset.row||'0');
      const suggestionIdx=Number(card.dataset.index||'0');
      applyBrandSuggestion(rowIdx,suggestionIdx);
    });
    updateAiAssistMediaPreview();
    aiAssistElementsBound=true;
  }
}

let scrollLockPosition = 0;

function toggleAiAssistBackdrop(show){
  ensureAiAssistElements();
  if(!aiAssistBackdrop) return;
  if(show){
    // Re-bind the Save to Dish button every time we show the panel
    // This ensures the handler is attached even if the button was recreated
    const applyBtn = document.getElementById('aiAssistApplyBtn');
    console.log('toggleAiAssistBackdrop: Re-binding Save to Dish button:', applyBtn);
    if(applyBtn){
      // Remove any existing listeners by cloning the button
      const newApplyBtn = applyBtn.cloneNode(true);
      applyBtn.parentNode.replaceChild(newApplyBtn, applyBtn);
      newApplyBtn.addEventListener('click',()=>{
        console.log('Save to Dish button clicked!');
        applyAiIngredientsToOverlay();
      });
      aiAssistApplyBtn = newApplyBtn;
    } else {
      console.error('toggleAiAssistBackdrop: aiAssistApplyBtn not found!');
    }

    aiAssistBackdrop.classList.add('show');
    aiAssistBackdrop.setAttribute('aria-hidden','false');
    // Mobile-safe scroll lock: store position and fix body
    scrollLockPosition = window.pageYOffset || document.documentElement.scrollTop;
    document.body.style.position = 'fixed';
    document.body.style.top = `-${scrollLockPosition}px`;
    document.body.style.width = '100%';
    document.body.style.overflow = 'hidden';
  } else {
    aiAssistBackdrop.classList.remove('show');
    aiAssistBackdrop.setAttribute('aria-hidden','true');
    // Restore scroll position and body styles
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.width = '';
    document.body.style.overflow = '';
    window.scrollTo(0, scrollLockPosition);
  }
}

function updateAiAssistMediaPreview(){
  ensureAiAssistElements();
  const hasImage=!!aiAssistState.imageData;
  const hasStream=!!aiAssistState.mediaStream;
  if(aiAssistMediaPreview){
    aiAssistMediaPreview.classList.toggle('show',hasImage||hasStream);
  }
  if(aiAssistVideo){
    if(hasStream){
      aiAssistVideo.classList.remove('aiAssistHidden');
      if(aiAssistVideo.srcObject!==aiAssistState.mediaStream){
        aiAssistVideo.srcObject=aiAssistState.mediaStream;
      }
      aiAssistVideo.play().catch(()=>{});
    } else {
      try{aiAssistVideo.pause();}catch(_){ }
      aiAssistVideo.srcObject=null;
      aiAssistVideo.classList.add('aiAssistHidden');
    }
  }
  if(aiAssistCaptureBtn){
    aiAssistCaptureBtn.classList.toggle('aiAssistHidden',!hasStream);
  }
  if(aiAssistCancelCameraBtn){
    aiAssistCancelCameraBtn.classList.toggle('aiAssistHidden',!hasStream);
  }
  if(aiAssistImagePreview){
    if(hasImage){
      aiAssistImagePreview.src=aiAssistState.imageData;
      aiAssistImagePreview.classList.remove('aiAssistHidden');
    } else {
      aiAssistImagePreview.src='';
      aiAssistImagePreview.classList.add('aiAssistHidden');
    }
  }
  if(aiAssistClearImageBtn){
    aiAssistClearImageBtn.classList.toggle('aiAssistHidden',!hasImage);
  }
}

function handleAiFileSelection(file){
  ensureAiAssistElements();
  if(!file){
    aiAssistSetStatus('No file selected.','warn');
    return;
  }
  const reader=new FileReader();
  reader.onload=()=>{
    aiAssistState.imageData=typeof reader.result==='string'?reader.result:null;
    aiAssistState.imageFileName=file.name||'label.jpg';
    stopAiCamera();
    updateAiAssistMediaPreview();
    aiAssistSetStatus('Label photo attached. Review before processing.','info');
  };
  reader.onerror=()=>{
    aiAssistSetStatus('Could not read the selected image.','warn');
  };
  reader.readAsDataURL(file);
}

async function startAiCamera(){
  ensureAiAssistElements();
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    aiAssistSetStatus('Camera capture is not supported in this browser.','warn');
    return;
  }
  try{
    if(aiAssistState.mediaStream){
      stopAiCamera();
    }
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
    aiAssistState.mediaStream=stream;
    aiAssistState.imageData=null;
    aiAssistState.imageFileName=null;
    updateAiAssistMediaPreview();
    aiAssistSetStatus('Camera ready. Capture the label when it looks clear.','info');
  }catch(err){
    console.error('Camera error',err);
    aiAssistSetStatus('Could not access the camera: '+(err.message||err),'warn');
  }
}

function stopAiCamera(notify){
  ensureAiAssistElements();
  if(aiAssistState.mediaStream){
    try{aiAssistState.mediaStream.getTracks().forEach(track=>track.stop());}catch(_){ }
  }
  aiAssistState.mediaStream=null;
  if(aiAssistVideo){
    try{aiAssistVideo.pause();}catch(_){ }
    aiAssistVideo.srcObject=null;
  }
  updateAiAssistMediaPreview();
  if(notify){
    aiAssistSetStatus('Camera closed.','info');
  }
}

async function captureAiPhoto(){
  ensureAiAssistElements();
  if(!aiAssistVideo || !aiAssistState.mediaStream){
    aiAssistSetStatus('Start the camera before capturing a photo.','warn');
    return;
  }
  const width=aiAssistVideo.videoWidth||1280;
  const height=aiAssistVideo.videoHeight||720;
  if(!width || !height){
    aiAssistSetStatus('Camera is still focusing. Try capturing again in a moment.','warn');
    return;
  }
  const canvas=document.createElement('canvas');
  canvas.width=width;
  canvas.height=height;
  const ctx=canvas.getContext('2d');
  if(!ctx){
    aiAssistSetStatus('Could not capture the photo.','warn');
    return;
  }
  ctx.drawImage(aiAssistVideo,0,0,width,height);
  const rawImage = canvas.toDataURL('image/jpeg',0.92);

  // Compress the captured photo
  const compressed = await compressImage(rawImage);

  // Add to photos array for multi-photo workflow
  if(!window.aiAssistPhotos) window.aiAssistPhotos = [];
  window.aiAssistPhotos.push(compressed);

  stopAiCamera();
  renderPhotoPreviews();
  aiAssistSetStatus('Photo captured. Review before processing.','success');
}

function clearAiImage(){
  ensureAiAssistElements();
  aiAssistState.imageData=null;
  aiAssistState.imageFileName=null;
  if(aiAssistFileInput){
    aiAssistFileInput.value='';
  }
  updateAiAssistMediaPreview();
  aiAssistSetStatus('Label image cleared.','info');
}

function getRowIngredientsList(rowElement){
  if(!rowElement || !rowElement.dataset.ingredientsList) return [];
  try{
    const parsed=JSON.parse(rowElement.dataset.ingredientsList);
    return Array.isArray(parsed)?parsed:[];
  }catch(_){
    return [];
  }
}

function updateAiBrandPreview(rowElement){
  if(!rowElement) return;
  const brandPreview=rowElement.querySelector('.aiBrandPreview');
  if(brandPreview){
    const parts=[];
    const brandImage=rowElement.dataset.brandImage||'';
    const ingredientsImage=rowElement.dataset.ingredientsImage||'';
    if(brandImage) parts.push(`<img src="${esc(brandImage)}" alt="Brand preview" loading="lazy" onclick="openImageModal('${esc(brandImage)}')" title="Click to enlarge">`);
    if(ingredientsImage) parts.push(`<img src="${esc(ingredientsImage)}" alt="Ingredients label" loading="lazy" onclick="openImageModal('${esc(ingredientsImage)}')" title="Click to enlarge">`);
    brandPreview.innerHTML=parts.join('');
  }
  const listNote=rowElement.querySelector('.aiIngredientList');
  if(listNote){
    const list=getRowIngredientsList(rowElement);
    listNote.textContent=list.length?`Label ingredients: ${list.join(', ')}`:'';
  }
}

function collectAiTableData(){
  ensureAiAssistElements();
  if(!aiAssistTableBody) return [];
  const data=[];
  aiAssistTableBody.querySelectorAll('tr').forEach(row=>{
    const idx=Number(row.dataset.index||'0');
    const name=row.querySelector('.aiIngredientName')?.value.trim()||'';
    const allergens=[...row.querySelectorAll('.aiAllergenChecklist input:checked')].map(input=>input.value);
    const diets=[...row.querySelectorAll('.aiDietChecklist input:checked')].map(input=>input.value);
    const confirmed=row.querySelector('.aiConfirmBtn')?.dataset.confirmed === 'true';

    // Collect removable status from checkbox (unchecked by default = not substitutable)
    const removableCheckbox=row.querySelector('.aiRemovableCheckbox');
    const removable=removableCheckbox?.checked || false;

    console.log(`collectAiTableData row ${idx} (${name}): removable=${removable}, removableCheckbox=`, removableCheckbox, 'checked=', removableCheckbox?.checked);

    // Collect multiple brands
    const brands=[];
    if(row.dataset.brands){
      try{
        const parsed = JSON.parse(row.dataset.brands);
        console.log(`Row ${idx} brands from dataset:`, parsed);
        brands.push(...parsed);
      }catch(e){
        console.error(`Failed to parse brands for row ${idx}:`, e);
      }
    }

    data.push({index:idx,name,allergens,diets,brands,confirmed,removable});
  });
  console.log('collectAiTableData final data:', data);
  return data;
}

function resetConfirmButton(rowElement){
  if(!rowElement) return;
  const btn = rowElement.querySelector('.aiConfirmBtn');
  if(!btn) return;

  const wasConfirmed = btn.dataset.confirmed === 'true';
  if(!wasConfirmed) return; // Already unconfirmed, no need to reset

  // Reset to unconfirmed state
  btn.dataset.confirmed = 'false';
  btn.classList.remove('confirmed');
  btn.classList.add('unconfirmed');
  btn.style.background = '#f59e0b';
  btn.style.borderColor = '#f59e0b';
  btn.textContent = 'Confirm';
}

function updateAiPreview(){
  const previewBox = document.getElementById('aiAssistPreviewBox');
  if(!previewBox) return;

  const rows = collectAiTableData();
  if(!rows || rows.length === 0){
    previewBox.innerHTML = '<div style="color:#8891b0;font-style:italic">Add ingredients to see preview</div>';
    return;
  }

  // Build a temporary overlay object from the AI table data
  const tempOverlay = {
    id: document.getElementById('aiAssistNameInput')?.value || 'Dish Name',
    allergens: [],
    diets: [],
    details: {},
    removable: [],
    crossContamination: []
  };

  // Aggregate allergens from all ingredients (OR logic - any ingredient with allergen adds it to dish)
  const allergenDetails = {};
  rows.forEach(row => {
    if(Array.isArray(row.allergens)){
      row.allergens.forEach(allergen => {
        const key = norm(allergen);
        if(key && !tempOverlay.allergens.includes(key)){
          tempOverlay.allergens.push(key);
        }
        // Add ingredient detail
        const ingredientLabel = row.name || '';
        const brandLabel = (row.brands && row.brands.length > 0) ? row.brands[0].name : '';
        const fullLabel = brandLabel ? `${ingredientLabel} (${brandLabel})` : ingredientLabel;
        if(fullLabel){
          if(!allergenDetails[key]) allergenDetails[key] = [];
          if(!allergenDetails[key].includes(fullLabel)){
            allergenDetails[key].push(fullLabel);
          }
        }

        // Track removable allergens
        if(row.removable === true){
          const detail = allergenDetails[key] && allergenDetails[key].length > 0 ?
            allergenDetails[key].join(', ') : key;
          // Only add if not already in the removable array
          if(!tempOverlay.removable.some(r => r.allergen === key)){
            tempOverlay.removable.push({allergen: key, component: detail});
          }
        }
      });
    }
  });

  // For dietary preferences, use AND logic - dish is only vegan if ALL ingredients are vegan
  // Start with all possible diets, then remove any that aren't supported by ALL ingredients
  let dishDiets = new Set(['Vegan', 'Vegetarian', 'Pescatarian']);
  rows.forEach(row => {
    const ingredientDiets = new Set(row.diets || []);
    // Remove any diets this ingredient doesn't support
    dishDiets.forEach(diet => {
      if(!ingredientDiets.has(diet)){
        dishDiets.delete(diet);
      }
    });
  });

  // Validate dietary preferences against allergens - remove incompatible diets
  const allergenConflicts = {
    'Vegan': ['dairy', 'egg', 'fish', 'shellfish'],
    'Vegetarian': ['fish', 'shellfish'],
    'Pescatarian': []
  };
  dishDiets.forEach(diet => {
    const conflicts = allergenConflicts[diet] || [];
    const hasConflict = conflicts.some(allergen => tempOverlay.allergens.includes(allergen));
    if(hasConflict){
      dishDiets.delete(diet);
    }
  });

  tempOverlay.diets = Array.from(dishDiets);

  // Add details text
  Object.keys(allergenDetails).forEach(key => {
    const items = allergenDetails[key];
    if(items.length > 0){
      tempOverlay.details[key] = `Contains ${items.join(', ')}`;
    }
  });

  // Collect cross-contamination data from checkboxes
  const noCrossCheckbox = document.getElementById('aiAssistNoCrossContamination');
  const crossAllergenCheckboxes = document.querySelectorAll('.aiCrossAllergenCheckbox');

  if(noCrossCheckbox && noCrossCheckbox.checked){
    tempOverlay.crossContamination = [];
    tempOverlay.noCrossContamination = true;
  } else {
    const selectedCrossAllergens = [];
    crossAllergenCheckboxes.forEach(cb => {
      if(cb.checked){
        selectedCrossAllergens.push(cb.dataset.allergen);
      }
    });
    tempOverlay.crossContamination = selectedCrossAllergens;
    tempOverlay.noCrossContamination = false;
  }

  // Use the same tooltip HTML generator that's used for the actual overlays
  const allAllergens = ['dairy','egg','peanut','tree nut','shellfish','fish','gluten','soy','sesame','wheat'];
  const allDiets = ['Vegan','Vegetarian','Pescatarian'];
  let html = tooltipBodyHTML(tempOverlay, allAllergens, allDiets);

  // Note: Cross-contamination information is already included in tooltipBodyHTML,
  // so we don't need to add it again here

  previewBox.innerHTML = html || '<div style="color:#8891b0;font-style:italic">No preview available</div>';
}

function renderAiTable(rows){
  ensureAiAssistElements();
  if(!aiAssistTableBody || !aiAssistResultsEl) return;
  const source=Array.isArray(rows)?rows:collectAiTableData();
  const data=source.map(item=>({...item}));
  aiAssistTableBody.innerHTML='';
  aiAssistState.brandSuggestions={};
  data.forEach((row,idx)=>{
    // Initialize brands array if not present
    if(!row.brands){
      row.brands = [];
    }

    // NOTE: We NO LONGER load brands from memory here during render.
    // Brands from memory are only loaded when:
    // 1. AI returns initial results (in handleAiAssistantResult)
    // 2. User opens a saved draft
    // This prevents the infinite loop where deleting a brand causes it to reload from memory.
    // The memory is now purely for auto-populating NEW ingredients, not re-populating deleted brands.

    const tr=document.createElement('tr');
    tr.dataset.index=idx;
    const allergens=new Set((row.allergens||[]).map(norm));

    // Support multiple brands - store in dataset
    const brands = row.brands || [];
    if(brands.length > 0){
      tr.dataset.brands=JSON.stringify(brands);
    } else {
      delete tr.dataset.brands;
    }

    // Collect all AI-detected allergens and diets from both base ingredient and brands
    const aiDetectedAllergens = new Set();
    const aiDetectedDiets = new Set();

    // Add allergens detected by AI for the base ingredient (from initial AI analysis)
    if(Array.isArray(row.allergens)){
      row.allergens.forEach(a => {
        if(a) aiDetectedAllergens.add(norm(a));
      });
    }

    // Add diets detected by AI for the base ingredient (from initial AI analysis)
    if(Array.isArray(row.diets)){
      row.diets.forEach(d => {
        if(d) aiDetectedDiets.add(d);
      });
    }

    // Also add allergens and diets from brand labels
    brands.forEach(brand => {
      console.log('Brand data:', brand);
      if(Array.isArray(brand.allergens)){
        brand.allergens.forEach(a => {
          console.log('Adding allergen to aiDetected:', a, '=> norm:', norm(a));
          aiDetectedAllergens.add(norm(a));
        });
      }
      if(Array.isArray(brand.diets)){
        brand.diets.forEach(d => {
          console.log('Adding diet to aiDetected:', d);
          aiDetectedDiets.add(d);
        });
      }
    });
    console.log('aiDetectedAllergens:', Array.from(aiDetectedAllergens));
    console.log('aiDetectedDiets:', Array.from(aiDetectedDiets));

    const brandsHTML = brands.length > 0 ? brands.map((brand, brandIdx) => {
      console.log(`Rendering brand ${brandIdx}:`, brand);
      console.log(`  - brandImage: ${brand.brandImage}`);
      console.log(`  - ingredientsImage: ${brand.ingredientsImage}`);
      console.log(`  - ingredientsList: ${brand.ingredientsList ? brand.ingredientsList.length : 0} items`);

      const brandImages = [];
      console.log(`  - Checking brand.brandImage: "${brand.brandImage}", truthy: ${!!brand.brandImage}, type: ${typeof brand.brandImage}`);
      console.log(`  - Checking brand.ingredientsImage: "${brand.ingredientsImage}", truthy: ${!!brand.ingredientsImage}, type: ${typeof brand.ingredientsImage}`);

      if(brand.brandImage) {
        const imgTag = `<img src="${esc(brand.brandImage)}" alt="${esc(brand.name||'Brand')}" loading="lazy" onclick="openImageModal('${esc(brand.brandImage)}')" title="Click to enlarge">`;
        console.log(`  - Adding brandImage tag (length: ${imgTag.length})`);
        brandImages.push(imgTag);
      } else {
        console.log(`  - SKIPPED brandImage (falsy value)`);
      }

      if(brand.ingredientsImage) {
        const imgTag = `<img src="${esc(brand.ingredientsImage)}" alt="Ingredients label" loading="lazy" onclick="openImageModal('${esc(brand.ingredientsImage)}')" title="Click to enlarge">`;
        console.log(`  - Adding ingredientsImage tag (length: ${imgTag.length})`);
        brandImages.push(imgTag);
      } else {
        console.log(`  - SKIPPED ingredientsImage (falsy value)`);
      }
      const ingredientsNote = brand.ingredientsList && brand.ingredientsList.length ? `Label ingredients: ${brand.ingredientsList.map(i=>esc(i)).join(', ')}` : '';

      // Show message if no images are available
      const imagesDisplay = brandImages.length > 0 ? brandImages.join('') : '<div style="color:var(--muted);font-size:0.85rem;font-style:italic">No product images available</div>';
      console.log(`  - Final imagesDisplay length: ${imagesDisplay.length}, brandImages count: ${brandImages.length}`);
      console.log(`  - imagesDisplay HTML: ${imagesDisplay.substring(0, 200)}...`);

      const brandItemHTML = `
        <div class="aiBrandItem" data-brand-idx="${brandIdx}">
          <div class="aiBrandItemHeader">
            <strong>${esc(brand.name || 'Brand ' + (brandIdx + 1))}</strong>
            <button type="button" class="btn btnSmall aiRemoveBrand" data-brand-idx="${brandIdx}">×</button>
          </div>
          <div class="aiBrandPreview">${imagesDisplay}</div>
          ${ingredientsNote ? `<div class="aiIngredientList">${ingredientsNote}</div>` : '<div style="color:var(--muted);font-size:0.85rem;font-style:italic">No ingredient list available</div>'}
        </div>
      `;
      console.log(`  - Brand item HTML length: ${brandItemHTML.length}`);
      return brandItemHTML;
    }).join('') : '<div class="aiNoBrands">No brands added yet</div>';

    console.log(`Total brandsHTML length: ${brandsHTML.length}`);

    const isConfirmed = row.confirmed || false;

    // Collect all allergens and diets from brands as well as base ingredient
    // This ensures checkboxes are checked for allergens/diets detected in brands
    const allAllergens = new Set(allergens);
    const allDiets = new Set((row.diets||[]).map(d=>d));
    brands.forEach(brand => {
      if(Array.isArray(brand.allergens)){
        brand.allergens.forEach(a => allAllergens.add(norm(a)));
      }
      if(Array.isArray(brand.diets)){
        brand.diets.forEach(d => allDiets.add(d));
      }
    });

    // Check if there's a remembered brand for this ingredient
    const rememberedBrand = getRememberedBrand(row.name);
    const rememberBrandHTML = rememberedBrand && rememberedBrand.brand ? `
      <div class="aiRememberedBrand" data-row-idx="${idx}" style="margin:8px 0;display:flex;align-items:start;gap:8px;padding:8px;background:rgba(76,175,80,0.05);border-radius:6px;border:1px dashed #4caf50">
        <div style="position:relative;flex-shrink:0">
          ${rememberedBrand.brandImage ?
            `<img src="${esc(rememberedBrand.brandImage)}" alt="${esc(rememberedBrand.brand)}" style="width:60px;height:60px;object-fit:contain;border-radius:4px;background:white">` :
            `<div style="width:60px;height:60px;background:#f0f0f0;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:0.7rem;color:#999;text-align:center">No image</div>`
          }
          <button type="button" class="btn aiAddRememberedBrand" data-row-idx="${idx}" style="position:absolute;top:-6px;right:-6px;width:24px;height:24px;border-radius:50%;background:#4caf50;border:2px solid white;color:white;font-size:1.2rem;font-weight:bold;padding:0;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,0.2)" title="Add this brand">+</button>
        </div>
        <div style="flex:1;min-width:0">
          <div style="font-weight:600;font-size:0.85rem;color:#2c5530">Previously used:</div>
          <div style="font-size:0.9rem;color:#333;margin-top:2px">${esc(rememberedBrand.brand)}</div>
          ${rememberedBrand.allergens && rememberedBrand.allergens.length > 0 ?
            `<div style="font-size:0.75rem;color:#666;margin-top:4px">Allergens: ${rememberedBrand.allergens.map(a=>esc(cap(a))).join(', ')}</div>` :
            ''}
        </div>
      </div>
    ` : '';

    tr.innerHTML=`
      <td colspan="7">
        <div class="aiIngredientRow">
          <div class="aiIngredientMain">
            <input type="text" class="aiIngredientName" placeholder="Ingredient name" value="${esc((row.name||'').toLowerCase())}">
            ${rememberBrandHTML}
            <div class="aiBrandCell">
              <div class="aiBrandsList">
                ${brandsHTML}
              </div>
              <div class="aiBrandActions">
                <button type="button" class="btn aiBrandSearchBtn">Search brand name</button>
                <button type="button" class="btn aiBrandBarcodeBtn" style="background:#17663a;border-color:#1a7b46">Scan item barcode</button>
              </div>
            </div>
            ${(aiDetectedAllergens.size > 0 || aiDetectedDiets.size > 0) ? '<div style="color:#4caf50;font-size:0.85rem;margin:16px 0 12px 0;font-weight:600;padding:8px 12px;background:rgba(76,175,80,0.1);border-radius:6px;border-left:3px solid #4caf50">✓ Green = AI detected from brand labels</div>' : ''}
            <div style="display:flex;gap:20px;margin-top:0">
              <div style="flex:1">
                <div class="aiAllergenChecklist">
                  ${ALLERGENS.map(allergen=>{
                    const checked=allAllergens.has(norm(allergen))?'checked':'';
                    const aiDetected=aiDetectedAllergens.has(norm(allergen))?'aiDetected':'';
                    console.log(`Allergen ${allergen}: aiDetected="${aiDetected}", checked="${checked}" (looking for norm(${allergen})="${norm(allergen)}" in`, Array.from(allAllergens), ')'  );
                    return `<label class="${aiDetected}"><input type="checkbox" class="aiAllergenCheckbox" value="${esc(allergen)}" ${checked}>${esc(cap(allergen))}</label>`;
                  }).join('')}
                </div>
              </div>
              <div style="flex:1">
                <div class="aiDietChecklist">
                  ${DIETS.map(diet=>{
                    const checked=allDiets.has(diet)?'checked':'';
                    const aiDetected=aiDetectedDiets.has(diet)?'aiDetected':'';
                    console.log(`Diet ${diet}: aiDetected="${aiDetected}", checked="${checked}" (looking for "${diet}" in`, Array.from(allDiets), ')');
                    return `<label class="${aiDetected}"><input type="checkbox" class="aiDietCheckbox" value="${esc(diet)}" ${checked}>${esc(diet)}</label>`;
                  }).join('')}
                </div>
              </div>
            </div>
            <div>
              <div style="display:flex;flex-direction:column;gap:8px">
                <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
                  <input type="checkbox" class="aiRemovableCheckbox" ${row.removable ? 'checked' : ''}>
                  <span style="font-size:0.9rem">Can be substituted out</span>
                </label>
              </div>
            </div>
            <div class="aiConfirmCell" style="text-align:center">
              <button type="button" class="btn aiConfirmBtn ${isConfirmed ? 'confirmed' : 'unconfirmed'}" data-confirmed="${isConfirmed ? 'true' : 'false'}" style="padding:8px 16px;font-size:0.9rem;font-weight:600;border-radius:6px;${isConfirmed ? 'background:#4caf50;border-color:#4caf50;color:white;' : 'background:#f59e0b;border-color:#f59e0b;color:white;'}">${isConfirmed ? '✓ Confirmed' : 'Confirm'}</button>
            </div>
            <button type="button" class="btn aiDeleteRow">Remove</button>
          </div>
          <div class="aiRowBrandResults" data-row-idx="${idx}"></div>
        </div>
      </td>
    `;
    aiAssistTableBody.appendChild(tr);
    // NOTE: updateAiBrandPreview() is obsolete now that we support multiple brands
    // It was overwriting the brand images we just rendered. Removed.
  });
  aiAssistResultsEl.classList.toggle('show', data.length>0);
  if(aiAssistBrandResults){
    aiAssistBrandResults.classList.remove('show');
    aiAssistBrandResults.innerHTML='';
  }

  // Update the preview whenever the table is rendered
  updateAiPreview();
}

function normalizeIngredientName(name){
  const lower = name.toLowerCase().trim();
  // Map common variations to standard names
  const aliases = {
    'mayo': 'mayonnaise',
    'cuke': 'cucumber',
    'cukes': 'cucumber',
    'pickles': 'pickle',
    'tomatoes': 'tomato',
    'onions': 'onion',
    'peppers': 'pepper',
    'mushrooms': 'mushroom',
    'olives': 'olive',
    'carrots': 'carrot',
    'potatoes': 'potato',
    'celery stalk': 'celery',
    'celery stalks': 'celery'
  };
  return aliases[lower] || lower;
}

function heuristicallyExtractIngredients(text){
  if(!text) return [];
  const tokens=text
    .split(/\r?\n|\.|;/)
    .map(part=>part.split(/\band\b|\bwith\b|,/i))
    .flat()
    .map(part=>part.trim())
    .filter(Boolean);
  const unique=new Map();
  tokens.forEach(token=>{
    const cleaned=token.replace(/[\d/]+/g,'').replace(/\b(teaspoons?|tablespoons?|cups?|ounces?|grams?|lbs?|pounds?|ml|l|kg)\b/gi,'').replace(/[\(\)]/g,'').replace(/\s+/g,' ').trim();
    if(!cleaned) return;
    const normalized = normalizeIngredientName(cleaned);
    const key=norm(normalized);
    if(unique.has(key)) return;
    const detectedAllergens=ALLERGENS.filter(a=>token.toLowerCase().includes(a));
    unique.set(key,{name:normalized,brand:'',allergens:detectedAllergens,ingredientsList:[normalized]});
  });
  if(unique.size===0){
    return [{name:'',brand:'',allergens:[]}];
  }
  return Array.from(unique.values());
}

function openAiAssistant(context){
  console.log('!!! openAiAssistant called', new Error().stack);
  ensureAiAssistElements();
  if(!aiAssistBackdrop) return;

  // IMPORTANT: Clear previous state completely before setting new state
  aiAssistState.context=null;
  aiAssistState.pendingRequestId=null;
  aiAssistState.brandSuggestions={};
  aiAssistState.imageData=null;
  aiAssistState.imageFileName=null;
  aiAssistState.detectedDietaryOptions=null;
  aiAssistState.savedToDish=false;
  aiAssistState.initialData=null;

  stopAiCamera();
  updateAiAssistMediaPreview();
  aiAssistSetStatus('');

  // Check if AI Assistant is already open - if so, don't reset checkboxes (preserve user edits)
  const isAlreadyOpen = aiAssistBackdrop && aiAssistBackdrop.style.display === 'flex';

  // Reset cross-contamination checkboxes ONLY if:
  // 1. Assistant is not already open (new opening), AND
  // 2. Context has explicit data to load
  // This preserves user's manual checkbox selections when assistant is re-opened
  const noCrossCheckbox = document.getElementById('aiAssistNoCrossContamination');
  const crossAllergenCheckboxes = document.querySelectorAll('.aiCrossAllergenCheckbox');
  const crossErrorEl = document.getElementById('aiAssistCrossContaminationError');

  // Only reset if we're opening fresh AND have context data to load
  const hasExplicitCrossData = context?.noCrossContamination === true ||
                                (context?.crossContamination && Array.isArray(context.crossContamination) && context.crossContamination.length > 0);

  console.log('openAiAssistant: Cross-contamination reset logic:', {
    isAlreadyOpen,
    hasExplicitCrossData,
    noCrossContamination: context?.noCrossContamination,
    crossContamination: context?.crossContamination
  });

  if(!isAlreadyOpen && hasExplicitCrossData){
    // Reset checkboxes before loading context data (only when opening fresh)
    console.log('  -> Resetting cross-contamination checkboxes to load context data');
    if(noCrossCheckbox){
      noCrossCheckbox.checked = false;
    }
    if(crossAllergenCheckboxes){
      crossAllergenCheckboxes.forEach(cb => {
        cb.checked = false;
        cb.disabled = false;
        if(cb.parentElement){
          cb.parentElement.style.opacity = '1';
          cb.parentElement.style.pointerEvents = 'auto';
        }
      });
    }
  } else if(isAlreadyOpen){
    console.log('  -> AI Assistant already open, preserving current checkbox state');
  } else {
    console.log('  -> No explicit cross-contamination data in context, keeping checkboxes as-is');
  }

  if(crossErrorEl){
    crossErrorEl.style.display = 'none';
  }

  // Keep the title generic - dish name is shown in the editable field below
  const titleEl = document.getElementById('aiAssistTitle');
  if(titleEl){
    titleEl.textContent = 'AI Ingredient Assistant';
  }

  // Get the dish name for the input field - MUST be done BEFORE setting context
  const dishName = context?.getCurrentName ? context.getCurrentName() : 'Dish';
  console.log('openAiAssistant: Setting dish name to:', dishName);

  // Populate the name input field - force the update
  const nameInput = document.getElementById('aiAssistNameInput');
  if(nameInput){
    // Force clear first, then set new value
    nameInput.value = '';
    setTimeout(() => {
      nameInput.value = dishName;
      console.log('openAiAssistant: Name input field updated to:', nameInput.value);
    }, 0);
  }

  // NOW set the context after the name has been determined
  aiAssistState.context=context||{};

  // Load existing cross-contamination data if available (MUST be after context is set)
  // BUT only if assistant was not already open (to preserve user's manual edits)
  console.log('Loading cross-contamination data from context:', {
    isAlreadyOpen,
    noCrossContamination: context?.noCrossContamination,
    crossContamination: context?.crossContamination
  });

  if(!isAlreadyOpen){
    if(context?.noCrossContamination){
      console.log('  Setting noCrossContamination checkbox to checked');
      if(noCrossCheckbox){
        noCrossCheckbox.checked = true;
        // Disable allergen checkboxes when "no cross-contamination" is set
        crossAllergenCheckboxes.forEach(cb => {
          cb.checked = false;
          cb.disabled = true;
          if(cb.parentElement){
            cb.parentElement.style.opacity = '0.5';
            cb.parentElement.style.pointerEvents = 'none';
          }
        });
      }
    } else if(context?.crossContamination && Array.isArray(context.crossContamination) && context.crossContamination.length > 0){
      console.log('  Loading cross-contamination allergens:', context.crossContamination);
      // Uncheck "no cross-contamination" since we have specific allergens
      if(noCrossCheckbox){
        noCrossCheckbox.checked = false;
      }
      // Check the appropriate allergen checkboxes
      context.crossContamination.forEach(allergen => {
        const checkbox = Array.from(crossAllergenCheckboxes).find(cb => cb.dataset.allergen === allergen);
        console.log(`    Looking for checkbox for ${allergen}:`, checkbox);
        if(checkbox){
          checkbox.checked = true;
          console.log(`    Set ${allergen} checkbox to checked`);
        } else {
          console.warn(`    Could not find checkbox for ${allergen}`);
        }
      });
    } else {
      console.log('  No cross-contamination data to load');
    }
  } else {
    console.log('  Skipping cross-contamination load because assistant is already open');
  }

  // Show/hide delete button and wire up callback
  const deleteBtn = document.getElementById('aiAssistDeleteBtn');
  const deleteWarning = document.getElementById('aiAssistDeleteWarning');
  const confirmDeleteBtn = document.getElementById('aiAssistConfirmDeleteBtn');
  const cancelDeleteBtn = document.getElementById('aiAssistCancelDeleteBtn');

  if(deleteBtn){
    if(context?.onDelete){
      deleteBtn.style.display = 'block';
      deleteBtn.onclick = () => {
        // Show inline delete warning instead of browser confirm
        if(deleteWarning){
          deleteWarning.style.display = 'block';
          deleteWarning.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      };

      // Set up confirm delete handler
      if(confirmDeleteBtn){
        confirmDeleteBtn.onclick = () => {
          if(deleteWarning) deleteWarning.style.display = 'none';
          toggleAiAssistBackdrop(false);
          context.onDelete();
        };
      }

      // Set up cancel delete handler
      if(cancelDeleteBtn){
        cancelDeleteBtn.onclick = () => {
          if(deleteWarning) deleteWarning.style.display = 'none';
        };
      }
    } else {
      deleteBtn.style.display = 'none';
      deleteBtn.onclick = null;
    }
  }

  // Check if there are existing ingredients to edit
  const existingIngredients = context?.existingIngredients;
  const hasExistingData = existingIngredients && Array.isArray(existingIngredients) && existingIngredients.length > 0;

  if(hasExistingData){
    // Skip input screen and go directly to ingredient editing table
    renderAiTable(existingIngredients);
    // Show the results section
    if(aiAssistResultsEl){
      aiAssistResultsEl.classList.add('show');
    }
    // Mark as saved since we're just loading existing data
    aiAssistState.savedToDish = true;
    // Store initial data to detect real changes
    aiAssistState.initialData = JSON.stringify(existingIngredients);
  } else {
    // New item - show input screen
    if(aiAssistInput){
      aiAssistInput.value=context?.seedText||'';
      setTimeout(()=>{aiAssistInput.focus(); aiAssistInput.selectionStart=aiAssistInput.value.length;},120);
    }
    renderAiTable([]);
    aiAssistState.savedToDish = false;
    aiAssistState.initialData = null;
  }

  toggleAiAssistBackdrop(true);
}

function openImageModal(imageSrc){
  const modal=document.getElementById('imageModal');
  const img=document.getElementById('imageModalImg');
  if(modal && img){
    img.src=imageSrc;
    modal.classList.add('show');
    document.body.style.overflow='hidden';
  }
}

function closeImageModal(){
  const modal=document.getElementById('imageModal');
  if(modal){
    modal.classList.remove('show');
    document.body.style.overflow='';
  }
}

function closeAiAssistant(){
  ensureAiAssistElements();

  // Check for unsaved changes (don't prompt if already saved to dish)
  const data = collectAiTableData();
  const hasData = data.length > 0 && data.some(item => item.name.trim());

  // Check if data has actually changed from initial state
  let dataChanged = false;
  if(aiAssistState.initialData){
    const currentData = JSON.stringify(data);
    dataChanged = currentData !== aiAssistState.initialData;
  } else {
    // No initial data means this is new work
    dataChanged = hasData;
  }

  const hasUnsavedChanges = dataChanged && !aiAssistState.savedToDish;

  if(hasUnsavedChanges){
    // Show inline warning instead of confirm dialog
    const warningEl = document.getElementById('aiAssistUnsavedWarning');
    if(warningEl){
      warningEl.style.display = 'block';

      // Scroll warning into view
      warningEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

      // Set up button handlers
      const saveAndExitBtn = document.getElementById('aiAssistSaveAndExitBtn');
      const exitWithoutSavingBtn = document.getElementById('aiAssistExitWithoutSavingBtn');
      const cancelExitBtn = document.getElementById('aiAssistCancelExitBtn');

      const handleSaveAndExit = () => {
        warningEl.style.display = 'none';
        // Apply ingredients to dish (same as clicking "Save to Dish" button)
        applyAiIngredientsToOverlay();
      };

      const handleExitWithoutSaving = () => {
        warningEl.style.display = 'none';
        // Continue with the actual close
        performAiAssistClose();
      };

      const handleCancelExit = () => {
        warningEl.style.display = 'none';
      };

      // Remove old listeners and add new ones
      if(saveAndExitBtn){
        saveAndExitBtn.replaceWith(saveAndExitBtn.cloneNode(true));
        document.getElementById('aiAssistSaveAndExitBtn').onclick = handleSaveAndExit;
      }
      if(exitWithoutSavingBtn){
        exitWithoutSavingBtn.replaceWith(exitWithoutSavingBtn.cloneNode(true));
        document.getElementById('aiAssistExitWithoutSavingBtn').onclick = handleExitWithoutSaving;
      }
      if(cancelExitBtn){
        cancelExitBtn.replaceWith(cancelExitBtn.cloneNode(true));
        document.getElementById('aiAssistCancelExitBtn').onclick = handleCancelExit;
      }

      return; // Stop here, don't close yet
    }
  }

  // If no unsaved changes, close directly
  performAiAssistClose();
}

function performAiAssistClose(){
  // Hide warning if visible
  const warningEl = document.getElementById('aiAssistUnsavedWarning');
  if(warningEl) warningEl.style.display = 'none';

  if(aiAssistState.recognition){
    try{aiAssistState.recognition.stop();}catch(_){}
  }
  aiAssistState.recognition=null;
  aiAssistState.listening=false;
  aiAssistState.pendingRequestId=null;
  aiAssistState.brandSuggestions={};
  aiAssistState.savedToDish=false;
  aiAssistSetStatus('');
  stopAiCamera();
  aiAssistState.imageData=null;
  aiAssistState.imageFileName=null;
  updateAiAssistMediaPreview();
  if(aiAssistResultsEl){
    aiAssistResultsEl.classList.remove('show');
  }
  if(aiAssistTableBody){
    aiAssistTableBody.innerHTML='';
  }
  if(aiAssistBrandResults){
    aiAssistBrandResults.classList.remove('show');
    aiAssistBrandResults.innerHTML='';
  }
  const finalConfirmation = document.getElementById('aiAssistFinalConfirmation');
  if(finalConfirmation){
    finalConfirmation.classList.add('aiAssistHidden');
  }
  if(aiAssistDictateBtn) aiAssistDictateBtn.textContent='🎙 Dictate';
  toggleAiAssistBackdrop(false);
}

// Save draft functionality
function saveAiDraft(){
  const data = collectAiTableData();
  if(data.length === 0 || !data.some(item => item.name.trim())){
    aiAssistSetStatus('No ingredients to save.', 'warn');
    return;
  }

  const dishName = document.getElementById('aiAssistNameInput')?.value || 'Untitled Dish';
  const draftKey = `aiAssistDraft_${Date.now()}`;

  try{
    localStorage.setItem(draftKey, JSON.stringify({
      dishName: dishName,
      ingredients: data,
      timestamp: Date.now()
    }));
    aiAssistSetStatus(`✓ Draft saved for "${dishName}"! You can load it later.`, 'info');
  }catch(err){
    console.error('Failed to save draft:', err);
    aiAssistSetStatus('Failed to save draft. Please try again.', 'error');
  }
}

// Confirm all ingredients workflow
function confirmAllIngredients(){
  const data = collectAiTableData();

  // Check if there are any ingredients
  if(data.length === 0 || !data.some(item => item.name.trim())){
    alert('Please add ingredients before confirming.');
    return;
  }

  // Check if all ingredients are confirmed
  const unconfirmed = data.filter(item => item.name.trim() && !item.confirmed);
  if(unconfirmed.length > 0){
    const ingredientNames = unconfirmed.map(item => `• ${item.name}`).join('\n');
    alert(
      `⚠️ Please confirm allergens for all ingredients first.\n\n` +
      `Unconfirmed ingredients:\n${ingredientNames}\n\n` +
      `Check the "Confirmed" checkbox for each ingredient after verifying its allergens.`
    );
    return;
  }

  // Show final confirmation section
  const finalConfirmation = document.getElementById('aiAssistFinalConfirmation');
  if(finalConfirmation){
    finalConfirmation.classList.remove('aiAssistHidden');
    finalConfirmation.scrollIntoView({behavior: 'smooth', block: 'nearest'});
  }
}

function toggleAiDictation(){
  ensureAiAssistElements();
  if(aiAssistState.listening){
    if(aiAssistState.recognition){
      try{aiAssistState.recognition.stop();}catch(_){}
    }
    aiAssistState.listening=false;
    aiAssistSetStatus('Dictation stopped.','info');
    if(aiAssistDictateBtn) aiAssistDictateBtn.textContent='🎙 Dictate';
    return;
  }
  const SpeechRecognition=window.SpeechRecognition||window.webkitSpeechRecognition;
  if(!SpeechRecognition){
    aiAssistSetStatus('Dictation is not supported in this browser.','warn');
    return;
  }
  try{
    const recognition=new SpeechRecognition();
    recognition.lang='en-US';
    recognition.continuous=true;
    recognition.interimResults=true;
    recognition.onresult=(event)=>{
      let transcript='';
      for(let i=0;i<event.results.length;i++){
        transcript+=event.results[i][0].transcript;
      }
      if(aiAssistInput) aiAssistInput.value=transcript.trim();
    };
    recognition.onerror=(evt)=>{
      aiAssistSetStatus('Dictation error: '+(evt.error||'unknown'), 'warn');
    };
    recognition.onend=()=>{
      aiAssistState.listening=false;
      aiAssistState.recognition=null;
      if(aiAssistDictateBtn) aiAssistDictateBtn.textContent='🎙 Dictate';
    };
    recognition.start();
    aiAssistState.recognition=recognition;
    aiAssistState.listening=true;
    aiAssistSetStatus('Dictation active… speak now.');
    if(aiAssistDictateBtn) aiAssistDictateBtn.textContent='⏹ Stop dictation';
  }catch(err){
    console.error('Dictation failed',err);
    aiAssistSetStatus('Could not start dictation: '+(err.message||err),'error');
  }
}

async function correctSpellingWithAI(query, ingredientName){
  try {
    // Use proxy to avoid CORS issues
    const response = await fetch('/api/ai-proxy', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        functionName: 'spelling-corrector',
        payload: {
          query: query,
          ingredientName: ingredientName
        }
      })
    });

    if(!response.ok){
      console.warn('Spelling correction failed:', response.status);
      return query;
    }

    const data = await response.json();
    const corrected = data?.corrected || query;
    return corrected;
  } catch(err) {
    console.warn('AI spelling correction failed', err);
  }
  return query;
}

async function fetchBrandSuggestions(query, ingredientName, onProgress){
  ensureAiAssistElements();
  if(!ingredientName) return [];

  // Extract brand filter from query if present
  const brandQuery = query !== ingredientName ? query.replace(ingredientName, '').trim() : '';

  console.log('Fetching brand suggestions:', { ingredientName, brandQuery });

  try {
    // Call the new AI-powered brand search Supabase edge function
    if(onProgress) onProgress(30, 'Searching for products...', 'Querying product database');

    const response = await window.supabaseClient.functions.invoke('ai-brand-search', {
      body: {
        ingredientName,
        brandQuery
      }
    });

    if (response.error) {
      console.error('AI brand search error:', response.error);
      return [];
    }

    const { products, aiReasoning, searchCount, totalFound, withImages } = response.data || {};

    console.log('AI Brand Search Results:', {
      aiReasoning,
      searchCount,
      totalFound,
      withImages,
      productsReturned: products?.length || 0
    });

    if (aiReasoning) {
      console.log('AI reasoning:', aiReasoning);
    }

    if (!products || products.length === 0) {
      console.log('No brand products found with required images');
      return [];
    }

    if(onProgress) onProgress(50, 'Products found', `Analyzing ${products.length} product${products.length > 1 ? 's' : ''} with AI...`);

    // Filter products to only include those with BOTH ingredient label image AND text ingredient list
    const filteredProducts = products.filter(product => {
      // Must have ingredient label image for visual verification
      const hasImage = product.ingredientsImage && product.ingredientsImage.trim().length > 0;
      // Must have text ingredient list for allergen/diet detection
      const hasIngredientsList = product.ingredientsList && product.ingredientsList.length > 0;
      // Both are required
      return hasImage && hasIngredientsList;
    });

    if(onProgress) onProgress(60, 'Analyzing ingredients...', `Using Claude AI to analyze ${filteredProducts.length} product${filteredProducts.length > 1 ? 's' : ''}`);

    // Show progress bar for AI analysis (for top-level progress bar)
    const progressBar = document.getElementById('aiProgressBar');
    const progressBarFill = document.getElementById('aiProgressBarFill');
    if (progressBar && progressBarFill && filteredProducts.length > 0) {
      progressBar.classList.add('show');
      progressBarFill.style.width = '30%';
    }

    // Use Claude AI to analyze each product's ingredients
    const analyzedProducts = await Promise.all(filteredProducts.map(async (product) => {
      let allergens = [];
      let diets = [];

      try {
        const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
          body: {
            ingredientText: product.ingredientsList.join(', '),
            productName: product.name || '',
            labels: product.labels_tags || [],
            categories: product.categories_tags || []
          }
        });

        if (analysisResult.error) {
          console.error('Claude AI analysis error for product:', product.name, analysisResult.error);
        } else {
          const { allergens: aiAllergens, diets: aiDiets } = analysisResult.data || {};
          allergens = aiAllergens || [];
          diets = aiDiets || [];
          console.log('Claude AI analyzed:', product.name, { allergens, diets });
        }
      } catch (aiError) {
        console.error('Failed to analyze product with Claude AI:', product.name, aiError);
      }

      return {
        name: product.name || '',
        brand: product.brand || '',
        image: product.image || '',
        ingredientsImage: product.ingredientsImage || '',
        ingredientsList: product.ingredientsList || [],
        allergens,
        diets,
        productUrl: product.productUrl || ''
      };
    }));

    // Complete progress bar
    if (progressBarFill) progressBarFill.style.width = '100%';
    setTimeout(() => {
      if (progressBar) progressBar.classList.remove('show');
      if (progressBarFill) progressBarFill.style.width = '0%';
    }, 300);

    return analyzedProducts;

  } catch (err) {
    console.error('Failed to fetch brand suggestions:', err);
    return [];
  }
}

async function openAiBrandSearch(rowIdx){
  ensureAiAssistElements();
  const rows=collectAiTableData();
  if(!rows[rowIdx]){
    aiAssistSetStatus('Select an ingredient first.','warn');
    return;
  }

  const ingredientName = rows[rowIdx].name;
  if(!ingredientName){
    aiAssistSetStatus('Add an ingredient name before searching for a brand.','warn');
    return;
  }

  // Find the row-specific brand results container
  const rowElement=aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"]`);
  if(!rowElement) return;
  const rowBrandResults=rowElement.querySelector('.aiRowBrandResults');
  if(!rowBrandResults) return;

  // Show search form
  rowBrandResults.classList.add('show');
  rowBrandResults.innerHTML=`
    <div class="aiBrandSearchForm">
      <div style="margin-bottom:12px">
        <label style="display:block;margin-bottom:6px;font-weight:500">Ingredient: <strong>${esc(ingredientName)}</strong></label>
        <input type="text" class="aiBrandSearchInput" placeholder="Optional: brand name (e.g., 'Chobani', 'Once Again')" style="width:100%;padding:8px;background:#0c102a;border:1px solid rgba(76,90,212,0.4);border-radius:8px;color:#fff">
      </div>
      <div style="display:flex;gap:8px">
        <button type="button" class="btn aiBrandSearchSubmit">Search</button>
        <button type="button" class="btn aiBrandSearchCancel" style="background:#301424;border-color:#4c2138">Cancel</button>
      </div>
    </div>
  `;

  const searchInput = rowBrandResults.querySelector('.aiBrandSearchInput');
  const submitBtn = rowBrandResults.querySelector('.aiBrandSearchSubmit');
  const cancelBtn = rowBrandResults.querySelector('.aiBrandSearchCancel');

  const performSearch = async () => {
    const brandFilter = searchInput.value.trim();
    const query = brandFilter ? `${ingredientName} ${brandFilter}` : ingredientName;

    aiAssistSetStatus('Searching for brand suggestions…');
    rowBrandResults.innerHTML=`
      <div style="padding:20px;text-align:center">
        <div id="brandSearchStatus" style="font-size:1rem;margin-bottom:12px;color:#a8b2d6">Searching for products...</div>
        <div class="aiProgressBar show" style="display:block;margin:0 auto;max-width:300px">
          <div id="brandSearchProgress" class="aiProgressBarFill" style="width:10%;animation:shimmer 1.5s infinite"></div>
        </div>
        <div id="brandSearchSubtext" style="font-size:0.85rem;margin-top:8px;color:#8891b0">Querying product database</div>
      </div>
    `;

    // Helper to update progress
    const updateProgress = (percent, status, subtext) => {
      const progressBar = document.getElementById('brandSearchProgress');
      const statusEl = document.getElementById('brandSearchStatus');
      const subtextEl = document.getElementById('brandSearchSubtext');
      if(progressBar) progressBar.style.width = percent + '%';
      if(statusEl && status) statusEl.textContent = status;
      if(subtextEl && subtext) subtextEl.textContent = subtext;
    };

    try{
      // Small delay to let DOM update
      await new Promise(resolve => setTimeout(resolve, 50));
      updateProgress(20, 'Searching for products...', 'Querying product database');

      const suggestions=await fetchBrandSuggestions(query, ingredientName, updateProgress);

      updateProgress(100, 'Complete!', 'Products analyzed');
      aiAssistState.brandSuggestions[rowIdx]=suggestions;
      if(!suggestions.length){
        rowBrandResults.innerHTML=`
          <div style="text-align:center;padding:20px">
            <p style="margin-bottom:12px">No brands found.</p>
            <button type="button" class="btn aiBrandSearchAgain">Try a different search</button>
          </div>
        `;
        rowBrandResults.querySelector('.aiBrandSearchAgain').addEventListener('click', () => {
          openAiBrandSearch(rowIdx);
        });
        return;
      }
      rowBrandResults.innerHTML=`
        <div style="background:rgba(220,82,82,0.15);border:1px solid rgba(220,82,82,0.4);border-radius:12px;padding:12px;margin-bottom:16px">
          <strong style="color:#dc5252">⚠️ Safety Warning</strong>
          <p style="margin:8px 0 0 0;font-size:0.9rem;line-height:1.4">Data is crowdsourced and may be outdated or incorrect. ALWAYS verify ingredient labels match the actual product image before relying on allergen information.</p>
        </div>
        ${suggestions.map((item,idx)=>`
        <div class="aiBrandSuggestion" data-row="${rowIdx}" data-index="${idx}">
          ${item.image?`<img src="${esc(item.image)}" alt="${esc(item.name)}" loading="lazy">`:''}
          <div class="aiBrandSuggestionInfo">
            <strong>${esc(item.name)}</strong>
            ${item.brand?`<span>${esc(item.brand)}</span>`:''}
            ${item.ingredientsImage?'<span style="color:#4c5ad4">✓ Has label image - click to verify</span>':'<span style="color:#dc5252">⚠️ No label image available</span>'}
            ${item.productUrl?`<a href="${esc(item.productUrl)}" target="_blank" rel="noopener" style="font-size:0.85rem;color:#4c5ad4">View on Open Food Facts</a>`:''}
            <button type="button" class="btn btnSmall aiBrandApply" data-row="${rowIdx}" data-index="${idx}" style="margin-top:8px">Add this brand</button>
          </div>
        </div>
      `).join('')}
      <div style="text-align:center;margin-top:16px;padding-top:16px;border-top:1px solid rgba(76,90,212,0.2)">
        <button type="button" class="btn aiBrandSearchAgain">Search again</button>
      </div>
      `;

      // Add click handlers for "Add this brand" buttons
      rowBrandResults.querySelectorAll('.aiBrandApply').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const suggestionIdx = Number(e.target.dataset.index);
          applyBrandSuggestion(rowIdx, suggestionIdx);
        });
      });

      // Add click handler for "Search again" button
      rowBrandResults.querySelector('.aiBrandSearchAgain').addEventListener('click', () => {
        openAiBrandSearch(rowIdx);
      });

      aiAssistSetStatus('Review images carefully before applying. Click images to verify ingredient labels match.','warn');
    }catch(err){
      console.error('Brand lookup failed',err);
      rowBrandResults.innerHTML='<div>Could not retrieve brand information.</div>';
      aiAssistSetStatus('Brand lookup failed. Try again later.','warn');
    }
  };

  submitBtn.addEventListener('click', performSearch);
  cancelBtn.addEventListener('click', () => {
    rowBrandResults.classList.remove('show');
    rowBrandResults.innerHTML = '';
  });
  searchInput.addEventListener('keypress', (e) => {
    if(e.key === 'Enter'){
      performSearch();
    }
  });

  // Focus the input
  setTimeout(() => searchInput.focus(), 100);
}

async function openAiBarcodeScanner(rowIdx){
  ensureAiAssistElements();
  const rows=collectAiTableData();
  if(!rows[rowIdx]){
    aiAssistSetStatus('Select an ingredient first.','warn');
    return;
  }

  const ingredientName = rows[rowIdx].name;
  if(!ingredientName){
    aiAssistSetStatus('Add an ingredient name before scanning a barcode.','warn');
    return;
  }

  // Create a full-screen modal overlay for the scanner
  const scannerModal = document.createElement('div');
  scannerModal.id = 'barcodeScannerModal';
  scannerModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.95);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;

  scannerModal.innerHTML = `
    <div style="width:100%;max-width:600px;display:flex;flex-direction:column;gap:16px">
      <div style="text-align:center">
        <h3 style="margin:0 0 8px 0;font-size:1.4rem;color:#fff">Scan Barcode</h3>
        <p style="margin:0;color:#a8b2d6;font-size:0.95rem">Ingredient: <strong style="color:#fff">${esc(ingredientName)}</strong></p>
        <p style="margin:8px 0 0 0;color:#a8b2d6;font-size:0.9rem">Point your camera at the product barcode</p>
      </div>
      <div style="position:relative;background:#000;border-radius:16px;overflow:hidden;width:100%">
        <video id="barcodeScannerVideo" autoplay playsinline muted style="width:100%;height:60vh;max-height:500px;display:block;object-fit:cover"></video>
        <div id="barcodeScannerOverlay" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:70%;height:40%;border:3px solid #4c5ad4;border-radius:12px;pointer-events:none;box-shadow:0 0 0 9999px rgba(0,0,0,0.5)"></div>
        <div id="barcodeScannerStatus" style="position:absolute;top:16px;left:16px;right:16px;background:rgba(11,16,32,0.95);padding:12px 16px;border-radius:12px;color:#fff;text-align:center;font-size:1rem;font-weight:500">Initializing camera...</div>
      </div>
      <div style="display:flex;gap:12px;justify-content:center">
        <button type="button" class="btn aiBarcodeScannerCancel" style="background:#ef4444;border-color:#dc2626;padding:12px 32px;font-size:1rem">Cancel</button>
      </div>
    </div>
  `;

  // Lock background scrolling (mobile-safe)
  scrollLockPosition = window.pageYOffset || document.documentElement.scrollTop;
  document.body.style.position = 'fixed';
  document.body.style.top = `-${scrollLockPosition}px`;
  document.body.style.width = '100%';
  document.body.style.overflow = 'hidden';

  document.body.appendChild(scannerModal);

  const video = scannerModal.querySelector('#barcodeScannerVideo');
  const statusDiv = scannerModal.querySelector('#barcodeScannerStatus');
  const cancelBtn = scannerModal.querySelector('.aiBarcodeScannerCancel');

  // Ensure video attributes are set for mobile compatibility
  video.setAttribute('autoplay', '');
  video.setAttribute('playsinline', '');
  video.setAttribute('muted', '');

  let codeReader = null;
  let scanning = false;

  const stopScanning = () => {
    if(codeReader){
      codeReader.reset();
      codeReader = null;
    }
    scanning = false;
    if(video.srcObject){
      video.srcObject.getTracks().forEach(track => track.stop());
      video.srcObject = null;
    }
  };

  const closeModal = () => {
    stopScanning();
    if(scannerModal && scannerModal.parentNode){
      scannerModal.parentNode.removeChild(scannerModal);
    }
    // Restore scroll position and body styles
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.width = '';
    document.body.style.overflow = '';
    window.scrollTo(0, scrollLockPosition);
  };

  cancelBtn.addEventListener('click', closeModal);

  try {
    // Check if ZXing library is loaded
    if(typeof ZXing === 'undefined'){
      statusDiv.textContent = 'Barcode scanner library not loaded. Please refresh the page.';
      statusDiv.style.background = 'rgba(220,82,82,0.9)';
      return;
    }

    codeReader = new ZXing.BrowserMultiFormatReader();
    statusDiv.textContent = 'Starting camera...';

    // Get available video devices
    const videoInputDevices = await codeReader.listVideoInputDevices();
    if(!videoInputDevices || videoInputDevices.length === 0){
      statusDiv.textContent = 'No camera found. Please check camera permissions.';
      statusDiv.style.background = 'rgba(220,82,82,0.9)';
      return;
    }

    // Prefer back camera on mobile
    let selectedDeviceId = videoInputDevices[0].deviceId;
    const backCamera = videoInputDevices.find(device =>
      device.label.toLowerCase().includes('back') ||
      device.label.toLowerCase().includes('rear') ||
      device.label.toLowerCase().includes('environment')
    );
    if(backCamera){
      selectedDeviceId = backCamera.deviceId;
    }

    statusDiv.textContent = 'Point camera at barcode...';
    statusDiv.style.background = 'rgba(76,90,212,0.9)';
    scanning = true;

    // Start scanning
    codeReader.decodeFromVideoDevice(selectedDeviceId, video, async (result, err) => {
      if(!scanning) return;

      if(result){
        const barcode = result.text;
        statusDiv.textContent = `Found barcode: ${barcode}`;
        statusDiv.style.background = 'rgba(34,197,94,0.9)';

        // Stop scanning (but keep modal open for feedback)
        stopScanning();

        // Look up product by barcode
        statusDiv.textContent = 'Looking up product...';
        statusDiv.style.background = 'rgba(59,130,246,0.9)';
        aiAssistSetStatus('Looking up product by barcode…');

        try {
          const product = await fetchProductByBarcode(barcode);
          if(product){
            // Close modal on success
            closeModal();

            // Use Claude AI to analyze ingredients (Sonnet 4.5)
            statusDiv.textContent = 'Analyzing ingredients with AI...';
            statusDiv.style.background = 'rgba(139,92,246,0.9)';
            aiAssistSetStatus('Analyzing ingredients with Claude AI…');

            // Show progress bar
            const progressBar = document.getElementById('aiProgressBar');
            const progressBarFill = document.getElementById('aiProgressBarFill');
            if (progressBar && progressBarFill) {
              progressBar.classList.add('show');
              progressBarFill.style.width = '30%';
            }

            let parsedAllergens = [];
            let diets = [];

            try {
              const analysisResult = await window.supabaseClient.functions.invoke('analyze-brand-allergens', {
                body: {
                  ingredientText: product.ingredients_text || '',
                  productName: product.product_name || '',
                  labels: product.labels_tags || [],
                  categories: product.categories_tags || []
                }
              });

              // Update progress
              if (progressBarFill) progressBarFill.style.width = '90%';

              if (analysisResult.error) {
                console.error('Claude AI analysis error:', analysisResult.error);
                // Fall back to empty arrays if AI fails
                parsedAllergens = [];
                diets = [];
              } else {
                const { allergens, diets: aiDiets, reasoning } = analysisResult.data || {};
                parsedAllergens = allergens || [];
                diets = aiDiets || [];
                console.log('Claude AI analysis:', { allergens: parsedAllergens, diets, reasoning });
              }

              // Complete progress
              if (progressBarFill) progressBarFill.style.width = '100%';
              setTimeout(() => {
                if (progressBar) progressBar.classList.remove('show');
                if (progressBarFill) progressBarFill.style.width = '0%';
              }, 300);

            } catch (aiError) {
              console.error('Failed to analyze with Claude AI:', aiError);
              // Fall back to empty arrays if AI call fails
              parsedAllergens = [];
              diets = [];

              // Hide progress bar on error
              if (progressBar) progressBar.classList.remove('show');
              if (progressBarFill) progressBarFill.style.width = '0%';
            }


            // Convert to the format expected by applyBrandSuggestionConfirmed
            const suggestion = {
              name: product.product_name || product.name || 'Unknown Product',
              brand: product.brands || product.brand || '',
              barcode: barcode,
              image: product.image_url || product.image || '',
              ingredientsImage: product.image_ingredients_url || product.ingredientsImage || '',
              ingredientsList: product.ingredients_text ? [product.ingredients_text] : (product.ingredientsList || []),
              allergens: parsedAllergens,
              diets: diets,
              productUrl: `https://world.openfoodfacts.org/product/${barcode}`
            };

            // Check if product has BOTH ingredient label image AND ingredient list
            // We require both for verification and allergen safety
            const hasImage = suggestion.ingredientsImage && suggestion.ingredientsImage.trim().length > 0;
            const hasIngredientsList = suggestion.ingredientsList && suggestion.ingredientsList.length > 0 && suggestion.ingredientsList[0].trim().length > 0;

            if(!hasImage || !hasIngredientsList){
              // Missing ingredient label image or list - show error and restart scanning
              let reason = '';
              if(!hasImage && !hasIngredientsList){
                reason = 'no ingredient label image or ingredient list';
              } else if(!hasImage){
                reason = 'no ingredient label image for visual verification';
              } else {
                reason = 'no ingredient list text';
              }

              statusDiv.textContent = `Product found but ${reason} (Barcode: ${barcode}). Scan again or close to search manually.`;
              statusDiv.style.background = 'rgba(220,82,82,0.9)';
              statusDiv.style.padding = '16px';
              statusDiv.style.fontSize = '0.95rem';
              aiAssistSetStatus(`Cannot use this product - ${reason}. Try scanning again or search manually.`,'warn');

              // Restart scanning after 3 seconds
              setTimeout(() => {
                if(scannerModal.parentNode){
                  scanning = true;
                  statusDiv.textContent = 'Point camera at barcode to try again...';
                  statusDiv.style.background = 'rgba(11,16,32,0.95)';
                  statusDiv.style.padding = '12px 16px';
                  statusDiv.style.fontSize = '1rem';
                }
              }, 3000);
            } else {
              // Has both ingredient label image AND ingredient list - show confirmation modal
              showBrandConfirmationModal(suggestion, () => {
                applyBrandSuggestionConfirmed(rowIdx, suggestion);
              });
              aiAssistSetStatus('Product found! Review and confirm.','success');
            }
          } else {
            // Product not found - show error and offer to retry
            statusDiv.textContent = `Product not found in Open Food Facts database (Barcode: ${barcode}). Scan again or close to search manually.`;
            statusDiv.style.background = 'rgba(220,82,82,0.9)';
            statusDiv.style.padding = '16px';
            statusDiv.style.fontSize = '0.95rem';
            aiAssistSetStatus('Product not found in database. Try scanning again or search manually.','warn');

            // Restart scanning after 3 seconds
            setTimeout(() => {
              if(scannerModal.parentNode){
                scanning = true;
                statusDiv.textContent = 'Point camera at barcode to try again...';
                statusDiv.style.background = 'rgba(11,16,32,0.95)';
                statusDiv.style.padding = '12px 16px';
                statusDiv.style.fontSize = '1rem';
              }
            }, 3000);
          }
        } catch(err){
          console.error('Barcode lookup failed', err);
          statusDiv.textContent = 'Network error. Check connection and try again.';
          statusDiv.style.background = 'rgba(220,82,82,0.9)';
          aiAssistSetStatus('Barcode lookup failed. Try again.','warn');

          // Restart scanning after 3 seconds
          setTimeout(() => {
            if(scannerModal.parentNode){
              scanning = true;
              statusDiv.textContent = 'Point camera at barcode...';
              statusDiv.style.background = 'rgba(11,16,32,0.95)';
            }
          }, 3000);
        }
      }

      if(err && !(err instanceof ZXing.NotFoundException)){
        console.error('Barcode scan error:', err);
      }
    });

  } catch(err){
    console.error('Failed to start barcode scanner:', err);
    statusDiv.textContent = 'Camera access denied or not available';
    statusDiv.style.background = 'rgba(220,82,82,0.9)';
    aiAssistSetStatus('Failed to access camera. Please check permissions.','warn');
  }
}

async function fetchProductByBarcode(barcode){
  try {
    const response = await fetch(`https://world.openfoodfacts.org/api/v0/product/${barcode}.json`);
    if(!response.ok) return null;

    const data = await response.json();
    if(data.status !== 1 || !data.product) return null;

    return data.product;
  } catch(err){
    console.error('Failed to fetch product by barcode:', err);
    return null;
  }
}

function applyBrandSuggestion(rowIdx, suggestionIdx){
  ensureAiAssistElements();
  const suggestions=aiAssistState.brandSuggestions[rowIdx]||[];
  const suggestion=suggestions[suggestionIdx];
  if(!suggestion) return;

  // Show confirmation modal to verify product and ingredients
  showBrandConfirmationModal(suggestion, () => {
    // User confirmed - proceed with applying the brand
    applyBrandSuggestionConfirmed(rowIdx, suggestion);
  });
}

function showBrandConfirmationModal(suggestion, onConfirm){
  const hasImage = suggestion.ingredientsImage;
  const hasIngredients = suggestion.ingredientsList && suggestion.ingredientsList.length > 0;

  // Create modal overlay with scroll lock
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10001;
    padding: 20px;
    overflow: hidden;
    touch-action: none;
  `;

  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
    background: #0c102a;
    border: 2px solid ${hasImage ? '#4c5ad4' : '#dc5252'};
    border-radius: 16px;
    max-width: 95vw;
    width: 1000px;
    max-height: 85vh;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 24px;
    color: #fff;
    touch-action: pan-y;
  `;

  modalContent.innerHTML = `
    <div style="margin-bottom: 20px;">
      <h3 style="margin: 0 0 8px 0; color: ${hasImage ? '#4c5ad4' : '#dc5252'}; font-size: 1.3rem;">
        ${hasImage ? '⚠️ Verify Product & Ingredients' : '⚠️ WARNING: No Label Image'}
      </h3>
      <p style="margin: 0; font-size: 0.95rem; color: #a0a0a0;">
        ${hasImage
          ? 'Please confirm this matches the exact product you use in your restaurant.'
          : 'This product has NO label image. You cannot verify if the data is accurate or current.'}
      </p>
    </div>

    ${suggestion.image ? `
      <div style="margin-bottom: 20px; text-align: center;">
        <img src="${esc(suggestion.image)}" alt="${esc(suggestion.name)}"
             style="max-width: 200px; max-height: 200px; border-radius: 8px; border: 1px solid rgba(76,90,212,0.3);">
        <p style="margin: 8px 0 0 0; font-weight: 600; font-size: 1.05rem;">${esc(suggestion.name)}</p>
        ${suggestion.brand ? `<p style="margin: 4px 0 0 0; color: #a0a0a0; font-size: 0.9rem;">${esc(suggestion.brand)}</p>` : ''}
      </div>
    ` : ''}

    ${hasImage ? `
      <div style="margin-bottom: 20px;">
        <div style="background: rgba(76,90,212,0.1); border: 1px solid rgba(76,90,212,0.3); border-radius: 8px; padding: 16px; margin-bottom: 12px;">
          <p style="margin: 0 0 12px 0; font-weight: 600; color: #4c5ad4;">📋 Ingredient Label Image:</p>
          <img src="${esc(suggestion.ingredientsImage)}" alt="Ingredient label"
               style="width: 100%; border-radius: 6px; cursor: pointer; border: 1px solid rgba(76,90,212,0.3);"
               onclick="window.open('${esc(suggestion.ingredientsImage)}', '_blank')">
          <p style="margin: 8px 0 0 0; font-size: 0.85rem; color: #a0a0a0; font-style: italic;">
            Click image to view full size
          </p>
        </div>
      </div>
    ` : ''}

    ${hasIngredients ? `
      <div style="background: rgba(76,90,212,0.1); border: 1px solid rgba(76,90,212,0.3); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <p style="margin: 0 0 8px 0; font-weight: 600; color: #4c5ad4;">📝 Ingredients List (from database):</p>
        <p style="margin: 0; font-size: 0.9rem; line-height: 1.5;">
          ${suggestion.ingredientsList.join(', ')}
        </p>
        ${suggestion.allergens && suggestion.allergens.length > 0 ? `
          <p style="margin: 12px 0 0 0; font-weight: 600; color: #dc5252;">🚨 Detected Allergens:</p>
          <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: #dc5252;">
            ${suggestion.allergens.join(', ')}
          </p>
        ` : ''}
        ${suggestion.diets && suggestion.diets.length > 0 ? `
          <p style="margin: 12px 0 0 0; font-weight: 600; color: #4caf50;">📋 Detected Dietary Preferences:</p>
          <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: #4caf50;">
            ${suggestion.diets.join(', ')}
          </p>
        ` : ''}
      </div>
    ` : ''}

    ${hasImage && hasIngredients ? `
      <div style="background: rgba(220,82,82,0.15); border: 1px solid rgba(220,82,82,0.4); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <p style="margin: 0 0 12px 0; font-weight: 600; color: #dc5252;">✓ Before confirming, verify:</p>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <label style="display: flex; align-items: center; gap: 12px; cursor: pointer; font-size: 0.95rem; line-height: 1.5;">
            <input type="checkbox" class="verifyCheckbox" style="width: 20px; height: 20px; cursor: pointer; flex-shrink: 0;">
            <span>The ingredient label image is readable and matches this exact product</span>
          </label>
        </div>
      </div>
    ` : !hasImage ? `
      <div style="background: rgba(220,82,82,0.15); border: 1px solid rgba(220,82,82,0.4); border-radius: 8px; padding: 16px; margin-bottom: 20px;">
        <p style="margin: 0 0 12px 0; font-weight: 600; color: #dc5252;">⚠️ Cannot Verify:</p>
        <ul style="margin: 0; padding-left: 20px; line-height: 1.8; font-size: 0.9rem;">
          <li>No ingredient label image available</li>
          <li>Cannot verify if data is current or accurate</li>
          <li>Cannot confirm allergen information</li>
          <li>Data may be outdated or incorrect</li>
        </ul>
        <p style="margin: 12px 0 0 0; font-weight: 600; color: #dc5252;">
          It is NOT RECOMMENDED to use this product without visual verification.
        </p>
      </div>
    ` : ''}

    <div style="display: flex; gap: 12px; justify-content: flex-end;">
      <button type="button" class="confirmCancel" style="
        padding: 12px 24px;
        background: #301424;
        border: 1px solid #4c2138;
        border-radius: 8px;
        color: #fff;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.2s;
      ">Cancel</button>
      <button type="button" class="confirmApply" style="
        padding: 12px 24px;
        background: ${hasImage ? '#4c5ad4' : '#dc5252'};
        border: 1px solid ${hasImage ? '#6b7ce6' : '#ef6f6f'};
        border-radius: 8px;
        color: #fff;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      ">${hasImage ? 'Confirm & Apply' : 'Use Anyway (Not Recommended)'}</button>
    </div>
  `;

  modal.appendChild(modalContent);
  document.body.appendChild(modal);

  // Add hover effects
  const confirmBtn = modalContent.querySelector('.confirmApply');
  const cancelBtn = modalContent.querySelector('.confirmCancel');
  const verifyCheckboxes = modalContent.querySelectorAll('.verifyCheckbox');

  // Disable confirm button initially if there are verification checkboxes
  if(verifyCheckboxes.length > 0 && hasImage){
    confirmBtn.disabled = true;
    confirmBtn.style.opacity = '0.5';
    confirmBtn.style.cursor = 'not-allowed';
  }

  // Enable/disable confirm button based on checkboxes
  const updateConfirmButton = () => {
    if(verifyCheckboxes.length === 0 || !hasImage){
      return; // No checkboxes or no image, always enabled
    }
    const allChecked = Array.from(verifyCheckboxes).every(cb => cb.checked);
    confirmBtn.disabled = !allChecked;
    confirmBtn.style.opacity = allChecked ? '1' : '0.5';
    confirmBtn.style.cursor = allChecked ? 'pointer' : 'not-allowed';
  };

  verifyCheckboxes.forEach(cb => {
    cb.addEventListener('change', updateConfirmButton);
  });

  confirmBtn.addEventListener('mouseenter', () => {
    if(!confirmBtn.disabled){
      confirmBtn.style.transform = 'translateY(-2px)';
      confirmBtn.style.boxShadow = '0 4px 12px rgba(76,90,212,0.4)';
    }
  });
  confirmBtn.addEventListener('mouseleave', () => {
    confirmBtn.style.transform = 'translateY(0)';
    confirmBtn.style.boxShadow = 'none';
  });

  cancelBtn.addEventListener('mouseenter', () => {
    cancelBtn.style.background = '#3d1a2e';
  });
  cancelBtn.addEventListener('mouseleave', () => {
    cancelBtn.style.background = '#301424';
  });

  // Handle confirm
  confirmBtn.addEventListener('click', () => {
    if(confirmBtn.disabled) return;
    document.body.removeChild(modal);
    onConfirm();
  });

  // Handle cancel
  const handleCancel = () => {
    document.body.removeChild(modal);
    aiAssistSetStatus('Brand not applied. Verification required for safety.', 'warn');
  };

  cancelBtn.addEventListener('click', handleCancel);
  modal.addEventListener('click', (e) => {
    if(e.target === modal) handleCancel();
  });
}

function applyBrandSuggestionConfirmed(rowIdx, suggestion){

  const row=aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"]`);
  if(!row) return;

  // Get existing brands array
  let brands = [];
  if(row.dataset.brands){
    try{
      brands = JSON.parse(row.dataset.brands);
    }catch(_){}
  }

  // Add new brand to the array
  const newBrand = {
    name: suggestion.brand || suggestion.name || 'Brand',
    brandImage: suggestion.image || '',
    ingredientsImage: suggestion.ingredientsImage || '',
    ingredientsList: Array.isArray(suggestion.ingredientsList) ? suggestion.ingredientsList : [],
    allergens: Array.isArray(suggestion.allergens) ? suggestion.allergens : [],
    diets: Array.isArray(suggestion.diets) ? suggestion.diets : []
  };
  console.log('Adding brand:', newBrand);
  brands.push(newBrand);

  // IMPORTANT: Update the DOM row's dataset BEFORE calling collectAiTableData
  // This ensures the brands data is available when we collect and re-render
  row.dataset.brands = JSON.stringify(brands);
  console.log('Updated row.dataset.brands:', row.dataset.brands);

  // Collect all AI-detected allergens and diets from all brands
  const aiDetectedAllergens = new Set();
  const aiDetectedDiets = new Set();
  brands.forEach(brand => {
    if(Array.isArray(brand.allergens)){
      brand.allergens.forEach(a => aiDetectedAllergens.add(norm(a)));
    }
    if(Array.isArray(brand.diets)){
      brand.diets.forEach(d => aiDetectedDiets.add(d));
    }
  });

  // Update allergen checkboxes and add green styling
  row.querySelectorAll('.aiAllergenChecklist label').forEach(label=>{
    const input = label.querySelector('input');
    if(!input) return;
    const allergen = input.value;
    if(aiDetectedAllergens.has(norm(allergen))){
      input.checked = true;
      label.classList.add('aiDetected');
    }
  });

  // Update dietary preference checkboxes and add green styling
  row.querySelectorAll('.aiDietChecklist label').forEach(label=>{
    const input = label.querySelector('input');
    if(!input) return;
    const diet = input.value;
    if(aiDetectedDiets.has(diet)){
      input.checked = true;
      label.classList.add('aiDetected');
    }
  });

  // Force a re-render to ensure green styling persists
  // The brands are now in row.dataset.brands, so they should be picked up
  const allData = collectAiTableData();
  // Reset confirmed state for this row since allergens/diets may have changed
  if(allData[rowIdx]){
    allData[rowIdx].confirmed = false;
  }
  renderAiTable(allData);

  // Close the inline brand results
  const rowBrandResults=aiAssistTableBody?.querySelector(`tr[data-index="${rowIdx}"] .aiRowBrandResults`);
  if(rowBrandResults){
    rowBrandResults.classList.remove('show');
    rowBrandResults.innerHTML='';
  }

  // Also close the old global results if present
  if(aiAssistBrandResults){
    aiAssistBrandResults.classList.remove('show');
    aiAssistBrandResults.innerHTML='';
  }
  aiAssistSetStatus('Brand applied. Please review allergens carefully.','warn');
}

async function requestAiExtraction(payload){
  const endpoint=state.aiAssistEndpoint || window.__CLE_AI_ENDPOINT__ || null;
  if(endpoint){
    const res=await fetch(endpoint,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    if(!res.ok){
      const text=await res.text().catch(()=>res.statusText);
      throw new Error(text||'AI endpoint returned an error');
    }
    return await res.json();
  }

  // Use proxy to avoid CORS issues
  try {
    const response = await fetch('/api/ai-proxy', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        functionName: 'ai-ingredient-assistant',
        payload: payload
      })
    });

    if(!response.ok){
      const text = await response.text().catch(() => response.statusText);
      throw new Error(text || 'AI proxy returned an error');
    }

    const data = await response.json();
    return data;
  } catch(err) {
    console.error('AI extraction via proxy failed:', err);
    // Provide more specific error message
    if(err.message && err.message.includes('JSON')) {
      throw new Error('Invalid response from AI service. Please try again.');
    }
    throw err; // Throw original error with its message
  }
}

async function handleRecipePhotoUpload(file){
  ensureAiAssistElements();
  try{
    const reader = new FileReader();
    reader.onload = async (e) => {
      const imageData = e.target.result;
      aiAssistSetStatus('Reading recipe from photo using AI...');

      // Get dish name from input field if available
      const nameInput = document.getElementById('aiAssistNameInput');
      const dishNameForAi = nameInput?.value?.trim() || (aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '');

      const payload = {
        imageData: imageData,
        imageFileName: file.name,
        text: 'Please extract all ingredients from this recipe image.',
        dishName: dishNameForAi
      };

      try{
        const result = await requestAiExtraction(payload);

        // Store dietary options if provided by AI
        const dishDietaryOptions = (result?.dietaryOptions && Array.isArray(result.dietaryOptions)) ? result.dietaryOptions : [];
        if (dishDietaryOptions.length > 0) {
          aiAssistState.detectedDietaryOptions = dishDietaryOptions;
        }

        // Map ingredients and add dish-level dietary options to each ingredient
        const rows = Array.isArray(result?.ingredients) ? result.ingredients.map(ing => ({
          ...ing,
          name: ing.name ? ing.name.toLowerCase() : ing.name,
          // Add dish-level dietary options to each ingredient
          diets: dishDietaryOptions
        })) : [];

        renderAiTable(rows);

        // Show dietary options in status if detected
        let statusMessage = rows.length ? 'Extracted ingredients from recipe photo. Review before applying.' : 'Could not extract ingredients from recipe photo.';
        if (dishDietaryOptions.length > 0) {
          statusMessage += ` Detected dietary options: ${dishDietaryOptions.join(', ')}.`;
        }

        aiAssistSetStatus(statusMessage, rows.length ? 'info' : 'warn');
      }catch(err){
        console.error('Recipe photo extraction failed', err);
        aiAssistSetStatus('Failed to read recipe photo: ' + (err.message || err), 'error');
      }
    };
    reader.readAsDataURL(file);
  }catch(err){
    console.error('Recipe photo upload failed', err);
    aiAssistSetStatus('Failed to upload recipe photo: ' + (err.message || err), 'error');
  }
}

function renderPhotoPreviews(){
  const container = document.getElementById('aiAssistPhotosContainer');
  const photosList = document.getElementById('aiAssistPhotosList');
  if(!container || !photosList) return;

  if(!window.aiAssistPhotos || window.aiAssistPhotos.length === 0){
    container.style.display = 'none';
    return;
  }

  container.style.display = 'block';
  photosList.innerHTML = '';

  window.aiAssistPhotos.forEach((photoData, idx) => {
    const photoDiv = document.createElement('div');
    photoDiv.style.cssText = 'position:relative;width:100px;height:100px;border:1px solid rgba(76,90,212,0.3);border-radius:4px;overflow:hidden;';
    photoDiv.innerHTML = `
      <img src="${photoData}" style="width:100%;height:100%;object-fit:cover;cursor:pointer;" onclick="openImageModal('${photoData}')" alt="Recipe photo ${idx + 1}">
      <button type="button" onclick="removePhotoAtIndex(${idx})" style="position:absolute;top:4px;right:4px;background:rgba(0,0,0,0.7);color:white;border:none;border-radius:50%;width:24px;height:24px;cursor:pointer;font-size:16px;line-height:1;">×</button>
    `;
    photosList.appendChild(photoDiv);
  });
}

// Compress image to reduce payload size
function compressImage(dataUrl, maxWidth = 1200, quality = 0.8) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let width = img.width;
      let height = img.height;

      // Calculate new dimensions while maintaining aspect ratio
      if (width > maxWidth) {
        height = (height * maxWidth) / width;
        width = maxWidth;
      }

      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);

      // Convert to JPEG with quality compression
      resolve(canvas.toDataURL('image/jpeg', quality));
    };
    img.src = dataUrl;
  });
}

async function handleMultipleRecipePhotoUpload(files){
  ensureAiAssistElements();
  if(!window.aiAssistPhotos) window.aiAssistPhotos = [];

  for(let i = 0; i < files.length; i++){
    const file = files[i];
    try{
      const reader = new FileReader();
      reader.onload = async (e) => {
        // Compress image before storing
        const compressed = await compressImage(e.target.result);
        window.aiAssistPhotos.push(compressed);
        renderPhotoPreviews();
      };
      reader.readAsDataURL(file);
    }catch(err){
      console.error('Failed to read file', err);
    }
  }
}

function removePhotoAtIndex(idx){
  if(window.aiAssistPhotos && idx >= 0 && idx < window.aiAssistPhotos.length){
    window.aiAssistPhotos.splice(idx, 1);
    renderPhotoPreviews();
  }
}

async function handleRecipePhotoCamera(){
  ensureAiAssistElements();
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    aiAssistState.mediaStream = stream;
    if(aiAssistVideo){
      aiAssistVideo.srcObject = stream;
      aiAssistVideo.play();
    }
    updateAiAssistMediaPreview();
    aiAssistSetStatus('Position recipe in view and click Capture photo');
  }catch(err){
    console.error('Camera access failed', err);
    aiAssistSetStatus('Could not access camera: ' + (err.message || err), 'error');
  }
}

// Helper function to check if ingredient is duplicate
function isDuplicateIngredient(newIngredient, existingData) {
  const newName = (newIngredient.name || '').toLowerCase().trim();
  if (!newName) return false;

  return existingData.some(existing => {
    const existingName = (existing.name || '').toLowerCase().trim();
    return existingName === newName;
  });
}

// Helper function to merge new ingredients with existing ones, avoiding duplicates
function mergeIngredientsWithoutDuplicates(existingData, newRows) {
  const merged = [...existingData];
  let duplicateCount = 0;

  newRows.forEach(newRow => {
    if (!isDuplicateIngredient(newRow, merged)) {
      merged.push(newRow);
    } else {
      duplicateCount++;
    }
  });

  return { merged, duplicateCount };
}

async function handleAiProcess(){
  ensureAiAssistElements();
  if(!aiAssistInput) return;
  const text=aiAssistInput.value.trim();
  const hasPhotos = window.aiAssistPhotos && window.aiAssistPhotos.length > 0;
  if(!text && !hasPhotos){
    aiAssistSetStatus('Describe the dish or add recipe photos before processing.','warn');
    return;
  }

  // If we have photos, process them
  if(hasPhotos){
    aiAssistSetStatus('Processing ' + window.aiAssistPhotos.length + ' recipe photo(s) using AI...');

    // Show progress bar
    const progressBar = document.getElementById('aiProgressBar');
    const progressBarFill = document.getElementById('aiProgressBarFill');
    if (progressBar && progressBarFill) {
      progressBar.classList.add('show');
      progressBarFill.style.width = '20%';
    }

    // Get dish name from input field if available
    const nameInput = document.getElementById('aiAssistNameInput');
    const dishNameForAi = nameInput?.value?.trim() || (aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '');

    for(let i = 0; i < window.aiAssistPhotos.length; i++){
      const photoData = window.aiAssistPhotos[i];
      const payload = {
        imageData: photoData,
        imageFileName: `recipe_${i+1}.jpg`,
        text: text || 'Please extract all ingredients from this recipe image.',
        dishName: dishNameForAi
      };

      // Update progress for current photo
      if (progressBarFill) {
        const progress = 20 + ((i / window.aiAssistPhotos.length) * 70);
        progressBarFill.style.width = progress + '%';
      }

      try{
        const result = await requestAiExtraction(payload);

        // Get dietary options from AI
        const dishDietaryOptions = (result?.dietaryOptions && Array.isArray(result.dietaryOptions)) ? result.dietaryOptions : [];

        // Add dietary options to each ingredient
        const rows = Array.isArray(result?.ingredients) ? result.ingredients.map(ing => ({
          ...ing,
          diets: dishDietaryOptions
        })) : [];

        if(rows.length > 0){
          // Merge with existing data, avoiding duplicates
          const existingData = collectAiTableData();
          const { merged, duplicateCount } = mergeIngredientsWithoutDuplicates(existingData, rows);
          renderAiTable(merged);

          let statusMsg = `Photo ${i+1}/${window.aiAssistPhotos.length} processed.`;
          if (duplicateCount > 0) {
            statusMsg += ` ${duplicateCount} duplicate${duplicateCount > 1 ? 's' : ''} skipped.`;
          }
          if (dishDietaryOptions.length > 0) {
            statusMsg += ` Detected: ${dishDietaryOptions.join(', ')}.`;
          }
          statusMsg += ' Review ingredients before applying.';
          aiAssistSetStatus(statusMsg, 'info');
        }
      }catch(err){
        console.error('Recipe photo extraction failed', err);
        aiAssistSetStatus(`Failed to read recipe photo ${i+1}: ` + (err.message || err), 'error');
      }
    }

    // Complete progress bar
    if (progressBarFill) progressBarFill.style.width = '100%';
    setTimeout(() => {
      if (progressBar) progressBar.classList.remove('show');
      if (progressBarFill) progressBarFill.style.width = '0%';
    }, 300);

    return;
  }

  // Otherwise process text
  aiAssistSetStatus('Preparing to analyze description…');
  // Get dish name from input field if available, otherwise use getCurrentName
  const nameInput = document.getElementById('aiAssistNameInput');
  const dishNameForAi = nameInput?.value?.trim() || (aiAssistState.context?.getCurrentName ? aiAssistState.context.getCurrentName() : '');
  const payload={
    text,
    dishName: dishNameForAi
  };
  if(window!==window.parent){
    const requestId=`ai-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    aiAssistState.pendingRequestId=requestId;
    parent.postMessage({
      type:'aiAssistExtract',
      requestId,
      ...payload
    },"*");
  } else {
    // Show progress bar
    const progressBar = document.getElementById('aiProgressBar');
    const progressBarFill = document.getElementById('aiProgressBarFill');
    if (progressBar && progressBarFill) {
      progressBar.classList.add('show');
      progressBarFill.style.width = '10%';
    }

    (async()=>{
      try{
        // Gradual progress updates to show activity
        aiAssistSetStatus('Sending to AI for analysis…');
        if (progressBarFill) progressBarFill.style.width = '20%';
        await new Promise(resolve => setTimeout(resolve, 100));
        if (progressBarFill) progressBarFill.style.width = '30%';

        const result=await requestAiExtraction(payload);

        // Update progress after AI call
        aiAssistSetStatus('Analyzing ingredients…');
        if (progressBarFill) progressBarFill.style.width = '80%';
        await new Promise(resolve => setTimeout(resolve, 100));

        const rows=Array.isArray(result?.ingredients)?result.ingredients:[];

        // Clean up ingredient names - remove extra text like "(optional)", "(garnish)", etc.
        rows.forEach(row => {
          if(row.name){
            // Remove text in parentheses and trim
            row.name = row.name.replace(/\s*\([^)]*\)\s*/g, '').trim();
            // Remove common prefixes/suffixes
            row.name = row.name.replace(/\s*(optional|garnish|topping|for serving|for garnish)\s*$/gi, '').trim();
          }
        });

        // NOTE: Brands from memory are now shown as thumbnails with + buttons
        // in the renderAiTable function, rather than auto-populating.
        // This gives users control over whether to use remembered brands.

        // Merge with existing data, avoiding duplicates
        const existingData = collectAiTableData();
        const { merged, duplicateCount } = mergeIngredientsWithoutDuplicates(existingData, rows);
        renderAiTable(merged);

        let statusMsg = rows.length ? 'AI ingredient suggestions ready. Review before applying.' : 'AI could not extract ingredients from the description.';
        if (duplicateCount > 0) {
          statusMsg += ` (${duplicateCount} duplicate${duplicateCount > 1 ? 's' : ''} skipped)`;
        }
        aiAssistSetStatus(statusMsg, 'info');

        // Complete progress bar
        if (progressBarFill) progressBarFill.style.width = '100%';
        setTimeout(() => {
          if (progressBar) progressBar.classList.remove('show');
          if (progressBarFill) progressBarFill.style.width = '0%';
        }, 300);

      }catch(err){
        console.error('AI extraction failed',err);

        // Hide progress bar on error
        if (progressBar) progressBar.classList.remove('show');
        if (progressBarFill) progressBarFill.style.width = '0%';

        if(text){
          const ingredients=heuristicallyExtractIngredients(text);
          // Also check for duplicates in fallback
          const existingData = collectAiTableData();
          const { merged, duplicateCount } = mergeIngredientsWithoutDuplicates(existingData, ingredients);
          renderAiTable(merged);

          let statusMsg = 'AI service unavailable—generated a draft using local parsing. Review before applying.';
          if (duplicateCount > 0) {
            statusMsg += ` (${duplicateCount} duplicate${duplicateCount > 1 ? 's' : ''} skipped)`;
          }
          aiAssistSetStatus(statusMsg, 'warn');
        } else {
          aiAssistSetStatus('AI assistant request failed: '+(err.message||err),'warn');
        }
      }
    })();
  }
}

function handleAiAssistantResult(payload){
  ensureAiAssistElements();
  if(!payload || payload.requestId!==aiAssistState.pendingRequestId) return;
  aiAssistState.pendingRequestId=null;
  const rows=Array.isArray(payload.ingredients)?payload.ingredients:[];

  // Clean up ingredient names - remove extra text like "(optional)", "(garnish)", etc.
  rows.forEach(row => {
    if(row.name){
      // Remove text in parentheses and trim
      row.name = row.name.replace(/\s*\([^)]*\)\s*/g, '').trim();
      // Remove common prefixes/suffixes
      row.name = row.name.replace(/\s*(optional|garnish|topping|for serving|for garnish)\s*$/gi, '').trim();
    }
  });

  // NOTE: Brands from memory are now shown as thumbnails with + buttons
  // in the renderAiTable function, rather than auto-populating.
  // This gives users control over whether to use remembered brands.

  // NOTE: Do NOT call rememberBrand here - brands should only be saved when dish is saved to server
  renderAiTable(rows);
  aiAssistSetStatus(rows.length?'AI ingredient suggestions ready. Review before applying.':'AI could not extract ingredients from the description.','info');
}

function handleAiAssistantError(payload){
  ensureAiAssistElements();
  if(!payload || payload.requestId!==aiAssistState.pendingRequestId) return;
  aiAssistState.pendingRequestId=null;
  aiAssistSetStatus(payload.error || 'AI assistant request failed.', 'warn');
}

function applyAiIngredientsToOverlay(){
  console.log('applyAiIngredientsToOverlay called');
  ensureAiAssistElements();
  const rows=collectAiTableData();

  // Hide any previous save error
  const saveErrorEl = document.getElementById('aiAssistSaveError');
  const saveErrorDetailsEl = document.getElementById('aiAssistSaveErrorDetails');
  if(saveErrorEl) saveErrorEl.style.display = 'none';

  if(!rows.length){
    console.log('No rows to apply');
    aiAssistSetStatus('Add at least one ingredient before applying.','warn');
    return;
  }

  // Check if all ingredients are confirmed
  const unconfirmed = rows.filter(item => item.name.trim() && !item.confirmed);
  if(unconfirmed.length > 0){
    const ingredientNames = unconfirmed.map(item => item.name).join(', ');
    console.log('Unconfirmed ingredients:', ingredientNames);

    // Show error at bottom near Save to Dish button
    if(saveErrorEl && saveErrorDetailsEl){
      saveErrorDetailsEl.textContent = `Please click "Confirm" for: ${ingredientNames}`;
      saveErrorEl.style.display = 'block';
      saveErrorEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    return;
  }

  // Validate cross-contamination selection
  const noCrossCheckbox = document.getElementById('aiAssistNoCrossContamination');
  const crossAllergenCheckboxes = document.querySelectorAll('.aiCrossAllergenCheckbox');
  const crossErrorEl = document.getElementById('aiAssistCrossContaminationError');

  console.log('Found cross-contamination elements:', {
    noCrossCheckbox,
    crossAllergenCheckboxesCount: crossAllergenCheckboxes.length
  });

  const noCrossChecked = noCrossCheckbox && noCrossCheckbox.checked;
  const anyAllergenChecked = Array.from(crossAllergenCheckboxes || []).some(cb => cb.checked);

  console.log('Cross-contamination checkbox states:');
  crossAllergenCheckboxes.forEach(cb => {
    console.log(`  ${cb.dataset.allergen}: checked=${cb.checked}`);
  });

  console.log('Cross-contamination validation:', {noCrossChecked, anyAllergenChecked});

  if(!noCrossChecked && !anyAllergenChecked){
    console.log('Cross-contamination validation failed');
    if(crossErrorEl){
      crossErrorEl.style.display = 'block';
      crossErrorEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    return;
  }

  // NOTE: Brands are NOT saved to memory here - they will only be saved to memory
  // when the overlay is actually saved to the server (not just applied to the dish)

  // Collect cross-contamination data
  const crossContaminationData = {
    noCrossContamination: noCrossCheckbox && noCrossCheckbox.checked,
    allergens: []
  };

  console.log('Collecting cross-contamination data...');
  if(!crossContaminationData.noCrossContamination){
    Array.from(crossAllergenCheckboxes || []).forEach(cb => {
      console.log(`  Checking ${cb.dataset.allergen}: checked=${cb.checked}`);
      if(cb.checked){
        console.log(`    -> Adding ${cb.dataset.allergen} to allergens array`);
        crossContaminationData.allergens.push(cb.dataset.allergen);
      }
    });
  } else {
    console.log('  noCrossContamination is checked, skipping allergen collection');
  }

  console.log('Cross-contamination data collected:', crossContaminationData);

  // Mark as saved
  aiAssistState.savedToDish = true;

  console.log('aiAssistState.context?.onApply exists?', !!aiAssistState.context?.onApply);

  if(aiAssistState.context?.onApply){
    // Pass ingredients, dietary options, and cross-contamination data to the overlay
    const dataToApply = {
      ingredients: rows,
      dietaryOptions: aiAssistState.detectedDietaryOptions || [],
      crossContamination: crossContaminationData
    };
    console.log('Calling onApply with:', {rowCount: rows.length, dataToApply});
    aiAssistState.context.onApply(rows, dataToApply);
  } else {
    console.error('No onApply callback found!');
  }
  closeAiAssistant();
  aiAssistSetStatus('');
}

const daysAgo=d=>{
  try{
    const x=new Date(d);
    if(isNaN(x)) return '—';
    const now=new Date();
    
    // Reset both dates to midnight for accurate day comparison
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const compareDate = new Date(x.getFullYear(), x.getMonth(), x.getDate());
    
    const diff=Math.floor((today-compareDate)/(1000*60*60*24));
    
    if(diff===0) return 'today';
    if(diff===1) return '1 day ago';
    if(diff<0) return 'today'; // Future date edge case
    return diff+' days ago';
  }catch(_){return '—';}
};
function div(html,cls){const d=document.createElement('div'); if(cls)d.className=cls; d.innerHTML=html; return d;}

function normalizeRestaurant(row){
  if(!row) return null;
  const id = row._id ?? row.id;
  const menuImage = row.menuImage ?? row.menu_image;
  const lastConfirmed = row.lastConfirmed ?? row.last_confirmed;
  const overlays = Array.isArray(row.overlays) ? row.overlays : [];
  return {
    _id: id,
    name: row.name,
    slug: row.slug,
    menuImage,
    lastConfirmed,
    overlays
  };
}

function configureModalClose({visible=true,onClick=null}={}){
  const closeBtn=document.getElementById('modalCloseBtn');
  if(closeBtn){
    closeBtn.style.display=visible?'inline-flex':'none';
    closeBtn.onclick=onClick || null;
  }
}

async function insertChangeLogEntry(base){
  const client=window.supabaseClient;
  if(!client) throw new Error('Supabase client not ready.');
  const payload={
    restaurant_id: base.restaurantId,
    type: base.type,
    description: base.description,
    changes: base.changes,
    user_email: base.userEmail || null,
    photos: Array.isArray(base.photos) ? base.photos : (base.photos ? [base.photos] : []),
    overlays: base.overlays || null,
    timestamp: base.timestamp || new Date().toISOString()
  };
  Object.keys(payload).forEach(k=>payload[k]==null&&delete payload[k]);
  const { error } = await client.from('change_logs').insert([payload]);
  if(error) throw error;
  return true;
}

async function fetchChangeLogEntries(restaurantId){
  const client=window.supabaseClient;
  if(!client) throw new Error('Supabase client not ready.');
  let query=client.from('change_logs').select('*').order('timestamp',{ascending:false}).limit(50);
  if(restaurantId){
    query=query.eq('restaurant_id',restaurantId);
  }
  const {data,error}=await query;
  if(error) throw error;
  return data||[];
}
/* risk + tooltip */
function computeStatus(item,sel,userDiets){
  const hasAllergenReqs = sel && sel.length > 0;
  const hasDietReqs = userDiets && userDiets.length > 0;

  if(!hasAllergenReqs && !hasDietReqs) return 'neutral';

  // Check allergen requirements
  const allergenHits=(item.allergens||[]).filter(a=>sel.includes(a));
  const hasAllergenIssues = allergenHits.length > 0;
  const allergenRemovableAll = hasAllergenIssues ? allergenHits.every(a=>(item.removable||[]).some(r=>r.allergen===a)) : true;

  // Check dietary requirements
  const itemDiets = new Set(item.diets || []);
  const meetsDietReqs = !hasDietReqs || userDiets.every(diet => itemDiets.has(diet));

  // If doesn't meet dietary requirements, it's unsafe
  if(!meetsDietReqs) return 'unsafe';

  // If has allergen issues that can't be removed, it's unsafe
  if(hasAllergenIssues && !allergenRemovableAll) return 'unsafe';

  // If has removable allergen issues, it's removable
  if(hasAllergenIssues && allergenRemovableAll) return 'removable';

  // Otherwise it's safe
  return 'safe';
}

function hasCrossContamination(item,sel){
  if(!sel||!sel.length) return false;
  const crossContam=(item.crossContamination||[]);
  return crossContam.some(a=>sel.includes(a));
}

/* scale-aware tooltip */
function currentScale(){
  try{ return (window.visualViewport && window.visualViewport.scale) ? window.visualViewport.scale : 1; }
  catch(_){ return 1; }
}
function tooltipBodyHTML(item,sel,userDiets){
  const status=computeStatus(item,sel,userDiets);
  const details=item.details||{};
  const hasCross=hasCrossContamination(item,sel);

  if(!sel.length && (!userDiets || !userDiets.length)) return `<div class="note">No dietary preferences saved. Sign in to save your preferences.</div>`;

  let html='';

  // Build allergen section first
  if(sel.length){
    html+=`<strong style="display:block;margin-bottom:8px;color:var(--ink)">Allergen Information</strong>`;
    const hits=(item.allergens||[]).filter(a=>sel.includes(a));
    const removableSet=new Set((item.removable||[]).map(r=>norm(r.allergen||'')));

    const unsafeHits=hits.filter(a=>!removableSet.has(norm(a)));
    const removableHits=hits.filter(a=>removableSet.has(norm(a)));

    if(unsafeHits.length){
      const list=unsafeHits.map(a=>{
        const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '⚠️';
        return `<div style="margin-bottom:4px">${emoji} Contains <strong>${esc(a.toLowerCase())}</strong> (cannot be substituted out)</div>`;
      }).join('');
      html+=`<div class="note tooltipDangerText">${list}</div>`;
    }
    if(removableHits.length){
      const list=removableHits.map(a=>{
        const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '⚠️';
        return `<div style="margin-bottom:4px">${emoji} Contains <strong>${esc(a.toLowerCase())}</strong> (can be substituted out)</div>`;
      }).join('');
      html+=`<div class="note tooltipWarnText">${list}</div>`;
    }
    if(!hits.length && !hasCross){
      html+=`<div class="note tooltipNeutralText">None of your selected allergens found.</div>`;
    }

    // Ingredients list removed per user request - not needed in tooltip
  }

  // Display dietary preferences section - show status for each user preference
  const hasUserDiets = userDiets && userDiets.length > 0;

  if(hasUserDiets){
    html+=`<div class="note" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(76,90,212,0.2)"><strong style="display:block;margin-bottom:8px;color:var(--ink)">Dietary Preferences</strong>`;

    const itemDietSet = new Set(item.diets || []);
    const removableAllergens = new Set((item.removable || []).map(r => norm(r.allergen)));

    // Define which allergens conflict with each diet
    const allergenConflicts = {
      'Vegan': ['dairy', 'egg', 'fish', 'shellfish'],
      'Vegetarian': ['fish', 'shellfish'],
      'Pescatarian': []
    };

    userDiets.forEach(userDiet => {
      const isDietMet = itemDietSet.has(userDiet);
      const emoji = {
        'Vegan': '🌱',
        'Vegetarian': '🥬',
        'Pescatarian': '🐟',
      }[userDiet] || '✓';
      const dietLower = userDiet.toLowerCase();

      if(isDietMet){
        // Diet is met - show green
        html+=`<div style="margin-bottom:6px;color:#4cc85a;font-size:0.9rem">${emoji} This dish is <strong>${esc(dietLower)}</strong></div>`;
      } else {
        // Diet is not met - check if it can be made to meet the diet
        const conflicts = allergenConflicts[userDiet] || [];
        const itemAllergens = item.allergens || [];
        const conflictingAllergens = conflicts.filter(allergen => itemAllergens.includes(allergen));

        // Check if ALL conflicting allergens are removable
        const canBeMade = conflictingAllergens.length > 0 &&
                          conflictingAllergens.every(allergen => removableAllergens.has(allergen));

        if(canBeMade){
          // All conflicting allergens can be substituted out - show yellow (same as allergen warning color)
          html+=`<div style="margin-bottom:6px;color:#facc15;font-size:0.9rem">${emoji} This dish can be made <strong>${esc(dietLower)}</strong></div>`;
        } else {
          // Cannot be made to meet the diet - show red
          html+=`<div style="margin-bottom:6px;color:#e85d5d;font-size:0.9rem">${emoji} This dish is not <strong>${esc(dietLower)}</strong></div>`;
        }
      }
    });

    html+=`</div>`;
  }

  // Add cross-contamination risk at the bottom with yellow warning icon
  if(hasCross && sel.length){
    const crossHits=(item.crossContamination||[]).filter(a=>sel.includes(a));
    if(crossHits.length > 0){
      const crossList=crossHits.map(a=>{
        const emoji = ALLERGEN_EMOJI[a.toLowerCase()] || '';
        return `${emoji} <strong>${esc(a.toLowerCase())}</strong>`;
      }).join(', ');
      html+=`<div class="note" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(76,90,212,0.2)">`;
      html+=`<div style="display:flex;align-items:flex-start;gap:8px;color:#facc15;font-size:0.9rem">`;
      html+=`<span style="font-size:1.2rem;flex-shrink:0;">⚠️</span>`;
      html+=`<div>Cross-contamination risk: ${crossList}</div>`;
      html+=`</div></div>`;
    }
  }

  return html;
}

function renderTopbar(){
  const el=document.getElementById('topbar'); el.innerHTML='';
  const isQrExperience=!!(state.qr||urlQR);
  document.body.classList.toggle('qrMode',isQrExperience);
  const brand=div(`<img src="https://static.wixstatic.com/media/945e9d_2b97098295d341d493e4a07d80d6b57c~mv2.png" alt=""><span>Clarivore</span>`,'brand');
  brand.onclick=()=>window.location.href='restaurants.html';
  brand.style.cursor='pointer';
  el.appendChild(brand);
  if(!isQrExperience){
    const navWrap=div('','topNav');
    const tabs=div('','tabs');
    const navItems=[
      {t:'All restaurants',to:'/restaurants'}
    ];
    if(state.user?.loggedIn){
      navItems.push({t:'Favorite restaurants',to:'/favorites'});
    }
    navItems.forEach(n=>{
      const b=div(n.t,'tab');
      b.onclick=()=>{
        if(n.external){
          window.location.href=n.to+'.html';
        } else {
          send({type:'navigate',to:n.to});
        }
      };
      tabs.appendChild(b);
    });
    navWrap.appendChild(tabs);
    const acct=div(state.user?.loggedIn?'Account settings':'Sign in','acctBtn');
    acct.onclick=()=>{
      if(state.user?.loggedIn){
        send({type:'navigate',to:'/accounts'});
      } else {
        requestSignIn();
      }
    };
    navWrap.appendChild(acct);
    el.appendChild(navWrap);
  }
}

/* tooltips */
const pageTip=document.getElementById('tip');
function prefersMobileInfo(){
  try{
    const hasCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
    const hasFine = window.matchMedia && window.matchMedia('(pointer: fine)').matches;
    if(hasCoarse) return true;
    if(hasFine) return false;
    return window.innerWidth <= 640;
  }catch(_){
    return window.innerWidth <= 640;
  }
}
function renderMobileInfo(item){
  ensureMobileInfoPanel();
  if(!mobileInfoPanel) return;
  mobileInfoPanel.style.position='fixed';
  mobileInfoPanel.style.left='12px';
  mobileInfoPanel.style.right='12px';
  mobileInfoPanel.style.bottom='12px';
  mobileInfoPanel.style.zIndex='3500';
  if(!prefersMobileInfo()){
    mobileInfoPanel.classList.remove('show');
    mobileInfoPanel.style.display='none';
    mobileInfoPanel.innerHTML='';
    currentMobileInfoItem=null;
    return;
  }
  if(!item){
    currentMobileInfoItem=null;
    mobileInfoPanel.innerHTML='';
    mobileInfoPanel.style.display='none';
    mobileInfoPanel.classList.remove('show');
    return;
  }
  currentMobileInfoItem=item;
  const bodyHTML=tooltipBodyHTML(item,state.allergies||[],state.diets||[]);
  mobileInfoPanel.innerHTML=`
    <div class="mobileInfoHeaderRow">
      <div class="mobileInfoHeader">${esc(item.id||'Item')}</div>
      <button type="button" class="mobileInfoClose" aria-label="Close dish details">×</button>
    </div>
    <div class="mobileInfoContent">
      ${bodyHTML}
    </div>
  `;
  mobileInfoPanel.style.background='rgba(11,16,32,0.94)';
  mobileInfoPanel.style.backdropFilter='blur(14px)';
  mobileInfoPanel.style.webkitBackdropFilter='blur(14px)';
  adjustMobileInfoPanelForZoom();
  mobileInfoPanel.style.display='block';
  mobileInfoPanel.classList.add('show');
  const closeBtn=mobileInfoPanel.querySelector('.mobileInfoClose');
  if(closeBtn){
    const closePanel=(ev)=>{
      if(ev){ev.preventDefault(); ev.stopPropagation();}
      renderMobileInfo(null);
    };
    closeBtn.addEventListener('click',closePanel);
    closeBtn.addEventListener('touchend',closePanel,{passive:false});
    closeBtn.addEventListener('keydown',(ev)=>{ if(ev.key==='Enter'||ev.key===' '){ closePanel(ev); }});
  }
}
function syncMobileInfoPanel(){
  if(!mobileInfoPanel) return;
  adjustMobileInfoPanelForZoom();
  if(prefersMobileInfo()){
    if(currentMobileInfoItem){
      renderMobileInfo(currentMobileInfoItem);
    } else {
      mobileInfoPanel.innerHTML='';
      mobileInfoPanel.style.display='none';
      mobileInfoPanel.classList.remove('show');
    }
    hideTip();
  } else {
    mobileInfoPanel.classList.remove('show');
    mobileInfoPanel.style.display='none';
    mobileInfoPanel.innerHTML='';
    currentMobileInfoItem=null;
  }
}
addEventListener('resize', ()=>syncMobileInfoPanel(), {passive:true});
if(window.visualViewport){
  visualViewport.addEventListener('resize', ()=>syncMobileInfoPanel(), {passive:true});
  visualViewport.addEventListener('scroll', ()=>syncMobileInfoPanel(), {passive:true});
}
ensureMobileInfoPanel();
function showTipIn(el, x, y, title, bodyHTML, anchorRect=null){
  const vv=window.visualViewport;
  const zoom = vv && vv.scale ? vv.scale : 1;
  const offsetLeft = vv && typeof vv.offsetLeft === 'number' ? vv.offsetLeft : 0;
  const offsetTop = vv && typeof vv.offsetTop === 'number' ? vv.offsetTop : 0;
  const viewportWidth = vv && vv.width ? vv.width : window.innerWidth;
  const viewportHeight = vv && vv.height ? vv.height : window.innerHeight;
  const scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft || 0;
  const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
  el.innerHTML = `
    <div class="tipHead">
      <div class="tTitle">${esc(title||'Item')}</div>
      <button class="tClose" type="button">✕</button>
    </div>
    ${bodyHTML}
  `;
  el.style.display = 'block';

  const isMobile = window.innerWidth <= 640;
  el.style.transform = '';
  el.style.transformOrigin = '';

  const layoutWidth = document.documentElement?.clientWidth || window.innerWidth;
  const baseMaxWidth = isMobile
    ? Math.min(280, Math.max(220, layoutWidth - 40))
    : Math.min(320, Math.max(240, layoutWidth - 80));
  el.style.maxWidth = baseMaxWidth + 'px';
  el.style.padding = isMobile ? '8px' : '10px';
  el.style.borderRadius = isMobile ? '8px' : '10px';
  el.style.fontSize = isMobile ? '12px' : '14px';
  
  const titleEl = el.querySelector('.tTitle');
  if(titleEl) titleEl.style.fontSize = isMobile ? '14px' : '16px';
  
  const closeEl = el.querySelector('.tClose');
  if(closeEl) {
    closeEl.style.padding = isMobile ? '3px 6px' : '4px 8px';
    closeEl.style.fontSize = isMobile ? '12px' : '14px';
    closeEl.style.borderRadius = isMobile ? '5px' : '6px';
  }

  const noteEls = el.querySelectorAll('.note');
  noteEls.forEach(n => n.style.fontSize = isMobile ? '11px' : '13px');

  requestAnimationFrame(() => {
    const r = el.getBoundingClientRect();
    const pad = isMobile ? 8 : 12;
    const visibleLeft = scrollX + offsetLeft;
    const visibleTop = scrollY + offsetTop;
    const visibleRight = visibleLeft + viewportWidth;
    const visibleBottom = visibleTop + viewportHeight;

    const useAnchor = !!anchorRect;

    const anchorLeft = anchorRect ? anchorRect.left + scrollX + offsetLeft : null;
    const anchorRight = anchorRect ? anchorRect.right + scrollX + offsetLeft : null;
    const anchorTop = anchorRect ? anchorRect.top + scrollY + offsetTop : null;
    const anchorBottom = anchorRect ? anchorRect.bottom + scrollY + offsetTop : null;
    const anchorCenterX = anchorRect ? (anchorLeft + anchorRight) / 2 : null;

    let left;
    let top;

    if(useAnchor){
      const offset = isMobile ? 12 : 16;
      left = (anchorCenterX || (visibleLeft + pad)) - (r.width/2);
      top = (anchorTop !== null ? anchorTop : (visibleTop + pad)) - r.height - offset;

      if (top < visibleTop + pad) {
        top = (anchorBottom !== null ? anchorBottom : (visibleTop + pad)) + offset;
      }
      if (top + r.height + pad > visibleBottom) {
        const anchorMiddle = anchorRect ? anchorTop + (anchorRect.height/2) : (visibleTop + viewportHeight/2);
        top = anchorMiddle - (r.height/2);
        if (top + r.height + pad > visibleBottom) {
          top = visibleBottom - r.height - pad;
        }
      }
    } else {
      const pointerX = (typeof x === 'number' ? x + scrollX + offsetLeft : (visibleLeft + viewportWidth/2));
      const pointerY = (typeof y === 'number' ? y + scrollY + offsetTop : (visibleTop + viewportHeight/2));
      left = pointerX + (isMobile ? 8 : 12);
      top = pointerY + (isMobile ? 8 : 12);
    }

    if (left + r.width + pad > visibleRight) {
      left = Math.max(visibleLeft + pad, visibleRight - r.width - pad);
    }
    if (top + r.height + pad > visibleBottom) {
      top = Math.max(visibleTop + pad, visibleBottom - r.height - pad);
    }
    
    left = Math.max(visibleLeft + pad, left);
    top = Math.max(visibleTop + pad, top);
    
    el.style.left = left + 'px';
    el.style.top  = top + 'px';
  });

  if(el.querySelector('.tClose')) {
    el.querySelector('.tClose').onclick = () => { el.style.display='none'; };
  }
}

function hideTip(){ pageTip.style.display='none'; }

/* list */
function renderCardsPage(){
  renderTopbar();
  const r=document.getElementById('root');
  r.innerHTML=`<h1 style="text-align:center">Restaurants</h1><div class="cards" id="grid"></div>`;
  const grid=document.getElementById('grid');
  (state.restaurants||[]).forEach(rs=>{
    const c=div(`<div class="card">
        <img src="${esc(rs.menuImage||'')}" alt="">
        <div class="pad">
          <div style="font-weight:800;margin-bottom:6px">${esc(rs.name||'Restaurant')}</div>
          <div class="note">Last confirmed by staff: ${rs.lastConfirmed?esc(daysAgo(rs.lastConfirmed)):'—'}</div>
          <div style="margin-top:10px"><button class="btn btnPrimary">View menu & allergens</button></div>
        </div></div>`);
    c.querySelector('.btn').onclick=()=>send({type:'openRestaurant',slug:rs.slug});
    grid.appendChild(c);
  });
}

/* chips */
function renderSavedChips(el){
  el.innerHTML='';
  const saved=(state.allergies||[]).map(norm);
  if(!saved.length){
    el.appendChild(div('<div class="note">No saved allergens. Use "Edit saved allergens".</div>'));
    updateFullScreenAllergySummary();
    return;
  }
  const row=div('','chips');
  saved.forEach(a=>{
    const emoji=ALLERGEN_EMOJI[a]||'🔴';
    row.appendChild(div(`${emoji} ${esc(cap(a))}`,'chip active'));
  });
  el.appendChild(row);
  updateFullScreenAllergySummary();
}

function renderSavedDiets(el){
  el.innerHTML='';
  const saved=(state.diets||[]);
  if(!saved.length){
    el.appendChild(div('<div class="note">No saved dietary preferences. Use "Edit saved dietary preferences".</div>'));
    return;
  }
  const row=div('','chips');
  saved.forEach(d=>{
    const emoji=d==='Vegan'?'🌱':d==='Vegetarian'?'🥬':d==='Pescatarian'?'🐟':'🍽️';
    row.appendChild(div(`${emoji} ${esc(d)}`,'chip active'));
  });
  el.appendChild(row);
}

/* selector for QR guests */
function renderSelector(el){
  el.innerHTML='';
  const row=div('','chips');
  row.setAttribute('role','list');
  const sel=new Set((state.allergies||[]).map(norm));
  ALLERGENS.forEach(a=>{
    const isActive=sel.has(a);
    const emoji=ALLERGEN_EMOJI[a]||'🔴';
    const c=div(`${emoji} ${esc(cap(a))}`,'chip clickable'+(isActive?' active':''));
    c.setAttribute('role','button');
    c.setAttribute('tabindex','0');
    c.setAttribute('aria-pressed',isActive?'true':'false');
    c.dataset.value=a;
    const toggle=()=>{
      if(sel.has(a)){
        sel.delete(a);
      } else {
        sel.add(a);
      }
      state.allergies=[...sel];
      updateFullScreenAllergySummary();
      try{sessionStorage.setItem('qrAllergies',JSON.stringify(state.allergies));}catch(_){}
      renderSelector(el);
      if(window.__rerenderLayer__) window.__rerenderLayer__();
      send({type:'qrAllergies',allergies:state.allergies});
      if(prefersMobileInfo()) renderMobileInfo(currentMobileInfoItem);
    };
    c.addEventListener('click',(evt)=>{
      evt.preventDefault();
      evt.stopPropagation();
      toggle();
    },{passive:false});
    c.addEventListener('touchend',(evt)=>{
      evt.preventDefault();
      evt.stopPropagation();
      toggle();
    },{passive:false});
    c.addEventListener('keydown',(evt)=>{
      if(evt.key==='Enter' || evt.key===' '){
        evt.preventDefault();
        toggle();
      }
    });
    row.appendChild(c);
  });
  el.appendChild(row);
  updateFullScreenAllergySummary();
}

function renderDietSelector(el){
  el.innerHTML='';
  const row=div('','chips');
  row.setAttribute('role','list');
  const sel=new Set(state.diets||[]);
  DIETS.forEach(diet=>{
    const isActive=sel.has(diet);
    const emoji=diet==='Vegan'?'🌱':diet==='Vegetarian'?'🥬':diet==='Pescatarian'?'🐟':'🍽️';
    const c=div(`${emoji} ${esc(diet)}`,'chip clickable'+(isActive?' active':''));
    c.setAttribute('role','button');
    c.setAttribute('tabindex','0');
    c.setAttribute('aria-pressed',isActive?'true':'false');
    c.dataset.value=diet;
    const toggle=()=>{
      if(sel.has(diet)){
        sel.delete(diet);
      } else {
        sel.add(diet);
      }
      state.diets=[...sel];
      try{sessionStorage.setItem('qrDiets',JSON.stringify(state.diets));}catch(_){}
      renderDietSelector(el);
      if(window.__rerenderLayer__) window.__rerenderLayer__();
      if(prefersMobileInfo()) renderMobileInfo(currentMobileInfoItem);
    };
    c.addEventListener('click',(evt)=>{
      evt.preventDefault();
      evt.stopPropagation();
      toggle();
    },{passive:false});
    c.addEventListener('touchend',(evt)=>{
      evt.preventDefault();
      evt.stopPropagation();
      toggle();
    },{passive:false});
    c.addEventListener('keydown',(evt)=>{
      if(evt.key==='Enter' || evt.key===' '){
        evt.preventDefault();
        toggle();
      }
    });
    row.appendChild(c);
  });
  el.appendChild(row);
}

/* draw (simple image that follows page zoom) */
function drawMenu(container,imageURL){
  container.innerHTML='';
  const inner=div('','menuInner'); container.appendChild(inner);
  if(!imageURL){ inner.innerHTML=`<div class="note" style="padding:16px">No menu image configured for this restaurant.</div>`; return; }

  const img=new Image(); img.src=imageURL; img.className='menuImg'; inner.appendChild(img);
  const layer=div('','overlayLayer'); inner.appendChild(layer);

  const menuState=getMenuState();
  menuState.img=img;
  menuState.layer=layer;
  menuState.inner=inner;

  ensureMobileViewerChrome();
  updateZoomIndicator();
  const showOverlayDetails=(evt,item,target)=>{
    ensureMobileInfoPanel();
    let pointerType='mouse';
    if(evt){
      if(typeof evt.pointerType==='string'){
        pointerType=evt.pointerType;
      } else if(evt.type && evt.type.toLowerCase().includes('touch')){
        pointerType='touch';
      } else if(evt.type && evt.type.toLowerCase().includes('pointer')){
        pointerType='pen';
      }
    }
    const useMobilePanel = (pointerType!=='mouse') && prefersMobileInfo();
    if(useMobilePanel){
      if(evt){
        if(typeof evt.preventDefault==='function') evt.preventDefault();
        if(typeof evt.stopPropagation==='function') evt.stopPropagation();
      }
      if(currentMobileInfoItem===item && mobileInfoPanel?.classList.contains('show')){
        renderMobileInfo(null);
      } else {
        hideTip();
        renderMobileInfo(item);
      }
      return;
    }
    if(mobileInfoPanel && mobileInfoPanel.classList.contains('show')){
      mobileInfoPanel.classList.remove('show');
      mobileInfoPanel.style.display='none';
      mobileInfoPanel.innerHTML='';
      currentMobileInfoItem=null;
    }
    const client = evt?.changedTouches ? evt.changedTouches[0] : evt;
    const rect = target?.getBoundingClientRect
      ? target.getBoundingClientRect()
      : (evt?.currentTarget?.getBoundingClientRect ? evt.currentTarget.getBoundingClientRect() : null);
    const clientX = client?.clientX ?? 0;
    const clientY = client?.clientY ?? 0;
    showTipIn(pageTip, clientX, clientY, item.id||'Item', tooltipBodyHTML(item,state.allergies||[],state.diets||[]), rect);
  };

  function renderLayer(){
    [...layer.querySelectorAll('.overlay')].forEach(n=>n.remove());
    const colors={ safe:'var(--ok)', removable:'var(--warn)', unsafe:'var(--bad)', neutral:'#ffffff1a'};
    
    if(!img.complete || !img.naturalWidth || !img.clientWidth || !img.clientHeight) {
      console.log('Image not ready yet');
      return;
    }
    
    layer.style.width = img.clientWidth + 'px';
    layer.style.height = img.clientHeight + 'px';
    
    (Array.isArray(state.restaurant?.overlays)?state.restaurant.overlays:[]).forEach(it=>{
      
      const box=document.createElement('div');
      box.className='overlay';
      const st=computeStatus(it,state.allergies||[],state.diets||[]);
      box.style.borderColor=colors[st]||colors.neutral;
      box.style.left=(+it.x||0)+'%'; 
      box.style.top=(+it.y||0)+'%'; 
      box.style.width=(+it.w||0)+'%'; 
      box.style.height=(+it.h||0)+'%';

      const hasCross=hasCrossContamination(it,state.allergies||[]);
      if(hasCross){
        const warning=document.createElement('div');
        warning.className='ovWarning';
        warning.title='Cross-contamination warning';
        warning.textContent='⚠';
        warning.addEventListener('click',(e)=>{showOverlayDetails(e,it,e.currentTarget);});
        warning.addEventListener('touchend',(e)=>{showOverlayDetails(e,it,e.currentTarget);});
        box.appendChild(warning);
      }

      const badge=document.createElement('div'); 
      badge.className='ovBadge'; 
      badge.title='Details'; 
      badge.textContent='i';
      badge.addEventListener('click',(e)=>{showOverlayDetails(e,it,e.currentTarget);});
      badge.addEventListener('touchend',(e)=>{showOverlayDetails(e,it,e.currentTarget);});
      box.appendChild(badge);

      box.addEventListener('mousemove',(e)=>{
        if(prefersMobileInfo()) return;
        const rect = (e.currentTarget && e.currentTarget.getBoundingClientRect)
          ? e.currentTarget.getBoundingClientRect()
          : box.getBoundingClientRect();
        showTipIn(pageTip, e.clientX, e.clientY, it.id||'Item', tooltipBodyHTML(it,state.allergies||[],state.diets||[]), rect);
      });
      box.addEventListener('mouseleave',hideTip);
      box.addEventListener('click',(e)=>{showOverlayDetails(e,it,e.currentTarget);});
      box.addEventListener('touchend',(e)=>{showOverlayDetails(e,it,e.currentTarget);});

      layer.appendChild(box);
    });
  }

  window.__rerenderLayer__=renderLayer;
  captureMenuBaseDimensions(true);

  if(img.complete && img.naturalWidth) {
    renderLayer();
    captureMenuBaseDimensions(true);
  } else {
    img.onload=()=>{
      setTimeout(renderLayer, 50);
      captureMenuBaseDimensions(true);
      if(document.body.classList.contains('mobileViewerActive')){
        setMobileZoom(mobileZoomLevel,true);
      }
    };
  }

  addEventListener('resize', ()=>{
    requestAnimationFrame(renderLayer);
  }, {passive:true});
  
  if (window.visualViewport){
    visualViewport.addEventListener('resize', ()=>{
      if (pageTip.style.display==='block'){
        const currentLeft = parseFloat(pageTip.style.left || 0);
        const currentTop = parseFloat(pageTip.style.top || 0);
        
        const zoom = visualViewport.scale || 1;
        const k = 1 / zoom;
        
        const isMobile = window.innerWidth <= 640;
        const vw = visualViewport.width;
        const vh = visualViewport.height;
        
        pageTip.style.transform = `scale(${k})`;
        pageTip.style.transformOrigin = 'top left';
        
        const vw2 = visualViewport.width;
        const vh2 = visualViewport.height;
        const baseMaxWidth = isMobile ? Math.min(220, vw2 - 30) : Math.min(280, vw2 - 40);
        pageTip.style.maxWidth = baseMaxWidth + 'px';
        
        requestAnimationFrame(() => {
          const pad = isMobile ? 8 : 12;
          const r = pageTip.getBoundingClientRect();
          
          let left = Math.min(currentLeft, vw2 - r.width - pad);
          let top = Math.min(currentTop, vh2 - r.height - pad);
          left = Math.max(pad, left);
          top = Math.max(pad, top);
          
          pageTip.style.left = left + 'px';
          pageTip.style.top = top + 'px';
        });
      }
    }, {passive:true});
  }
}

/* restaurant page */
function renderRestaurant(){
  renderTopbar();
  const root=document.getElementById('root');
  const rs=state.restaurant||{}; state.ack=false;

  root.innerHTML=`
    <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:12px;flex-wrap:wrap;gap:10px">
      <h1 style="margin:0">${esc(rs.name||'Restaurant')}</h1>
      ${state.canEdit?`<button class="btn btnPrimary" id="mgrEdit">Manager Edit</button>`:''}
    </div>
    <div class="pill">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;flex-wrap:wrap;gap:8px">
        <div style="font-weight:600">${(state.qr||!state.user?.loggedIn)?'Select Your Allergens':'Your Saved Allergens'}</div>
        ${(!state.qr && state.user?.loggedIn)?`<button class="btn clickable" id="editSavedBtn">Edit Saved Allergens</button>`:''}
      </div>
      <div id="savedChips"></div>
    </div>
    <div class="pill">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;flex-wrap:wrap;gap:8px">
        <div style="font-weight:600">${(state.qr||!state.user?.loggedIn)?'Dietary Preferences':'Your Saved Dietary Preferences'}</div>
        ${(!state.qr && state.user?.loggedIn)?`<button class="btn clickable" id="editSavedDietsBtn">Edit Saved Dietary Preferences</button>`:''}
      </div>
      <div id="dietChips"></div>
    </div>
    <div class="banner">
      <span>Reference only. Ingredients & practices can change. Always inform staff about your allergens.</span>
      <button class="ackBtn off" id="ackBtn">I understand</button>
    </div>
    <div id="legendRow" style="display:none" class="legend">
      <span><span class="key ok"></span> Meets all requirements</span>
      <span><span class="key warn"></span> Can be accommodated</span>
      <span><span class="key bad"></span> Does not meet requirements</span>
      <span><span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;background:#facc15;border:2px solid #facc15;border-radius:50%;font-size:9px;vertical-align:middle;color:#000;font-weight:bold;margin-right:4px;">⚠</span>Cross-contamination risk</span>
      <span class="note">👆 Hover or tap for details</span>
    </div>
    <div id="confirmedRow" style="display:none" class="note">Last confirmed by staff: ${rs.lastConfirmed?esc(fmtDate(rs.lastConfirmed)):'—'}</div>
    <div class="menuWrap" id="menu"></div>
    <div class="mobileMenuNotice" id="mobileMenuNotice" aria-hidden="true" style="display:none">
      <button class="btn btnPrimary mobileMenuOpenBtn" type="button" style="width:100%;max-width:100%">Open menu full screen</button>
    </div>
  `;

  const chipsHost=document.getElementById('savedChips');
  if(state.qr||!state.user?.loggedIn) renderSelector(chipsHost); else renderSavedChips(chipsHost);

  const dietChipsHost=document.getElementById('dietChips');
  if(state.qr||!state.user?.loggedIn) renderDietSelector(dietChipsHost); else renderSavedDiets(dietChipsHost);

  const menu=document.getElementById('menu');
  ensureMobileInfoPanel();
  mobileInfoPanel.classList.remove('show');
  mobileInfoPanel.style.display='none';
  mobileInfoPanel.innerHTML='';
  document.getElementById('ackBtn').onclick=()=>{
    if(!state.ack){send({type:'ack'}); state.ack=true;}
    const b=document.getElementById('ackBtn'); b.textContent='Acknowledged'; b.classList.remove('off'); b.classList.add('on');
    menu.classList.add('show');
    document.getElementById('legendRow').style.display='flex';
    document.getElementById('confirmedRow').style.display='block';
    drawMenu(menu, rs.menuImage);
    const hasMenuImage=!!rs.menuImage;
    if(hasMenuImage){
      ensureMobileViewerChrome();
      updateZoomIndicator();
      const notice=document.getElementById('mobileMenuNotice');
      if(notice){
        notice.style.display='flex';
        notice.setAttribute('aria-hidden','false');
        notice.dataset.enabled='1';
        const openBtn=notice.querySelector('.mobileMenuOpenBtn');
        if(openBtn){
          if(!openBtn.__openHandler){
            const handler=(e)=>{
              if(e && typeof e.preventDefault==='function') e.preventDefault();
              if(e && typeof e.stopPropagation==='function') e.stopPropagation();
              openMobileViewer();
            };
            openBtn.__openHandler=handler;
            openBtn.addEventListener('click', handler);
          }
        }
      }
    } else {
      const notice=document.getElementById('mobileMenuNotice');
      if(notice){
        notice.style.display='none';
        notice.setAttribute('aria-hidden','true');
        delete notice.dataset.enabled;
        const openBtn=notice.querySelector('.mobileMenuOpenBtn');
        if(openBtn && openBtn.__openHandler){
          openBtn.removeEventListener('click', openBtn.__openHandler);
          delete openBtn.__openHandler;
        }
      }
    }
    if(mobileInfoPanel){
      mobileInfoPanel.classList.remove('show');
      mobileInfoPanel.style.display='none';
      mobileInfoPanel.innerHTML='';
      currentMobileInfoItem=null;
    }
    if((state.qr || urlQR) && !state.user?.loggedIn && shouldShowQrPromo()){
      queueQrPromoTimer();
    } else {
      cancelQrPromoTimer();
    }
  };

  if((state.qr || urlQR) && !state.user?.loggedIn){
    if(!shouldShowQrPromo() && shouldShowQrBanner()){
      showQrBanner();
    } else if(!shouldShowQrBanner()){
      hideQrBanner();
    }
  } else {
    hideQrBanner();
  }

  if(!state.qr && state.user?.loggedIn){
    const editBtn=document.getElementById('editSavedBtn');
    if(editBtn) editBtn.onclick=()=>send({type:'navigate',to:'/accounts',slug:rs.slug});

    const editDietsBtn=document.getElementById('editSavedDietsBtn');
    if(editDietsBtn) editDietsBtn.onclick=()=>send({type:'navigate',to:'/accounts',slug:rs.slug});
  }

  if(state.canEdit){
    const mgr=document.getElementById('mgrEdit');
    if(mgr) mgr.onclick=()=>{state.page='editor'; renderEditor();};
  }
}

/* editor */
async function detectDishesOnMenu(imageData){
  try {
    const response=await fetch('https://fgoiyycctnwnghrvsilt.supabase.co/functions/v1/detect-menu-dishes',{
      method:'POST',
      headers:{
        'Authorization':'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZnb2l5eWNjdG53bmdocnZzaWx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MzY1MjYsImV4cCI6MjA3NjAxMjUyNn0.xlSSXr0Gl7j-vsckrj-2anpPmp4BG2SUIdN-_dquSA8',
        'Content-Type':'application/json'
      },
      body:JSON.stringify({imageData})
    });

    if(!response.ok){
      const errorText=await response.text();
      console.error('API error:',errorText);
      throw new Error('Failed to detect dishes');
    }

    const result=await response.json();
    return result;
  } catch(err){
    console.error('Detection error:',err);
    return {success:false,error:err.message,dishes:[]};
  }
}

function renderEditor(){
  renderTopbar();
  const rs=state.restaurant||{};
  const root=document.getElementById('root');
  root.innerHTML=`
    <h1>${esc(rs.name||'Restaurant')} — Menu Editor</h1>
    <div class="mgrRow" style="justify-content:space-between">
      <button class="btn" id="backBtn">← Done</button>
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <button class="btn" id="undoBtn" title="Undo (Ctrl+Z)" style="opacity:0.5">↶ Undo</button>
        <button class="btn" id="redoBtn" title="Redo (Ctrl+Y)" style="opacity:0.5">↷ Redo</button>
        <button class="btn" id="viewLogBtn">📋 View log of changes</button>
        <button class="btn" id="uploadMenuBtn">📷 Upload new menu image</button>
        <button class="btn btnDanger" id="confirmBtn">Confirm allergen information is up-to-date</button>
        <button class="btn" id="addBox">Add overlay</button>
        <button class="btn btnPrimary" id="saveBtn" style="display:none">Save to site</button>
      </div>
    </div>

    <!-- Unsaved Changes Warning -->
    <div id="editorUnsavedWarning" style="display:none;background:#2a1a0a;border:2px solid #f59e0b;border-radius:8px;padding:20px;margin:16px 0">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
        <span style="font-size:2rem">⚠️</span>
        <div>
          <div style="font-size:1.1rem;font-weight:600;color:#f59e0b;margin-bottom:4px">You have unsaved changes</div>
          <div style="font-size:0.95rem;color:#d1d5db">Would you like to save before exiting?</div>
        </div>
      </div>
      <div style="display:flex;gap:12px">
        <button type="button" class="btn btnPrimary" id="editorSaveAndExitBtn" style="flex:1;padding:12px;font-size:1rem">💾 Save and Exit</button>
        <button type="button" class="btn" id="editorExitWithoutSavingBtn" style="flex:1;padding:12px;font-size:1rem;background:#4a1a1a;border-color:#721c24">Exit Without Saving</button>
      </div>
      <button type="button" class="btn" id="editorCancelExitBtn" style="width:100%;margin-top:12px;padding:8px;font-size:0.9rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
    </div>

    <input type="file" id="menuImageInput" accept="image/*" style="display:none">
    <div class="note" id="lastConfirmedText" style="text-align:right;font-size:12px;margin-top:4px">Last confirmed: ${rs.lastConfirmed?esc(fmtDateTime(rs.lastConfirmed)):'Never'}</div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div class="note" id="editorNote">Drag to move. Drag any corner to resize. Click ✏️ to edit details.</div>
      <div style="display:flex;gap:8px;align-items:center">
        <span class="note" style="font-size:12px">Zoom:</span>
        <button class="btn" id="zoomOutBtn" style="padding:4px 12px;font-size:18px;line-height:1">−</button>
        <span id="zoomLevel" style="font-size:13px;min-width:45px;text-align:center;color:#a8b2d6">100%</span>
        <button class="btn" id="zoomInBtn" style="padding:4px 12px;font-size:18px;line-height:1">+</button>
        <button class="btn" id="zoomResetBtn" style="padding:4px 8px;font-size:11px">Reset</button>
      </div>
    </div>

    <div id="detectedDishesPanel" style="display:none;background:#1a2351;border:1px solid #2a3261;border-radius:12px;padding:20px;margin-bottom:16px;text-align:center">
      <div style="font-size:1.3rem;font-weight:600;margin-bottom:8px" id="currentDishName"></div>
      <div class="note" style="margin-bottom:12px">Press and drag on the menu to create an overlay for this item</div>
      <div style="display:flex;gap:12px;justify-content:center;align-items:center;font-size:14px;flex-wrap:wrap">
        <button class="btn" id="prevDishBtn" style="padding:6px 12px;font-size:13px">← Previous</button>
        <span id="dishProgress" style="color:#a8b2d6"></span>
        <button class="btn" id="nextDishBtn" style="padding:6px 12px;font-size:13px">Next →</button>
        <button class="btn btnSuccess" id="finishMappingBtn" style="padding:6px 12px;font-size:13px;display:none">✓ Finish Mapping</button>
      </div>
    </div>

    <div class="menuWrap show" id="menu"></div>
  `;
  const menu=document.getElementById('menu');
  const inner=div('','menuInner'); menu.appendChild(inner);
  const img=new Image(); img.src=rs.menuImage||''; img.className='menuImg'; inner.appendChild(img);

  const overlays=JSON.parse(JSON.stringify(rs.overlays||[]));
  let dirty=false; function setDirty(v=true){dirty=v; document.getElementById('saveBtn').style.display=dirty?'inline-flex':'none';}

  // Track all changes as they happen
  let pendingChanges=[];
  let originalOverlaysRef = JSON.stringify(rs.overlays||[]);

  // History tracking for undo/redo
  let history = [{overlays: JSON.parse(JSON.stringify(overlays)), pendingChanges: [], timestamp: Date.now()}];
  let historyIndex = 0;

  function pushHistory(){
    // Remove any future history if we've undone and then made a new change
    if(historyIndex < history.length - 1){
      history = history.slice(0, historyIndex + 1);
    }
    // Add new history entry
    history.push({
      overlays: JSON.parse(JSON.stringify(overlays)),
      pendingChanges: [...pendingChanges],
      timestamp: Date.now()
    });
    historyIndex = history.length - 1;
    // Limit history to 50 entries
    if(history.length > 50){
      history.shift();
      historyIndex--;
    }
    updateUndoRedoButtons();
  }

  function undo(){
    if(historyIndex > 0){
      historyIndex--;
      const snapshot = history[historyIndex];
      overlays.splice(0, overlays.length, ...JSON.parse(JSON.stringify(snapshot.overlays)));
      pendingChanges.splice(0, pendingChanges.length, ...snapshot.pendingChanges);
      drawAll();
      setDirty(true);
      updateUndoRedoButtons();
    }
  }

  function redo(){
    if(historyIndex < history.length - 1){
      historyIndex++;
      const snapshot = history[historyIndex];
      overlays.splice(0, overlays.length, ...JSON.parse(JSON.stringify(snapshot.overlays)));
      pendingChanges.splice(0, pendingChanges.length, ...snapshot.pendingChanges);
      drawAll();
      setDirty(true);
      updateUndoRedoButtons();
    }
  }

  function updateUndoRedoButtons(){
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    if(undoBtn){
      undoBtn.disabled = historyIndex <= 0;
      undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
    }
    if(redoBtn){
      redoBtn.disabled = historyIndex >= history.length - 1;
      redoBtn.style.opacity = historyIndex >= history.length - 1 ? '0.5' : '1';
    }
  }

  const saveBtn=document.getElementById('saveBtn');
  function setSaveState(s){
    if(!saveBtn)return;
    if(s==='saving'){saveBtn.disabled=true;saveBtn.textContent='Saving…';saveBtn.classList.remove('btnSuccess','btnDanger','btnPrimary');saveBtn.classList.add('btn');}
    else if(s==='saved'){saveBtn.disabled=true;saveBtn.textContent='Saved';saveBtn.classList.remove('btn','btnDanger','btnPrimary');saveBtn.classList.add('btnSuccess');
      // Update originalOverlaysRef after successful save
      originalOverlaysRef = JSON.stringify(overlays);
      setTimeout(()=>{saveBtn.disabled=false;saveBtn.textContent='Save to site';saveBtn.classList.remove('btnSuccess','btnDanger');saveBtn.classList.add('btnPrimary');pendingChanges=[];setDirty(false);},900);}
    else if(s==='error'){saveBtn.disabled=false;saveBtn.textContent='Retry save';saveBtn.classList.remove('btnSuccess','btnPrimary');saveBtn.classList.add('btnDanger');}
  }
  function formatChangesForLog(changesList){
    const firstName=state.user?.user_metadata?.first_name||'';
    const lastName=state.user?.user_metadata?.last_name||'';
    let fullName=`${firstName} ${lastName}`.trim();
    if(!fullName) fullName=(state.user?.name||'').trim();
    if(!fullName) fullName=(state.user?.email||'').trim();
    if(!fullName) fullName='User';

    const grouped={};
    const generalChanges=[];

    (changesList||[]).forEach(change=>{
      if(typeof change!=='string') return;
      const colonIndex=change.indexOf(':');
      if(colonIndex>0){
        const itemName=change.substring(0,colonIndex).trim();
        const itemChange=change.substring(colonIndex+1).trim();
        if(!grouped[itemName]) grouped[itemName]=[];
        if(itemChange) grouped[itemName].push(itemChange);
      } else if(change.trim()){
        generalChanges.push(change.trim());
      }
    });

    return {
      author: fullName,
      general: generalChanges,
      items: grouped
    };
  }

  if(saveBtn){
    saveBtn.onclick=()=>{
      setSaveState('saving');
      let changesList=[];
      if(pendingChanges.length>0){
        changesList=[...pendingChanges];
      } else {
        changesList=describeOverlayChanges(JSON.parse(originalOverlaysRef),overlays);
      }
      if(!changesList.length){
        setSaveState('saved');
        return;
      }
      // Debug: Log what we're saving
      console.log('Saving overlays:', JSON.stringify(overlays, null, 2));
      overlays.forEach((overlay, idx) => {
        console.log(`Overlay ${idx} (${overlay.id}):`, {
          crossContamination: overlay.crossContamination,
          noCrossContamination: overlay.noCrossContamination,
          removable: overlay.removable
        });
      });
      const formattedChanges=formatChangesForLog(changesList);
      send({type:'saveOverlays',overlays,menuImage:rs.menuImage||'',changes:formattedChanges});
    };
  }
  
  function describeOverlayChanges(oldOverlays,newOverlays){
    const changes=[];
    const oldList=Array.isArray(oldOverlays)?oldOverlays:[];
    const newList=Array.isArray(newOverlays)?newOverlays:[];
    const oldById=new Map(oldList.filter(o=>o&&o.id).map(o=>[o.id,o]));
    const newById=new Map(newList.filter(o=>o&&o.id).map(o=>[o.id,o]));
    const renamedPairs=[];

    newList.forEach((item,idx)=>{
      if(!item) return;
      const itemName=item.id||'Item';
      const old=oldList[idx];
      if(old && old.id && item.id && old.id!==item.id){
        renamedPairs.push({from:old.id,to:item.id});
        changes.push(`Renamed "${old.id}" to "${item.id}"`);
      }
      if(old){
        const oldAllergens=new Set((old.allergens||[]).map(norm));
        const newAllergens=new Set((item.allergens||[]).map(norm));
        const added=[...newAllergens].filter(a=>!oldAllergens.has(a));
        const removed=[...oldAllergens].filter(a=>!newAllergens.has(a));
        if(added.length){
          const allergenWord=added.length===1?'allergen':'allergens';
          changes.push(`${itemName}: Added ${allergenWord} ${added.join(', ')}`);
        }
        if(removed.length){
          const allergenWord=removed.length===1?'allergen':'allergens';
          changes.push(`${itemName}: Removed ${allergenWord} ${removed.join(', ')}`);
        }
        // Track dietary preference changes
        const oldDiets=new Set(old.diets||[]);
        const newDiets=new Set(item.diets||[]);
        const addedDiets=[...newDiets].filter(d=>!oldDiets.has(d));
        const removedDiets=[...oldDiets].filter(d=>!newDiets.has(d));
        if(addedDiets.length){
          const dietWord=addedDiets.length===1?'dietary option':'dietary options';
          changes.push(`${itemName}: Added ${dietWord} ${addedDiets.join(', ')}`);
        }
        if(removedDiets.length){
          const dietWord=removedDiets.length===1?'dietary option':'dietary options';
          changes.push(`${itemName}: Removed ${dietWord} ${removedDiets.join(', ')}`);
        }
        const moved=old.x!==item.x || old.y!==item.y || old.w!==item.w || old.h!==item.h;
        if(moved){
          changes.push(`${itemName}: Adjusted overlay position`);
        }
      }
    });

    const renamedNewIds=new Set(renamedPairs.map(p=>p.to));
    const renamedOldIds=new Set(renamedPairs.map(p=>p.from));

    newList.forEach(item=>{
      if(!item || !item.id) return;
      if(renamedNewIds.has(item.id)) return;
      if(!oldById.has(item.id)){
        const itemName=item.id||'Item';
        changes.push(`${itemName}: Added overlay`);
      }
    });

    oldList.forEach(item=>{
      if(!item || !item.id) return;
      if(renamedOldIds.has(item.id)) return;
      if(!newById.has(item.id)){
        const itemName=item.id||'Item';
        changes.push(`${itemName}: Removed overlay`);
      }
    });

    return changes;
  }

  const confirmBtn=document.getElementById('confirmBtn');
  if(confirmBtn){confirmBtn.onclick=()=>{openPhotoCapture();};}

  const viewLogBtn=document.getElementById('viewLogBtn');
  if(viewLogBtn){viewLogBtn.onclick=()=>{openChangeLog();};}

  const undoBtn=document.getElementById('undoBtn');
  if(undoBtn){undoBtn.onclick=()=>{undo();};}

  const redoBtn=document.getElementById('redoBtn');
  if(redoBtn){redoBtn.onclick=()=>{redo();};}

  // Keyboard shortcuts for undo/redo
  document.addEventListener('keydown', function handleEditorKeydown(e){
    if((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey){
      e.preventDefault();
      undo();
    } else if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))){
      e.preventDefault();
      redo();
    }
  });

  function updateLastConfirmedText(){
    const lastConfirmedText=document.getElementById('lastConfirmedText');
    if(lastConfirmedText){
      const now=new Date();
      lastConfirmedText.textContent='Last confirmed: '+fmtDateTime(now);
    }
  }
  
  function openPhotoCapture(){
    const mb=document.getElementById('modalBack');
    const body=document.getElementById('modalBody');
    document.getElementById('modalTitle').textContent='Confirm Allergen Information';
    
    body.innerHTML=`
      <div class="photoCapture">
        <div class="note" style="text-align:center;margin-bottom:8px">Take photos of your current menu to confirm that it aligns with the menu on Clarivore</div>
        <video id="videoStream" class="videoPreview" autoplay playsinline style="display:none"></video>
        <canvas id="photoCanvas" style="display:none"></canvas>
        <div id="photosContainer" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-bottom:12px"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
          <button class="btn btnPrimary" id="startCameraBtn">📷 Take Photo</button>
          <button class="btn btnPrimary" id="takePictureBtn" style="display:none">📸 Capture</button>
          <input type="file" id="fileInput" accept="image/*" capture="environment" style="display:none" multiple>
          <button class="btn" id="uploadBtn">📁 Upload Photos</button>
          <button class="btn btnSuccess" id="doneAddingBtn" style="display:none">Done adding photos</button>
        </div>
        <div id="confirmSection" style="display:none;width:100%;text-align:center">
          <div class="note" style="margin:12px 0 8px">Are all dishes clearly visible in these photos?</div>
          <div style="display:flex;gap:8px;justify-content:center;margin-bottom:12px">
            <button class="btn btnSuccess" id="yesVisibleBtn">✓ Yes</button>
            <button class="btn btnDanger" id="noVisibleBtn">✗ No</button>
          </div>
        </div>
        <div id="menuConfirmSection" style="display:none;width:100%;text-align:center">
          <div class="note" style="margin:12px 0 8px">Are these photos of your most current menu?</div>
          <div style="display:flex;gap:8px;justify-content:center">
            <button class="btn btnSuccess" id="confirmPhotoBtn">✓ Yes, confirm</button>
            <button class="btn btnDanger" id="cancelPhotoBtn">✗ Cancel</button>
          </div>
        </div>
      </div>
    `;
    
    mb.style.display='flex';
    configureModalClose({visible:true,onClick:()=>{
      mb.style.display='none';
      if(stream){
        stream.getTracks().forEach(track=>track.stop());
        stream=null;
      }
    }});
    
    let stream=null;
    let photoDataArray=[];

    function renderPhotos(){
      const container=document.getElementById('photosContainer');
      container.innerHTML='';
      photoDataArray.forEach((photoData,idx)=>{
        const wrapper=document.createElement('div');
        wrapper.style.cssText='position:relative;display:inline-block';
        const img=document.createElement('img');
        img.src=photoData;
        img.style.cssText='max-width:120px;max-height:80px;object-fit:cover;border-radius:6px;border:1px solid #2a3466;cursor:pointer';
        img.onclick=()=>window.showPhotoPreview(photoData);
        const removeBtn=document.createElement('button');
        removeBtn.textContent='×';
        removeBtn.className='btn btnDanger';
        removeBtn.style.cssText='position:absolute;top:-8px;right:-8px;width:24px;height:24px;padding:0;min-width:24px;border-radius:50%;font-size:16px;line-height:1';
        removeBtn.onclick=(e)=>{e.stopPropagation();photoDataArray.splice(idx,1);renderPhotos();updateButtonStates();};
        wrapper.appendChild(img);
        wrapper.appendChild(removeBtn);
        container.appendChild(wrapper);
      });
    }

    function updateButtonStates(){
      const doneBtn=document.getElementById('doneAddingBtn');
      const confirmSection=document.getElementById('confirmSection');
      if(photoDataArray.length>0){
        doneBtn.style.display='inline-flex';
      }else{
        doneBtn.style.display='none';
        confirmSection.style.display='none';
        document.getElementById('menuConfirmSection').style.display='none';
      }
    }
    
    document.getElementById('startCameraBtn').onclick=async()=>{
      try{
        if(!stream){
          stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
          const video=document.getElementById('videoStream');
          video.srcObject=stream;
        }
        document.getElementById('videoStream').style.display='block';
        document.getElementById('startCameraBtn').textContent='📷 Take another';
        document.getElementById('takePictureBtn').style.display='inline-flex';
      }catch(err){
        alert('Camera access denied or not available. Please use the upload option.');
      }
    };
    
    document.getElementById('takePictureBtn').onclick=()=>{
      const video=document.getElementById('videoStream');
      const canvas=document.getElementById('photoCanvas');
      const ctx=canvas.getContext('2d');

      const maxWidth = 600;
      const scale = Math.min(1, maxWidth / video.videoWidth);
      canvas.width = video.videoWidth * scale;
      canvas.height = video.videoHeight * scale;

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const photoData = canvas.toDataURL('image/jpeg', 0.6);

      console.log('Photo captured, size:', photoData.length, 'bytes');

      photoDataArray.push(photoData);
      renderPhotos();
      updateButtonStates();

      video.style.display='none';
      document.getElementById('takePictureBtn').style.display='none';
      document.getElementById('startCameraBtn').style.display='inline-flex';
    };
    
    document.getElementById('doneAddingBtn').onclick=()=>{
      if(photoDataArray.length===0){
        alert('Please add at least one photo.');
        return;
      }
      if(stream){
        stream.getTracks().forEach(track=>track.stop());
        stream=null;
      }
      document.getElementById('videoStream').style.display='none';
      document.getElementById('startCameraBtn').style.display='inline-flex';
      document.getElementById('takePictureBtn').style.display='none';
      document.getElementById('confirmSection').style.display='block';
    };
    
    document.getElementById('uploadBtn').onclick=()=>{
      document.getElementById('fileInput').click();
    };
    
    document.getElementById('fileInput').onchange=(e)=>{
      const files=Array.from(e.target.files);
      let processed=0;

      files.forEach(file=>{
        const reader=new FileReader();
        reader.onload=(ev)=>{
          const img = new Image();
          img.onload = () => {
            const canvas = document.getElementById('photoCanvas');
            const ctx = canvas.getContext('2d');

            const maxWidth = 600;
            const scale = Math.min(1, maxWidth / img.width);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;

            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const photoData = canvas.toDataURL('image/jpeg', 0.6);

            console.log('Photo uploaded, size:', photoData.length, 'bytes');

            photoDataArray.push(photoData);
            processed++;

            if(processed===files.length){
              renderPhotos();
              updateButtonStates();
            }
          };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      });

      e.target.value='';
    };
    
    document.getElementById('yesVisibleBtn').onclick=()=>{
      document.getElementById('confirmSection').style.display='none';
      document.getElementById('menuConfirmSection').style.display='block';
    };

    document.getElementById('noVisibleBtn').onclick=()=>{
      photoDataArray=[];
      renderPhotos();
      updateButtonStates();
      document.getElementById('confirmSection').style.display='none';
      document.getElementById('menuConfirmSection').style.display='none';
      document.getElementById('startCameraBtn').textContent='📷 Take Photo';
    };

    document.getElementById('confirmPhotoBtn').onclick=()=>{
      if(photoDataArray.length>0){
        send({type:'confirmAllergens',photos:photoDataArray,timestamp:new Date().toISOString()});
        const confirmBtn=document.querySelectorAll('.btn.btnDanger')[0];
        if(confirmBtn){
          confirmBtn.textContent='Allergy information confirmed';
          confirmBtn.classList.remove('btnDanger');
          confirmBtn.classList.add('btnSuccess');
        }
        updateLastConfirmedText();
        mb.style.display='none';
        if(stream){
          stream.getTracks().forEach(track=>track.stop());
        }
      }
    };

    document.getElementById('cancelPhotoBtn').onclick=()=>{
      mb.style.display='none';
      if(stream){
        stream.getTracks().forEach(track=>track.stop());
      }
    };
  }
  
  function openChangeLog(){
    const mb=document.getElementById('modalBack');
    const body=document.getElementById('modalBody');
    document.getElementById('modalTitle').textContent='Change Log - '+esc(rs.name||'Restaurant');
    configureModalClose({visible:true,onClick:()=>{mb.style.display='none'; mb.onclick=null;}});
    
    send({type:'getChangeLog',restaurantId:rs._id||rs.id||null});
    
    body.innerHTML=`
      <div class="note" style="margin-bottom:12px">Loading change log...</div>
    `;
    
    mb.style.display='flex';
    
    // Add click handler to close modal when clicking outside
    mb.onclick=(e)=>{
      if(e.target===mb){
        mb.style.display='none';
        mb.onclick=null;
      }
    };
  }
  
  window.displayChangeLog=(logs,errorMsg)=>{
    const body=document.getElementById('modalBody');
    if(errorMsg){
      body.innerHTML=`
        <div class="note" style="color:var(--bad);">${esc(errorMsg)}</div>
        <div style="margin-top:12px;text-align:center">
          <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
        </div>`;
      return;
    }
    const restaurantId = state.restaurant?._id || state.restaurant?.id || null;
    if(Array.isArray(logs) && restaurantId){
      logs = logs.filter(log=>log.restaurantId===restaurantId || log.restaurant_id===restaurantId);
    }
    if(!logs||!logs.length){
      body.innerHTML=`
        <div class="note">No changes recorded yet.</div>
        <div style="margin-top:12px;text-align:center">
          <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
        </div>`;
      return;
    }
    
    let html='';
    logs.forEach(log=>{
      const typeLabel=log.type==='confirm'?'Allergen Confirmation':'Allergen Update';
      const typeClass=log.type==='confirm'?'confirm':'update';

      html+=`<div class="logEntry">
        <div class="logHeader">
          <span class="logType ${typeClass}">${esc(typeLabel)}</span>
          <span class="logTimestamp">${esc(fmtDateTime(log.timestamp))}</span>
        </div>`;
      const parsedChanges = (()=>{
        if(!log.changes) return null;
        if(typeof log.changes==='object') return log.changes;
        if(typeof log.changes==='string'){
          try{return JSON.parse(log.changes);}catch(_){return null;}
        }
        return null;
      })();

      if(parsedChanges && (Object.keys(parsedChanges.items||{}).length || (parsedChanges.general||[]).length)){
        let authorName=parsedChanges.author || log.description || '';
        if(authorName.includes(':')) authorName=authorName.split(':')[0];
        if(authorName){
          html+=`<div class="logAuthor">${esc(authorName)}</div>`;
        }
        if(Array.isArray(parsedChanges.general) && parsedChanges.general.length){
          html+=`<ul class="logList">${parsedChanges.general.map(item=>`<li>${esc(item)}</li>`).join('')}</ul>`;
        }
        Object.entries(parsedChanges.items||{}).forEach(([itemName,entries])=>{
          html+=`<div class="logItem">${esc(itemName)}</div>`;
          if(Array.isArray(entries) && entries.length){
            html+=`<ul class="logList">${entries.map(entry=>`<li>${esc(entry)}</li>`).join('')}</ul>`;
          }
        });
      } else {
        let authorLine = log.description || (parsedChanges && parsedChanges.author);
        if(authorLine && authorLine.includes(':')) authorLine=authorLine.split(':')[0];
        if(authorLine){
          html+=`<div class="logAuthor">${esc(authorLine)}</div>`;
        }
        if(log.changes){
          let changesHtml=esc(typeof log.changes==='string'?log.changes:JSON.stringify(log.changes));
          changesHtml=changesHtml.replace(/\*\*([^*]+)\*\*/g,'<strong>$1</strong>');
          changesHtml=changesHtml.replace(/\n/g,'<br>');
          html+=`<div class="note" style="margin-top:8px;font-size:13px;line-height:1.6">${changesHtml}</div>`;
        }
      }
      // Display photos if present (stored as array in database)
      const photos = log.photos || [];
      if(Array.isArray(photos) && photos.length > 0){
        photos.forEach(photoUrl => {
          const photoEsc=esc(photoUrl).replace(/'/g,'&#39;');
          html+=`<img src="${esc(photoUrl)}" class="logThumbnail" onclick="window.showPhotoPreview('${photoEsc}')" alt="Confirmation photo">`;
        });
      }
      // Add restore button if this log entry has overlays data and is an update
      if(log.type === 'update' && log.overlays){
        const logDataEsc = esc(JSON.stringify({overlays: log.overlays, menuImage: log.menu_image || log.menuImage})).replace(/'/g,'&#39;');
        html+=`<div style="margin-top:12px;text-align:right">
          <button class="btn btnPrimary" onclick="window.restoreFromLog('${logDataEsc}')" style="font-size:0.9rem;padding:6px 12px">↶ Restore this version</button>
        </div>`;
      }
      html+=`</div>`;
    });
    
    html+=`<div style="margin-top:12px;text-align:center">
      <button class="btn" onclick="document.getElementById('modalBack').style.display='none'">Close</button>
    </div>`;
    
    body.innerHTML=html;
  };
  
  window.showPhotoPreview=(photoUrl)=>{
    const modal=document.getElementById('photoModal');
    const img=document.getElementById('photoModalImage');
    img.src=photoUrl;
    modal.style.display='flex';
  };

  window.restoreFromLog=(logDataStr)=>{
    try{
      const logData = JSON.parse(logDataStr);
      if(!logData.overlays){
        alert('This log entry does not contain overlay data.');
        return;
      }

      if(!confirm('Restore overlays from this version? This will replace your current overlays and cannot be undone (but you can use Undo after restoring).')){
        return;
      }

      // Clear current overlays and load from log
      overlays.splice(0, overlays.length, ...JSON.parse(JSON.stringify(logData.overlays)));

      // Update menu image if it's different
      if(logData.menuImage && logData.menuImage !== rs.menuImage){
        rs.menuImage = logData.menuImage;
        const img = document.querySelector('.menuImg');
        if(img) img.src = logData.menuImage;
      }

      // Add to pending changes
      pendingChanges.push(`Restored overlays from previous version`);

      // Redraw and mark dirty
      drawAll();
      setDirty(true);
      pushHistory();

      // Close the change log modal
      document.getElementById('modalBack').style.display='none';

      alert('Overlays restored successfully! You can use Undo if needed.');
    } catch(err){
      console.error('Failed to restore from log:', err);
      alert('Failed to restore from this version. The log data may be corrupted.');
    }
  };

  document.getElementById('photoModalClose').onclick=()=>{
    document.getElementById('photoModal').style.display='none';
  };
  
  document.getElementById('photoModal').onclick=(e)=>{
    if(e.target.id==='photoModal'){
      document.getElementById('photoModal').style.display='none';
    }
  };

  const mb=document.getElementById('modalBack');

  function drawAll(){
    [...inner.querySelectorAll('.editBox')].forEach(n=>n.remove());
    const iw=img.clientWidth, ih=img.clientHeight;

    overlays.forEach((it,idx)=>{
      const box=document.createElement('div'); box.className='editBox';
      Object.assign(box.style,{left:(+it.x)+'%',top:(+it.y)+'%',width:(+it.w)+'%',height:(+it.h)+'%'});

      ['nw','ne','sw','se'].forEach(c=>{const h=document.createElement('div'); h.className='handle '+c; box.appendChild(h); h.addEventListener('pointerdown',(e)=>startResize(e,c));});

      const eb=document.createElement('div'); eb.className='editBadge'; eb.title='Edit this item'; eb.innerHTML='✏️';
      eb.addEventListener('click',(e)=>{e.stopPropagation();openItemEditor(it,idx);}); box.appendChild(eb);

      let dragging=false,start={};
      box.addEventListener('pointerdown',(e)=>{ if(e.target.classList.contains('handle')||e.target===eb) return;
        // Set this box as active, remove active from others
        inner.querySelectorAll('.editBox').forEach(b=>b.classList.remove('active'));
        box.classList.add('active');
        dragging=true; box.setPointerCapture(e.pointerId);
        start={x:e.clientX,y:e.clientY,l:box.offsetLeft,t:box.offsetTop,w:box.offsetWidth,h:box.offsetHeight};});
      box.addEventListener('pointermove',(e)=>{ if(!dragging) return;
        const nx=Math.max(0,Math.min(iw-start.w,start.l+(e.clientX-start.x)));
        const ny=Math.max(0,Math.min(ih-start.h,start.t+(e.clientY-start.y)));
        const xPct=nx/iw*100,yPct=ny/ih*100; it.x=xPct; it.y=yPct; box.style.left=xPct+'%'; box.style.top=yPct+'%';});
      box.addEventListener('pointerup',()=>{ if(dragging){dragging=false; setDirty(true); pushHistory();} });

      function startResize(e,corner){
        e.stopPropagation(); e.preventDefault(); box.setPointerCapture(e.pointerId);
        // Set this box as active when resizing
        inner.querySelectorAll('.editBox').forEach(b=>b.classList.remove('active'));
        box.classList.add('active');
        const rect=inner.getBoundingClientRect(); const st={x:e.clientX,y:e.clientY,left:+it.x,top:+it.y,w:+it.w,h:+it.h};
        const snapThreshold=0.3;
        
        function getSnapTargets(){
          const targets={xEdges:[],yEdges:[]};
          overlays.forEach((other,otherIdx)=>{
            if(otherIdx===idx) return;
            targets.xEdges.push(+other.x);
            targets.xEdges.push(+other.x + +other.w);
            targets.yEdges.push(+other.y);
            targets.yEdges.push(+other.y + +other.h);
          });
          return targets;
        }
        
        function snapValue(val,edges,threshold){
          for(const edge of edges){
            if(Math.abs(val-edge)<threshold) return edge;
          }
          return val;
        }
        
        function onMove(ev){
          const dx=(ev.clientX-st.x)/rect.width*100, dy=(ev.clientY-st.y)/rect.height*100;
          let x=st.left,y=st.top,w=st.w,h=st.h;
          
          if(corner==='se'){w=st.w+dx;h=st.h+dy;}
          if(corner==='ne'){w=st.w+dx;h=st.h-dy;y=st.top+dy;}
          if(corner==='sw'){w=st.w-dx;h=st.h+dy;x=st.left+dx;}
          if(corner==='nw'){w=st.w-dx;h=st.h-dy;x=st.left+dx;y=st.top+dy;}
          
          w=Math.max(1,Math.min(100,w));
          h=Math.max(0.5,Math.min(100,h));
          x=Math.max(0,Math.min(100-w,x));
          y=Math.max(0,Math.min(100-h,y));

          const snapTargets=getSnapTargets();
          const right=x+w;
          const bottom=y+h;

          if(corner==='se'){
            const snappedRight=snapValue(right,snapTargets.xEdges,snapThreshold);
            const snappedBottom=snapValue(bottom,snapTargets.yEdges,snapThreshold);
            if(snappedRight!==right) w=Math.max(1,snappedRight-x);
            if(snappedBottom!==bottom) h=Math.max(0.5,snappedBottom-y);
          }
          else if(corner==='ne'){
            const snappedRight=snapValue(right,snapTargets.xEdges,snapThreshold);
            const snappedTop=snapValue(y,snapTargets.yEdges,snapThreshold);
            if(snappedRight!==right) w=Math.max(1,snappedRight-x);
            if(snappedTop!==y){
              const oldBottom=y+h;
              y=snappedTop;
              h=Math.max(0.5,oldBottom-y);
            }
          }
          else if(corner==='sw'){
            const snappedLeft=snapValue(x,snapTargets.xEdges,snapThreshold);
            const snappedBottom=snapValue(bottom,snapTargets.yEdges,snapThreshold);
            if(snappedLeft!==x){
              const oldRight=x+w;
              x=snappedLeft;
              w=Math.max(1,oldRight-x);
            }
            if(snappedBottom!==bottom) h=Math.max(0.5,snappedBottom-y);
          }
          else if(corner==='nw'){
            const snappedLeft=snapValue(x,snapTargets.xEdges,snapThreshold);
            const snappedTop=snapValue(y,snapTargets.yEdges,snapThreshold);
            if(snappedLeft!==x){
              const oldRight=x+w;
              x=snappedLeft;
              w=Math.max(1,oldRight-x);
            }
            if(snappedTop!==y){
              const oldBottom=y+h;
              y=snappedTop;
              h=Math.max(0.5,oldBottom-y);
            }
          }

          w=Math.max(1,Math.min(100,w));
          h=Math.max(0.5,Math.min(100,h));
          x=Math.max(0,Math.min(100-w,x)); 
          y=Math.max(0,Math.min(100-h,y));
          
          it.x=x; it.y=y; it.w=w; it.h=h;
          box.style.left=x+'%'; box.style.top=y+'%'; box.style.width=w+'%'; box.style.height=h+'%';
        }
        function onUp(ev){ box.releasePointerCapture(ev.pointerId); document.removeEventListener('pointermove',onMove); document.removeEventListener('pointerup',onUp); setDirty(true); pushHistory(); }
        document.addEventListener('pointermove',onMove); document.addEventListener('pointerup',onUp);
      }

      box.addEventListener('click',(e)=>{e.preventDefault(); e.stopPropagation();});
      inner.appendChild(box);
    });
  }

  img.onload=drawAll; if(img.complete) drawAll();
  document.getElementById('addBox').onclick=()=>{
    const newOverlay={id:'New item',x:10,y:10,w:20,h:8,allergens:[],removable:[],crossContamination:[],diets:[],details:{}};
    overlays.push(newOverlay);
    pendingChanges.push(`${newOverlay.id}: Added overlay`);
    drawAll();
    setDirty(true);
    pushHistory();
  };

  // Detect & Map Dishes - AI-assisted overlay creation
  const detectDishesBtn = document.getElementById('detectDishesBtn');
  if (detectDishesBtn) {
    detectDishesBtn.onclick=async()=>{
    const btn=document.getElementById('detectDishesBtn');
    const originalText=btn.textContent;
    btn.disabled=true;
    btn.textContent='🔍 Detecting dishes...';

    try {
      // Detect all dishes on the menu
      const result=await detectDishesOnMenu(rs.menuImage);

      if(!result.success || !result.dishes || result.dishes.length===0){
        alert('Could not detect any dishes on the menu. Please try adding overlays manually.');
        btn.disabled=false;
        btn.textContent=originalText;
        return;
      }

      // Show the detected dishes panel
      const panel=document.getElementById('detectedDishesPanel');
      const currentDishNameEl=document.getElementById('currentDishName');
      const dishProgressEl=document.getElementById('dishProgress');
      const prevBtn=document.getElementById('prevDishBtn');
      const nextBtn=document.getElementById('nextDishBtn');
      const finishBtn=document.getElementById('finishMappingBtn');

      let detectedDishes=result.dishes;
      let currentDishIndex=0;
      let dragMode=true;
      let dragStart=null;
      let dragPreview=null;

      // Show current dish and update UI
      function showCurrentDish(){
        const mapped=detectedDishes.filter(d=>d.mapped).length;
        const total=detectedDishes.length;

        // Check if all done
        if(mapped>=total){
          currentDishNameEl.textContent='All items mapped!';
          dishProgressEl.textContent=`${mapped} of ${total} items mapped`;
          prevBtn.style.display='none';
          nextBtn.style.display='none';
          finishBtn.style.display='inline-flex';
          menu.style.cursor='';
          dragMode=false;
          return;
        }

        const dish=detectedDishes[currentDishIndex];
        currentDishNameEl.textContent=dish.name;
        dishProgressEl.textContent=`Item ${currentDishIndex+1} of ${total} (${mapped} mapped)`;

        // Update button states
        prevBtn.disabled=currentDishIndex<=0;
        nextBtn.disabled=currentDishIndex>=total-1;
        finishBtn.style.display=mapped>0?'inline-flex':'none';

        menu.style.cursor='crosshair';
        panel.style.display='block';
        dragMode=true;
      }

      // Previous dish
      prevBtn.onclick=()=>{
        if(currentDishIndex>0){
          currentDishIndex--;
          showCurrentDish();
        }
      };

      // Next dish
      nextBtn.onclick=()=>{
        if(currentDishIndex<detectedDishes.length-1){
          currentDishIndex++;
          showCurrentDish();
        }
      };

      // Finish mapping
      finishBtn.onclick=()=>{
        panel.style.display='none';
        menu.style.cursor='';
        dragMode=false;
        drawAll();
      };

      showCurrentDish();

      // Handle drag-to-create overlay
      function handleDragStart(e){
        if(!dragMode) return;

        const rect=img.getBoundingClientRect();
        const x=((e.clientX-rect.left)/rect.width)*100;
        const y=((e.clientY-rect.top)/rect.height)*100;

        dragStart={x,y};

        // Create preview element
        dragPreview=document.createElement('div');
        dragPreview.style.cssText='position:absolute;border:2px dashed #4CAF50;background:rgba(76,175,80,0.2);pointer-events:none;z-index:1000';
        inner.appendChild(dragPreview);

        e.preventDefault();
      }

      function handleDragMove(e){
        if(!dragStart || !dragPreview) return;

        const rect=img.getBoundingClientRect();
        const x=((e.clientX-rect.left)/rect.width)*100;
        const y=((e.clientY-rect.top)/rect.height)*100;

        const minX=Math.min(dragStart.x,x);
        const minY=Math.min(dragStart.y,y);
        const maxX=Math.max(dragStart.x,x);
        const maxY=Math.max(dragStart.y,y);

        dragPreview.style.left=minX+'%';
        dragPreview.style.top=minY+'%';
        dragPreview.style.width=(maxX-minX)+'%';
        dragPreview.style.height=(maxY-minY)+'%';

        e.preventDefault();
      }

      function handleDragEnd(e){
        if(!dragStart || !dragPreview) return;

        const rect=img.getBoundingClientRect();
        const x=((e.clientX-rect.left)/rect.width)*100;
        const y=((e.clientY-rect.top)/rect.height)*100;

        const minX=Math.min(dragStart.x,x);
        const minY=Math.min(dragStart.y,y);
        const maxX=Math.max(dragStart.x,x);
        const maxY=Math.max(dragStart.y,y);

        const w=maxX-minX;
        const h=maxY-minY;

        // Only create overlay if drag was meaningful (at least 1% width/height)
        if(w>1 && h>1){
          const dish=detectedDishes[currentDishIndex];

          // Create new overlay
          const newOverlay={
            id:dish.name,
            x:minX,
            y:minY,
            w:w,
            h:h,
            allergens:[],
            removable:[],
            crossContamination:[],
            diets:[],
            details:{}
          };

          overlays.push(newOverlay);
          pendingChanges.push(`${newOverlay.id}: Added overlay manually`);

          // Mark dish as mapped
          dish.mapped=true;

          drawAll();
          setDirty(true);
          pushHistory();
          showCurrentDish();
        }

        // Clean up
        if(dragPreview && dragPreview.parentNode){
          dragPreview.parentNode.removeChild(dragPreview);
        }
        dragPreview=null;
        dragStart=null;

        e.preventDefault();
      }

      // Add drag handlers to menu image
      img.addEventListener('mousedown',handleDragStart);
      img.addEventListener('mousemove',handleDragMove);
      img.addEventListener('mouseup',handleDragEnd);
      img.addEventListener('mouseleave',handleDragEnd);

      btn.textContent='✓ Dishes Detected';

    } catch(err){
      console.error('Detect dishes error:',err);
      alert('Failed to detect dishes: '+err.message);
      btn.disabled=false;
      btn.textContent=originalText;
    }
  };
  }

  // Zoom controls
  let zoomScale = 1.0;
  const zoomStep = 0.25;
  const minZoom = 0.5;
  const maxZoom = 3.0;

  function updateZoom() {
    const inner = menu.querySelector('.menuInner');
    const zoomLevelEl = document.getElementById('zoomLevel');

    inner.style.transform = `scale(${zoomScale})`;
    inner.style.transformOrigin = 'top left';

    // Don't set explicit width/height on menu container
    // Let it size naturally based on image and transform
    if (zoomScale !== 1.0) {
      const displayWidth = img.clientWidth;
      const displayHeight = img.clientHeight;
      menu.style.width = `${displayWidth * zoomScale}px`;
      menu.style.height = `${displayHeight * zoomScale}px`;
    } else {
      menu.style.width = '';
      menu.style.height = '';
    }
    menu.style.overflow = 'auto';

    zoomLevelEl.textContent = `${Math.round(zoomScale * 100)}%`;

    // Update button states
    document.getElementById('zoomOutBtn').disabled = zoomScale <= minZoom;
    document.getElementById('zoomInBtn').disabled = zoomScale >= maxZoom;
  }

  function initializeZoom() {
    // Just set zoom to 1.0 and update
    zoomScale = 1.0;
    updateZoom();
  }

  document.getElementById('zoomInBtn').onclick = () => {
    if (zoomScale < maxZoom) {
      zoomScale = Math.min(maxZoom, zoomScale + zoomStep);
      updateZoom();
    }
  };

  document.getElementById('zoomOutBtn').onclick = () => {
    if (zoomScale > minZoom) {
      zoomScale = Math.max(minZoom, zoomScale - zoomStep);
      updateZoom();
    }
  };

  document.getElementById('zoomResetBtn').onclick = () => {
    zoomScale = 1.0;
    updateZoom();
  };

  // Initialize zoom on image load
  img.onload = () => {
    initializeZoom();
    drawAll();
  };

  // If image already loaded, initialize now
  if (img.complete) {
    initializeZoom();
  }

  // Upload new menu image
  document.getElementById('uploadMenuBtn').onclick=()=>{
    document.getElementById('menuImageInput').click();
  };

  document.getElementById('menuImageInput').onchange=(e)=>{
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      const img = new Image();
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Resize image to max 1200px wide while maintaining aspect ratio
        const maxWidth = 1200;
        const scale = Math.min(1, maxWidth / img.width);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const newMenuImageData = canvas.toDataURL('image/jpeg', 0.85);

        // Analyze the new menu with AI to detect changes
        const oldTitle = document.title;
        document.title = 'Clarivore - Analyzing menu...';

        // Show a loading message
        const statusDiv = document.createElement('div');
        statusDiv.id = 'menuAnalysisStatus';
        statusDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(17,22,48,0.95);padding:30px;border-radius:12px;z-index:10000;color:#e9ecff;text-align:center;min-width:300px;box-shadow:0 20px 60px rgba(0,0,0,0.5);';
        statusDiv.innerHTML = '<div style="font-size:1.2rem;margin-bottom:12px">🔍 Analyzing new menu...</div><div style="color:#a8b2d6">Please wait while AI detects menu items</div>';
        document.body.appendChild(statusDiv);

        try {
          // Detect dishes on the new menu
          const detectedDishes = await detectDishesOnMenu(newMenuImageData);

          // Compare with existing overlays
          const existingDishNames = new Set(overlays.map(o => (o.id || '').toLowerCase().trim()));
          const newDishNames = new Set(detectedDishes.map(d => d.name.toLowerCase().trim()));

          // Find differences
          const addedDishes = detectedDishes.filter(d => !existingDishNames.has(d.name.toLowerCase().trim()));
          const removedDishes = overlays.filter(o => !newDishNames.has((o.id || '').toLowerCase().trim()));
          const keptDishes = overlays.filter(o => newDishNames.has((o.id || '').toLowerCase().trim()));

          // Remove status div
          document.body.removeChild(statusDiv);
          document.title = oldTitle;

          // Show comparison results
          let message = 'New menu image analyzed!\n\n';

          if (addedDishes.length > 0) {
            message += `✅ NEW ITEMS DETECTED (${addedDishes.length}):\n`;
            addedDishes.forEach(d => message += `   • ${d.name}\n`);
            message += '\n';
          }

          if (removedDishes.length > 0) {
            message += `❌ ITEMS NO LONGER FOUND (${removedDishes.length}):\n`;
            removedDishes.forEach(o => message += `   • ${o.id || 'Unnamed'}\n`);
            message += '\n';
          }

          if (keptDishes.length > 0) {
            message += `✓ Existing items found: ${keptDishes.length}\n\n`;
          }

          message += 'The overlays will stay in their current positions.\n';
          message += 'You will need to manually add/adjust overlays as needed.\n\n';
          message += 'Proceed with updating the menu image?';

          const hasChanges = addedDishes.length > 0 || removedDishes.length > 0;

          // Modify message to include approval notice if changes detected
          if (hasChanges) {
            message += '\n⚠️ NOTE: Since changes were detected, this update will require admin approval.\nYou will be notified once approved.';
          }

          const confirmed = confirm(message);

          if (confirmed) {
            // Update the menu image
            rs.menuImage = newMenuImageData;
            state.restaurant.menuImage = newMenuImageData;

            // Re-render the menu with new image but same overlays
            const menuImg = document.querySelector('.menuImg');
            if (menuImg) {
              menuImg.src = newMenuImageData;
            }

            // Mark as dirty and log the change with details
            let changeLog = 'Uploaded new menu image';
            if (hasChanges) {
              changeLog += ` (AI detected: ${addedDishes.length} new items, ${removedDishes.length} removed items - pending approval)`;
            }
            pendingChanges.push(changeLog);
            setDirty(true);

            // Send email notification if changes detected
            if (hasChanges) {
              try {
                await fetch('https://fgoiyycctnwnghrvsilt.supabase.co/functions/v1/send-notification-email', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZnb2l5eWNjdG53bmdocnZzaWx0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MzY1MjYsImV4cCI6MjA3NjAxMjUyNn0.xlSSXr0Gl7j-vsckrj-2anpPmp4BG2SUIdN-_dquSA8'
                  },
                  body: JSON.stringify({
                    restaurantName: rs.name || 'Unknown Restaurant',
                    restaurantSlug: rs.slug || '',
                    addedItems: addedDishes.map(d => d.name),
                    removedItems: removedDishes.map(o => o.id || 'Unnamed'),
                    keptItems: keptDishes.length
                  })
                });

                // Show pending approval message
                setTimeout(() => {
                  alert(`📧 Admin Notification Sent\n\nMenu changes detected and admin has been notified.\n\nYour update is pending approval.\n\n${addedDishes.length > 0 ? `New items to add:\n${addedDishes.map(d => '• ' + d.name).join('\n')}` : ''}`);
                }, 500);
              } catch (err) {
                console.error('Failed to send notification:', err);
                // Still show the alert about new items
                if (addedDishes.length > 0) {
                  setTimeout(() => {
                    alert(`⚠️ ATTENTION: ${addedDishes.length} new menu item(s) detected!\n\nPlease add overlays for:\n${addedDishes.map(d => '• ' + d.name).join('\n')}`);
                  }, 500);
                }
              }
            } else {
              // No changes detected, just show confirmation
              setTimeout(() => {
                alert('✓ Menu image updated successfully.\n\nNo menu changes detected by AI.');
              }, 500);
            }
          }
        } catch (err) {
          console.error('Menu analysis failed:', err);
          document.body.removeChild(statusDiv);
          document.title = oldTitle;

          // Fall back to simple confirmation if AI fails
          const confirmed = confirm('Failed to analyze menu changes automatically.\n\nNew menu image loaded. The overlays will stay in their current positions.\n\nPlease verify all overlays are correctly positioned over the right items before saving.\n\nProceed?');

          if (confirmed) {
            rs.menuImage = newMenuImageData;
            state.restaurant.menuImage = newMenuImageData;
            const menuImg = document.querySelector('.menuImg');
            if (menuImg) {
              menuImg.src = newMenuImageData;
            }
            pendingChanges.push('Uploaded new menu image');
            setDirty(true);
          }
        }

        // Clear the file input
        e.target.value = '';
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  };

  document.getElementById('backBtn').onclick=()=>{
    if(dirty){
      // Show inline warning instead of confirm dialog
      const warningEl = document.getElementById('editorUnsavedWarning');
      if(warningEl){
        warningEl.style.display = 'block';

        // Scroll warning into view
        warningEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

        // Set up button handlers
        const saveAndExitBtn = document.getElementById('editorSaveAndExitBtn');
        const exitWithoutSavingBtn = document.getElementById('editorExitWithoutSavingBtn');
        const cancelExitBtn = document.getElementById('editorCancelExitBtn');

        const handleSaveAndExit = () => {
          warningEl.style.display = 'none';
          setSaveState('saving');
          // Use pendingChanges if available, otherwise fall back to comparison
          let changesList=[];
          if(pendingChanges.length>0){
            changesList=[...pendingChanges];
          } else {
            changesList=describeOverlayChanges(JSON.parse(originalOverlaysRef),overlays);
          }
          if(changesList.length){
            const formattedChanges=formatChangesForLog(changesList);
            send({type:'saveOverlays',overlays,menuImage:rs.menuImage||'',changes:formattedChanges});
            setTimeout(()=>{state.page='restaurant'; renderRestaurant();},500);
          } else {
            state.page='restaurant'; renderRestaurant();
          }
        };

        const handleExitWithoutSaving = () => {
          warningEl.style.display = 'none';
          state.page='restaurant';
          renderRestaurant();
        };

        const handleCancelExit = () => {
          warningEl.style.display = 'none';
        };

        // Remove old listeners and add new ones
        if(saveAndExitBtn){
          const newBtn = saveAndExitBtn.cloneNode(true);
          saveAndExitBtn.parentNode.replaceChild(newBtn, saveAndExitBtn);
          newBtn.onclick = handleSaveAndExit;
        }
        if(exitWithoutSavingBtn){
          const newBtn = exitWithoutSavingBtn.cloneNode(true);
          exitWithoutSavingBtn.parentNode.replaceChild(newBtn, exitWithoutSavingBtn);
          newBtn.onclick = handleExitWithoutSaving;
        }
        if(cancelExitBtn){
          const newBtn = cancelExitBtn.cloneNode(true);
          cancelExitBtn.parentNode.replaceChild(newBtn, cancelExitBtn);
          newBtn.onclick = handleCancelExit;
        }
      }
    } else {
      state.page='restaurant'; renderRestaurant();
    }
  };

  // Check if there's a pending dish to auto-open (from WordPress deep link)
  if (window.__pendingDishToOpen) {
    const pendingDish = window.__pendingDishToOpen;
    window.__pendingDishToOpen = null; // Clear it

    setTimeout(function() {
      console.log('Looking for dish:', pendingDish.dishName);
      console.log('Available dishes:', overlays.map(o => o.id));

      const matchIndex = overlays.findIndex(item => {
        const itemId = (item.id || '').toLowerCase().trim();
        const searchName = (pendingDish.dishName || '').toLowerCase().trim();

        // Exact match
        if (searchName && itemId === searchName) {
          return true;
        }
        // WordPress ID match
        if (pendingDish.dishId && item.wpPostId && item.wpPostId.toString() === pendingDish.dishId.toString()) {
          return true;
        }
        // Contains match (either direction)
        if (searchName && (itemId.includes(searchName) || searchName.includes(itemId))) {
          return true;
        }
        // Fuzzy match - remove spaces and special chars
        const normalizedItem = itemId.replace(/[^a-z0-9]/g, '');
        const normalizedSearch = searchName.replace(/[^a-z0-9]/g, '');
        if (normalizedItem && normalizedSearch && normalizedItem === normalizedSearch) {
          return true;
        }
        return false;
      });

      if (matchIndex !== -1) {
        console.log('Auto-opening dish editor for:', overlays[matchIndex].id);
        openItemEditor(overlays[matchIndex], matchIndex);

        // After opening, click AI button if requested
        if (pendingDish.openAI) {
          setTimeout(function() {
            const aiBtn = document.getElementById('aiAssistBtn');
            if (aiBtn) {
              console.log('Auto-clicking AI Ingredient Helper button');
              aiBtn.click();
            }
          }, 500);
        }
      } else {
        console.log('Could not find dish to auto-open:', pendingDish);
        console.log('Tried to match:', pendingDish.dishName);
      }
    }, 500);
  }

  function openItemEditor(it,idx){
    configureModalClose({visible:false});
    if(mb) mb.onclick=null;
    const body=document.getElementById('modalBody'); document.getElementById('modalTitle').textContent='Edit item';

    // Check if this is a new item or has existing data
    const hasExistingData = (it.allergens && it.allergens.length > 0) || (it.details && Object.keys(it.details).length > 0);

    // Hide the modal initially - AI assistant will open on top
    if(mb) mb.style.display='none';

    body.innerHTML=`<div class="algRow" style="grid-template-columns:1fr">
        <input id="itemName" class="algInput" style="font-weight:700" placeholder="Item name" value="${esc(it.id||'')}">
      </div>

      <!-- Delete Overlay Warning -->
      <div id="editorDeleteWarning" style="display:none;background:#1a0a0a;border:2px solid #dc2626;border-radius:8px;padding:20px;margin:16px 0">
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
          <span style="font-size:2rem">🗑️</span>
          <div>
            <div style="font-size:1.1rem;font-weight:600;color:#dc2626;margin-bottom:4px">Delete this dish?</div>
            <div style="font-size:0.95rem;color:#d1d5db">This action cannot be undone.</div>
          </div>
        </div>
        <div style="display:flex;gap:12px">
          <button type="button" class="btn btnDanger" id="editorConfirmDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:#dc2626;border-color:#b91c1c">🗑 Delete</button>
          <button type="button" class="btn" id="editorCancelDeleteBtn" style="flex:1;padding:12px;font-size:1rem;background:rgba(76,90,212,0.2);border-color:rgba(76,90,212,0.4)">Cancel</button>
        </div>
      </div>

      <div id="manualEntrySection" style="display:none;">
        <div id="algList"></div>
        <div class="note" style="margin:8px 0 4px">Live preview</div>
        <div id="previewBox" style="border:1px solid #2a3466;border-radius:10px;padding:10px"></div>
      </div>
      <div class="editorActionRow" style="display:flex;gap:8px;margin-top:10px;flex-wrap:wrap">
        <button class="btn btnPrimary" id="doneBtn">Done</button>
        <button class="btn btnDanger" id="delBtn">Delete overlay</button>
      </div>`;
    const list=document.getElementById('algList');
    if(list){
      // Preserve existing AI ingredients data if available
      const existingIngredients = it.aiIngredients || '';
      const existingSummary = it.aiIngredientSummary || '';
      list.dataset.aiIngredients = existingIngredients;
      list.dataset.aiIngredientSummary = existingSummary;
    }
    const sel=new Set(it.allergens||[]);
    const details=it.details||{};
    const rem=new Map((it.removable||[]).map(r=>[r.allergen,r.component]));
    const cross=new Set(it.crossContamination||[]);

    // Add allergen section heading
    const allergenTitle = document.createElement('h3');
    allergenTitle.textContent = 'Allergen Information';
    allergenTitle.style.cssText = 'margin: 0 0 12px 0; color: var(--ink);';
    list.appendChild(allergenTitle);

    ALLERGENS.forEach(a=>{
      const row=document.createElement('div'); row.className='algRow';
      const b=document.createElement('div'); b.className='algBtn'; b.textContent=cap(a); b.dataset.a=a; if(sel.has(a)) b.classList.add('active');
      const inp=document.createElement('input'); inp.className='algInput'; inp.placeholder='Which part of the dish contains the allergen?'; inp.value=details[a]||'';
      const lab=document.createElement('label'); lab.className='algChk'; const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=rem.has(a); lab.appendChild(cb); lab.appendChild(document.createTextNode('can be substituted out'));
      const labCross=document.createElement('label'); labCross.className='algChk'; const cbCross=document.createElement('input'); cbCross.type='checkbox'; cbCross.checked=cross.has(a); labCross.appendChild(cbCross); labCross.appendChild(document.createTextNode('cross-contamination risk'));

      function reflect(){
        const on=b.classList.contains('active');
        inp.style.display=on?'block':'none';
        lab.style.display=on?'flex':'none';
        labCross.style.display='flex';
        updatePreview();
      }
      b.onclick=()=>{b.classList.toggle('active'); reflect();};
      cb.onchange=updatePreview;
      cbCross.onchange=updatePreview;
      inp.oninput=updatePreview;
      row.appendChild(b); row.appendChild(inp); row.appendChild(lab); row.appendChild(labCross); list.appendChild(row); reflect();
    });

    // Add dietary preference section
    const dietTitle = document.createElement('h3');
    dietTitle.textContent = 'Dietary Preferences';
    dietTitle.style.cssText = 'margin: 24px 0 12px 0; padding-top: 16px; border-top: 1px solid rgba(76,90,212,0.3); color: var(--ink);';
    list.appendChild(dietTitle);

    const dietSel = new Set(it.diets||[]);
    DIETS.forEach(diet=>{
      const row=document.createElement('div'); row.className='algRow';
      const b=document.createElement('div'); b.className='algBtn dietBtn'; b.textContent=diet; b.dataset.diet=diet; if(dietSel.has(diet)) b.classList.add('active');

      b.onclick=()=>{b.classList.toggle('active'); updatePreview();};
      row.appendChild(b); list.appendChild(row);
    });
    
    function updatePreview(){
      const tmp={id:(document.getElementById('itemName').value||it.id||'Item'),allergens:[],removable:[],crossContamination:[],diets:[],details:{}};
      list.querySelectorAll('.algRow').forEach(row=>{
        const btn = row.querySelector('.algBtn');
        const a=btn.dataset.a;
        const diet=btn.dataset.diet;
        const on=btn.classList.contains('active');

        if(diet){
          // This is a diet button
          if(on) tmp.diets.push(diet);
        } else if(a){
          // This is an allergen button
          const txt=row.querySelector('.algInput')?.value.trim()||'';
          const checkboxes=row.querySelectorAll('input[type="checkbox"]');
          const isRem=checkboxes[0]?.checked;
          const isCross=checkboxes[1]?.checked;
          if(on){tmp.allergens.push(a); if(txt) tmp.details[a]=txt; if(isRem) tmp.removable.push({allergen:a,component:txt||a});}
          if(isCross){tmp.crossContamination.push(a);}
        }
      });

      // Validate dietary preferences against allergens
      const allergenConflicts = {
        'Vegan': ['dairy', 'egg', 'fish', 'shellfish'], // Vegan excludes all animal products
        'Vegetarian': ['fish', 'shellfish'], // Vegetarian allows dairy and eggs but not meat/fish
        'Pescatarian': [] // Pescatarian allows fish, dairy, eggs, but not other meats
      };

      tmp.diets = tmp.diets.filter(diet => {
        const conflicts = allergenConflicts[diet] || [];
        const hasConflict = conflicts.some(allergen => tmp.allergens.includes(allergen));
        return !hasConflict;
      });

      document.getElementById('previewBox').innerHTML=tooltipBodyHTML(tmp,ALLERGENS.slice(),DIETS.slice());
    }
    updatePreview();
    
    function applyIngredientsFromAi(rows, extraData){
    if(!Array.isArray(rows) || !rows.length){
      aiAssistSetStatus('No ingredients to apply.', 'warn');
      return;
    }
      // Save AI ingredients data to the overlay object immediately
      if(list){
        list.dataset.aiIngredients = JSON.stringify(rows);
      }
      it.aiIngredients = JSON.stringify(rows);
      const allergenDetailsMap={};
      const activeAllergens=new Set();
      const removableIngredients=new Set(); // Track removable ingredients
      const aggregatedIngredientNames=[];

      // For dietary preferences, start with all possible diets, then remove any that aren't supported by ALL ingredients
      // A dish is only vegan if ALL ingredients are vegan, etc.
      let activeDiets=new Set(['Vegan', 'Vegetarian', 'Pescatarian']);

      rows.forEach(row=>{
        const allergens=Array.isArray(row.allergens)?row.allergens:[];
        const diets=Array.isArray(row.diets)?row.diets:[];
        const name=(row.name||'').trim();
        const brand=(row.brand||'').trim();
        const isRemovable=row.removable===true;
        console.log(`Processing row: name="${name}", allergens=`, allergens, `removable=${row.removable}, isRemovable=${isRemovable}`);
        if(Array.isArray(row.ingredientsList) && row.ingredientsList.length){
          aggregatedIngredientNames.push(...row.ingredientsList);
        } else if(name){
          aggregatedIngredientNames.push(brand ? `${cap(name)} (${brand})` : cap(name));
        }
        const label=name?cap(name):'';
        const labelWithBrand=brand ? (label?`${label} (${brand})`:brand) : label;
        allergens.forEach(al=>{
          const key=norm(al);
          if(!key) return;
          activeAllergens.add(key);
          if(labelWithBrand){
            if(!allergenDetailsMap[key]) allergenDetailsMap[key]=[];
            if(!allergenDetailsMap[key].includes(labelWithBrand)){
              allergenDetailsMap[key].push(labelWithBrand);
            }
          }
          // If this ingredient is marked as removable, track the allergen
          if(isRemovable){
            console.log(`  -> Adding allergen "${key}" to removableIngredients because row is removable`);
            removableIngredients.add(key);
          }
        });

        // Remove any diets that this ingredient doesn't support
        // This way, only diets supported by ALL ingredients remain
        const ingredientDietSet = new Set(diets);
        activeDiets.forEach(diet => {
          if(!ingredientDietSet.has(diet)){
            activeDiets.delete(diet);
          }
        });
      });

      // Ignore the AI's overall dish analysis dietary options - we only trust per-ingredient analysis
      // If the AI said "this dish is vegan" but an ingredient isn't marked vegan, the dish isn't vegan

      // Validate dietary preferences against allergens
      // Remove incompatible dietary preferences based on allergens present
      const allergenConflicts = {
        'Vegan': ['dairy', 'egg', 'fish', 'shellfish'], // Vegan excludes all animal products
        'Vegetarian': ['fish', 'shellfish'], // Vegetarian allows dairy and eggs but not meat/fish
        'Pescatarian': [] // Pescatarian allows fish, dairy, eggs, but not other meats (meat allergens not in our list)
      };

      activeDiets.forEach(diet => {
        const conflicts = allergenConflicts[diet] || [];
        const hasConflict = conflicts.some(allergen => activeAllergens.has(allergen));
        if(hasConflict){
          activeDiets.delete(diet);
          console.log(`Removed ${diet} diet due to allergen conflict with ${conflicts.filter(a => activeAllergens.has(a)).join(', ')}`);
        }
      });
      if(list){
        const uniqueAggregated=[...new Set(aggregatedIngredientNames.map(item=>(item||'').trim()).filter(Boolean))];
        list.dataset.aiIngredientSummary = JSON.stringify(uniqueAggregated);
      }
      // Also save ingredient summary to overlay object
      const uniqueAggregated=[...new Set(aggregatedIngredientNames.map(item=>(item||'').trim()).filter(Boolean))];
      it.aiIngredientSummary = JSON.stringify(uniqueAggregated);

      list.querySelectorAll('.algRow').forEach(row=>{
        const btn=row.querySelector('.algBtn');
        const allergen=btn.dataset.a;
        const key=norm(allergen);
        const input=row.querySelector('.algInput');
        const labels=row.querySelectorAll('.algChk');
        const remLabel=labels[0];
        const crossLabel=labels[1];
        const remChk=remLabel?remLabel.querySelector('input'):null;
        const crossChk=crossLabel?crossLabel.querySelector('input'):null;
        const isActive=activeAllergens.has(key);
        btn.classList.toggle('active',isActive);
        if(input){
          if(isActive){
            const explanations=allergenDetailsMap[key]||[];
            input.value=explanations.length?`Contains ${explanations.join(', ')}`:'';
          } else {
            input.value='';
          }
          input.style.display=isActive?'block':'none';
        }
        if(remLabel){
          remLabel.style.display=isActive?'flex':'none';
          if(isActive && remChk){
            // Check the removable checkbox if this allergen is marked as removable
            remChk.checked=removableIngredients.has(key);
          } else if(!isActive && remChk){
            remChk.checked=false;
          }
        }
        if(crossLabel){
          crossLabel.style.display='flex';
        }
      });
      // Apply dietary preferences
      list.querySelectorAll('.algRow').forEach(row=>{
        const btn=row.querySelector('.algBtn.dietBtn');
        if(btn){
          const diet=btn.dataset.diet;
          const isActive=activeDiets.has(diet);
          btn.classList.toggle('active',isActive);
        }
      });

      // Track old values for change log
      const oldAllergens = new Set(it.allergens || []);
      const oldDiets = new Set(it.diets || []);
      const oldCrossContamination = new Set(it.crossContamination || []);
      const oldNoCrossContamination = it.noCrossContamination || false;
      const dishName = it.id || 'Item';

      // Update the overlay object with the new allergen data
      it.allergens = Array.from(activeAllergens);
      it.diets = Array.from(activeDiets);
      it.details = {};
      Object.keys(allergenDetailsMap).forEach(key => {
        const explanations = allergenDetailsMap[key] || [];
        if(explanations.length){
          it.details[key] = `Contains ${explanations.join(', ')}`;
        }
      });
      // Add ingredient summary to details
      if(uniqueAggregated && uniqueAggregated.length){
        it.details.__ingredientsSummary = uniqueAggregated.join(', ');
      }

      // Store cross-contamination data from AI Assistant
      console.log(`=== applyIngredientsFromAi: Processing crossContamination for "${it.id}" ===`);
      console.log('  Current it.crossContamination:', it.crossContamination);
      console.log('  extraData.crossContamination:', extraData?.crossContamination);
      if(extraData && extraData.crossContamination){
        if(extraData.crossContamination.noCrossContamination){
          it.crossContamination = [];
          it.noCrossContamination = true;
          console.log('  -> Set noCrossContamination=true');
        } else {
          it.crossContamination = extraData.crossContamination.allergens || [];
          it.noCrossContamination = false;
          console.log('  -> Set crossContamination:', it.crossContamination);
        }
      } else {
        console.log('  -> No extraData.crossContamination, keeping existing value:', it.crossContamination);
      }
      console.log('  Final it.crossContamination:', it.crossContamination);

      // Track cross-contamination changes
      const newCrossContamination = new Set(it.crossContamination || []);
      const newNoCrossContamination = it.noCrossContamination || false;

      // Check if noCrossContamination status changed
      if(oldNoCrossContamination !== newNoCrossContamination){
        if(newNoCrossContamination){
          pendingChanges.push(`${dishName}: Set to no cross-contamination risk`);
          console.log(`Added pendingChange: ${dishName}: Set to no cross-contamination risk`);
        } else {
          pendingChanges.push(`${dishName}: Removed no cross-contamination status`);
          console.log(`Added pendingChange: ${dishName}: Removed no cross-contamination status`);
        }
      }

      // Check if specific cross-contamination allergens changed
      const addedCross = [...newCrossContamination].filter(a => !oldCrossContamination.has(a));
      const removedCross = [...oldCrossContamination].filter(a => !newCrossContamination.has(a));

      if(addedCross.length){
        const word = addedCross.length === 1 ? 'cross-contamination risk' : 'cross-contamination risks';
        pendingChanges.push(`${dishName}: Added ${word} for ${addedCross.join(', ')}`);
        console.log(`Added pendingChange: ${dishName}: Added ${word} for ${addedCross.join(', ')}`);
      }
      if(removedCross.length){
        const word = removedCross.length === 1 ? 'cross-contamination risk' : 'cross-contamination risks';
        pendingChanges.push(`${dishName}: Removed ${word} for ${removedCross.join(', ')}`);
        console.log(`Added pendingChange: ${dishName}: Removed ${word} for ${removedCross.join(', ')}`);
      }

      // Track allergen changes
      const addedAllergens = [...activeAllergens].filter(a => !oldAllergens.has(a));
      const removedAllergens = [...oldAllergens].filter(a => !activeAllergens.has(a));
      if(addedAllergens.length){
        const word = addedAllergens.length === 1 ? 'allergen' : 'allergens';
        pendingChanges.push(`${dishName}: Added ${word} ${addedAllergens.join(', ')}`);
      }
      if(removedAllergens.length){
        const word = removedAllergens.length === 1 ? 'allergen' : 'allergens';
        pendingChanges.push(`${dishName}: Removed ${word} ${removedAllergens.join(', ')}`);
      }

      // Track dietary changes
      const addedDiets = [...activeDiets].filter(d => !oldDiets.has(d));
      const removedDiets = [...oldDiets].filter(d => !activeDiets.has(d));
      if(addedDiets.length){
        const word = addedDiets.length === 1 ? 'diet' : 'diets';
        pendingChanges.push(`${dishName}: Added ${word} ${addedDiets.join(', ')}`);
      }
      if(removedDiets.length){
        const word = removedDiets.length === 1 ? 'diet' : 'diets';
        pendingChanges.push(`${dishName}: Removed ${word} ${removedDiets.join(', ')}`);
      }

      // Update the overlay name from the AI Assistant name input only if user explicitly changed it
      const aiNameInput = document.getElementById('aiAssistNameInput');
      const manualNameInput = document.getElementById('itemName');
      const currentName = it.id || 'Item';
      const inputValue = aiNameInput?.value?.trim() || '';

      // Only treat the input as a rename if it differs from the current dish name
      // This prevents stale input values from accidentally renaming dishes
      const newName = (inputValue && inputValue !== currentName) ? inputValue : currentName;

      if(newName !== it.id){
        const oldName = it.id;
        it.id = newName;
        pendingChanges.push(`Renamed "${oldName}" to "${newName}"`);
        // Also update the manual editor input if it exists
        if(manualNameInput){
          manualNameInput.value = newName;
        }
      }

      // Update removable ingredients
      console.log('removableIngredients Set before converting:', Array.from(removableIngredients));
      it.removable = [];
      removableIngredients.forEach(allergen => {
        const detail = it.details[allergen] || allergen;
        it.removable.push({allergen, component: detail});
      });
      console.log('Set removable for', it.id, ':', it.removable);

      updatePreview();
      setDirty(true);
      pushHistory();
      aiAssistSetStatus('Ingredient details applied and saved to dish!','success');
    }
    
    // Auto-open AI assistant immediately
    // For new items (no allergens): show input screen (photo/upload/describe)
    // For existing items with data: show ingredient editing table
    const seedText=Object.values(it.details||{}).join('\n');
    const isNewItem = !it.allergens || it.allergens.length === 0;

    // If there's existing AI ingredients data, parse and pass it to the assistant
    let existingIngredientRows = null;
    console.log('Opening editor for:', it.id, 'isNewItem:', isNewItem, 'allergens:', it.allergens, 'details:', it.details);

    if(it.aiIngredients && typeof it.aiIngredients === 'string'){
      try{
        existingIngredientRows = JSON.parse(it.aiIngredients);
        console.log('Found saved AI ingredients:', existingIngredientRows);
        existingIngredientRows.forEach((row, idx) => {
          console.log(`  Row ${idx}: name="${row.name}", removable=${row.removable}, allergens=`, row.allergens);
        });
      }catch(e){
        console.warn('Failed to parse existing AI ingredients:', e);
      }
    } else if(!isNewItem){
      // Convert existing allergen data into ingredient rows for editing
      // This handles dishes created before the AI ingredient system
      existingIngredientRows = [];
      console.log('Converting legacy allergen data to ingredients, allergens:', it.allergens, 'details:', it.details);

      // If we have details with allergen descriptions, use those
      if(it.details && Object.keys(it.details).length > 0){
        Object.keys(it.details).forEach(allergen => {
          if(allergen.startsWith('__')) return; // Skip special fields like __ingredientsSummary
          const detail = it.details[allergen];
          if(detail){
            // Create an ingredient row from the allergen detail
            existingIngredientRows.push({
              name: detail,
              brand: '',
              allergens: [allergen],
              diets: it.diets || [],
              removable: (it.removable || []).some(r => r.allergen === allergen),
              confirmed: false
            });
          }
        });
      } else if(it.allergens && it.allergens.length > 0){
        // No details, but we have allergens - create generic ingredient rows
        it.allergens.forEach(allergen => {
          existingIngredientRows.push({
            name: `Ingredient with ${allergen}`,
            brand: '',
            allergens: [allergen],
            diets: it.diets || [],
            removable: (it.removable || []).some(r => r.allergen === allergen),
            confirmed: false
          });
        });
      }

      console.log('Converted to ingredient rows:', existingIngredientRows);
    }

    console.log('Final existingIngredientRows:', existingIngredientRows);

    // Open AI assistant immediately - store dish name in closure to avoid stale references
    const currentDishId = it.id || 'Item';
    console.log('openItemEditor: About to open AI Assistant for dish:', currentDishId);

    openAiAssistant({
      seedText,
      getCurrentName:()=>{
        // IMPORTANT: Return the dish ID that was captured in the closure when this editor was opened
        // This prevents stale data from other dishes
        console.log('getCurrentName called, returning:', currentDishId);
        return currentDishId;
      },
      onApply:(rows, extraData)=>applyIngredientsFromAi(rows, extraData),
      existingIngredients: existingIngredientRows,
      crossContamination: it.crossContamination || [],
      noCrossContamination: it.noCrossContamination || false,
      onDelete: () => {
        // Delete the overlay
        pendingChanges.push(`${it.id||'Item'}: Removed overlay`);
        overlays.splice(idx,1);
        if(mb) mb.style.display='none';
        drawAll();
        setDirty(true);
        pushHistory();
      }
    });

    document.getElementById('doneBtn').onclick=()=>{
      const oldName=it.id;
      const oldAllergens=new Set(it.allergens||[]);

      const final={allergens:[],removable:[],crossContamination:[],diets:[],details:{}};
      console.log('=== DONE BUTTON: Starting to collect dish data ===');
      list.querySelectorAll('.algRow').forEach(row=>{
        const btn = row.querySelector('.algBtn');
        const a=btn.dataset.a;
        const diet=btn.dataset.diet;
        const on=btn.classList.contains('active');

        if(diet){
          // This is a diet button
          if(on) final.diets.push(diet);
        } else if(a){
          // This is an allergen button
          const txt=row.querySelector('.algInput')?.value.trim()||'';
          const checkboxes=row.querySelectorAll('input[type="checkbox"]');
          console.log(`  Allergen ${a}: found ${checkboxes.length} checkboxes`);
          const isRem=checkboxes[0]?.checked;
          const isCross=checkboxes[1]?.checked;
          console.log(`    - isRem (checkbox[0]): ${isRem}`);
          console.log(`    - isCross (checkbox[1]): ${isCross}`);
          if(on){final.allergens.push(a); if(txt) final.details[a]=txt; if(isRem) final.removable.push({allergen:a,component:txt||a}); }
          if(isCross){
            console.log(`    -> Adding ${a} to crossContamination array`);
            final.crossContamination.push(a);
          }
        }
      });
      console.log('=== DONE BUTTON: Final crossContamination array ===', final.crossContamination);
      if(list && list.dataset.aiIngredientSummary){
        try{
          const rawSummary=JSON.parse(list.dataset.aiIngredientSummary)||[];
          const summary=[...new Set(rawSummary.map(item=>(item||'').trim()).filter(Boolean))];
          if(summary.length){
            final.details.__ingredientsSummary=summary.join(', ');
          } else {
            delete final.details.__ingredientsSummary;
          }
        }catch(_){ delete final.details.__ingredientsSummary; }
      }
      const newName=(document.getElementById('itemName').value||it.id||'Item');

      // Track rename
      if(oldName!==newName){
        pendingChanges.push(`Renamed "${oldName}" to "${newName}"`);
      }

      // Track allergen changes
      const newAllergens=new Set(final.allergens);
      const added=[...newAllergens].filter(a=>!oldAllergens.has(a));
      const removed=[...oldAllergens].filter(a=>!newAllergens.has(a));
      if(added.length){
        const allergenWord=added.length===1?'allergen':'allergens';
        pendingChanges.push(`${newName}: Added ${allergenWord} ${added.join(', ')}`);
      }
      if(removed.length){
        const allergenWord=removed.length===1?'allergen':'allergens';
        pendingChanges.push(`${newName}: Removed ${allergenWord} ${removed.join(', ')}`);
      }

      // Validate dietary preferences against allergens before saving
      const allergenConflicts = {
        'Vegan': ['dairy', 'egg', 'fish', 'shellfish'], // Vegan excludes all animal products
        'Vegetarian': ['fish', 'shellfish'], // Vegetarian allows dairy and eggs but not meat/fish
        'Pescatarian': [] // Pescatarian allows fish, dairy, eggs, but not other meats
      };

      final.diets = final.diets.filter(diet => {
        const conflicts = allergenConflicts[diet] || [];
        const hasConflict = conflicts.some(allergen => final.allergens.includes(allergen));
        if(hasConflict){
          console.log(`Removed ${diet} from final save due to allergen conflict`);
        }
        return !hasConflict;
      });

      it.id=newName;
      it.allergens=final.allergens;
      it.details=final.details;
      it.removable=final.removable;
      it.crossContamination=final.crossContamination;
      it.diets=final.diets;
      console.log(`=== DONE BUTTON: Set it.crossContamination for "${newName}" ===`, it.crossContamination);
      // Save AI ingredients data for future editing
      if(list){
        it.aiIngredients = list.dataset.aiIngredients || '';
        it.aiIngredientSummary = list.dataset.aiIngredientSummary || '';
      }
      mb.style.display='none'; drawAll(); setDirty(true); pushHistory();
    };
    const deleteWarning = document.getElementById('editorDeleteWarning');
    const confirmDeleteBtn = document.getElementById('editorConfirmDeleteBtn');
    const cancelDeleteBtn = document.getElementById('editorCancelDeleteBtn');

    document.getElementById('delBtn').onclick=()=>{
      // Show inline delete warning instead of browser confirm
      if(deleteWarning){
        deleteWarning.style.display = 'block';
        deleteWarning.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    };

    // Set up confirm delete handler
    if(confirmDeleteBtn){
      confirmDeleteBtn.onclick = () => {
        if(deleteWarning) deleteWarning.style.display = 'none';
        pendingChanges.push(`${it.id||'Item'}: Removed overlay`);
        overlays.splice(idx,1);
        mb.style.display='none';
        drawAll();
        setDirty(true);
        pushHistory();
      };
    }

    // Set up cancel delete handler
    if(cancelDeleteBtn){
      cancelDeleteBtn.onclick = () => {
        if(deleteWarning) deleteWarning.style.display = 'none';
      };
    }
    // Don't show the modal - AI assistant opens instead
    // mb.style.display='flex';
  }
}

/* report */
function renderReport(){
  renderTopbar();
  const root=document.getElementById('root');
  root.innerHTML=`<h1>Report an issue</h1>
    <div style="max-width:640px">
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin:8px 0">
        <input id="rName" type="text" placeholder="Your name" style="flex:1">
        <input id="rEmail" type="email" placeholder="Email (required)" style="flex:1">
      </div>
      <textarea id="rMsg" rows="6" style="width:100%;border-radius:16px" placeholder="Describe the issue"></textarea>
      <div class="mgrRow" style="justify-content:flex-start"><button class="btn btnPrimary" id="rSend">Send</button></div>
      <div class="note">We require an email so we can follow up if needed.</div>
    </div>`;
  document.getElementById('rSend').onclick=()=>{ 
    const name=(document.getElementById('rName').value||'').trim();
    const email=(document.getElementById('rEmail').value||'').trim();
    const message=(document.getElementById('rMsg').value||'').trim();
    if(!email){alert('Please enter your email.');return;}
    send({type:'sendReport',name,email,message});
  };
}

/* router */
function render(){
  switch(state.page){
    case 'restaurants': return renderCardsPage();
    case 'editor':      return renderEditor();
    case 'report':      return renderReport();
    case 'restaurant':  return renderRestaurant();
    default:            return;
  }
}

/* Warn on page unload if there are unsaved changes */
window.addEventListener('beforeunload', (event) => {
  // Check if AI Assistant modal is open and has unsaved changes
  const modalIsOpen = aiAssistBackdrop && aiAssistBackdrop.classList.contains('show');

  if (modalIsOpen && aiAssistState && aiAssistState.savedToDish === false) {
    const dataChanged = collectAiTableData().length > 0;
    if (dataChanged) {
      // Modern browsers require returnValue to be set
      event.preventDefault();
      event.returnValue = '';
      return '';
    }
  }
});

/* hydrate */
window.addEventListener('message',(ev)=>{
  const m=ev.data||{};
  if(!state._hydrated){state._hydrated=true; document.body.style.display='';}

  if(m.user){state.user=m.user;}
  if(state.user?.loggedIn){closeQrPromo('login'); hideQrBanner();}
  if(m.allergies){state.allergies=m.allergies;}
  if(m.diets){state.diets=m.diets;}
  if(m.restaurant){
    state.restaurant=normalizeRestaurant(m.restaurant);
    rebuildBrandMemoryFromRestaurant();
  }
  if(m.restaurants){state.restaurants=m.restaurants;}
  if(typeof m.canEdit==='boolean'){state.canEdit=m.canEdit;}
  if(typeof m.qr==='boolean'){state.qr=m.qr;} else if(urlQR){state.qr=true;}

  // Set page - URL parameter for editor mode takes precedence
  if(m.page){state.page=m.page;}
  // Auto-activate editor mode if URL parameter is present and user has edit permission
  // This overrides any incoming page message
  if(window.__startInEditor && state.canEdit){
    console.log('Activating editor mode from URL parameter, canEdit:', state.canEdit);
    state.page='editor';
  } else if(window.__startInEditor){
    console.log('Editor mode requested but canEdit is:', state.canEdit);
  }
  if(m.aiAssistEndpoint){state.aiAssistEndpoint=m.aiAssistEndpoint;}
  if((state.qr||urlQR) && (!state.allergies||!state.allergies.length)){
    try{const s=sessionStorage.getItem('qrAllergies'); if(s) state.allergies=JSON.parse(s)||[];}catch(_){}
  }
  if((state.qr||urlQR) && (!state.diets||!state.diets.length)){
    try{const s=sessionStorage.getItem('qrDiets'); if(s) state.diets=JSON.parse(s)||[];}catch(_){}
  }
  if(m.page==='restaurant'||m.restaurant){state.ack=false;}
  if(m.type==='allergiesSaved'){state.allergies=m.allergies||[];}
  if(m.type==='aiAssistResult'){handleAiAssistantResult(m); return;}
  if(m.type==='aiAssistError'){handleAiAssistantError(m); return;}

  if(m.type==='overlaysSaved'){
    try{setSaveState('saved');}catch(_){ }
    if(m.restaurant){
      state.restaurant=normalizeRestaurant(m.restaurant) || state.restaurant;
      rebuildBrandMemoryFromRestaurant();
    }
    // Re-render overlays to update colors based on new data
    if(window.__rerenderLayer__) window.__rerenderLayer__();
  }
  if(m.type==='saveFailed'){try{setSaveState('error');}catch(_){ }}
  if(m.type==='confirmationSaved'){
    if(m.timestamp && state.restaurant) state.restaurant.lastConfirmed=m.timestamp;
    if(m.restaurant){
      state.restaurant=normalizeRestaurant(m.restaurant) || state.restaurant;
      rebuildBrandMemoryFromRestaurant();
    }
    try{updateLastConfirmedText();}catch(_){ }
  }
  if(m.type==='confirmationFailed'){
    alert('Could not confirm allergen information. '+(m.message||''));
  }
  if(m.type==='changeLog'){
    try{if(window.displayChangeLog)window.displayChangeLog(m.logs||[], m.error);}catch(_){ }
    return;
  }

  renderTopbar(); render();
  updateFullScreenAllergySummary();
});

// Auto-open specific dish editor if coming from WordPress
(function() {
  const urlParams = new URLSearchParams(window.location.search);
  const openAI = urlParams.get('openAI');
  const dishId = urlParams.get('dishId');
  const dishName = urlParams.get('dishName');

  if (openAI === 'true' && (dishId || dishName)) {
    console.log('WordPress deep link detected, dishName:', dishName, 'dishId:', dishId);

    // Set flag to auto-start in editor mode
    window.__startInEditor = true;

    // Set pending dish to open (will be picked up by renderEditor)
    window.__pendingDishToOpen = {
      dishId: dishId,
      dishName: dishName,
      openAI: openAI === 'true'
    };

    console.log('Set __startInEditor and __pendingDishToOpen flags');
  }
})();
</script>
<script type="module" src="js/report-modal.js"></script>
</body>
</html>
