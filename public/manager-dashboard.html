<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="favicon.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Manager Dashboard - Clarivore</title>
  <link rel="stylesheet" href="css/styles.css">
  <style>
    .dashboard-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .dashboard-header {
      margin-bottom: 30px;
    }

    .dashboard-header h1 {
      font-size: 1.8rem;
      margin-bottom: 8px;
    }

    .dashboard-header p {
      color: var(--muted);
    }

    .section {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #1a2351;
      cursor: pointer;
      color: #fff;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn:hover {
      background: #232d5f;
      border-color: var(--hover);
    }

    .btnPrimary {
      background: #3651ff;
      border-color: #4e65ff;
    }

    .btnPrimary:hover {
      background: #4e65ff;
      border-color: #6b7fff;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .section-title {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 12px;
    }

    .tab-btn {
      padding: 8px 16px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--muted);
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      border-color: var(--hover);
      color: var(--ink);
    }

    .tab-btn.active {
      background: var(--brand);
      border-color: var(--brand);
      color: white;
    }

    .dish-table {
      width: 100%;
      border-collapse: collapse;
    }

    .dish-table th,
    .dish-table td {
      text-align: left;
      padding: 12px;
      border-bottom: 1px solid var(--border);
    }

    .dish-table th {
      color: var(--muted);
      font-weight: 500;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .dish-table tr:hover td {
      background: rgba(124, 156, 255, 0.05);
    }

    .allergen-badge, .diet-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
      margin: 2px;
    }

    .allergen-badge {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .diet-badge {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .diet-badge.vegan { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .diet-badge.vegetarian { background: rgba(132, 204, 22, 0.2); color: #84cc16; }
    .diet-badge.pescatarian { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }

    .request-card {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 12px;
    }

    .request-card:hover {
      border-color: var(--hover);
    }

    .request-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .request-dish {
      font-weight: 600;
      font-size: 1.1rem;
    }

    .request-date {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .request-details {
      margin-bottom: 12px;
    }

    .request-needs {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }

    .request-needs-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .request-needs-label {
      color: var(--muted);
      font-size: 0.8rem;
    }

    .request-count {
      background: rgba(124, 156, 255, 0.2);
      color: var(--brand);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .request-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .action-btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--ink);
    }

    .action-btn:hover {
      border-color: var(--hover);
    }

    .action-btn.primary {
      background: var(--brand);
      border-color: var(--brand);
      color: white;
    }

    .action-btn.primary:hover {
      background: var(--hover);
    }

    .action-btn.success {
      background: rgba(34, 197, 94, 0.2);
      border-color: #22c55e;
      color: #22c55e;
    }

    .action-btn.decline {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .status-badge.pending {
      background: rgba(250, 204, 21, 0.2);
      color: #facc15;
    }

    .status-badge.implemented {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .status-badge.reviewed {
      background: rgba(59, 130, 246, 0.2);
      color: #3b82f6;
    }

    .status-badge.declined {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .suggestion-card {
      background: linear-gradient(135deg, rgba(124, 156, 255, 0.1), rgba(124, 156, 255, 0.05));
      border: 1px solid rgba(124, 156, 255, 0.3);
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 12px;
    }

    .suggestion-icon {
      width: 40px;
      height: 40px;
      background: rgba(124, 156, 255, 0.2);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 12px;
      color: var(--brand);
    }

    .suggestion-title {
      font-weight: 600;
      margin-bottom: 8px;
    }

    .suggestion-description {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 12px;
    }

    .suggestion-impact {
      display: flex;
      gap: 16px;
      font-size: 0.85rem;
    }

    .impact-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .impact-item .positive {
      color: #22c55e;
    }

    .chart-container {
      height: 200px;
      display: flex;
      align-items: flex-end;
      gap: 8px;
      padding: 20px 0;
    }

    .chart-bar {
      flex: 1;
      background: var(--brand);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      transition: height 0.3s;
      position: relative;
    }

    .chart-bar:hover {
      background: var(--hover);
    }

    .chart-bar-label {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: var(--muted);
      white-space: nowrap;
    }

    .chart-bar-value {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      font-weight: 600;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }

    .empty-state svg {
      width: 48px;
      height: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .loading-state {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }

    .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--brand);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .restaurant-selector {
      margin-bottom: 24px;
    }

    .restaurant-selector select {
      width: 100%;
      max-width: 400px;
      padding: 12px 16px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--ink);
      font-size: 1rem;
      cursor: pointer;
    }

    .restaurant-selector select:focus {
      outline: none;
      border-color: var(--brand);
    }

    .response-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .response-modal.show {
      display: flex;
    }

    .response-modal-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 100%;
    }

    .response-modal h3 {
      margin-bottom: 16px;
    }

    .response-modal textarea {
      width: 100%;
      min-height: 100px;
      padding: 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--ink);
      font-size: 0.95rem;
      resize: vertical;
      margin-bottom: 16px;
    }

    .response-modal textarea:focus {
      outline: none;
      border-color: var(--brand);
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    /* Quick Actions Section */
    .quick-actions-section {
      margin-bottom: 24px;
    }

    .quick-actions-section > .quick-actions-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .quick-actions-panel {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      display: flex;
      flex-direction: column;
    }

    .quick-actions-title {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 0 0 16px 0;
      color: var(--muted);
    }

    .recent-changes-list {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 320px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .recent-changes-list::-webkit-scrollbar {
      width: 6px;
    }

    .recent-changes-list::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 3px;
    }

    .recent-changes-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
    }

    .recent-changes-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    .recent-change-item {
      padding: 14px 16px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 8px;
      transition: background 0.2s;
    }

    .recent-change-item:hover {
      background: rgba(255, 255, 255, 0.04);
    }

    .recent-change-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .recent-change-author {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--ink);
    }

    .recent-change-time {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .recent-change-details {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .recent-change-dish {
      font-weight: 500;
      color: var(--ink);
      margin-bottom: 4px;
    }

    .recent-change-list {
      margin: 0;
      padding-left: 16px;
    }

    .recent-change-list li {
      margin-bottom: 2px;
    }

    .recent-change-general {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
    }

    .recent-change-summary {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.4;
    }

    .no-changes-message {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 0.9rem;
      padding: 20px;
      text-align: center;
    }

    .confirmation-status {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .confirmation-info {
      text-align: center;
      padding: 8px 0;
    }

    .confirmation-due-label {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .confirmation-due-date {
      font-size: 1.75rem;
      font-weight: 700;
      margin-bottom: 6px;
      line-height: 1.2;
    }

    .confirmation-due-date.overdue {
      color: #ef4444;
    }

    .confirmation-due-date.soon {
      color: #f59e0b;
    }

    .confirmation-due-date.ok {
      color: #22c55e;
    }

    .confirmation-last {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 20px;
    }

    .quick-actions-panel .btn {
      margin-top: auto;
    }

    .quick-actions-panel .btnPrimary {
      width: 100%;
      padding: 12px 24px;
      font-weight: 600;
    }

    @media (max-width: 768px) {
      .quick-actions-section > .quick-actions-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .dashboard-container {
        padding: 12px;
        overflow-x: hidden;
      }

      .dashboard-header h1 {
        font-size: 1.4rem;
      }

      .section {
        padding: 16px;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .dish-table {
        display: block;
        overflow-x: auto;
      }

      .request-header {
        flex-direction: column;
        gap: 8px;
      }

      .request-needs {
        flex-direction: column;
      }

      .heatmap-metric-toggle {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
        width: 100%;
      }

      .heatmap-metric-buttons {
        width: 100%;
      }

      .heatmap-metric-btn {
        font-size: 0.7rem;
        padding: 5px 8px;
      }

      .heatmap-legend {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .section-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
    }

    /* Menu Heatmap Styles */
    .menu-heatmap-container {
      position: relative;
      background: #0d132a;
      border-radius: 12px;
      overflow: hidden;
      min-height: 300px;
      display: flex;
      justify-content: center;
    }

    #menu-heatmap-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
    }

    .menu-heatmap-inner {
      position: relative;
      display: inline-block;
      line-height: 0;
      user-select: none;
      max-width: 100%;
      margin: 0 auto;
    }

    .menu-heatmap-img {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .menu-heatmap-overlays {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      line-height: normal;
    }

    /* Match restaurant page overlay styling */
    .heatmap-overlay {
      position: absolute;
      border: 1.5px solid;
      border-radius: 4px;
      cursor: pointer;
      pointer-events: auto;
      box-sizing: border-box;
      touch-action: manipulation;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: box-shadow 0.2s ease;
    }

    .heatmap-overlay:hover {
      z-index: 10;
      box-shadow: 0 0 8px rgba(255,255,255,0.3);
    }

    .heatmap-overlay .view-count {
      background: rgba(0,0,0,0.8);
      color: white;
      font-size: 11px;
      font-weight: 600;
      padding: 2px 6px;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.2s;
      white-space: nowrap;
    }

    .heatmap-overlay:hover .view-count {
      opacity: 1;
    }

    /* Page navigation */
    .heatmap-page-nav {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .heatmap-page-btn {
      background: rgba(76, 90, 212, 0.2);
      border: 1px solid rgba(76, 90, 212, 0.4);
      color: var(--ink);
      width: 40px;
      height: 40px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .heatmap-page-btn:hover:not(:disabled) {
      background: rgba(76, 90, 212, 0.4);
      border-color: var(--hover);
    }

    .heatmap-page-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .heatmap-page-btn svg {
      width: 20px;
      height: 20px;
    }

    .heatmap-page-indicator {
      color: var(--ink);
      font-weight: 600;
      min-width: 80px;
      text-align: center;
    }

    /* Heatmap controls (metric toggle + legend) */
    .heatmap-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 12px;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      flex-wrap: wrap;
    }

    .heatmap-filter-checkbox {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .heatmap-filter-checkbox:hover {
      border-color: var(--accent);
    }

    .heatmap-filter-checkbox input {
      width: 14px;
      height: 14px;
      margin: 0;
    }

    .heatmap-metric-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .heatmap-metric-label {
      color: var(--muted);
      font-size: 0.85rem;
    }

    .heatmap-metric-buttons {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .heatmap-metric-btn {
      background: rgba(76, 90, 212, 0.1);
      border: 1px solid rgba(76, 90, 212, 0.3);
      color: var(--muted);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .heatmap-metric-btn:hover {
      background: rgba(76, 90, 212, 0.2);
      border-color: rgba(76, 90, 212, 0.5);
    }

    .heatmap-metric-btn.active {
      background: rgba(76, 90, 212, 0.3);
      border-color: var(--brand);
      color: var(--ink);
    }

    .heatmap-legend {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .heatmap-legend-gradient {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .heatmap-gradient-bar {
      width: 120px;
      height: 10px;
      border-radius: 5px;
      background: linear-gradient(to right, #ef4444, #facc15, #22c55e);
    }

    @media (max-width: 600px) {
      .heatmap-controls {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    /* Dish Analytics Modal */
    .dish-analytics-modal {
      position: fixed;
      inset: 0;
      background: rgba(7, 11, 28, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5000;
      padding: 20px;
    }

    .dish-analytics-modal.show {
      display: flex;
    }

    .dish-analytics-content {
      background: linear-gradient(180deg, #111a3c, #0d132a);
      border: 1px solid #2a3466;
      border-radius: 16px;
      max-width: 600px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      padding: 24px;
    }

    .dish-analytics-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 20px;
    }

    .dish-analytics-header h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .dish-analytics-close {
      background: rgba(22, 32, 90, 0.9);
      border: 1px solid rgba(76, 90, 212, 0.4);
      color: var(--ink);
      width: 36px;
      height: 36px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .dish-analytics-close:hover {
      border-color: var(--hover);
    }

    .analytics-stat-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .analytics-stat {
      background: rgba(76, 90, 212, 0.1);
      border: 1px solid rgba(76, 90, 212, 0.2);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
    }

    .analytics-stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--brand);
    }

    .analytics-stat-label {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .analytics-section {
      margin-bottom: 20px;
    }

    .analytics-section-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .analytics-bar-chart {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .analytics-bar-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .analytics-bar-label {
      width: 100px;
      font-size: 0.85rem;
      color: var(--ink);
    }

    .analytics-bar-track {
      flex: 1;
      height: 20px;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      overflow: hidden;
    }

    .analytics-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .analytics-bar-fill.allergen {
      background: linear-gradient(90deg, #ef4444, #f97316);
    }

    .analytics-bar-fill.diet {
      background: linear-gradient(90deg, #22c55e, #84cc16);
    }

    .analytics-bar-fill.status-safe {
      background: #22c55e;
    }

    .analytics-bar-fill.status-unsafe {
      background: #ef4444;
    }

    .analytics-bar-fill.status-removable {
      background: #facc15;
    }

    .analytics-bar-count {
      width: 40px;
      text-align: right;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .no-menu-image {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 200px;
      color: var(--muted);
    }

    .no-menu-image svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      opacity: 0.5;
    }

    /* Stacked bar chart styles - horizontal layout */
    .stacked-bar-chart {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 12px 0;
    }

    .chart-comparison-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .chart-group-title {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .chart-group-bars {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .stacked-bar-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .stacked-bar-row-label {
      font-size: 0.75rem;
      color: var(--ink);
      width: 70px;
      min-width: 70px;
      text-align: right;
    }

    .stacked-bar-wrapper {
      flex: 1;
      height: 24px;
      display: flex;
      flex-direction: row;
      border-radius: 4px;
      overflow: hidden;
    }

    .stacked-bar-segment {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .stacked-bar-segment.safe {
      background: #22c55e;
    }

    .stacked-bar-segment.removable {
      background: #facc15;
    }

    .stacked-bar-segment.unsafe {
      background: #ef4444;
    }

    .stacked-bar-segment.views {
      background: #3b82f6;
    }

    .stacked-bar-segment.neutral {
      background: rgba(255,255,255,0.2);
    }

    .segment-percent {
      font-size: 0.65rem;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 0 2px rgba(0,0,0,0.5);
      white-space: nowrap;
    }

    .stacked-bar-value {
      font-size: 0.75rem;
      color: var(--muted);
      min-width: 30px;
      text-align: left;
    }

    .stacked-bar-total {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 4px;
    }

    .stacked-bar-legend {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    /* Conflict breakdown horizontal bar charts */
    .conflict-charts-container {
      display: flex;
      gap: 24px;
      margin-top: 12px;
    }

    .conflict-chart {
      flex: 1;
      min-width: 0;
    }

    .conflict-chart-title {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .conflict-bars {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .conflict-bar-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .conflict-bar-label {
      font-size: 0.75rem;
      color: var(--ink);
      width: 90px;
      min-width: 90px;
      white-space: nowrap;
      text-align: left;
    }

    .conflict-bar-track {
      flex: 1;
      height: 16px;
      background: transparent;
      border-radius: 4px;
      overflow: hidden;
    }

    .conflict-bar-fill {
      height: 100%;
      background: #ef4444;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .conflict-bar-value {
      font-size: 0.75rem;
      color: var(--muted);
      min-width: 24px;
      text-align: right;
    }

    .conflict-no-data {
      font-size: 0.75rem;
      color: var(--muted);
      font-style: italic;
    }

    .dish-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    .dish-tag.allergen {
      background: rgba(239, 68, 68, 0.15);
      color: #f87171;
    }

    .dish-tag.diet {
      background: rgba(34, 197, 94, 0.15);
      color: #4ade80;
    }

    .dish-tag.removable {
      background: rgba(250, 204, 21, 0.15);
      color: #fde047;
    }

    /* Accommodation rows */
    .accommodation-row {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 6px;
      margin-bottom: 8px;
      border: 1.5px solid;
    }

    .accommodation-row.cannot {
      border-color: #ef4444;
      background: rgba(239, 68, 68, 0.08);
    }

    .accommodation-row.can {
      border-color: #facc15;
      background: rgba(250, 204, 21, 0.08);
    }

    .accommodation-row.compatible {
      border-color: #22c55e;
      background: rgba(34, 197, 94, 0.08);
    }

    .accommodation-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--ink);
      white-space: nowrap;
    }

    .accommodation-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .accommodation-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      background: rgba(255,255,255,0.1);
    }

    /* Question mark tooltip styles */
    .info-tooltip-container {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    .info-tooltip-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: transparent;
      color: var(--muted);
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid var(--muted);
      margin-left: 4px;
      flex-shrink: 0;
    }
    .info-tooltip-btn:hover {
      color: var(--ink);
      border-color: var(--ink);
    }
    .info-tooltip-popup {
      display: none;
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #1e293b;
      color: #f1f5f9;
      padding: 10px 14px;
      border-radius: 6px;
      font-size: 0.75rem;
      line-height: 1.5;
      width: 220px;
      z-index: 100;
      margin-bottom: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    }
    .info-tooltip-popup.active {
      display: block;
    }
    .info-tooltip-popup::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid #1e293b;
    }
  </style>
</head>
<body class="page-shell">
  <header class="simple-topbar">
    <div class="simple-topbar-inner">
      <a class="simple-brand" href="home.html">
        <img src="https://static.wixstatic.com/media/945e9d_2b97098295d341d493e4a07d80d6b57c~mv2.png" alt="Clarivore logo">
        <span>Clarivore</span>
      </a>
      <div class="simple-nav">
        <!-- Navigation populated by shared-nav.js -->
      </div>
      <div class="mode-toggle-container" id="modeToggleContainer" style="display:none"></div>
    </div>
  </header>

  <main class="page-main">
    <div class="dashboard-container">
      <div class="dashboard-header">
        <h1>Restaurant Manager Dashboard</h1>
        <p>View customer dietary analytics and accommodation requests</p>
      </div>

      <!-- Restaurant Selector -->
      <div class="restaurant-selector" id="restaurant-selector-container">
        <label style="display:block;margin-bottom:8px;color:var(--muted);">Select Restaurant</label>
        <select id="restaurant-select">
          <option value="">Loading restaurants...</option>
        </select>
      </div>

      <!-- Auth Required Message -->
      <div id="auth-required" class="section" style="display:none;">
        <div class="empty-state">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
            <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
          </svg>
          <h3>Sign in Required</h3>
          <p>Please sign in to access the manager dashboard.</p>
          <a href="account.html" class="action-btn primary" style="display:inline-block;margin-top:16px;text-decoration:none;">Sign In</a>
        </div>
      </div>

      <!-- Not a Manager Message -->
      <div id="not-manager" class="section" style="display:none;">
        <div class="empty-state">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="12"/>
            <line x1="12" y1="16" x2="12.01" y2="16"/>
          </svg>
          <h3>Manager Access Required</h3>
          <p>You don't have manager access to any restaurants yet.</p>
        </div>
      </div>

      <!-- Loading State -->
      <div id="loading-state" class="section">
        <div class="loading-state">
          <div class="spinner"></div>
          <p>Loading dashboard...</p>
        </div>
      </div>

      <!-- Dashboard Content -->
      <div id="dashboard-content" style="display:none;">
        <!-- Quick Actions Section -->
        <div class="section quick-actions-section">
          <div class="quick-actions-grid">
            <!-- Recent Changes -->
            <div class="quick-actions-panel">
              <h3 class="quick-actions-title">Recent Changes</h3>
              <div id="recent-changes-list" class="recent-changes-list">
                <div class="loading-state" style="padding:20px;text-align:center;">
                  <div class="spinner" style="width:24px;height:24px;margin:0 auto 8px;"></div>
                  <p style="color:var(--muted);font-size:0.85rem;margin:0;">Loading...</p>
                </div>
              </div>
              <button class="btn" id="viewFullLogBtn" style="width:100%;margin-top:16px;">View full change log</button>
            </div>
            <!-- Confirmation Status -->
            <div class="quick-actions-panel">
              <h3 class="quick-actions-title">Menu Confirmation</h3>
              <div id="confirmation-status" class="confirmation-status">
                <div class="loading-state" style="padding:20px;text-align:center;">
                  <div class="spinner" style="width:24px;height:24px;margin:0 auto 8px;"></div>
                  <p style="color:var(--muted);font-size:0.85rem;margin:0;">Loading...</p>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Menu Heatmap Section -->
        <div class="section">
          <div class="section-header">
            <h2 class="section-title">Menu Interest Heatmap</h2>
            <p style="color:var(--muted);font-size:0.85rem;margin:0;">Click on a dish to see detailed analytics</p>
          </div>
          <!-- Metric toggle at top -->
          <div class="heatmap-controls">
            <div class="heatmap-metric-toggle">
              <span class="heatmap-metric-label">Categorize interest by:</span>
              <div class="heatmap-metric-buttons">
                <button class="heatmap-metric-btn active" data-metric="views">Total views</button>
                <button class="heatmap-metric-btn" data-metric="loves">Total loves</button>
                <button class="heatmap-metric-btn" data-metric="orders">Total orders</button>
                <button class="heatmap-metric-btn" data-metric="requests">Total requests</button>
                <button class="heatmap-metric-btn" data-metric="accommodation">Proportion of views safe/accommodable</button>
              </div>
            </div>
            <div class="heatmap-legend">
              <div class="heatmap-legend-gradient">
                <span style="font-size:0.75rem;color:var(--muted);">Low</span>
                <div class="heatmap-gradient-bar"></div>
                <span style="font-size:0.75rem;color:var(--muted);">High</span>
              </div>
            </div>
          </div>
          <div class="menu-heatmap-container" id="menu-heatmap-container">
            <div id="menu-heatmap-loading" class="loading-state" style="padding:40px;">
              <div class="spinner"></div>
              <p>Loading menu...</p>
            </div>
            <div id="menu-heatmap-content" style="display:none;">
              <div class="menu-heatmap-inner" id="menu-heatmap-inner">
                <img id="menu-heatmap-img" class="menu-heatmap-img" src="" alt="Menu">
                <div class="menu-heatmap-overlays" id="menu-heatmap-overlays"></div>
              </div>
              <!-- Page navigation at bottom -->
              <div class="heatmap-page-nav" id="heatmap-page-nav" style="display:none;">
                <button class="heatmap-page-btn" id="heatmap-prev-btn" disabled>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 18l-6-6 6-6"/>
                  </svg>
                </button>
                <span class="heatmap-page-indicator" id="heatmap-page-indicator">Page 1 of 1</span>
                <button class="heatmap-page-btn" id="heatmap-next-btn" disabled>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 18l6-6-6-6"/>
                  </svg>
                </button>
              </div>
            </div>
            <div id="menu-heatmap-empty" class="no-menu-image" style="display:none;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21 15 16 10 5 21"/>
              </svg>
              <p>No menu image available for this restaurant</p>
            </div>
          </div>
          <!-- Menu Accommodation Breakdown -->
          <div class="menu-accommodation-breakdown" id="menu-accommodation-breakdown" style="display:none;">
            <h3 style="font-size:1rem;font-weight:600;color:var(--ink);margin:16px 0 8px 0;">Menu Accommodation Breakdown</h3>
            <div id="menu-allergen-breakdown" style="margin-bottom:16px;"></div>
            <div id="menu-diet-breakdown"></div>
          </div>
        </div>

        <!-- User Dietary Profile Breakdown (Pie Charts) -->
        <div class="section" id="user-dietary-profile-section" style="display:none;">
          <div class="section-header">
            <h2 class="section-title">User Dietary Profile Breakdown</h2>
          </div>
          <p style="font-size:0.85rem;color:var(--muted);margin-bottom:16px;">Distribution of allergens and diets among users who viewed this menu</p>
          <div style="display:flex;gap:32px;flex-wrap:wrap;justify-content:center;">
            <div id="user-allergen-pie" style="flex:1;min-width:280px;max-width:400px;"></div>
            <div id="user-diet-pie" style="flex:1;min-width:280px;max-width:400px;"></div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Response Modal -->
  <div class="response-modal" id="response-modal">
    <div class="response-modal-content">
      <h3 id="modal-title">Respond to Request</h3>
      <p id="modal-dish" style="color:var(--muted);margin-bottom:16px;"></p>
      <textarea id="response-text" placeholder="Add a response message (optional)..."></textarea>
      <div class="modal-actions">
        <button class="action-btn" id="modal-cancel">Cancel</button>
        <button class="action-btn decline" id="modal-decline">Decline</button>
        <button class="action-btn success" id="modal-implement">Mark Implemented</button>
      </div>
    </div>
  </div>

  <!-- Dish Analytics Modal -->
  <div class="dish-analytics-modal" id="dish-analytics-modal">
    <div class="dish-analytics-content">
      <div class="dish-analytics-header">
        <h3 id="dish-analytics-title">Dish Analytics</h3>
        <button class="dish-analytics-close" id="dish-analytics-close">&times;</button>
      </div>

      <!-- Cannot be accommodated row -->
      <div id="cannot-accommodate-row" class="accommodation-row cannot" style="display:none;">
        <span class="accommodation-label">Cannot be accommodated:</span>
        <div id="cannot-accommodate-tags" class="accommodation-tags"></div>
      </div>

      <!-- Can be accommodated row -->
      <div id="can-accommodate-row" class="accommodation-row can" style="display:none;">
        <span class="accommodation-label">Can be accommodated:</span>
        <div id="can-accommodate-tags" class="accommodation-tags"></div>
      </div>

      <!-- Stacked bar chart for status breakdown -->
      <div class="analytics-section" style="margin-top:16px;">
        <div class="analytics-section-title">Dish Interest Summary</div>
        <div class="stacked-bar-chart" id="analytics-stacked-chart">
          <!-- Populated by JS -->
        </div>
      </div>

      <!-- Conflict breakdown by allergen/diet -->
      <div class="analytics-section" style="margin-top:16px;" id="conflict-breakdown-section">
        <div class="analytics-section-title">Views by Conflicting Restriction</div>
        <div class="conflict-charts-container">
          <div class="conflict-chart">
            <div class="conflict-chart-title">Allergens</div>
            <div class="conflict-bars" id="conflict-allergen-bars">
              <!-- Populated by JS -->
            </div>
          </div>
          <div class="conflict-chart">
            <div class="conflict-chart-title">Diets</div>
            <div class="conflict-bars" id="conflict-diet-bars">
              <!-- Populated by JS -->
            </div>
          </div>
        </div>
        <div class="stacked-bar-legend" style="margin-top:12px;">
          <span class="legend-item"><span class="legend-color" style="background:#22c55e;"></span> Safe</span>
          <span class="legend-item"><span class="legend-color" style="background:#facc15;"></span> Can be accommodated</span>
          <span class="legend-item"><span class="legend-color" style="background:#ef4444;"></span> Cannot be accommodated</span>
        </div>
      </div>

      <!-- Accommodation requests count for this dish -->
      <div class="analytics-section" style="margin-top:16px;">
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="font-size:0.9rem;color:var(--muted);">Accommodation Requests:</span>
          <span id="analytics-requests" style="font-weight:600;color:var(--ink);">0</span>
        </div>
      </div>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="js/auth-redirect.js" defer></script>
  <script type="module">
    import supabaseClient from './js/supabase-client.js';
    import { setupNav } from './js/shared-nav.js';
    import { fetchManagerRestaurants } from './js/manager-context.js';

    // State
    let currentUser = null;
    let managedRestaurants = [];
    let selectedRestaurantId = null;
    let dishAnalytics = [];
    let accommodationRequests = [];
    let currentRequestId = null;
    let currentRestaurantData = null; // For menu image and overlays
    let recentChangeLogs = []; // Recent change log entries
    let currentHeatmapPage = 0; // Current page index for menu heatmap
    let currentHeatmapMetric = 'views'; // views, loves, or orders
    let dishLoves = {}; // Dish name -> love count
    let dishOrders = {}; // Dish name -> order count
    let rawInteractions = []; // Raw dish_interactions for full profile data
    let rawLoves = []; // Raw user_loved_dishes for filtering
    let userLovedSet = new Set(); // Set of user_ids who loved dishes
    let userOrderCounts = {}; // Map user_id -> number of order visits

    // DOM Elements
    const loadingState = document.getElementById('loading-state');
    const authRequired = document.getElementById('auth-required');
    const notManager = document.getElementById('not-manager');
    const dashboardContent = document.getElementById('dashboard-content');
    const restaurantSelect = document.getElementById('restaurant-select');
    const restaurantSelectorContainer = document.getElementById('restaurant-selector-container');

    const OWNER_EMAIL = 'matt.29.ds@gmail.com';

    // Initialize
    async function init() {
      try {
        const { data: { user } } = await supabaseClient.auth.getUser();

        if (!user) {
          showAuthRequired();
          return;
        }

        currentUser = user;
        const isOwner = user.email === OWNER_EMAIL;
        const isManager = user.user_metadata?.role === 'manager';

        // Fetch manager restaurants for navigation
        let navRestaurants = [];
        if (isManager || isOwner) {
          navRestaurants = await fetchManagerRestaurants(supabaseClient, user.id);
        }

        // Setup navigation
        setupNav('home', user, { managerRestaurants: navRestaurants });

        // Set up mode toggle
        const modeToggleContainer = document.getElementById('modeToggleContainer');
        if ((isManager || isOwner) && modeToggleContainer) {
          let currentMode = localStorage.getItem('clarivoreManagerMode');
          if (!currentMode) {
            currentMode = 'editor';
            localStorage.setItem('clarivoreManagerMode', 'editor');
          }
          const isEditorMode = currentMode === 'editor';

          modeToggleContainer.style.display = 'flex';
          modeToggleContainer.innerHTML = `
            <span class="mode-toggle-label">${isEditorMode ? 'Editor mode' : 'Customer mode'}</span>
            <div class="mode-toggle ${isEditorMode ? 'active' : ''}" id="modeToggle" title="Toggle between Editor and Customer mode"></div>
          `;

          // If in customer mode, redirect to home.html
          if (!isEditorMode) {
            window.location.href = 'home.html';
            return;
          }

          // Toggle click handler
          const toggle = document.getElementById('modeToggle');
          if (toggle) {
            toggle.onclick = () => {
              if (isEditorMode) {
                localStorage.setItem('clarivoreManagerMode', 'customer');
                window.location.href = 'home.html';
              } else {
                localStorage.setItem('clarivoreManagerMode', 'editor');
                window.location.href = 'manager-dashboard.html';
              }
            };
          }
        }

        await loadManagedRestaurants();
      } catch (err) {
        console.error('Init error:', err);
        showAuthRequired();
      }
    }

    function showAuthRequired() {
      loadingState.style.display = 'none';
      authRequired.style.display = 'block';
      restaurantSelectorContainer.style.display = 'none';
    }

    function showNotManager() {
      loadingState.style.display = 'none';
      notManager.style.display = 'block';
      restaurantSelectorContainer.style.display = 'none';
    }

    async function loadManagedRestaurants() {
      try {
        const isOwner = currentUser.email === OWNER_EMAIL;

        let restaurants = [];

        if (isOwner) {
          // Owner can see all restaurants
          const { data, error } = await supabaseClient
            .from('restaurants')
            .select('id, name, slug')
            .order('name');

          if (error) throw error;
          restaurants = data || [];
        } else {
          // Regular managers - check restaurant_managers table
          const { data, error } = await supabaseClient
            .from('restaurant_managers')
            .select('restaurant_id, restaurants(id, name, slug)')
            .eq('user_id', currentUser.id);

          if (error) throw error;
          restaurants = (data || []).map(d => d.restaurants).filter(r => r);
        }

        if (restaurants.length === 0) {
          showNotManager();
          return;
        }

        managedRestaurants = restaurants;

        // Populate restaurant selector
        restaurantSelect.innerHTML = managedRestaurants.map(r =>
          `<option value="${r.id}">${r.name}</option>`
        ).join('');

        // Select first restaurant
        if (managedRestaurants.length > 0) {
          selectedRestaurantId = managedRestaurants[0].id;
          await loadDashboardData();
        }
      } catch (err) {
        console.error('Failed to load managed restaurants:', err);
        showNotManager();
      }
    }

    async function loadDashboardData() {
      if (!selectedRestaurantId) return;

      loadingState.style.display = 'block';
      dashboardContent.style.display = 'none';

      try {
        // Load restaurant data (for menu image, overlays, and last_confirmed)
        const { data: restaurantData, error: restaurantError } = await supabaseClient
          .from('restaurants')
          .select('id, name, slug, menu_images, menu_image, overlays, last_confirmed')
          .eq('id', selectedRestaurantId)
          .single();

        if (restaurantError) throw restaurantError;
        currentRestaurantData = restaurantData;

        // Load recent change log entries (last 3)
        const { data: changeLogData, error: changeLogError } = await supabaseClient
          .from('change_logs')
          .select('*')
          .eq('restaurant_id', selectedRestaurantId)
          .order('timestamp', { ascending: false })
          .limit(3);

        recentChangeLogs = changeLogError ? [] : (changeLogData || []);

        // Load dish analytics
        const { data: analyticsData, error: analyticsError } = await supabaseClient
          .from('dish_analytics')
          .select('*')
          .eq('restaurant_id', selectedRestaurantId);

        if (analyticsError) throw analyticsError;
        dishAnalytics = analyticsData || [];

        // Load accommodation requests
        const { data: requestsData, error: requestsError } = await supabaseClient
          .from('accommodation_requests')
          .select('*')
          .eq('restaurant_id', selectedRestaurantId)
          .order('created_at', { ascending: false });

        if (requestsError) throw requestsError;
        accommodationRequests = requestsData || [];

        // Load raw dish_interactions for full user profile data (include dish_name for heatmap filtering)
        const { data: interactionsData, error: interactionsError } = await supabaseClient
          .from('dish_interactions')
          .select('user_id, user_allergens, user_diets, dish_name')
          .eq('restaurant_id', selectedRestaurantId);

        rawInteractions = interactionsError ? [] : (interactionsData || []);

        // Load loved dishes with user_id for filtering
        const { data: lovesData, error: lovesError } = await supabaseClient
          .from('user_loved_dishes')
          .select('user_id, dish_name')
          .eq('restaurant_id', selectedRestaurantId);

        dishLoves = {};
        userLovedSet = new Set();
        rawLoves = lovesError ? [] : (lovesData || []); // Store raw loves for filtering
        if (!lovesError && lovesData) {
          lovesData.forEach(love => {
            dishLoves[love.dish_name] = (dishLoves[love.dish_name] || 0) + 1;
            if (love.user_id) userLovedSet.add(love.user_id);
          });
        }

        // Load tablet orders with user info for filtering
        const { data: ordersData, error: ordersError } = await supabaseClient
          .from('tablet_orders')
          .select('payload')
          .eq('restaurant_id', selectedRestaurantId);

        dishOrders = {};
        userOrderCounts = {}; // Map user_id -> number of orders (visits with orders)
        if (!ordersError && ordersData) {
          ordersData.forEach(order => {
            // Extract dish names from payload
            const payload = order.payload || {};
            const dishes = payload.dishes || payload.items || [];
            if (Array.isArray(dishes)) {
              dishes.forEach(dish => {
                const dishName = typeof dish === 'string' ? dish : (dish.name || dish.dish_name || dish.id);
                if (dishName) {
                  dishOrders[dishName] = (dishOrders[dishName] || 0) + 1;
                }
              });
            }
            // Also check for single dish property
            if (payload.dish_name) {
              dishOrders[payload.dish_name] = (dishOrders[payload.dish_name] || 0) + 1;
            }
            // Track user order counts for weighting
            const userId = payload.user_id;
            if (userId) {
              userOrderCounts[userId] = (userOrderCounts[userId] || 0) + 1;
            }
          });
        }

        // Render dashboard
        renderDashboard();
      } catch (err) {
        console.error('Failed to load dashboard data:', err);
        // Show empty state
        dishAnalytics = [];
        accommodationRequests = [];
        currentRestaurantData = null;
        dishLoves = {};
        dishOrders = {};
        rawInteractions = [];
        rawLoves = [];
        userLovedSet = new Set();
        userOrderCounts = {};
        renderDashboard();
      }

      loadingState.style.display = 'none';
      dashboardContent.style.display = 'block';
    }

    function renderDashboard() {
      renderQuickActions();
      renderHeatmap();
      renderMenuAccommodationBreakdown();
      renderUserDietaryProfilePieCharts();
    }

    function renderQuickActions() {
      // Render recent changes
      const changesList = document.getElementById('recent-changes-list');
      if (changesList) {
        if (recentChangeLogs.length === 0) {
          changesList.innerHTML = '<div class="no-changes-message">No changes recorded yet</div>';
        } else {
          let html = '';
          recentChangeLogs.forEach(log => {
            const timestamp = log.timestamp ? new Date(log.timestamp).toLocaleDateString('en-US', {
              month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'
            }) : '';

            // Parse changes to get full details
            let author = 'Unknown';
            let detailsHtml = '';
            if (log.changes) {
              const parsed = typeof log.changes === 'string' ?
                (() => { try { return JSON.parse(log.changes); } catch(e) { return null; } })() : log.changes;
              if (parsed && parsed.author) author = parsed.author;

              // Build detailed view from items
              if (parsed?.items && Object.keys(parsed.items).length > 0) {
                for (const [dishName, changes] of Object.entries(parsed.items)) {
                  detailsHtml += `<div class="recent-change-dish">${escapeHtml(dishName)}</div>`;
                  if (Array.isArray(changes) && changes.length > 0) {
                    detailsHtml += '<ul class="recent-change-list">';
                    changes.forEach(change => {
                      detailsHtml += `<li>${escapeHtml(change)}</li>`;
                    });
                    detailsHtml += '</ul>';
                  }
                }
              }

              // Add general changes if any
              if (parsed?.general && parsed.general.length > 0) {
                if (detailsHtml) {
                  detailsHtml += '<div class="recent-change-general">';
                }
                detailsHtml += '<ul class="recent-change-list">';
                parsed.general.forEach(change => {
                  detailsHtml += `<li>${escapeHtml(change)}</li>`;
                });
                detailsHtml += '</ul>';
                if (parsed?.items && Object.keys(parsed.items).length > 0) {
                  detailsHtml += '</div>';
                }
              }

              if (!detailsHtml) {
                detailsHtml = '<span style="color:var(--muted)">Menu updated</span>';
              }
            }

            html += `
              <div class="recent-change-item">
                <div class="recent-change-header">
                  <span class="recent-change-author">${escapeHtml(author)}</span>
                  <span class="recent-change-time">${escapeHtml(timestamp)}</span>
                </div>
                <div class="recent-change-details">${detailsHtml}</div>
              </div>
            `;
          });
          changesList.innerHTML = html;
        }
      }

      // Render confirmation status
      const confirmStatus = document.getElementById('confirmation-status');
      if (confirmStatus && currentRestaurantData) {
        const lastConfirmed = currentRestaurantData.last_confirmed ? new Date(currentRestaurantData.last_confirmed) : null;
        const now = new Date();

        let dueDateClass, dueText;
        if (!lastConfirmed) {
          dueText = 'Never confirmed';
          dueDateClass = 'overdue';
        } else {
          // Calculate next due date as 1 month from last confirmed
          const nextDue = new Date(lastConfirmed);
          nextDue.setMonth(nextDue.getMonth() + 1);
          const daysUntilDue = Math.ceil((nextDue - now) / (24 * 60 * 60 * 1000));

          if (daysUntilDue < 0) {
            dueText = `${Math.abs(daysUntilDue)} day${Math.abs(daysUntilDue) > 1 ? 's' : ''} overdue`;
            dueDateClass = 'overdue';
          } else if (daysUntilDue <= 7) {
            dueText = daysUntilDue === 0 ? 'Due today' : `Due in ${daysUntilDue} day${daysUntilDue > 1 ? 's' : ''}`;
            dueDateClass = 'soon';
          } else {
            dueText = `Due in ${daysUntilDue} days`;
            dueDateClass = 'ok';
          }
        }

        const lastConfirmedText = lastConfirmed ?
          `Last confirmed: ${lastConfirmed.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}` :
          'Never confirmed';

        confirmStatus.innerHTML = `
          <div class="confirmation-info">
            <div class="confirmation-due-label">Next confirmation due</div>
            <div class="confirmation-due-date ${dueDateClass}">${dueText}</div>
            <div class="confirmation-last">${lastConfirmedText}</div>
            <button class="btn btnPrimary" id="confirmNowBtn">Confirm information is up-to-date</button>
          </div>
        `;

        // Add click handler for confirm button
        const confirmBtn = document.getElementById('confirmNowBtn');
        if (confirmBtn) {
          confirmBtn.onclick = async () => {
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'Confirming...';
            try {
              const now = new Date().toISOString();
              const { error } = await supabaseClient
                .from('restaurants')
                .update({ last_confirmed: now })
                .eq('id', selectedRestaurantId);

              if (error) throw error;
              currentRestaurantData.last_confirmed = now;
              renderQuickActions(); // Re-render to show updated status
            } catch (err) {
              console.error('Failed to confirm:', err);
              confirmBtn.disabled = false;
              confirmBtn.textContent = 'Confirm information is up-to-date';
              alert('Failed to confirm. Please try again.');
            }
          };
        }
      }

      // View full log button
      const viewLogBtn = document.getElementById('viewFullLogBtn');
      if (viewLogBtn && currentRestaurantData) {
        viewLogBtn.onclick = () => {
          const slug = currentRestaurantData.slug;
          if (slug) {
            window.location.href = `restaurant.html?slug=${encodeURIComponent(slug)}&edit=1&openLog=1`;
          }
        };
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    function renderMenuAccommodationBreakdown() {
      const container = document.getElementById('menu-accommodation-breakdown');
      const allergenContainer = document.getElementById('menu-allergen-breakdown');
      const dietContainer = document.getElementById('menu-diet-breakdown');

      const overlays = currentRestaurantData?.overlays || [];

      if (overlays.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'block';

      // Define all allergens and diets to track
      const allAllergens = ['dairy', 'egg', 'peanut', 'tree nut', 'shellfish', 'fish', 'soy', 'sesame', 'wheat'];
      const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];

      const allergenEmojis = {
        'dairy': '', 'egg': '', 'peanut': '', 'tree nut': '',
        'shellfish': '', 'fish': '', 'soy': '', 'sesame': '', 'wheat': ''
      };
      const dietEmojis = {
        'Vegan': '', 'Vegetarian': '', 'Pescatarian': '', 'Gluten-free': ''
      };

      // Build a map of dish name -> overlay data for quick lookup
      const dishOverlayMap = {};
      overlays.forEach(overlay => {
        const name = (overlay.name || overlay.id || '').toLowerCase();
        if (name) dishOverlayMap[name] = overlay;
      });

      // DISH STATS: Count dishes for each allergen/diet
      const allergenDishStats = {};
      allAllergens.forEach(allergen => {
        allergenDishStats[allergen] = { safe: 0, accommodated: 0, cannot: 0 };
      });

      const dietDishStats = {};
      allDiets.forEach(diet => {
        dietDishStats[diet] = { safe: 0, cannot: 0 };
      });

      const totalDishes = overlays.length;

      overlays.forEach(overlay => {
        const dishAllergens = (overlay.allergens || []).map(a => a.toLowerCase());
        const removableList = overlay.removable || [];
        const removableAllergens = removableList.map(r => (r.allergen || '').toLowerCase());
        const dishDiets = new Set(overlay.diets || []);

        // Tally allergen stats for each allergen
        allAllergens.forEach(allergen => {
          const allergenLower = allergen.toLowerCase();
          if (!dishAllergens.includes(allergenLower)) {
            allergenDishStats[allergen].safe++;
          } else if (removableAllergens.includes(allergenLower)) {
            allergenDishStats[allergen].accommodated++;
          } else {
            allergenDishStats[allergen].cannot++;
          }
        });

        // Tally diet stats
        allDiets.forEach(diet => {
          if (dishDiets.has(diet)) {
            dietDishStats[diet].safe++;
          } else {
            dietDishStats[diet].cannot++;
          }
        });
      });

      // VIEW STATS: Count views based on user restrictions
      const allergenViewStats = {};
      allAllergens.forEach(allergen => {
        allergenViewStats[allergen] = { noConflict: 0, accommodated: 0, cannot: 0 };
      });

      const dietViewStats = {};
      allDiets.forEach(diet => {
        dietViewStats[diet] = { noConflict: 0, cannot: 0 };
      });

      // Process each interaction to calculate view stats
      let categorizedViewCount = 0;
      rawInteractions.forEach(interaction => {
        const dishName = (interaction.dish_name || '').toLowerCase();
        const overlay = dishOverlayMap[dishName];
        if (!overlay) return;
        categorizedViewCount++;

        const userAllergens = (interaction.user_allergens || []).map(a => a.toLowerCase());
        const userDiets = interaction.user_diets || [];
        const dishAllergens = (overlay.allergens || []).map(a => a.toLowerCase());
        const removableAllergens = (overlay.removable || []).map(r => (r.allergen || '').toLowerCase());
        const dishDietsSet = new Set(overlay.diets || []);

        // For each allergen, categorize this view
        allAllergens.forEach(allergen => {
          const allergenLower = allergen.toLowerCase();
          const dishHasAllergen = dishAllergens.includes(allergenLower);
          const userHasAllergen = userAllergens.includes(allergenLower);

          if (!userHasAllergen) {
            allergenViewStats[allergen].noConflict++;
          } else if (dishHasAllergen && removableAllergens.includes(allergenLower)) {
            allergenViewStats[allergen].accommodated++;
          } else if (dishHasAllergen) {
            allergenViewStats[allergen].cannot++;
          } else {
            allergenViewStats[allergen].noConflict++;
          }
        });

        // For each diet, categorize this view
        allDiets.forEach(diet => {
          const userHasDiet = userDiets.includes(diet);
          const dishMeetsDiet = dishDietsSet.has(diet);

          if (!userHasDiet) {
            dietViewStats[diet].noConflict++;
          } else if (dishMeetsDiet) {
            dietViewStats[diet].noConflict++;
          } else {
            dietViewStats[diet].cannot++;
          }
        });
      });

      // Helper to render a single horizontal bar
      function renderBar(safe, accommodated, cannot, total) {
        const safePercent = total > 0 ? (safe / total) * 100 : 0;
        const accommodatedPercent = total > 0 ? (accommodated / total) * 100 : 0;
        const cannotPercent = total > 0 ? (cannot / total) * 100 : 0;

        if (total === 0) {
          return `<div style="flex:1;height:18px;display:flex;border-radius:4px;overflow:hidden;background:#e5e7eb;"></div>`;
        }

        return `
          <div style="flex:1;height:18px;display:flex;border-radius:4px;overflow:hidden;background:#e5e7eb;">
            ${safePercent > 0 ? `<div style="width:${safePercent}%;background:#22c55e;display:flex;align-items:center;justify-content:center;font-size:0.6rem;color:#fff;font-weight:600;">${safePercent >= 5 ? Math.round(safePercent) + '%' : ''}</div>` : ''}
            ${accommodatedPercent > 0 ? `<div style="width:${accommodatedPercent}%;background:#facc15;display:flex;align-items:center;justify-content:center;font-size:0.6rem;color:#000;font-weight:600;">${accommodatedPercent >= 5 ? Math.round(accommodatedPercent) + '%' : ''}</div>` : ''}
            ${cannotPercent > 0 ? `<div style="width:${cannotPercent}%;background:#ef4444;display:flex;align-items:center;justify-content:center;font-size:0.6rem;color:#fff;font-weight:600;">${cannotPercent >= 5 ? Math.round(cannotPercent) + '%' : ''}</div>` : ''}
          </div>
        `;
      }

      // Helper to render a row with two bars (Dishes and Views)
      function renderDualBarRow(label, emoji, dishStats, viewStats, totalDishes, totalViews) {
        return `
          <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
            <span style="font-size:0.75rem;width:90px;min-width:90px;text-align:right;white-space:nowrap;">${emoji} ${label}</span>
            <div style="flex:1;display:flex;gap:8px;">
              ${renderBar(dishStats.safe, dishStats.accommodated || 0, dishStats.cannot, totalDishes)}
            </div>
            <div style="flex:1;display:flex;gap:8px;">
              ${renderBar(viewStats.noConflict, viewStats.accommodated || 0, viewStats.cannot, totalViews)}
            </div>
          </div>
        `;
      }

      const totalViews = categorizedViewCount;

      // Filter to only show allergens/diets that are relevant
      const relevantAllergens = allAllergens.filter(a =>
        allergenDishStats[a].accommodated > 0 || allergenDishStats[a].cannot > 0
      );

      const relevantDiets = allDiets.filter(d =>
        dietDishStats[d].cannot > 0
      );

      // Render allergen section with column headers
      if (relevantAllergens.length > 0) {
        allergenContainer.innerHTML = `
          <div style="display:flex;align-items:flex-end;gap:12px;margin-bottom:8px;">
            <span style="width:90px;min-width:90px;font-size:0.85rem;font-weight:600;color:var(--ink);">Allergens</span>
            <div style="flex:1;text-align:center;">
              <div class="info-tooltip-container" style="justify-content:center;">
                <span style="font-size:0.75rem;font-weight:600;color:var(--ink);">Menu Coverage</span>
                <button class="info-tooltip-btn" onclick="toggleInfoTooltip(event, 'menu-coverage-tooltip')">?</button>
                <div class="info-tooltip-popup" id="menu-coverage-tooltip">Proportion of dishes not containing the allergen , containing but can be accommodated , or containing and can't be accommodated </div>
              </div>
            </div>
            <div style="flex:1;text-align:center;">
              <div class="info-tooltip-container" style="justify-content:center;">
                <span style="font-size:0.75rem;font-weight:600;color:var(--ink);">Viewer Restrictions</span>
                <button class="info-tooltip-btn" onclick="toggleInfoTooltip(event, 'viewer-restrictions-tooltip')">?</button>
                <div class="info-tooltip-popup" id="viewer-restrictions-tooltip">Proportion of views where the allergen/diet is safe , conflicts but can be accommodated , or conflicts and cannot be accommodated  for that user</div>
              </div>
            </div>
          </div>
          <div style="border-bottom:1px solid var(--border);margin-bottom:12px;"></div>
          ${relevantAllergens.map(allergen =>
            renderDualBarRow(
              allergen.charAt(0).toUpperCase() + allergen.slice(1),
              allergenEmojis[allergen] || '',
              allergenDishStats[allergen],
              allergenViewStats[allergen],
              totalDishes,
              totalViews
            )
          ).join('')}
        `;
      } else {
        allergenContainer.innerHTML = '<p style="font-size:0.85rem;color:var(--muted);">No allergen data available</p>';
      }

      // Render diet section without repeating headers
      if (relevantDiets.length > 0) {
        dietContainer.innerHTML = `
          <div style="display:flex;align-items:flex-end;gap:12px;margin-top:20px;margin-bottom:8px;">
            <span style="width:90px;min-width:90px;font-size:0.85rem;font-weight:600;color:var(--ink);">Diets</span>
            <div style="flex:1;"></div>
            <div style="flex:1;"></div>
          </div>
          <div style="border-bottom:1px solid var(--border);margin-bottom:12px;"></div>
          ${relevantDiets.map(diet =>
            renderDualBarRow(
              diet,
              dietEmojis[diet] || '',
              dietDishStats[diet],
              dietViewStats[diet],
              totalDishes,
              totalViews
            )
          ).join('')}
        `;
      } else {
        dietContainer.innerHTML = '<p style="font-size:0.85rem;color:var(--muted);">No diet data available</p>';
      }
    }

    function renderUserDietaryProfilePieCharts() {
      const section = document.getElementById('user-dietary-profile-section');
      const allergenContainer = document.getElementById('user-allergen-pie');
      const dietContainer = document.getElementById('user-diet-pie');

      if (rawInteractions.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      // Define all allergens and diets to track
      const allAllergens = ['dairy', 'egg', 'peanut', 'tree nut', 'shellfish', 'fish', 'soy', 'sesame', 'wheat'];
      const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];

      const allergenEmojis = {
        'dairy': '', 'egg': '', 'peanut': '', 'tree nut': '',
        'shellfish': '', 'fish': '', 'soy': '', 'sesame': '', 'wheat': ''
      };
      const dietEmojis = {
        'Vegan': '', 'Vegetarian': '', 'Pescatarian': '', 'Gluten-free': ''
      };

      // Colors for pie chart segments - high contrast, distinguishable palette
      // Last color (gray) is reserved for "No allergies" / "No diets"
      const pieColors = [
        '#3b82f6', '#ef4444', '#22c55e', '#f59e0b', '#8b5cf6',
        '#06b6d4', '#ec4899', '#f97316', '#14b8a6', '#6b7280'
      ];

      // Count unique users with each allergen
      const allergenUserCounts = {};
      allAllergens.forEach(a => allergenUserCounts[a] = new Set());

      // Count unique users with each diet
      const dietUserCounts = {};
      allDiets.forEach(d => dietUserCounts[d] = new Set());

      // Track users with no allergens and no diets
      const usersWithNoAllergens = new Set();
      const usersWithNoDiets = new Set();
      const allUniqueUsers = new Set();

      // Process interactions to count unique users
      rawInteractions.forEach(interaction => {
        const userId = interaction.user_id;
        allUniqueUsers.add(userId);

        const userAllergens = (interaction.user_allergens || []).map(a => a.toLowerCase());
        const userDiets = interaction.user_diets || [];

        // Track users with no allergens
        if (userAllergens.length === 0) {
          usersWithNoAllergens.add(userId);
        }

        // Track users with no diets
        if (userDiets.length === 0) {
          usersWithNoDiets.add(userId);
        }

        userAllergens.forEach(allergen => {
          if (allergenUserCounts[allergen]) {
            allergenUserCounts[allergen].add(userId);
          }
        });

        userDiets.forEach(diet => {
          if (dietUserCounts[diet]) {
            dietUserCounts[diet].add(userId);
          }
        });
      });

      // Convert sets to counts and filter to non-zero
      const allergenData = allAllergens
        .map(a => ({ name: a, count: allergenUserCounts[a].size, emoji: allergenEmojis[a] }))
        .filter(d => d.count > 0)
        .sort((a, b) => b.count - a.count);

      // Add "No allergies" segment if there are users without allergens
      if (usersWithNoAllergens.size > 0) {
        allergenData.push({ name: 'No allergies', count: usersWithNoAllergens.size, emoji: '' });
      }

      const dietData = allDiets
        .map(d => ({ name: d, count: dietUserCounts[d].size, emoji: dietEmojis[d] }))
        .filter(d => d.count > 0)
        .sort((a, b) => b.count - a.count);

      // Add "No diets" segment if there are users without diets
      if (usersWithNoDiets.size > 0) {
        dietData.push({ name: 'No diets', count: usersWithNoDiets.size, emoji: '' });
      }

      // Helper to render a pie chart with legend
      function renderPieChart(title, data, colors, uniqueUserCount) {
        if (data.length === 0) {
          return `<p style="font-size:0.85rem;color:var(--muted);text-align:center;">No ${title.toLowerCase()} data available</p>`;
        }

        const total = data.reduce((sum, d) => sum + d.count, 0);
        const displayUserCount = uniqueUserCount || total;
        const size = 200;
        const radius = size / 2 - 10;
        const centerX = size / 2;
        const centerY = size / 2;
        const labelRadius = radius * 0.65;

        let segments = '';
        let labels = '';
        let currentAngle = -90;

        data.forEach((item, i) => {
          const percentage = (item.count / total) * 100;
          const angle = (item.count / total) * 360;
          const color = colors[i % colors.length];

          if (angle > 0) {
            const startAngle = currentAngle;
            const endAngle = currentAngle + angle;
            const startRad = (startAngle * Math.PI) / 180;
            const endRad = (endAngle * Math.PI) / 180;
            const x1 = centerX + radius * Math.cos(startRad);
            const y1 = centerY + radius * Math.sin(startRad);
            const x2 = centerX + radius * Math.cos(endRad);
            const y2 = centerY + radius * Math.sin(endRad);
            const largeArc = angle > 180 ? 1 : 0;

            if (data.length === 1) {
              segments += `<circle cx="${centerX}" cy="${centerY}" r="${radius}" fill="${color}" stroke="#1a1a2e" stroke-width="2" />`;
            } else {
              segments += `<path d="M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z" fill="${color}" stroke="#1a1a2e" stroke-width="2" />`;
            }

            const midAngle = startAngle + angle / 2;
            const midRad = (midAngle * Math.PI) / 180;
            const labelX = centerX + labelRadius * Math.cos(midRad);
            const labelY = centerY + labelRadius * Math.sin(midRad);

            if (percentage >= 5) {
              labels += `<text x="${labelX}" y="${labelY}" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="11" font-weight="600" style="text-shadow: 0 1px 2px rgba(0,0,0,0.5);">${Math.round(percentage)}%</text>`;
            }

            currentAngle = endAngle;
          }
        });

        const legendItems = data.map((item, i) => {
          const percentage = ((item.count / total) * 100).toFixed(1);
          const color = colors[i % colors.length];
          const label = item.name.charAt(0).toUpperCase() + item.name.slice(1);
          return `
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
              <span style="display:inline-block;width:12px;height:12px;background:${color};border-radius:2px;flex-shrink:0;border:1px solid rgba(255,255,255,0.2);"></span>
              <span style="font-size:0.75rem;color:var(--ink);">${item.emoji} ${label}</span>
              <span style="font-size:0.7rem;color:var(--muted);margin-left:auto;">${item.count} (${percentage}%)</span>
            </div>
          `;
        }).join('');

        return `
          <div style="text-align:center;">
            <h4 style="font-size:0.85rem;font-weight:600;color:var(--ink);margin-bottom:12px;">${title}</h4>
            <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="margin-bottom:8px;">
              ${segments}
              ${labels}
            </svg>
            <p style="font-size:0.75rem;color:var(--muted);margin-bottom:12px;">Total unique users: ${displayUserCount}</p>
            <div style="text-align:left;padding:0 8px;">
              ${legendItems}
            </div>
          </div>
        `;
      }

      allergenContainer.innerHTML = renderPieChart('User Allergens', allergenData, pieColors, allUniqueUsers.size);
      dietContainer.innerHTML = renderPieChart('User Diets', dietData, pieColors, allUniqueUsers.size);
    }

    function renderHeatmap() {
      const loadingEl = document.getElementById('menu-heatmap-loading');
      const contentEl = document.getElementById('menu-heatmap-content');
      const emptyEl = document.getElementById('menu-heatmap-empty');
      const imgEl = document.getElementById('menu-heatmap-img');
      const overlaysEl = document.getElementById('menu-heatmap-overlays');
      const pageNavEl = document.getElementById('heatmap-page-nav');
      const pageIndicatorEl = document.getElementById('heatmap-page-indicator');
      const prevBtnEl = document.getElementById('heatmap-prev-btn');
      const nextBtnEl = document.getElementById('heatmap-next-btn');

      // Check if restaurant has menu image
      const menuImages = currentRestaurantData?.menu_images || [];
      const overlays = currentRestaurantData?.overlays || [];

      // Also check for single menu_image field (legacy)
      if (menuImages.length === 0 && currentRestaurantData?.menu_image) {
        menuImages.push(currentRestaurantData.menu_image);
      }

      if (menuImages.length === 0 || overlays.length === 0) {
        loadingEl.style.display = 'none';
        contentEl.style.display = 'none';
        emptyEl.style.display = 'flex';
        return;
      }

      // Ensure current page is valid
      if (currentHeatmapPage >= menuImages.length) {
        currentHeatmapPage = 0;
      }

      // Show/hide page navigation
      if (menuImages.length > 1) {
        pageNavEl.style.display = 'flex';
        pageIndicatorEl.textContent = `Page ${currentHeatmapPage + 1} of ${menuImages.length}`;
        prevBtnEl.disabled = currentHeatmapPage === 0;
        nextBtnEl.disabled = currentHeatmapPage === menuImages.length - 1;
      } else {
        pageNavEl.style.display = 'none';
      }

      // Use current page's menu image
      const menuImage = menuImages[currentHeatmapPage];
      imgEl.src = menuImage;
      imgEl.onload = () => {
        loadingEl.style.display = 'none';
        contentEl.style.display = 'flex';
        emptyEl.style.display = 'none';
        // Render overlays after image loads to ensure proper sizing
        renderHeatmapOverlays();
      };
      imgEl.onerror = () => {
        loadingEl.style.display = 'none';
        contentEl.style.display = 'none';
        emptyEl.style.display = 'flex';
      };
    }

    function renderHeatmapOverlays() {
      const overlaysEl = document.getElementById('menu-heatmap-overlays');
      const overlays = currentRestaurantData?.overlays || [];

      // Filter overlays for current page (if they have pageIndex, otherwise show all on page 0)
      const pageOverlays = overlays.filter(overlay => {
        const overlayPage = overlay.pageIndex ?? overlay.page ?? 0;
        return overlayPage === currentHeatmapPage;
      });

      // Get metric values based on selected metric (no filtering - show all data)
      const metricByDish = {};
      let metricLabel = 'views';

      if (currentHeatmapMetric === 'views') {
        metricLabel = 'views';
        // Count all views
        rawInteractions.forEach(interaction => {
          const dishName = interaction.dish_name;
          metricByDish[dishName] = (metricByDish[dishName] || 0) + 1;
        });
      } else if (currentHeatmapMetric === 'loves') {
        metricLabel = 'loves';
        // Count all loves
        rawLoves.forEach(love => {
          metricByDish[love.dish_name] = (metricByDish[love.dish_name] || 0) + 1;
        });
      } else if (currentHeatmapMetric === 'orders') {
        metricLabel = 'orders';
        // Use all orders
        Object.assign(metricByDish, dishOrders);
      } else if (currentHeatmapMetric === 'requests') {
        metricLabel = 'requests';
        // Count all accommodation requests per dish
        accommodationRequests.forEach(request => {
          const dishName = request.dish_name;
          if (dishName) {
            metricByDish[dishName] = (metricByDish[dishName] || 0) + 1;
          }
        });
      } else if (currentHeatmapMetric === 'accommodation') {
        metricLabel = '% accommodated';
        // Build a map of dish name -> overlay for quick lookup
        const overlays = currentRestaurantData?.overlays || [];
        const dishOverlayMap = {};
        overlays.forEach(overlay => {
          const name = (overlay.name || overlay.id || '').toLowerCase();
          if (name) dishOverlayMap[name] = overlay;
        });

        // Calculate accommodation rate per dish
        const dishViewCounts = {};
        const dishAccommodatedCounts = {};

        rawInteractions.forEach(interaction => {
          const dishName = interaction.dish_name;
          const overlay = dishOverlayMap[(dishName || '').toLowerCase()];
          if (!overlay) return;

          dishViewCounts[dishName] = (dishViewCounts[dishName] || 0) + 1;

          // Check if dish is safe or can be accommodated for this user
          const userAllergens = (interaction.user_allergens || []).map(a => a.toLowerCase());
          const userDiets = interaction.user_diets || [];
          const dishAllergens = (overlay.allergens || []).map(a => a.toLowerCase());
          const removableAllergens = (overlay.removable || []).map(r => (r.allergen || '').toLowerCase());
          const dishDietsSet = new Set(overlay.diets || []);

          // Check allergen conflicts
          const hasUnsafeAllergen = userAllergens.some(allergen =>
            dishAllergens.includes(allergen) && !removableAllergens.includes(allergen)
          );

          // Check diet compatibility
          let meetsDiet = true;
          if (userDiets && userDiets.length > 0) {
            for (const diet of userDiets) {
              if (!dishDietsSet.has(diet)) {
                meetsDiet = false;
                break;
              }
            }
          }

          // If no unsafe allergens and meets diet requirements, count as accommodated
          if (!hasUnsafeAllergen && meetsDiet) {
            dishAccommodatedCounts[dishName] = (dishAccommodatedCounts[dishName] || 0) + 1;
          }
        });

        // Calculate percentage for each dish
        Object.keys(dishViewCounts).forEach(dishName => {
          const total = dishViewCounts[dishName];
          const accommodated = dishAccommodatedCounts[dishName] || 0;
          metricByDish[dishName] = total > 0 ? Math.round((accommodated / total) * 100) : 0;
        });
      }

      // Find min/max for color scaling
      const metricValues = Object.values(metricByDish);
      const maxMetric = Math.max(...metricValues, 1);
      const minMetric = Math.min(...metricValues, 0);

      // Render overlays with frequency-based coloring
      // Use w/h properties (matching restaurant page) or fall back to width/height
      overlaysEl.innerHTML = pageOverlays.map((overlay, index) => {
        const dishName = overlay.id || overlay.dish_name || overlay.label || `Dish ${index + 1}`;
        const metricValue = metricByDish[dishName] || 0;

        // Calculate color - green (high) to red (low)
        const normalizedValue = maxMetric > minMetric
          ? (metricValue - minMetric) / (maxMetric - minMetric)
          : 0.5;

        const color = getHeatmapColor(normalizedValue);

        // Use w/h (restaurant page format) or width/height as fallback
        const width = overlay.w ?? overlay.width ?? 10;
        const height = overlay.h ?? overlay.height ?? 10;

        return `
          <div class="heatmap-overlay"
               style="left: ${overlay.x || 0}%; top: ${overlay.y || 0}%; width: ${width}%; height: ${height}%;
                      background: ${color}; border-color: ${color};"
               data-dish-name="${escapeHtml(dishName)}"
               data-metric="${metricValue}"
               onclick="showDishAnalytics('${escapeHtml(dishName).replace(/'/g, "\\'")}')">
            <span class="view-count">${metricValue} ${metricLabel}</span>
          </div>
        `;
      }).join('');
    }

    function goToHeatmapPage(direction) {
      const menuImages = currentRestaurantData?.menu_images || [];
      if (direction === 'prev' && currentHeatmapPage > 0) {
        currentHeatmapPage--;
        renderHeatmap();
      } else if (direction === 'next' && currentHeatmapPage < menuImages.length - 1) {
        currentHeatmapPage++;
        renderHeatmap();
      }
    }

    // Color interpolation for heatmap (red -> yellow -> green)
    function getHeatmapColor(value) {
      // value: 0 = red (low), 0.5 = yellow (medium), 1 = green (high)
      let r, g, b;

      if (value < 0.5) {
        // Red to Yellow
        const t = value * 2;
        r = 239; // #ef
        g = Math.round(68 + (204 - 68) * t); // 44 -> cc
        b = Math.round(68 + (21 - 68) * t); // 44 -> 15
      } else {
        // Yellow to Green
        const t = (value - 0.5) * 2;
        r = Math.round(250 + (34 - 250) * t); // fa -> 22
        g = Math.round(204 + (197 - 204) * t); // cc -> c5
        b = Math.round(21 + (94 - 21) * t); // 15 -> 5e
      }

      return `rgba(${r}, ${g}, ${b}, 0.5)`;
    }

    function showDishAnalytics(dishName) {
      const dish = dishAnalytics.find(d => d.dish_name === dishName);
      const dishRequests = accommodationRequests.filter(r => r.dish_name === dishName);

      // Find dish overlay data for allergens/diets
      const overlays = currentRestaurantData?.overlays || [];
      const dishOverlay = overlays.find(o => (o.id || o.dish_name || o.label) === dishName);

      // Update modal title
      document.getElementById('dish-analytics-title').textContent = dishName;

      // Allergen emojis
      const allergenEmojis = {
        'dairy': '', 'egg': '', 'peanut': '', 'tree nut': '',
        'shellfish': '', 'fish': '', 'soy': '', 'sesame': '', 'wheat': ''
      };
      const dietEmojis = {
        'Vegan': '', 'Vegetarian': '', 'Pescatarian': '', 'Gluten-free': ''
      };

      // Get dish data
      const dishAllergens = dishOverlay?.allergens || [];
      const dishDiets = dishOverlay?.diets || [];
      const removableList = dishOverlay?.removable || [];
      const removableAllergens = removableList.map(r => (r.allergen || '').toLowerCase());

      // Separate allergens into can/cannot accommodate
      const cannotAccommodateAllergens = dishAllergens.filter(a => !removableAllergens.includes(a.toLowerCase()));
      const canAccommodateAllergens = dishAllergens.filter(a => removableAllergens.includes(a.toLowerCase()));

      // dishDiets contains diets the dish IS compatible with
      // We want to show diets the dish is NOT compatible with (cannot accommodate)
      const allDiets = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];
      const cannotAccommodateDiets = allDiets.filter(d => !dishDiets.includes(d));

      // Populate "Cannot be accommodated" row (allergens + diets)
      const cannotRow = document.getElementById('cannot-accommodate-row');
      const cannotTags = document.getElementById('cannot-accommodate-tags');
      const hasCannotAccommodate = cannotAccommodateAllergens.length > 0 || cannotAccommodateDiets.length > 0;
      if (hasCannotAccommodate) {
        const allergenTagsHtml = cannotAccommodateAllergens.map(a => {
          const emoji = allergenEmojis[a.toLowerCase()] || '';
          return `<span class="accommodation-tag">${emoji} ${a}</span>`;
        }).join('');
        const dietTagsHtml = cannotAccommodateDiets.map(d => {
          const emoji = dietEmojis[d] || '';
          return `<span class="accommodation-tag">${emoji} ${d}</span>`;
        }).join('');
        cannotTags.innerHTML = allergenTagsHtml + dietTagsHtml;
        cannotRow.style.display = 'flex';
      } else {
        cannotRow.style.display = 'none';
      }

      // Populate "Can be accommodated" row (only allergens - diets cannot be accommodated by removal)
      const canRow = document.getElementById('can-accommodate-row');
      const canTags = document.getElementById('can-accommodate-tags');
      if (canAccommodateAllergens.length > 0) {
        canTags.innerHTML = canAccommodateAllergens.map(a => {
          const emoji = allergenEmojis[a.toLowerCase()] || '';
          return `<span class="accommodation-tag">${emoji} ${a}</span>`;
        }).join('');
        canRow.style.display = 'flex';
      } else {
        canRow.style.display = 'none';
      }

      // Update accommodation requests count
      document.getElementById('analytics-requests').textContent = dishRequests.length;

      // Calculate status breakdowns for each metric
      // Build user profile map from rawInteractions
      const userProfileMap = {};
      rawInteractions.forEach(interaction => {
        if (interaction.user_id && !userProfileMap[interaction.user_id]) {
          userProfileMap[interaction.user_id] = {
            allergens: interaction.user_allergens || [],
            diets: interaction.user_diets || []
          };
        }
      });

      // Views - calculate live from rawInteractions (same logic as heatmap)
      let viewsSafe = 0, viewsRemovable = 0, viewsUnsafe = 0;
      rawInteractions.filter(i => i.dish_name === dishName).forEach(interaction => {
        const status = computeDishStatus(dishOverlay, interaction.user_allergens || [], interaction.user_diets || []);
        if (status === 'safe') viewsSafe++;
        else if (status === 'removable') viewsRemovable++;
        else viewsUnsafe++;
      });
      const viewsTotal = viewsSafe + viewsRemovable + viewsUnsafe;

      // Unique users - calculate from rawInteractions for this dish
      let uniqueSafe = 0, uniqueRemovable = 0, uniqueUnsafe = 0;
      const seenUsers = new Set();
      rawInteractions.filter(i => i.dish_name === dishName).forEach(interaction => {
        if (interaction.user_id && !seenUsers.has(interaction.user_id)) {
          seenUsers.add(interaction.user_id);
          const profile = userProfileMap[interaction.user_id];
          if (profile) {
            const status = computeDishStatus(dishOverlay, profile.allergens, profile.diets);
            if (status === 'safe') uniqueSafe++;
            else if (status === 'removable') uniqueRemovable++;
            else uniqueUnsafe++;
          }
        }
      });
      const uniqueTotal = uniqueSafe + uniqueRemovable + uniqueUnsafe;

      // Loves - calculate from rawLoves and user profiles
      let lovesSafe = 0, lovesRemovable = 0, lovesUnsafe = 0;
      rawLoves.filter(l => l.dish_name === dishName).forEach(love => {
        const profile = userProfileMap[love.user_id];
        if (profile) {
          const status = computeDishStatus(dishOverlay, profile.allergens, profile.diets);
          if (status === 'safe') lovesSafe++;
          else if (status === 'removable') lovesRemovable++;
          else lovesUnsafe++;
        }
      });
      const lovesTotal = lovesSafe + lovesRemovable + lovesUnsafe;

      // Orders - we don't have user profile data for orders, so show total only
      const ordersTotal = dishOrders[dishName] || 0;

      // Calculate average views and status breakdown across all dishes
      const allDishNames = [...new Set(rawInteractions.map(i => i.dish_name))];
      const numDishes = allDishNames.length || 1;

      // Calculate total views and status breakdown across all dishes
      let totalAllViews = 0;
      let totalAllSafe = 0, totalAllRemovable = 0, totalAllUnsafe = 0;

      allDishNames.forEach(dn => {
        const dishOv = currentRestaurantData?.overlays?.find(o =>
          (o.id || o.dish_name || o.label) === dn
        );
        rawInteractions.filter(i => i.dish_name === dn).forEach(interaction => {
          totalAllViews++;
          const status = computeDishStatus(dishOv, interaction.user_allergens || [], interaction.user_diets || []);
          if (status === 'safe') totalAllSafe++;
          else if (status === 'removable') totalAllRemovable++;
          else totalAllUnsafe++;
        });
      });

      const avgViews = numDishes > 0 ? Math.round(totalAllViews / numDishes) : 0;
      const avgSafe = numDishes > 0 ? totalAllSafe / numDishes : 0;
      const avgRemovable = numDishes > 0 ? totalAllRemovable / numDishes : 0;
      const avgUnsafe = numDishes > 0 ? totalAllUnsafe / numDishes : 0;
      const avgTotal = avgSafe + avgRemovable + avgUnsafe;

      // Generate stacked bar chart - horizontal layout
      const stackedChart = document.getElementById('analytics-stacked-chart');

      // Render horizontal status distribution bar (normalized to 100% width)
      function renderStatusBar(label, safe, removable, unsafe, total, isAverage = false) {
        const safePercent = total > 0 ? Math.round((safe / total) * 100) : 0;
        const removablePercent = total > 0 ? Math.round((removable / total) * 100) : 0;
        const unsafePercent = total > 0 ? Math.round((unsafe / total) * 100) : 0;

        const opacity = isAverage ? 'opacity: 0.6;' : '';
        const hasData = total > 0;

        return `
          <div class="stacked-bar-row" style="${opacity}">
            <span class="stacked-bar-row-label">${label}</span>
            <div class="stacked-bar-wrapper">
              ${hasData ? `
                ${safePercent > 0 ? `<div class="stacked-bar-segment safe" style="width:${safePercent}%;" title="Safe: ${Math.round(safe)}"><span class="segment-percent">${safePercent}%</span></div>` : ''}
                ${removablePercent > 0 ? `<div class="stacked-bar-segment removable" style="width:${removablePercent}%;" title="Can be accommodated: ${Math.round(removable)}"><span class="segment-percent">${removablePercent}%</span></div>` : ''}
                ${unsafePercent > 0 ? `<div class="stacked-bar-segment unsafe" style="width:${unsafePercent}%;" title="Cannot be accommodated: ${Math.round(unsafe)}"><span class="segment-percent">${unsafePercent}%</span></div>` : ''}
              ` : `
                <div class="stacked-bar-segment neutral" style="width:100%;" title="No data"></div>
              `}
            </div>
          </div>
        `;
      }

      // Render horizontal views bar (scaled to max)
      function renderViewsBar(label, views, maxViews, isAverage = false) {
        const widthPercent = maxViews > 0 ? (views / maxViews) * 100 : 0;
        const opacity = isAverage ? 'opacity: 0.6;' : '';

        return `
          <div class="stacked-bar-row" style="${opacity}">
            <span class="stacked-bar-row-label">${label}</span>
            <div class="stacked-bar-wrapper">
              <div class="stacked-bar-segment views" style="width:${widthPercent}%;" title="${Math.round(views)} views"></div>
            </div>
            <span class="stacked-bar-value">${Math.round(views)}</span>
          </div>
        `;
      }

      // Max views for scaling
      const maxViewsForScale = Math.max(viewsTotal, avgViews, 1);

      stackedChart.innerHTML = `
        <div class="chart-comparison-group">
          <div class="chart-group-title">Total Views</div>
          <div class="chart-group-bars">
            ${renderViewsBar('This Dish', viewsTotal, maxViewsForScale, false)}
            ${renderViewsBar('Menu Avg', avgViews, maxViewsForScale, true)}
          </div>
        </div>
        <div class="chart-comparison-group">
          <div class="chart-group-title">Status Distribution</div>
          <div class="chart-group-bars">
            ${renderStatusBar('This Dish', viewsSafe, viewsRemovable, viewsUnsafe, viewsTotal, false)}
            ${renderStatusBar('Menu Avg', avgSafe, avgRemovable, avgUnsafe, avgTotal, true)}
          </div>
        </div>
      `;

      // Calculate conflict counts per allergen and diet
      const allergenConflictCounts = {};
      const dietConflictCounts = {};

      // Initialize counts for dish allergens
      dishAllergens.forEach(a => {
        allergenConflictCounts[a.toLowerCase()] = 0;
      });

      // Initialize counts for incompatible diets
      cannotAccommodateDiets.forEach(d => {
        dietConflictCounts[d] = 0;
      });

      // Count conflicts from raw interactions for this dish
      rawInteractions.filter(i => i.dish_name === dishName).forEach(interaction => {
        const userAllergens = (interaction.user_allergens || []).map(a => a.toLowerCase());
        const userDiets = interaction.user_diets || [];

        // Count allergen conflicts
        userAllergens.forEach(userAllergen => {
          if (allergenConflictCounts.hasOwnProperty(userAllergen)) {
            allergenConflictCounts[userAllergen]++;
          }
        });

        // Count diet conflicts (user has diet that dish can't accommodate)
        userDiets.forEach(userDiet => {
          if (dietConflictCounts.hasOwnProperty(userDiet)) {
            dietConflictCounts[userDiet]++;
          }
        });
      });

      // Find shared max for scaling (so bars are proportional across both charts)
      const allergenValues = Object.values(allergenConflictCounts);
      const dietValues = Object.values(dietConflictCounts);
      const maxConflict = Math.max(...allergenValues, ...dietValues, 1);

      // Render allergen conflict bars
      const allergenBarsEl = document.getElementById('conflict-allergen-bars');
      // Get lowercase versions of accommodatable allergens for comparison
      const canAccommodateAllergensLower = canAccommodateAllergens.map(a => a.toLowerCase());
      if (Object.keys(allergenConflictCounts).length > 0) {
        allergenBarsEl.innerHTML = Object.entries(allergenConflictCounts)
          .sort((a, b) => b[1] - a[1]) // Sort by count descending
          .map(([allergen, count]) => {
            const emoji = allergenEmojis[allergen] || '';
            const widthPercent = (count / maxConflict) * 100;
            // Yellow if can be accommodated, red if cannot
            const barColor = canAccommodateAllergensLower.includes(allergen.toLowerCase()) ? '#facc15' : '#ef4444';
            return `
              <div class="conflict-bar-row">
                <span class="conflict-bar-label">${emoji} ${allergen}</span>
                <div class="conflict-bar-track">
                  <div class="conflict-bar-fill" style="width:${widthPercent}%; background:${barColor};"></div>
                </div>
                <span class="conflict-bar-value">${count}</span>
              </div>
            `;
          }).join('');
      } else {
        allergenBarsEl.innerHTML = '<div class="conflict-no-data">No allergen conflicts</div>';
      }

      // Render diet conflict bars
      const dietBarsEl = document.getElementById('conflict-diet-bars');
      if (Object.keys(dietConflictCounts).length > 0) {
        dietBarsEl.innerHTML = Object.entries(dietConflictCounts)
          .sort((a, b) => b[1] - a[1]) // Sort by count descending
          .map(([diet, count]) => {
            const emoji = dietEmojis[diet] || '';
            const widthPercent = (count / maxConflict) * 100;
            return `
              <div class="conflict-bar-row">
                <span class="conflict-bar-label">${emoji} ${diet}</span>
                <div class="conflict-bar-track">
                  <div class="conflict-bar-fill" style="width:${widthPercent}%;"></div>
                </div>
                <span class="conflict-bar-value">${count}</span>
              </div>
            `;
          }).join('');
      } else {
        dietBarsEl.innerHTML = '<div class="conflict-no-data">No diet conflicts</div>';
      }

      // Show modal
      document.getElementById('dish-analytics-modal').classList.add('show');
    }

    // Compute dish status for a user based on their allergens/diets
    function computeDishStatus(dishOverlay, userAllergens, userDiets) {
      if (!dishOverlay) return 'neutral';

      const dishAllergens = (dishOverlay.allergens || []).map(a => a.toLowerCase());
      const removableAllergens = (dishOverlay.removable || []).map(r => (r.allergen || '').toLowerCase());
      const dishDiets = new Set(dishOverlay.diets || []);

      // Check allergen conflicts
      const conflictingAllergens = userAllergens.filter(a => dishAllergens.includes(a.toLowerCase()));
      const unsafeAllergens = conflictingAllergens.filter(a => !removableAllergens.includes(a.toLowerCase()));
      const removableConflicts = conflictingAllergens.filter(a => removableAllergens.includes(a.toLowerCase()));

      // Check diet conflicts
      const unmetDiets = userDiets.filter(d => !dishDiets.has(d));

      if (unsafeAllergens.length > 0 || unmetDiets.length > 0) {
        return 'unsafe';
      } else if (removableConflicts.length > 0) {
        return 'removable';
      } else {
        return 'safe';
      }
    }

    function closeDishAnalyticsModal() {
      document.getElementById('dish-analytics-modal').classList.remove('show');
    }

    // Make showDishAnalytics available globally for onclick handlers
    window.showDishAnalytics = showDishAnalytics;

    // Get filtered user profiles based on current filter settings
    function getFilteredUserProfiles() {
      const filterViews = document.getElementById('filter-views')?.checked ?? true;
      const filterLoves = document.getElementById('filter-loves')?.checked ?? false;
      const filterOrders = document.getElementById('filter-orders')?.checked ?? false;
      const weightMode = document.querySelector('input[name="weight-mode"]:checked')?.value || 'unique';

      // Build set of user_ids from views (dish_interactions)
      const viewedUsers = new Set(rawInteractions.map(i => i.user_id).filter(Boolean));
      // Set of user_ids who loved dishes
      const lovedUsers = userLovedSet;
      // Set of user_ids who placed orders
      const orderedUsers = new Set(Object.keys(userOrderCounts));

      // Filter users based on selected criteria (OR logic - include if ANY criteria matches)
      const matchingUsers = new Set();
      if (filterViews) viewedUsers.forEach(u => matchingUsers.add(u));
      if (filterLoves) lovedUsers.forEach(u => matchingUsers.add(u));
      if (filterOrders) orderedUsers.forEach(u => matchingUsers.add(u));

      // If no filters selected, include all viewed users as default
      if (!filterViews && !filterLoves && !filterOrders) {
        viewedUsers.forEach(u => matchingUsers.add(u));
      }

      // Build user profile map from rawInteractions (use first interaction's profile per user)
      const userProfiles = {};
      rawInteractions.forEach(interaction => {
        const userId = interaction.user_id;
        if (!userId || !matchingUsers.has(userId)) return;
        // Only store first occurrence (profiles should be consistent)
        if (!userProfiles[userId]) {
          userProfiles[userId] = {
            allergens: interaction.user_allergens || [],
            diets: interaction.user_diets || []
          };
        }
      });

      // For users who loved/ordered but may not have viewed, we won't have profile data
      // (they need to have at least one dish_interaction to have profile data)

      // Apply weighting
      const result = [];
      Object.entries(userProfiles).forEach(([userId, profile]) => {
        let weight = 1;
        if (weightMode === 'weighted' && userOrderCounts[userId]) {
          weight = userOrderCounts[userId]; // Number of order visits
        }
        result.push({ ...profile, weight, userId });
      });

      return result;
    }

    function renderAllergenChart() {
      const container = document.getElementById('allergens-chart');
      const allergensList = ['dairy', 'egg', 'peanut', 'tree nut', 'shellfish', 'fish', 'soy', 'sesame', 'wheat'];
      const allergenLabels = {
        'dairy': 'Dairy', 'egg': 'Egg', 'peanut': 'Peanut', 'tree nut': 'Tree Nut',
        'shellfish': 'Shellfish', 'fish': 'Fish', 'soy': 'Soy', 'sesame': 'Sesame', 'wheat': 'Wheat'
      };

      const userProfiles = getFilteredUserProfiles();

      // Count allergens from full user profiles
      const totals = allergensList.map(allergen => {
        let count = 0;
        userProfiles.forEach(profile => {
          if (profile.allergens.includes(allergen)) {
            count += profile.weight;
          }
        });
        return { label: allergenLabels[allergen], count };
      });

      const maxCount = Math.max(...totals.map(t => t.count), 1);

      if (userProfiles.length === 0) {
        container.innerHTML = '<div style="color:var(--muted);padding:20px;text-align:center;">No customer profile data available for the selected filters.</div>';
        return;
      }

      container.innerHTML = totals.map(t => `
        <div class="chart-bar" style="height: ${(t.count / maxCount) * 150 + 10}px;">
          <span class="chart-bar-value">${t.count}</span>
          <span class="chart-bar-label">${t.label}</span>
        </div>
      `).join('');
    }

    function renderDietChart() {
      const container = document.getElementById('diets-chart');
      const dietsList = ['Vegan', 'Vegetarian', 'Pescatarian', 'Gluten-free'];

      const userProfiles = getFilteredUserProfiles();

      // Count diets from full user profiles
      const totals = dietsList.map(diet => {
        let count = 0;
        userProfiles.forEach(profile => {
          if (profile.diets.includes(diet)) {
            count += profile.weight;
          }
        });
        return { label: diet, count };
      });

      const maxCount = Math.max(...totals.map(t => t.count), 1);

      if (userProfiles.length === 0) {
        container.innerHTML = '<div style="color:var(--muted);padding:20px;text-align:center;">No customer profile data available for the selected filters.</div>';
        return;
      }

      container.innerHTML = totals.map(t => `
        <div class="chart-bar" style="height: ${(t.count / maxCount) * 150 + 10}px; flex: 0 0 80px;">
          <span class="chart-bar-value">${t.count}</span>
          <span class="chart-bar-label">${t.label}</span>
        </div>
      `).join('');
    }

    function renderDishTable() {
      const tbody = document.getElementById('dish-analytics-body');

      if (dishAnalytics.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="6" style="text-align:center;padding:40px;color:var(--muted);">
              No dish interaction data yet. Data will appear as users view dishes.
            </td>
          </tr>
        `;
        return;
      }

      const sortedDishes = [...dishAnalytics].sort((a, b) => b.total_interactions - a.total_interactions);

      tbody.innerHTML = sortedDishes.map(dish => {
        const topAllergens = [];
        const allergenKeys = [
          { key: 'users_with_dairy_allergy', label: 'dairy' },
          { key: 'users_with_egg_allergy', label: 'egg' },
          { key: 'users_with_peanut_allergy', label: 'peanut' },
          { key: 'users_with_tree_nut_allergy', label: 'tree nut' },
          { key: 'users_with_wheat_allergy', label: 'wheat' }
        ];

        allergenKeys.forEach(a => {
          if (dish[a.key] > 0) {
            topAllergens.push({ label: a.label, count: dish[a.key] });
          }
        });

        topAllergens.sort((a, b) => b.count - a.count);
        const top3Allergens = topAllergens.slice(0, 3);

        return `
          <tr>
            <td><strong>${escapeHtml(dish.dish_name)}</strong></td>
            <td>${dish.total_interactions || 0}</td>
            <td style="color:#22c55e;">${dish.safe_interactions || 0}</td>
            <td style="color:#facc15;">${dish.removable_interactions || 0}</td>
            <td style="color:#ef4444;">${dish.unsafe_interactions || 0}</td>
            <td>
              ${top3Allergens.map(a => `<span class="allergen-badge">${a.label} (${a.count})</span>`).join('') || '<span style="color:var(--muted);">None</span>'}
            </td>
          </tr>
        `;
      }).join('');
    }

    function renderRequests(filter = 'pending') {
      const container = document.getElementById('requests-list');

      const filteredRequests = filter === 'pending'
        ? accommodationRequests.filter(r => r.status === 'pending')
        : accommodationRequests;

      if (filteredRequests.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M9 12l2 2 4-4"/>
              <circle cx="12" cy="12" r="10"/>
            </svg>
            <p>${filter === 'pending' ? 'No pending accommodation requests' : 'No accommodation requests yet'}</p>
          </div>
        `;
        return;
      }

      container.innerHTML = filteredRequests.map(req => {
        const allergenBadges = (req.requested_allergens || []).map(a =>
          `<span class="allergen-badge">${a}</span>`
        ).join('');

        const dietBadges = (req.requested_diets || []).map(d =>
          `<span class="diet-badge ${d.toLowerCase()}">${d}</span>`
        ).join('');

        const date = new Date(req.created_at).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });

        return `
          <div class="request-card" data-request-id="${req.id}">
            <div class="request-header">
              <div>
                <div class="request-dish">${escapeHtml(req.dish_name)}</div>
                <div class="request-date">${date}</div>
              </div>
              <span class="status-badge ${req.status}">${req.status}</span>
            </div>
            <div class="request-details">
              <div class="request-needs">
                ${allergenBadges ? `
                  <div class="request-needs-group">
                    <span class="request-needs-label">Allergen Accommodations Needed</span>
                    <div>${allergenBadges}</div>
                  </div>
                ` : ''}
                ${dietBadges ? `
                  <div class="request-needs-group">
                    <span class="request-needs-label">Dietary Accommodations Needed</span>
                    <div>${dietBadges}</div>
                  </div>
                ` : ''}
              </div>
            </div>
            ${req.manager_response ? `
              <div style="background:rgba(255,255,255,0.05);padding:12px;border-radius:8px;margin-bottom:12px;">
                <div style="color:var(--muted);font-size:0.8rem;margin-bottom:4px;">Manager Response</div>
                <div>${escapeHtml(req.manager_response)}</div>
              </div>
            ` : ''}
            ${req.status === 'pending' ? `
              <div class="request-actions">
                <button class="action-btn success" onclick="openResponseModal('${req.id}', '${escapeHtml(req.dish_name)}', 'implemented')">
                  Mark Implemented
                </button>
                <button class="action-btn" onclick="openResponseModal('${req.id}', '${escapeHtml(req.dish_name)}', 'reviewed')">
                  Mark Reviewed
                </button>
                <button class="action-btn decline" onclick="openResponseModal('${req.id}', '${escapeHtml(req.dish_name)}', 'declined')">
                  Decline
                </button>
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    function renderSuggestions() {
      const container = document.getElementById('suggestions-list');
      const suggestions = generateSuggestions();

      if (suggestions.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 16v-4"/>
              <path d="M12 8h.01"/>
            </svg>
            <p>More data needed to generate suggestions. Keep tracking user interactions!</p>
          </div>
        `;
        return;
      }

      container.innerHTML = suggestions.map(s => `
        <div class="suggestion-card">
          <div class="suggestion-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
              <path d="M12 2L2 7l10 5 10-5-10-5z"/>
              <path d="M2 17l10 5 10-5"/>
              <path d="M2 12l10 5 10-5"/>
            </svg>
          </div>
          <div class="suggestion-title">${escapeHtml(s.title)}</div>
          <div class="suggestion-description">${escapeHtml(s.description)}</div>
          <div class="suggestion-impact">
            <div class="impact-item">
              <span class="positive">+${s.potentialUsers}</span>
              <span style="color:var(--muted);">potential users</span>
            </div>
            <div class="impact-item">
              <span style="color:var(--muted);">Priority:</span>
              <span style="color:${s.priority === 'high' ? '#ef4444' : s.priority === 'medium' ? '#facc15' : 'var(--muted)'};">${s.priority}</span>
            </div>
          </div>
        </div>
      `).join('');
    }

    function generateSuggestions() {
      const suggestions = [];

      // Analyze accommodation requests to find patterns
      const requestsByDish = {};
      accommodationRequests.forEach(req => {
        if (!requestsByDish[req.dish_name]) {
          requestsByDish[req.dish_name] = {
            count: 0,
            allergens: {},
            diets: {}
          };
        }
        requestsByDish[req.dish_name].count++;
        (req.requested_allergens || []).forEach(a => {
          requestsByDish[req.dish_name].allergens[a] = (requestsByDish[req.dish_name].allergens[a] || 0) + 1;
        });
        (req.requested_diets || []).forEach(d => {
          requestsByDish[req.dish_name].diets[d] = (requestsByDish[req.dish_name].diets[d] || 0) + 1;
        });
      });

      // Generate suggestions based on request patterns
      Object.entries(requestsByDish).forEach(([dishName, data]) => {
        if (data.count >= 2) {
          // Top allergen request for this dish
          const topAllergen = Object.entries(data.allergens).sort((a, b) => b[1] - a[1])[0];
          const topDiet = Object.entries(data.diets).sort((a, b) => b[1] - a[1])[0];

          if (topAllergen && topAllergen[1] >= 2) {
            suggestions.push({
              title: `Add ${topAllergen[0]}-free option for "${dishName}"`,
              description: `${topAllergen[1]} users have requested a ${topAllergen[0]}-free version of this dish. Consider adding a substitution option.`,
              potentialUsers: topAllergen[1] * 5, // Estimated impact
              priority: topAllergen[1] >= 5 ? 'high' : topAllergen[1] >= 3 ? 'medium' : 'low'
            });
          }

          if (topDiet && topDiet[1] >= 2) {
            suggestions.push({
              title: `Make "${dishName}" available for ${topDiet[0]} diners`,
              description: `${topDiet[1]} ${topDiet[0].toLowerCase()} users have requested this dish. Consider creating a ${topDiet[0].toLowerCase()} version.`,
              potentialUsers: topDiet[1] * 5,
              priority: topDiet[1] >= 5 ? 'high' : topDiet[1] >= 3 ? 'medium' : 'low'
            });
          }
        }
      });

      // Analyze dish analytics for high unsafe rates
      dishAnalytics.forEach(dish => {
        const total = dish.total_interactions || 0;
        const unsafe = dish.unsafe_interactions || 0;
        if (total >= 10 && (unsafe / total) > 0.5) {
          // More than 50% unsafe - high opportunity
          const topAllergens = [];
          if (dish.users_with_dairy_allergy > 0) topAllergens.push({ name: 'dairy', count: dish.users_with_dairy_allergy });
          if (dish.users_with_egg_allergy > 0) topAllergens.push({ name: 'egg', count: dish.users_with_egg_allergy });
          if (dish.users_with_peanut_allergy > 0) topAllergens.push({ name: 'peanut', count: dish.users_with_peanut_allergy });

          topAllergens.sort((a, b) => b.count - a.count);
          const topAllergen = topAllergens[0];

          if (topAllergen) {
            suggestions.push({
              title: `High demand for allergen-friendly "${dish.dish_name}"`,
              description: `${unsafe} users viewed this dish but it was unsafe for them. ${topAllergen.count} users with ${topAllergen.name} allergies are interested.`,
              potentialUsers: unsafe,
              priority: unsafe >= 20 ? 'high' : unsafe >= 10 ? 'medium' : 'low'
            });
          }
        }
      });

      // Sort by priority and potential users
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      suggestions.sort((a, b) => {
        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
        if (priorityDiff !== 0) return priorityDiff;
        return b.potentialUsers - a.potentialUsers;
      });

      return suggestions.slice(0, 5); // Return top 5 suggestions
    }

    // Modal functions
    function openResponseModal(requestId, dishName, action) {
      currentRequestId = requestId;
      document.getElementById('modal-dish').textContent = `Dish: ${dishName}`;
      document.getElementById('response-text').value = '';
      document.getElementById('response-modal').classList.add('show');

      // Update modal title based on action
      const titles = {
        implemented: 'Mark as Implemented',
        reviewed: 'Mark as Reviewed',
        declined: 'Decline Request'
      };
      document.getElementById('modal-title').textContent = titles[action] || 'Respond to Request';

      // Store the action for submission
      document.getElementById('response-modal').dataset.action = action;
    }

    async function submitResponse(status) {
      if (!currentRequestId) return;

      const response = document.getElementById('response-text').value.trim();

      try {
        const { error } = await supabaseClient
          .from('accommodation_requests')
          .update({
            status: status,
            manager_response: response || null,
            manager_reviewed_at: new Date().toISOString(),
            manager_reviewed_by: currentUser.id,
            updated_at: new Date().toISOString()
          })
          .eq('id', currentRequestId);

        if (error) throw error;

        // Refresh data
        await loadDashboardData();
        closeModal();
      } catch (err) {
        console.error('Failed to update request:', err);
        alert('Failed to update request. Please try again.');
      }
    }

    function closeModal() {
      document.getElementById('response-modal').classList.remove('show');
      currentRequestId = null;
    }

    // Event Listeners
    restaurantSelect.addEventListener('change', async (e) => {
      selectedRestaurantId = e.target.value;
      currentHeatmapPage = 0; // Reset to first page when changing restaurant
      await loadDashboardData();
    });

    // Tab switching for charts
    document.querySelectorAll('.tabs .tab-btn[data-tab]').forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        document.querySelectorAll('.tabs .tab-btn[data-tab]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        document.getElementById('allergens-chart').style.display = tab === 'allergens' ? 'flex' : 'none';
        document.getElementById('diets-chart').style.display = tab === 'diets' ? 'flex' : 'none';
      });
    });

    // Profile filter controls - re-render charts when filters change
    ['filter-views', 'filter-loves', 'filter-orders'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('change', () => {
          renderAllergenChart();
          renderDietChart();
        });
      }
    });

    // Weight mode toggle - re-render charts when mode changes
    document.querySelectorAll('input[name="weight-mode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        renderAllergenChart();
        renderDietChart();
      });
    });

    // Tab switching for requests
    document.querySelectorAll('.tabs .tab-btn[data-filter]').forEach(btn => {
      btn.addEventListener('click', () => {
        const filter = btn.dataset.filter;
        document.querySelectorAll('.tabs .tab-btn[data-filter]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        renderRequests(filter);
      });
    });

    // Modal buttons
    document.getElementById('modal-cancel').addEventListener('click', closeModal);
    document.getElementById('modal-implement').addEventListener('click', () => submitResponse('implemented'));
    document.getElementById('modal-decline').addEventListener('click', () => submitResponse('declined'));

    // Close modal on backdrop click
    document.getElementById('response-modal').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) closeModal();
    });

    // Dish analytics modal buttons
    document.getElementById('dish-analytics-close').addEventListener('click', closeDishAnalyticsModal);
    document.getElementById('dish-analytics-modal').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) closeDishAnalyticsModal();
    });

    // Heatmap page navigation
    document.getElementById('heatmap-prev-btn').addEventListener('click', () => goToHeatmapPage('prev'));
    document.getElementById('heatmap-next-btn').addEventListener('click', () => goToHeatmapPage('next'));

    // Heatmap metric toggle
    document.querySelectorAll('.heatmap-metric-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const metric = btn.dataset.metric;
        if (metric !== currentHeatmapMetric) {
          currentHeatmapMetric = metric;
          document.querySelectorAll('.heatmap-metric-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          renderHeatmapOverlays();
        }
      });
    });

    // Info tooltip toggle function (global for onclick handlers)
    window.toggleInfoTooltip = function(event, tooltipId) {
      event.stopPropagation();
      const tooltip = document.getElementById(tooltipId);
      const wasActive = tooltip.classList.contains('active');

      // Close all other tooltips
      document.querySelectorAll('.info-tooltip-popup.active').forEach(t => {
        t.classList.remove('active');
      });

      // Toggle this tooltip
      if (!wasActive) {
        tooltip.classList.add('active');
      }
    };

    // Close tooltips when clicking outside
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.info-tooltip-container')) {
        document.querySelectorAll('.info-tooltip-popup.active').forEach(t => {
          t.classList.remove('active');
        });
      }
    });

    // Initialize
    init();
  </script>
  <script type="module" src="js/report-modal.js"></script>
</body>
</html>
